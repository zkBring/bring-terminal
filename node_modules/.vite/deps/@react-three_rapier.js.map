{
  "version": 3,
  "sources": ["../../@react-three/rapier/dist/react-three-rapier.esm.js", "../../@react-three/rapier/node_modules/src/math/ConvexHull.js", "../../@react-three/rapier/node_modules/src/misc/ConvexObjectBreaker.js", "../../@react-three/rapier/node_modules/src/misc/Gyroscope.js", "../../@react-three/rapier/node_modules/src/_polyfill/constants.ts", "../../@react-three/rapier/node_modules/src/_polyfill/uv1.ts", "../../@react-three/rapier/node_modules/src/renderers/CSS2DRenderer.js", "../../@react-three/rapier/node_modules/src/renderers/CSS3DRenderer.js", "../../@react-three/rapier/node_modules/src/modifiers/CurveModifier.ts", "../../@react-three/rapier/node_modules/src/utils/BufferGeometryUtils.ts", "../../@react-three/rapier/node_modules/src/modifiers/SimplifyModifier.ts", "../../@react-three/rapier/node_modules/src/exporters/GLTFExporter.js", "../../@react-three/rapier/node_modules/src/exporters/DRACOExporter.ts", "../../@react-three/rapier/node_modules/src/animation/CCDIKSolver.js", "../../@react-three/rapier/node_modules/src/animation/MMDPhysics.js", "../../@react-three/rapier/node_modules/src/animation/MMDAnimationHelper.js", "../../@react-three/rapier/node_modules/src/objects/BatchedMesh.ts", "../../@react-three/rapier/node_modules/src/objects/Reflector.js", "../../@react-three/rapier/node_modules/src/objects/Refractor.js", "../../@react-three/rapier/node_modules/src/objects/ShadowMesh.js", "../../@react-three/rapier/node_modules/src/objects/Lensflare.js", "../../@react-three/rapier/node_modules/src/objects/MarchingCubes.js", "../../@react-three/rapier/node_modules/src/math/SimplexNoise.ts", "../../@react-three/rapier/node_modules/src/geometries/LightningStrike.js", "../../@react-three/rapier/node_modules/src/objects/ReflectorForSSRPass.js", "../../@react-three/rapier/node_modules/src/objects/Sky.ts", "../../@react-three/rapier/node_modules/src/objects/Water2.js", "../../@react-three/rapier/node_modules/src/utils/RoughnessMipmapper.js", "../../@react-three/rapier/node_modules/src/shaders/UnpackDepthRGBAShader.ts", "../../@react-three/rapier/node_modules/src/shaders/BokehShader2.ts", "../../@react-three/rapier/node_modules/src/math/MeshSurfaceSampler.js", "../../@react-three/rapier/node_modules/src/math/OBB.js", "../../@react-three/rapier/node_modules/src/math/Capsule.js", "../../@react-three/rapier/node_modules/src/math/ImprovedNoise.js", "../../@react-three/rapier/node_modules/src/math/Octree.js", "../../@react-three/rapier/node_modules/src/controls/FirstPersonControls.ts", "../../@react-three/rapier/node_modules/src/controls/PointerLockControls.ts", "../../@react-three/rapier/node_modules/src/controls/OrbitControls.ts", "../../@react-three/rapier/node_modules/src/controls/ArcballControls.ts", "../../@react-three/rapier/node_modules/src/postprocessing/Pass.ts", "../../@react-three/rapier/node_modules/src/shaders/HalftoneShader.ts", "../../@react-three/rapier/node_modules/src/shaders/SMAAShader.ts", "../../@react-three/rapier/node_modules/src/shaders/FilmShader.ts", "../../@react-three/rapier/node_modules/src/shaders/CopyShader.ts", "../../@react-three/rapier/node_modules/src/shaders/SSAOShader.ts", "../../@react-three/rapier/node_modules/src/postprocessing/SSAOPass.js", "../../@react-three/rapier/node_modules/src/shaders/BokehShader.ts", "../../@react-three/rapier/node_modules/src/shaders/LuminosityShader.ts", "../../@react-three/rapier/node_modules/src/shaders/ToneMapShader.ts", "../../@react-three/rapier/node_modules/src/shaders/LuminosityHighPassShader.ts", "../../@react-three/rapier/node_modules/src/postprocessing/UnrealBloomPass.js", "../../@react-three/rapier/node_modules/src/shaders/SAOShader.ts", "../../@react-three/rapier/node_modules/src/shaders/DepthLimitedBlurShader.ts", "../../@react-three/rapier/node_modules/src/postprocessing/SAOPass.js", "../../@react-three/rapier/node_modules/src/shaders/AfterimageShader.ts", "../../@react-three/rapier/node_modules/src/shaders/DotScreenShader.ts", "../../@react-three/rapier/node_modules/src/shaders/SSRShader.ts", "../../@react-three/rapier/node_modules/src/postprocessing/SSRPass.js", "../../@react-three/rapier/node_modules/src/shaders/ConvolutionShader.ts", "../../@react-three/rapier/node_modules/src/_polyfill/LoaderUtils.js", "../../@react-three/rapier/node_modules/src/loaders/GLTFLoader.js", "../../@react-three/rapier/node_modules/src/webxr/OculusHandPointerModel.js", "../../@react-three/rapier/node_modules/src/webxr/VRButton.ts", "../../@react-three/rapier/node_modules/src/libs/MotionControllers.ts", "../../@react-three/rapier/node_modules/src/webxr/XRHandPrimitiveModel.js", "../../@react-three/rapier/node_modules/src/geometries/RoundedBoxGeometry.js", "../../@react-three/rapier/node_modules/src/csm/CSMFrustum.js", "../../@react-three/rapier/node_modules/src/csm/CSM.js", "../../@react-three/rapier/node_modules/src/shaders/ACESFilmicToneMappingShader.ts", "../../@react-three/rapier/node_modules/src/shaders/BasicShader.ts", "../../@react-three/rapier/node_modules/src/shaders/BleachBypassShader.ts", "../../@react-three/rapier/node_modules/src/shaders/BlendShader.ts", "../../@react-three/rapier/node_modules/src/shaders/BrightnessContrastShader.ts", "../../@react-three/rapier/node_modules/src/shaders/ColorCorrectionShader.ts", "../../@react-three/rapier/node_modules/src/shaders/ColorifyShader.ts", "../../@react-three/rapier/node_modules/src/shaders/DOFMipMapShader.ts", "../../@react-three/rapier/node_modules/src/shaders/FXAAShader.ts", "../../@react-three/rapier/node_modules/src/shaders/FocusShader.ts", "../../@react-three/rapier/node_modules/src/shaders/FreiChenShader.ts", "../../@react-three/rapier/node_modules/src/shaders/FresnelShader.ts", "../../@react-three/rapier/node_modules/src/shaders/GammaCorrectionShader.ts", "../../@react-three/rapier/node_modules/src/shaders/GodRaysShader.ts", "../../@react-three/rapier/node_modules/src/shaders/HorizontalBlurShader.ts", "../../@react-three/rapier/node_modules/src/shaders/HorizontalTiltShiftShader.ts", "../../@react-three/rapier/node_modules/src/shaders/HueSaturationShader.ts", "../../@react-three/rapier/node_modules/src/shaders/KaleidoShader.ts", "../../@react-three/rapier/node_modules/src/shaders/MirrorShader.ts", "../../@react-three/rapier/node_modules/src/shaders/NormalMapShader.ts", "../../@react-three/rapier/node_modules/src/shaders/ParallaxShader.ts", "../../@react-three/rapier/node_modules/src/shaders/PixelShader.ts", "../../@react-three/rapier/node_modules/src/shaders/RGBShiftShader.ts", "../../@react-three/rapier/node_modules/src/shaders/SepiaShader.ts", "../../@react-three/rapier/node_modules/src/shaders/SobelOperatorShader.ts", "../../@react-three/rapier/node_modules/src/shaders/TechnicolorShader.ts", "../../@react-three/rapier/node_modules/src/shaders/ToonShader.ts", "../../@react-three/rapier/node_modules/src/shaders/TriangleBlurShader.ts", "../../@react-three/rapier/node_modules/src/shaders/VerticalBlurShader.ts", "../../@react-three/rapier/node_modules/src/shaders/VerticalTiltShiftShader.ts", "../../@react-three/rapier/node_modules/src/shaders/VignetteShader.ts", "../../@react-three/rapier/node_modules/src/shaders/VolumeShader.ts", "../../@react-three/rapier/node_modules/src/shaders/WaterRefractionShader.ts", "../../@react-three/rapier/node_modules/src/interactive/InteractiveGroup.js", "../../@react-three/rapier/node_modules/src/interactive/SelectionBox.js", "../../@react-three/rapier/node_modules/src/loaders/FBXLoader.js", "../../@react-three/rapier/node_modules/src/loaders/FontLoader.ts", "../../@react-three/rapier/node_modules/src/_polyfill/Data3DTexture.js", "../../@react-three/rapier/node_modules/src/loaders/XLoader.js", "../../@react-three/rapier/node_modules/src/libs/chevrotain.js", "../../@react-three/rapier/node_modules/src/utils/WorkerPool.js", "../../@react-three/rapier/node_modules/src/libs/ktx-parse.js", "../../@react-three/rapier/node_modules/src/libs/zstddec.ts", "../../@react-three/rapier/node_modules/src/_polyfill/CompressedCubeTexture.js", "../../@react-three/rapier/node_modules/src/_polyfill/CompressedArrayTexture.js", "../../@react-three/rapier/node_modules/src/loaders/KTX2Loader.js", "../../@react-three/rapier/node_modules/src/libs/lottie.js", "../../@react-three/rapier/node_modules/src/libs/opentype.js", "../../@react-three/rapier/node_modules/src/loaders/EXRLoader.js", "../../@react-three/rapier/node_modules/src/loaders/BasisTextureLoader.js", "../../@react-three/rapier/node_modules/src/loaders/LDrawLoader.js", "../../@react-three/rapier/node_modules/src/loaders/OBJLoader.js", "../../@react-three/rapier/node_modules/src/loaders/KTXLoader.js", "../../@react-three/rapier/node_modules/src/lines/LineSegmentsGeometry.js", "../../@react-three/rapier/node_modules/src/lines/Wireframe.js", "../../@react-three/rapier/node_modules/src/lines/LineSegments2.js", "../../@react-three/rapier/node_modules/src/helpers/RaycasterHelper.ts", "../../@react-three/rapier/node_modules/src/helpers/VertexTangentsHelper.js", "../../@react-three/rapier/node_modules/src/helpers/VertexNormalsHelper.js", "../../@react-three/rapier/node_modules/src/deprecated/Geometry.js"],
  "sourcesContent": ["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(/*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\n", "import { Line3, Plane, Triangle, Vector3 } from 'three'\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0\nconst Deleted = 1\n\nconst _v1 = new Vector3()\nconst _line3 = new Line3()\nconst _plane = new Plane()\nconst _closestPoint = new Vector3()\nconst _triangle = new Triangle()\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1\n\n    this.faces = [] // the generated faces of the convex hull\n    this.newFaces = [] // this array holds the faces that are generated within a single iteration\n\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n    this.assigned = new VertexList()\n    this.unassigned = new VertexList()\n\n    this.vertices = [] // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n\n    if (points.length >= 4) {\n      this.makeEmpty()\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]))\n      }\n\n      this.compute()\n    }\n\n    return this\n  }\n\n  setFromObject(object) {\n    const points = []\n\n    object.updateMatrixWorld(true)\n\n    object.traverse(function (node) {\n      const geometry = node.geometry\n\n      if (geometry !== undefined) {\n        const attribute = geometry.attributes.position\n\n        if (attribute !== undefined) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3()\n\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld)\n\n            points.push(point)\n          }\n        }\n      }\n    })\n\n    return this.setFromPoints(points)\n  }\n\n  containsPoint(point) {\n    const faces = this.faces\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]\n\n      // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false\n    }\n\n    return true\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n    const faces = this.faces\n\n    let tNear = -Infinity\n    let tFar = Infinity\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]\n\n      // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin)\n      const vD = face.normal.dot(ray.direction)\n\n      // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null\n\n      // compute the distance from the rays origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0\n\n      // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue\n\n      // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        // plane faces away from the ray, so this plane is a back-face\n\n        tFar = Math.min(t, tFar)\n      } else {\n        // front-face\n\n        tNear = Math.max(t, tNear)\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n\n        return null\n      }\n    }\n\n    // evaluate intersection point\n\n    // always try tNear first since its the closer intersection point\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target)\n    } else {\n      ray.at(tFar, target)\n    }\n\n    return target\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null\n  }\n\n  makeEmpty() {\n    this.faces = []\n    this.vertices = []\n\n    return this\n  }\n\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face\n\n    if (face.outside === null) {\n      this.assigned.append(vertex)\n    } else {\n      this.assigned.insertBefore(face.outside, vertex)\n    }\n\n    face.outside = vertex\n\n    return this\n  }\n\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n\n        face.outside = vertex.next\n      } else {\n        // vertex was the only outside vertex that face had\n\n        face.outside = null\n      }\n    }\n\n    this.assigned.remove(vertex)\n\n    return this\n  }\n\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n\n      const start = face.outside\n      let end = face.outside\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next\n      }\n\n      this.assigned.removeSubList(start, end)\n\n      // fix references\n\n      start.prev = end.next = null\n      face.outside = null\n\n      return start\n    }\n  }\n\n  // Removes all the visible vertices that 'face' is able to see\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face)\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n\n        this.unassigned.appendChain(faceVertices)\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n\n        let vertex = faceVertices\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n\n          const nextVertex = vertex.next\n\n          const distance = absorbingFace.distanceToPoint(vertex.point)\n\n          // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace)\n          } else {\n            this.unassigned.append(vertex)\n          }\n\n          // now assign next vertex\n\n          vertex = nextVertex\n        } while (vertex !== null)\n      }\n    }\n\n    return this\n  }\n\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first()\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n\n        const nextVertex = vertex.next\n\n        let maxDistance = this.tolerance\n\n        let maxFace = null\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i]\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = face\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break\n          }\n        }\n\n        // 'maxFace' can be null e.g. if there are identical vertices\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n\n        vertex = nextVertex\n      } while (vertex !== null)\n    }\n\n    return this\n  }\n\n  // Computes the extremes of a simplex which will be the initial hull\n\n  computeExtremes() {\n    const min = new Vector3()\n    const max = new Vector3()\n\n    const minVertices = []\n    const maxVertices = []\n\n    // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0]\n    }\n\n    min.copy(this.vertices[0].point)\n    max.copy(this.vertices[0].point)\n\n    // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i]\n      const point = vertex.point\n\n      // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j))\n          minVertices[j] = vertex\n        }\n      }\n\n      // update the max coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j))\n          maxVertices[j] = vertex\n        }\n      }\n    }\n\n    // use min/max vectors to compute an optimal epsilon\n\n    this.tolerance =\n      3 *\n      Number.EPSILON *\n      (Math.max(Math.abs(min.x), Math.abs(max.x)) +\n        Math.max(Math.abs(min.y), Math.abs(max.y)) +\n        Math.max(Math.abs(min.z), Math.abs(max.z)))\n\n    return { min: minVertices, max: maxVertices }\n  }\n\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n  computeInitialHull() {\n    const vertices = this.vertices\n    const extremes = this.computeExtremes()\n    const min = extremes.min\n    const max = extremes.max\n\n    // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0\n    let index = 0\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i)\n\n      if (distance > maxDistance) {\n        maxDistance = distance\n        index = i\n      }\n    }\n\n    const v0 = min[index]\n    const v1 = max[index]\n    let v2\n    let v3\n\n    // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0\n    _line3.set(v0.point, v1.point)\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint)\n\n        const distance = _closestPoint.distanceToSquared(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          v2 = vertex\n        }\n      }\n    }\n\n    // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n    maxDistance = -1\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point)\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point))\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          v3 = vertex\n        }\n      }\n    }\n\n    const faces = []\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2))\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j))\n\n        // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0))\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0))\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3))\n\n        // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1))\n      }\n    }\n\n    // the initial hull is the tetrahedron\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i])\n    }\n\n    // initial assignment of vertices to the faces of the tetrahedron\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance\n        let maxFace = null\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point)\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            maxFace = this.faces[j]\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n      }\n    }\n\n    return this\n  }\n\n  // Removes inactive faces\n\n  reindexFaces() {\n    const activeFaces = []\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      if (face.mark === Visible) {\n        activeFaces.push(face)\n      }\n    }\n\n    this.faces = activeFaces\n\n    return this\n  }\n\n  // Finds the next vertex to create faces with the current hull\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0\n\n      // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face\n      let vertex = eyeFace.outside\n\n      // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          eyeVertex = vertex\n        }\n\n        vertex = vertex.next\n      } while (vertex !== null && vertex.face === eyeFace)\n\n      return eyeVertex\n    }\n  }\n\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n\n    this.deleteFaceVertices(face)\n\n    face.mark = Deleted\n\n    let edge\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0)\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n      edge = crossEdge.next\n    }\n\n    do {\n      const twinEdge = edge.twin\n      const oppositeFace = twinEdge.face\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon)\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n\n          horizon.push(edge)\n        }\n      }\n\n      edge = edge.next\n    } while (edge !== crossEdge)\n\n    return this\n  }\n\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head())\n\n    this.faces.push(face)\n\n    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin)\n\n    return face.getEdge(0) // the half edge whose vertex is the eyeVertex\n  }\n\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = []\n\n    let firstSideEdge = null\n    let previousSideEdge = null\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]\n\n      // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge)\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n        sideEdge.next.setTwin(previousSideEdge)\n      }\n\n      this.newFaces.push(sideEdge.face)\n      previousSideEdge = sideEdge\n    }\n\n    // perform final join of new faces\n\n    firstSideEdge.next.setTwin(previousSideEdge)\n\n    return this\n  }\n\n  // Adds a vertex to the hull\n\n  addVertexToHull(eyeVertex) {\n    const horizon = []\n\n    this.unassigned.clear()\n\n    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face)\n\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon)\n\n    this.addNewFaces(eyeVertex, horizon)\n\n    // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces)\n\n    return this\n  }\n\n  cleanup() {\n    this.assigned.clear()\n    this.unassigned.clear()\n    this.newFaces = []\n\n    return this\n  }\n\n  compute() {\n    let vertex\n\n    this.computeInitialHull()\n\n    // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex)\n    }\n\n    this.reindexFaces()\n\n    this.cleanup()\n\n    return this\n  }\n}\n\n//\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3()\n    this.midpoint = new Vector3()\n    this.area = 0\n\n    this.constant = 0 // signed distance from face to the origin\n    this.outside = null // reference to a vertex in a vertex list this face can see\n    this.mark = Visible\n    this.edge = null\n  }\n\n  static create(a, b, c) {\n    const face = new Face()\n\n    const e0 = new HalfEdge(a, face)\n    const e1 = new HalfEdge(b, face)\n    const e2 = new HalfEdge(c, face)\n\n    // join edges\n\n    e0.next = e2.prev = e1\n    e1.next = e0.prev = e2\n    e2.next = e1.prev = e0\n\n    // main half edge reference\n\n    face.edge = e0\n\n    return face.compute()\n  }\n\n  getEdge(i) {\n    let edge = this.edge\n\n    while (i > 0) {\n      edge = edge.next\n      i--\n    }\n\n    while (i < 0) {\n      edge = edge.prev\n      i++\n    }\n\n    return edge\n  }\n\n  compute() {\n    const a = this.edge.tail()\n    const b = this.edge.head()\n    const c = this.edge.next.head()\n\n    _triangle.set(a.point, b.point, c.point)\n\n    _triangle.getNormal(this.normal)\n    _triangle.getMidpoint(this.midpoint)\n    this.area = _triangle.getArea()\n\n    this.constant = this.normal.dot(this.midpoint)\n\n    return this\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant\n  }\n}\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex\n    this.prev = null\n    this.next = null\n    this.twin = null\n    this.face = face\n  }\n\n  head() {\n    return this.vertex\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null\n  }\n\n  length() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point)\n    }\n\n    return -1\n  }\n\n  lengthSquared() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point)\n    }\n\n    return -1\n  }\n\n  setTwin(edge) {\n    this.twin = edge\n    edge.twin = this\n\n    return this\n  }\n}\n\n// A vertex as a double linked list node.\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point\n    this.prev = null\n    this.next = null\n    this.face = null // the face that is able to see this vertex\n  }\n}\n\n// A double linked list that contains vertex nodes.\n\nclass VertexList {\n  constructor() {\n    this.head = null\n    this.tail = null\n  }\n\n  first() {\n    return this.head\n  }\n\n  last() {\n    return this.tail\n  }\n\n  clear() {\n    this.head = this.tail = null\n\n    return this\n  }\n\n  // Inserts a vertex before the target vertex\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev\n    vertex.next = target\n\n    if (vertex.prev === null) {\n      this.head = vertex\n    } else {\n      vertex.prev.next = vertex\n    }\n\n    target.prev = vertex\n\n    return this\n  }\n\n  // Inserts a vertex after the target vertex\n\n  insertAfter(target, vertex) {\n    vertex.prev = target\n    vertex.next = target.next\n\n    if (vertex.next === null) {\n      this.tail = vertex\n    } else {\n      vertex.next.prev = vertex\n    }\n\n    target.next = vertex\n\n    return this\n  }\n\n  // Appends a vertex to the end of the linked list\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n    vertex.next = null // the tail has no subsequent vertex\n\n    this.tail = vertex\n\n    return this\n  }\n\n  // Appends a chain of vertices where 'vertex' is the head.\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n\n    // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next\n    }\n\n    this.tail = vertex\n\n    return this\n  }\n\n  // Removes a vertex from the linked list\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next\n    } else {\n      vertex.prev.next = vertex.next\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev\n    } else {\n      vertex.next.prev = vertex.prev\n    }\n\n    return this\n  }\n\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next\n    } else {\n      a.prev.next = b.next\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev\n    } else {\n      b.next.prev = a.prev\n    }\n\n    return this\n  }\n\n  isEmpty() {\n    return this.head === null\n  }\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList }\n", "import { Line3, Mesh, Plane, Vector3 } from 'three'\nimport { ConvexGeometry } from '../geometries/ConvexGeometry'\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a buffer geometry and a material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nconst _v1 = new Vector3()\n\nclass ConvexObjectBreaker {\n  constructor(minSizeForBreak = 1.4, smallDelta = 0.0001) {\n    this.minSizeForBreak = minSizeForBreak\n    this.smallDelta = smallDelta\n\n    this.tempLine1 = new Line3()\n    this.tempPlane1 = new Plane()\n    this.tempPlane2 = new Plane()\n    this.tempPlane_Cut = new Plane()\n    this.tempCM1 = new Vector3()\n    this.tempCM2 = new Vector3()\n    this.tempVector3 = new Vector3()\n    this.tempVector3_2 = new Vector3()\n    this.tempVector3_3 = new Vector3()\n    this.tempVector3_P0 = new Vector3()\n    this.tempVector3_P1 = new Vector3()\n    this.tempVector3_P2 = new Vector3()\n    this.tempVector3_N0 = new Vector3()\n    this.tempVector3_N1 = new Vector3()\n    this.tempVector3_AB = new Vector3()\n    this.tempVector3_CB = new Vector3()\n    this.tempResultObjects = { object1: null, object2: null }\n\n    this.segments = []\n    const n = 30 * 30\n    for (let i = 0; i < n; i++) this.segments[i] = false\n  }\n\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n\n    const userData = object.userData\n    userData.mass = mass\n    userData.velocity = velocity.clone()\n    userData.angularVelocity = angularVelocity.clone()\n    userData.breakable = breakable\n  }\n\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = []\n\n    const tempPlane1 = this.tempPlane1\n    const tempPlane2 = this.tempPlane2\n\n    this.tempVector3.addVectors(pointOfImpact, normal)\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3)\n\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations\n\n    const scope = this\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject)\n\n        return\n      }\n\n      let angle = Math.PI\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal)\n        tempPlane2.constant = tempPlane1.constant\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle\n\n          // Rotate tempPlane2 at impact point around normal axis and the angle\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact)\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2)\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI\n\n          // Rotate tempPlane2 at object position around normal axis and the angle\n          scope.tempVector3_2\n            .copy(pointOfImpact)\n            .sub(subObject.position)\n            .applyAxisAngle(normal, angle)\n            .add(subObject.position)\n          scope.tempVector3_3.copy(normal).add(subObject.position)\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2)\n        }\n      }\n\n      // Perform the cut\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects)\n\n      const obj1 = scope.tempResultObjects.object1\n      const obj2 = scope.tempResultObjects.object2\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1)\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1)\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0)\n\n    return debris\n  }\n\n  cutByPlane(object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n\n    const geometry = object.geometry\n    const coords = geometry.attributes.position.array\n    const normals = geometry.attributes.normal.array\n\n    const numPoints = coords.length / 3\n    let numFaces = numPoints / 3\n\n    let indices = geometry.getIndex()\n\n    if (indices) {\n      indices = indices.array\n      numFaces = indices.length / 3\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n\n      const idx = faceIdx * 3 + vert\n\n      return indices ? indices[idx] : idx\n    }\n\n    const points1 = []\n    const points2 = []\n\n    const delta = this.smallDelta\n\n    // Reset segments mark\n    const numPointPairs = numPoints * numPoints\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false\n\n    const p0 = this.tempVector3_P0\n    const p1 = this.tempVector3_P1\n    const n0 = this.tempVector3_N0\n    const n1 = this.tempVector3_N1\n\n    // Iterate through the faces to mark edges shared by coplanar faces\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0)\n      const b1 = getVertexIndex(i, 1)\n      const c1 = getVertexIndex(i, 2)\n\n      // Assuming all 3 vertices have the same normal\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2)\n\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0)\n        const b2 = getVertexIndex(j, 1)\n        const c2 = getVertexIndex(j, 2)\n\n        // Assuming all 3 vertices have the same normal\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2)\n\n        const coplanar = 1 - n0.dot(n1) < delta\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true\n              this.segments[b1 * numPoints + a1] = true\n            } else {\n              this.segments[c1 * numPoints + a1] = true\n              this.segments[a1 * numPoints + c1] = true\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true\n            this.segments[b1 * numPoints + c1] = true\n          }\n        }\n      }\n    }\n\n    // Transform the plane to object local space\n    const localPlane = this.tempPlane_Cut\n    object.updateMatrix()\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane)\n\n    // Iterate through the faces adding points to both pieces\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0)\n      const vb = getVertexIndex(i, 1)\n      const vc = getVertexIndex(i, 2)\n\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va\n\n        const segmentState = this.segments[i0 * numPoints + i1]\n\n        if (segmentState) continue // The segment already has been processed in another face\n\n        // Mark segment as processed (also inverted segment)\n        this.segments[i0 * numPoints + i1] = true\n        this.segments[i1 * numPoints + i0] = true\n\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2])\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2])\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark0 = 0\n\n        let d = localPlane.distanceToPoint(p0)\n\n        if (d > delta) {\n          mark0 = 2\n          points2.push(p0.clone())\n        } else if (d < -delta) {\n          mark0 = 1\n          points1.push(p0.clone())\n        } else {\n          mark0 = 3\n          points1.push(p0.clone())\n          points2.push(p0.clone())\n        }\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark1 = 0\n\n        d = localPlane.distanceToPoint(p1)\n\n        if (d > delta) {\n          mark1 = 2\n          points2.push(p1.clone())\n        } else if (d < -delta) {\n          mark1 = 1\n          points1.push(p1.clone())\n        } else {\n          mark1 = 3\n          points1.push(p1.clone())\n          points2.push(p1.clone())\n        }\n\n        if ((mark0 === 1 && mark1 === 2) || (mark0 === 2 && mark1 === 1)) {\n          // Intersection of segment with the plane\n\n          this.tempLine1.start.copy(p0)\n          this.tempLine1.end.copy(p1)\n\n          let intersection = new Vector3()\n          intersection = localPlane.intersectLine(this.tempLine1, intersection)\n\n          if (intersection === null) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.')\n            output.segmentedObject1 = null\n            output.segmentedObject2 = null\n            return 0\n          }\n\n          points1.push(intersection)\n          points2.push(intersection.clone())\n        }\n      }\n    }\n\n    // Calculate debris mass (very fast and imprecise):\n    const newMass = object.userData.mass * 0.5\n\n    // Calculate debris Center of Mass (again fast and imprecise)\n    this.tempCM1.set(0, 0, 0)\n    let radius1 = 0\n    const numPoints1 = points1.length\n\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i])\n\n      this.tempCM1.divideScalar(numPoints1)\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i]\n        p.sub(this.tempCM1)\n        radius1 = Math.max(radius1, p.x, p.y, p.z)\n      }\n\n      this.tempCM1.add(object.position)\n    }\n\n    this.tempCM2.set(0, 0, 0)\n    let radius2 = 0\n    const numPoints2 = points2.length\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i])\n\n      this.tempCM2.divideScalar(numPoints2)\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i]\n        p.sub(this.tempCM2)\n        radius2 = Math.max(radius2, p.x, p.y, p.z)\n      }\n\n      this.tempCM2.add(object.position)\n    }\n\n    let object1 = null\n    let object2 = null\n\n    let numObjects = 0\n\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material)\n      object1.position.copy(this.tempCM1)\n      object1.quaternion.copy(object.quaternion)\n\n      this.prepareBreakableObject(\n        object1,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius1 > this.minSizeForBreak,\n      )\n\n      numObjects++\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material)\n      object2.position.copy(this.tempCM2)\n      object2.quaternion.copy(object.quaternion)\n\n      this.prepareBreakableObject(\n        object2,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius2 > this.minSizeForBreak,\n      )\n\n      numObjects++\n    }\n\n    output.object1 = object1\n    output.object2 = object2\n\n    return numObjects\n  }\n\n  static transformFreeVector(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[4] * y + e[8] * z\n    v.y = e[1] * x + e[5] * y + e[9] * z\n    v.z = e[2] * x + e[6] * y + e[10] * z\n\n    return v\n  }\n\n  static transformFreeVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[1] * y + e[2] * z\n    v.y = e[4] * x + e[5] * y + e[6] * z\n    v.z = e[8] * x + e[9] * y + e[10] * z\n\n    return v\n  }\n\n  static transformTiedVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a tied (ordinary) vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12]\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13]\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14]\n\n    return v\n  }\n\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal)\n    resultPlane.constant = plane.constant\n\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m)\n\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m)\n\n    // recalculate constant (like in setFromNormalAndCoplanarPoint)\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal)\n  }\n}\n\nexport { ConvexObjectBreaker }\n", "import { Object3D, Quaternion, Vector3 } from 'three'\n\nconst _translationObject = new Vector3()\nconst _quaternionObject = new Quaternion()\nconst _scaleObject = new Vector3()\n\nconst _translationWorld = new Vector3()\nconst _quaternionWorld = new Quaternion()\nconst _scaleWorld = new Vector3()\n\nclass Gyroscope extends Object3D {\n  constructor() {\n    super()\n  }\n\n  updateMatrixWorld(force) {\n    this.matrixAutoUpdate && this.updateMatrix()\n\n    // update matrixWorld\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent !== null) {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)\n\n        this.matrixWorld.decompose(_translationWorld, _quaternionWorld, _scaleWorld)\n        this.matrix.decompose(_translationObject, _quaternionObject, _scaleObject)\n\n        this.matrixWorld.compose(_translationWorld, _quaternionObject, _scaleWorld)\n      } else {\n        this.matrixWorld.copy(this.matrix)\n      }\n\n      this.matrixWorldNeedsUpdate = false\n\n      force = true\n    }\n\n    // update children\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].updateMatrixWorld(force)\n    }\n  }\n}\n\nexport { Gyroscope }\n", "import { REVISION } from 'three'\n\nexport const version = parseInt(REVISION.replace(/\\D+/g, ''))\n", "import { version } from \"./constants\";\n\n/** uv2 renamed to uv1 in r125\n * \n * https://github.com/mrdoob/three.js/pull/25943\n*/\nexport const UV1 = version >= 125 ? 'uv1' : 'uv2'", "import { Matrix4, Object3D, Vector2, Vector3 } from 'three'\n\nclass CSS2DObject extends Object3D {\n  constructor(element = document.createElement('div')) {\n    super()\n\n    this.isCSS2DObject = true\n\n    this.element = element\n\n    this.element.style.position = 'absolute'\n    this.element.style.userSelect = 'none'\n\n    this.element.setAttribute('draggable', false)\n\n    this.center = new Vector2(0.5, 0.5) // ( 0, 0 ) is the lower left; ( 1, 1 ) is the top right\n\n    this.addEventListener('removed', function () {\n      this.traverse(function (object) {\n        if (object.element instanceof Element && object.element.parentNode !== null) {\n          object.element.parentNode.removeChild(object.element)\n        }\n      })\n    })\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.element = source.element.cloneNode(true)\n\n    this.center = source.center\n\n    return this\n  }\n}\n\nconst _vector = new Vector3()\nconst _viewMatrix = new Matrix4()\nconst _viewProjectionMatrix = new Matrix4()\nconst _a = new Vector3()\nconst _b = new Vector3()\n\nclass CSS2DRenderer {\n  constructor(parameters = {}) {\n    const _this = this\n\n    let _width, _height\n    let _widthHalf, _heightHalf\n\n    const cache = {\n      objects: new WeakMap(),\n    }\n\n    const domElement = parameters.element !== undefined ? parameters.element : document.createElement('div')\n\n    domElement.style.overflow = 'hidden'\n\n    this.domElement = domElement\n\n    this.getSize = function () {\n      return {\n        width: _width,\n        height: _height,\n      }\n    }\n\n    this.render = function (scene, camera) {\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld()\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld()\n\n      _viewMatrix.copy(camera.matrixWorldInverse)\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix)\n\n      renderObject(scene, scene, camera)\n      zOrder(scene)\n    }\n\n    this.setSize = function (width, height) {\n      _width = width\n      _height = height\n\n      _widthHalf = _width / 2\n      _heightHalf = _height / 2\n\n      domElement.style.width = width + 'px'\n      domElement.style.height = height + 'px'\n    }\n\n    function renderObject(object, scene, camera) {\n      if (object.isCSS2DObject) {\n        _vector.setFromMatrixPosition(object.matrixWorld)\n        _vector.applyMatrix4(_viewProjectionMatrix)\n\n        const visible =\n          object.visible === true && _vector.z >= -1 && _vector.z <= 1 && object.layers.test(camera.layers) === true\n        object.element.style.display = visible === true ? '' : 'none'\n\n        if (visible === true) {\n          object.onBeforeRender(_this, scene, camera)\n\n          const element = object.element\n\n          element.style.transform =\n            'translate(' +\n            -100 * object.center.x +\n            '%,' +\n            -100 * object.center.y +\n            '%)' +\n            'translate(' +\n            (_vector.x * _widthHalf + _widthHalf) +\n            'px,' +\n            (-_vector.y * _heightHalf + _heightHalf) +\n            'px)'\n\n          if (element.parentNode !== domElement) {\n            domElement.appendChild(element)\n          }\n\n          object.onAfterRender(_this, scene, camera)\n        }\n\n        const objectData = {\n          distanceToCameraSquared: getDistanceToSquared(camera, object),\n        }\n\n        cache.objects.set(object, objectData)\n      }\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        renderObject(object.children[i], scene, camera)\n      }\n    }\n\n    function getDistanceToSquared(object1, object2) {\n      _a.setFromMatrixPosition(object1.matrixWorld)\n      _b.setFromMatrixPosition(object2.matrixWorld)\n\n      return _a.distanceToSquared(_b)\n    }\n\n    function filterAndFlatten(scene) {\n      const result = []\n\n      scene.traverse(function (object) {\n        if (object.isCSS2DObject) result.push(object)\n      })\n\n      return result\n    }\n\n    function zOrder(scene) {\n      const sorted = filterAndFlatten(scene).sort(function (a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n          return b.renderOrder - a.renderOrder\n        }\n\n        const distanceA = cache.objects.get(a).distanceToCameraSquared\n        const distanceB = cache.objects.get(b).distanceToCameraSquared\n\n        return distanceA - distanceB\n      })\n\n      const zMax = sorted.length\n\n      for (let i = 0, l = sorted.length; i < l; i++) {\n        sorted[i].element.style.zIndex = zMax - i\n      }\n    }\n  }\n}\n\nexport { CSS2DObject, CSS2DRenderer }\n", "import { Matrix4, Object3D, Quaternion, Vector3 } from 'three'\n\n/**\n * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs\n */\n\nconst _position = new Vector3()\nconst _quaternion = new Quaternion()\nconst _scale = new Vector3()\n\nclass CSS3DObject extends Object3D {\n  constructor(element = document.createElement('div')) {\n    super()\n\n    this.isCSS3DObject = true\n\n    this.element = element\n    this.element.style.position = 'absolute'\n    this.element.style.pointerEvents = 'auto'\n    this.element.style.userSelect = 'none'\n\n    this.element.setAttribute('draggable', false)\n\n    this.addEventListener('removed', function () {\n      this.traverse(function (object) {\n        if (object.element instanceof Element && object.element.parentNode !== null) {\n          object.element.parentNode.removeChild(object.element)\n        }\n      })\n    })\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.element = source.element.cloneNode(true)\n\n    return this\n  }\n}\n\nclass CSS3DSprite extends CSS3DObject {\n  constructor(element) {\n    super(element)\n\n    this.isCSS3DSprite = true\n\n    this.rotation2D = 0\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.rotation2D = source.rotation2D\n\n    return this\n  }\n}\n\n//\n\nconst _matrix = new Matrix4()\nconst _matrix2 = new Matrix4()\n\nclass CSS3DRenderer {\n  constructor(parameters = {}) {\n    const _this = this\n\n    let _width, _height\n    let _widthHalf, _heightHalf\n\n    const cache = {\n      camera: { style: '' },\n      objects: new WeakMap(),\n    }\n\n    const domElement = parameters.element !== undefined ? parameters.element : document.createElement('div')\n\n    domElement.style.overflow = 'hidden'\n\n    this.domElement = domElement\n\n    const viewElement = document.createElement('div')\n    viewElement.style.transformOrigin = '0 0'\n    viewElement.style.pointerEvents = 'none'\n    domElement.appendChild(viewElement)\n\n    const cameraElement = document.createElement('div')\n\n    cameraElement.style.transformStyle = 'preserve-3d'\n\n    viewElement.appendChild(cameraElement)\n\n    this.getSize = function () {\n      return {\n        width: _width,\n        height: _height,\n      }\n    }\n\n    this.render = function (scene, camera) {\n      const fov = camera.projectionMatrix.elements[5] * _heightHalf\n\n      if (camera.view && camera.view.enabled) {\n        // view offset\n        viewElement.style.transform = `translate( ${-camera.view.offsetX * (_width / camera.view.width)}px, ${\n          -camera.view.offsetY * (_height / camera.view.height)\n        }px )`\n\n        // view fullWidth and fullHeight, view width and height\n        viewElement.style.transform += `scale( ${camera.view.fullWidth / camera.view.width}, ${\n          camera.view.fullHeight / camera.view.height\n        } )`\n      } else {\n        viewElement.style.transform = ''\n      }\n\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld()\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld()\n\n      let tx, ty\n\n      if (camera.isOrthographicCamera) {\n        tx = -(camera.right + camera.left) / 2\n        ty = (camera.top + camera.bottom) / 2\n      }\n\n      const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1\n      const cameraCSSMatrix = camera.isOrthographicCamera\n        ? `scale( ${scaleByViewOffset} )` +\n          'scale(' +\n          fov +\n          ')' +\n          'translate(' +\n          epsilon(tx) +\n          'px,' +\n          epsilon(ty) +\n          'px)' +\n          getCameraCSSMatrix(camera.matrixWorldInverse)\n        : `scale( ${scaleByViewOffset} )` + 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse)\n      const perspective = camera.isPerspectiveCamera ? 'perspective(' + fov + 'px) ' : ''\n\n      const style = perspective + cameraCSSMatrix + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)'\n\n      if (cache.camera.style !== style) {\n        cameraElement.style.transform = style\n\n        cache.camera.style = style\n      }\n\n      renderObject(scene, scene, camera, cameraCSSMatrix)\n    }\n\n    this.setSize = function (width, height) {\n      _width = width\n      _height = height\n      _widthHalf = _width / 2\n      _heightHalf = _height / 2\n\n      domElement.style.width = width + 'px'\n      domElement.style.height = height + 'px'\n\n      viewElement.style.width = width + 'px'\n      viewElement.style.height = height + 'px'\n\n      cameraElement.style.width = width + 'px'\n      cameraElement.style.height = height + 'px'\n    }\n\n    function epsilon(value) {\n      return Math.abs(value) < 1e-10 ? 0 : value\n    }\n\n    function getCameraCSSMatrix(matrix) {\n      const elements = matrix.elements\n\n      return (\n        'matrix3d(' +\n        epsilon(elements[0]) +\n        ',' +\n        epsilon(-elements[1]) +\n        ',' +\n        epsilon(elements[2]) +\n        ',' +\n        epsilon(elements[3]) +\n        ',' +\n        epsilon(elements[4]) +\n        ',' +\n        epsilon(-elements[5]) +\n        ',' +\n        epsilon(elements[6]) +\n        ',' +\n        epsilon(elements[7]) +\n        ',' +\n        epsilon(elements[8]) +\n        ',' +\n        epsilon(-elements[9]) +\n        ',' +\n        epsilon(elements[10]) +\n        ',' +\n        epsilon(elements[11]) +\n        ',' +\n        epsilon(elements[12]) +\n        ',' +\n        epsilon(-elements[13]) +\n        ',' +\n        epsilon(elements[14]) +\n        ',' +\n        epsilon(elements[15]) +\n        ')'\n      )\n    }\n\n    function getObjectCSSMatrix(matrix) {\n      const elements = matrix.elements\n      const matrix3d =\n        'matrix3d(' +\n        epsilon(elements[0]) +\n        ',' +\n        epsilon(elements[1]) +\n        ',' +\n        epsilon(elements[2]) +\n        ',' +\n        epsilon(elements[3]) +\n        ',' +\n        epsilon(-elements[4]) +\n        ',' +\n        epsilon(-elements[5]) +\n        ',' +\n        epsilon(-elements[6]) +\n        ',' +\n        epsilon(-elements[7]) +\n        ',' +\n        epsilon(elements[8]) +\n        ',' +\n        epsilon(elements[9]) +\n        ',' +\n        epsilon(elements[10]) +\n        ',' +\n        epsilon(elements[11]) +\n        ',' +\n        epsilon(elements[12]) +\n        ',' +\n        epsilon(elements[13]) +\n        ',' +\n        epsilon(elements[14]) +\n        ',' +\n        epsilon(elements[15]) +\n        ')'\n\n      return 'translate(-50%,-50%)' + matrix3d\n    }\n\n    function renderObject(object, scene, camera, cameraCSSMatrix) {\n      if (object.isCSS3DObject) {\n        const visible = object.visible === true && object.layers.test(camera.layers) === true\n        object.element.style.display = visible === true ? '' : 'none'\n\n        if (visible === true) {\n          object.onBeforeRender(_this, scene, camera)\n\n          let style\n\n          if (object.isCSS3DSprite) {\n            // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\n\n            _matrix.copy(camera.matrixWorldInverse)\n            _matrix.transpose()\n\n            if (object.rotation2D !== 0) _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D))\n\n            object.matrixWorld.decompose(_position, _quaternion, _scale)\n            _matrix.setPosition(_position)\n            _matrix.scale(_scale)\n\n            _matrix.elements[3] = 0\n            _matrix.elements[7] = 0\n            _matrix.elements[11] = 0\n            _matrix.elements[15] = 1\n\n            style = getObjectCSSMatrix(_matrix)\n          } else {\n            style = getObjectCSSMatrix(object.matrixWorld)\n          }\n\n          const element = object.element\n          const cachedObject = cache.objects.get(object)\n\n          if (cachedObject === undefined || cachedObject.style !== style) {\n            element.style.transform = style\n\n            const objectData = { style: style }\n            cache.objects.set(object, objectData)\n          }\n\n          if (element.parentNode !== cameraElement) {\n            cameraElement.appendChild(element)\n          }\n\n          object.onAfterRender(_this, scene, camera)\n        }\n      }\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        renderObject(object.children[i], scene, camera, cameraCSSMatrix)\n      }\n    }\n  }\n}\n\nexport { CSS3DObject, CSS3DSprite, CSS3DRenderer }\n", "// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4\nconst TEXTURE_WIDTH = 1024\nconst TEXTURE_HEIGHT = 4\n\nimport {\n  DataTexture,\n  RGBAFormat,\n  FloatType,\n  RepeatWrapping,\n  Mesh,\n  InstancedMesh,\n  NearestFilter,\n  DynamicDrawUsage,\n  Matrix4,\n  Material,\n  Curve,\n  BufferGeometry,\n} from 'three'\n\nimport type { IUniform } from 'three'\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nexport const initSplineTexture = (numberOfCurves = 1): DataTexture => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS)\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType)\n\n  dataTexture.wrapS = RepeatWrapping\n  dataTexture.wrapT = RepeatWrapping\n  dataTexture.magFilter = NearestFilter\n  dataTexture.needsUpdate = true\n\n  return dataTexture\n}\n\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\nexport const updateSplineTexture = <TCurve extends Curve<any>>(\n  texture: DataTexture,\n  splineCurve: TCurve,\n  offset = 0,\n): void => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4))\n  splineCurve.arcLengthDivisions = numberOfPoints / 2\n  splineCurve.updateArcLengths()\n  const points = splineCurve.getSpacedPoints(numberOfPoints)\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true)\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH)\n    const rowIndex = i % TEXTURE_WIDTH\n\n    let pt = points[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset)\n    pt = frenetFrames.tangents[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset)\n    pt = frenetFrames.normals[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset)\n    pt = frenetFrames.binormals[i]\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset)\n  }\n\n  texture.needsUpdate = true\n}\n\nconst setTextureValue = (texture: DataTexture, index: number, x: number, y: number, z: number, o: number): void => {\n  const image = texture.image\n  const { data } = image\n  const i = CHANNELS * TEXTURE_WIDTH * o // Row Offset\n  data[index * CHANNELS + i + 0] = x\n  data[index * CHANNELS + i + 1] = y\n  data[index * CHANNELS + i + 2] = z\n  data[index * CHANNELS + i + 3] = 1\n}\n\nexport interface INumericUniform extends IUniform {\n  type: 'f' | 'i'\n  value: number\n}\n\nexport type CurveModifierUniforms = {\n  spineTexture: IUniform<DataTexture>\n  pathOffset: INumericUniform\n  pathSegment: INumericUniform\n  spineOffset: INumericUniform\n  spineLength: INumericUniform\n  flow: INumericUniform\n}\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nexport const getUniforms = (splineTexture: DataTexture): CurveModifierUniforms => ({\n  spineTexture: { value: splineTexture },\n  pathOffset: { type: 'f', value: 0 }, // time of path curve\n  pathSegment: { type: 'f', value: 1 }, // fractional length of path\n  spineOffset: { type: 'f', value: 161 },\n  spineLength: { type: 'f', value: 400 },\n  flow: { type: 'i', value: 1 },\n})\n\nexport type ModifiedMaterial<TMaterial extends Material> = TMaterial & {\n  __ok: boolean\n}\n\nexport function modifyShader<TMaterial extends Material = Material>(\n  material: ModifiedMaterial<TMaterial>,\n  uniforms: CurveModifierUniforms,\n  numberOfCurves = 1,\n): void {\n  if (material.__ok) return\n  material.__ok = true\n\n  material.onBeforeCompile = (shader: { vertexShader: string; uniforms: { [uniform: string]: IUniform } }): void => {\n    if ((shader as any).__modified) return\n    ;(shader as any).__modified = true\n\n    Object.assign(shader.uniforms, uniforms)\n\n    const vertexShader = /* glsl */ `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t`\n      // chunk import moved in front of modified shader below\n      .replace('#include <beginnormal_vertex>', '')\n\n      // vec3 transformedNormal declaration overriden below\n      .replace('#include <defaultnormal_vertex>', '')\n\n      // vec3 transformed declaration overriden below\n      .replace('#include <begin_vertex>', '')\n\n      // shader override\n      .replace(\n        /void\\s*main\\s*\\(\\)\\s*\\{/,\n        /* glsl */ `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`,\n      )\n      .replace(\n        '#include <project_vertex>',\n        /* glsl */ `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`,\n      )\n\n    shader.vertexShader = vertexShader\n  }\n}\n\n/**\n * A helper class for making meshes bend aroudn curves\n */\nexport class Flow<TMesh extends Mesh = Mesh> {\n  public curveArray: Curve<any>[]\n  public curveLengthArray: number[]\n\n  public object3D: TMesh\n  public splineTexure: DataTexture\n  public uniforms: CurveModifierUniforms\n\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh: TMesh, numberOfCurves = 1) {\n    const obj3D = mesh.clone() as TMesh\n    const splineTexure = initSplineTexture(numberOfCurves)\n    const uniforms = getUniforms(splineTexure)\n\n    obj3D.traverse((child) => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone()\n        modifyShader(child.material, uniforms, numberOfCurves)\n      }\n    })\n\n    this.curveArray = new Array(numberOfCurves)\n    this.curveLengthArray = new Array(numberOfCurves)\n\n    this.object3D = obj3D\n    this.splineTexure = splineTexure\n    this.uniforms = uniforms\n  }\n\n  public updateCurve<TCurve extends Curve<any>>(index: number, curve: TCurve): void {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow')\n    const curveLength = curve.getLength()\n    this.uniforms.spineLength.value = curveLength\n    this.curveLengthArray[index] = curveLength\n    this.curveArray[index] = curve\n    updateSplineTexture(this.splineTexure, curve, index)\n  }\n\n  public moveAlongCurve(amount: number): void {\n    this.uniforms.pathOffset.value += amount\n  }\n}\nconst matrix = new Matrix4()\n\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\nexport class InstancedFlow<\n  TGeometry extends BufferGeometry = BufferGeometry,\n  TMaterial extends Material = Material\n> extends Flow<InstancedMesh<TGeometry, TMaterial>> {\n  public offsets: number[]\n  public whichCurve: number[]\n\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count: number, curveCount: number, geometry: TGeometry, material: TMaterial) {\n    const mesh = new InstancedMesh(geometry, material, count)\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage)\n    mesh.frustumCulled = false\n    super(mesh, curveCount)\n\n    this.offsets = new Array(count).fill(0)\n    this.whichCurve = new Array(count).fill(0)\n  }\n\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n  private writeChanges(index: number): void {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index])\n    this.object3D.setMatrixAt(index, matrix)\n    this.object3D.instanceMatrix.needsUpdate = true\n  }\n\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n  public moveIndividualAlongCurve(index: number, offset: number): void {\n    this.offsets[index] += offset\n    this.writeChanges(index)\n  }\n\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n  public setCurve(index: number, curveNo: number): void {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)')\n    this.whichCurve[index] = curveNo\n    this.writeChanges(index)\n  }\n}\n", "import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n", "import { BufferGeometry, Float32BufferAttribute, Vector3 } from 'three'\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils'\n\nconst cb = new Vector3()\nconst ab = new Vector3()\n\nfunction pushIfUnique<TItem>(array: TItem[], object: TItem): void {\n  if (array.indexOf(object) === -1) array.push(object)\n}\n\nfunction removeFromArray<TItem>(array: TItem[], object: TItem): void {\n  const k = array.indexOf(object)\n  if (k > -1) array.splice(k, 1)\n}\n\nclass Vertex {\n  public position: Vector3\n  private id: number\n\n  public faces: Triangle[]\n  public neighbors: Vertex[]\n\n  public collapseCost: number\n  public collapseNeighbor: null | Vertex\n\n  public minCost: number = 0\n  public totalCost: number = 0\n  public costCount: number = 0\n\n  constructor(v: Vector3, id: number) {\n    this.position = v\n    this.id = id // old index id\n\n    this.faces = [] // faces vertex is connected\n    this.neighbors = [] // neighbouring vertices aka \"adjacentVertices\"\n\n    // these will be computed in computeEdgeCostAtVertex()\n    this.collapseCost = 0 // cost of collapsing this vertex, the less the better. aka objdist\n    this.collapseNeighbor = null // best candinate for collapsing\n  }\n\n  public addUniqueNeighbor(vertex: Vertex): void {\n    pushIfUnique(this.neighbors, vertex)\n  }\n\n  public removeIfNonNeighbor(n: Vertex): void {\n    const neighbors = this.neighbors\n    const faces = this.faces\n\n    const offset = neighbors.indexOf(n)\n    if (offset === -1) return\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return\n    }\n\n    neighbors.splice(offset, 1)\n  }\n}\n\n// we use a triangle class to represent structure of face slightly differently\nclass Triangle {\n  private a: number\n  private b: number\n  private c: Number\n\n  public v1: Vertex\n  public v2: Vertex\n  public v3: Vertex\n\n  public normal = new Vector3()\n\n  constructor(v1: Vertex, v2: Vertex, v3: Vertex, a: number, b: number, c: number) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.v1 = v1\n    this.v2 = v2\n    this.v3 = v3\n\n    this.computeNormal()\n\n    v1.faces.push(this)\n    v1.addUniqueNeighbor(v2)\n    v1.addUniqueNeighbor(v3)\n\n    v2.faces.push(this)\n    v2.addUniqueNeighbor(v1)\n    v2.addUniqueNeighbor(v3)\n\n    v3.faces.push(this)\n    v3.addUniqueNeighbor(v1)\n    v3.addUniqueNeighbor(v2)\n  }\n\n  private computeNormal(): void {\n    const vA = this.v1.position\n    const vB = this.v2.position\n    const vC = this.v3.position\n\n    cb.subVectors(vC, vB)\n    ab.subVectors(vA, vB)\n    cb.cross(ab).normalize()\n\n    this.normal.copy(cb)\n  }\n\n  public hasVertex(v: Vertex): boolean {\n    return v === this.v1 || v === this.v2 || v === this.v3\n  }\n\n  public replaceVertex(oldv: Vertex, newv: Vertex): void {\n    if (oldv === this.v1) this.v1 = newv\n    else if (oldv === this.v2) this.v2 = newv\n    else if (oldv === this.v3) this.v3 = newv\n\n    removeFromArray(oldv.faces, this)\n    newv.faces.push(this)\n\n    oldv.removeIfNonNeighbor(this.v1)\n    this.v1.removeIfNonNeighbor(oldv)\n\n    oldv.removeIfNonNeighbor(this.v2)\n    this.v2.removeIfNonNeighbor(oldv)\n\n    oldv.removeIfNonNeighbor(this.v3)\n    this.v3.removeIfNonNeighbor(oldv)\n\n    this.v1.addUniqueNeighbor(this.v2)\n    this.v1.addUniqueNeighbor(this.v3)\n\n    this.v2.addUniqueNeighbor(this.v1)\n    this.v2.addUniqueNeighbor(this.v3)\n\n    this.v3.addUniqueNeighbor(this.v1)\n    this.v3.addUniqueNeighbor(this.v2)\n\n    this.computeNormal()\n  }\n}\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nclass SimplifyModifier {\n  constructor() {}\n\n  private computeEdgeCollapseCost = (u: Vertex, v: Vertex): number => {\n    // if we collapse edge uv by moving u to v then how\n    // much different will the model change, i.e. the \"error\".\n\n    const edgelength = v.position.distanceTo(u.position)\n    let curvature = 0\n\n    const sideFaces = []\n    let i,\n      il = u.faces.length,\n      face,\n      sideFace\n\n    // find the \"sides\" triangles that are on the edge uv\n    for (i = 0; i < il; i++) {\n      face = u.faces[i]\n\n      if (face.hasVertex(v)) {\n        sideFaces.push(face)\n      }\n    }\n\n    // use the triangle facing most away from the sides\n    // to determine our curvature term\n    for (i = 0; i < il; i++) {\n      let minCurvature = 1\n      face = u.faces[i]\n\n      for (let j = 0; j < sideFaces.length; j++) {\n        sideFace = sideFaces[j]\n        // use dot product of face normals.\n        const dotProd = face.normal.dot(sideFace.normal)\n        minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2)\n      }\n\n      curvature = Math.max(curvature, minCurvature)\n    }\n\n    // crude approach in attempt to preserve borders\n    // though it seems not to be totally correct\n    const borders = 0\n    if (sideFaces.length < 2) {\n      // we add some arbitrary cost for borders,\n      // borders += 10;\n      curvature = 1\n    }\n\n    const amt = edgelength * curvature + borders\n\n    return amt\n  }\n\n  private removeVertex(v: Vertex, vertices: Vertex[]): void {\n    console.assert(v.faces.length === 0)\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop() as Vertex\n      removeFromArray(n.neighbors, v)\n    }\n\n    removeFromArray(vertices, v)\n  }\n\n  private computeEdgeCostAtVertex = (v: Vertex): void => {\n    // compute the edge collapse cost for all edges that start\n    // from vertex v.  Since we are only interested in reducing\n    // the object by selecting the min cost edge at each step, we\n    // only cache the cost of the least cost edge at this vertex\n    // (in member variable collapse) as well as the value of the\n    // cost (in member variable collapseCost).\n\n    if (v.neighbors.length === 0) {\n      // collapse if no neighbors.\n      v.collapseNeighbor = null\n      v.collapseCost = -0.01\n\n      return\n    }\n\n    v.collapseCost = 100000\n    v.collapseNeighbor = null\n\n    // search all neighboring edges for \"least cost\" edge\n    for (let i = 0; i < v.neighbors.length; i++) {\n      const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i])\n\n      if (!v.collapseNeighbor) {\n        v.collapseNeighbor = v.neighbors[i]\n        v.collapseCost = collapseCost\n        v.minCost = collapseCost\n        v.totalCost = 0\n        v.costCount = 0\n      }\n\n      v.costCount++\n      v.totalCost += collapseCost\n\n      if (collapseCost < v.minCost) {\n        v.collapseNeighbor = v.neighbors[i]\n        v.minCost = collapseCost\n      }\n    }\n\n    // we average the cost of collapsing at this vertex\n    v.collapseCost = v.totalCost / v.costCount\n    // v.collapseCost = v.minCost;\n  }\n\n  private removeFace = (f: Triangle, faces: Triangle[]): void => {\n    removeFromArray(faces, f)\n\n    if (f.v1) removeFromArray(f.v1.faces, f)\n    if (f.v2) removeFromArray(f.v2.faces, f)\n    if (f.v3) removeFromArray(f.v3.faces, f)\n\n    // TODO optimize this!\n    const vs = [f.v1, f.v2, f.v3]\n    let v1, v2\n\n    for (let i = 0; i < 3; i++) {\n      v1 = vs[i]\n      v2 = vs[(i + 1) % 3]\n\n      if (!v1 || !v2) continue\n\n      v1.removeIfNonNeighbor(v2)\n      v2.removeIfNonNeighbor(v1)\n    }\n  }\n\n  private collapse = (vertices: Vertex[], faces: Triangle[], u: Vertex, v: Vertex): void => {\n    // u and v are pointers to vertices of an edge\n\n    // Collapse the edge uv by moving vertex u onto v\n\n    if (!v) {\n      // u is a vertex all by itself so just delete it..\n      this.removeVertex(u, vertices)\n      return\n    }\n\n    let i\n    const tmpVertices = []\n\n    for (i = 0; i < u.neighbors.length; i++) {\n      tmpVertices.push(u.neighbors[i])\n    }\n\n    // delete triangles on edge uv:\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      if (u.faces[i].hasVertex(v)) {\n        this.removeFace(u.faces[i], faces)\n      }\n    }\n\n    // update remaining triangles to have v instead of u\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      u.faces[i].replaceVertex(u, v)\n    }\n\n    this.removeVertex(u, vertices)\n\n    // recompute the edge collapse costs in neighborhood\n    for (i = 0; i < tmpVertices.length; i++) {\n      this.computeEdgeCostAtVertex(tmpVertices[i])\n    }\n  }\n\n  private minimumCostEdge = (vertices: Vertex[]): Vertex => {\n    // O(n * n) approach. TODO optimize this\n\n    let least = vertices[0]\n\n    for (let i = 0; i < vertices.length; i++) {\n      if (vertices[i].collapseCost < least.collapseCost) {\n        least = vertices[i]\n      }\n    }\n\n    return least\n  }\n\n  public modify = (geometry: BufferGeometry, count: number): BufferGeometry => {\n    geometry = geometry.clone()\n    const attributes = geometry.attributes\n\n    // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n    for (let name in attributes) {\n      if (name !== 'position') geometry.deleteAttribute(name)\n    }\n\n    geometry = BufferGeometryUtils.mergeVertices(geometry)\n\n    //\n    // put data of original geometry in different data structures\n    //\n\n    const vertices = []\n    const faces = []\n\n    // add vertices\n\n    const positionAttribute = geometry.getAttribute('position')\n\n    for (let i = 0; i < positionAttribute.count; i++) {\n      const v = new Vector3().fromBufferAttribute(positionAttribute, i)\n\n      const vertex = new Vertex(v, i)\n      vertices.push(vertex)\n    }\n\n    // add faces\n\n    const geomIndex = geometry.getIndex()\n\n    if (geomIndex !== null) {\n      for (let i = 0; i < geomIndex.count; i += 3) {\n        const a = geomIndex.getX(i)\n        const b = geomIndex.getX(i + 1)\n        const c = geomIndex.getX(i + 2)\n\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c)\n        faces.push(triangle)\n      }\n    } else {\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        const a = i\n        const b = i + 1\n        const c = i + 2\n\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c)\n        faces.push(triangle)\n      }\n    }\n\n    // compute all edge collapse costs\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.computeEdgeCostAtVertex(vertices[i])\n    }\n\n    let nextVertex\n\n    let z = count\n\n    while (z--) {\n      nextVertex = this.minimumCostEdge(vertices)\n\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex')\n        break\n      } else {\n        this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor as Vertex)\n      }\n    }\n\n    //\n\n    const simplifiedGeometry = new BufferGeometry()\n    const position = []\n    let index = []\n\n    //\n\n    for (let i = 0; i < vertices.length; i++) {\n      const vertex = vertices[i].position\n      position.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    //\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      const a = vertices.indexOf(face.v1)\n      const b = vertices.indexOf(face.v2)\n      const c = vertices.indexOf(face.v3)\n\n      index.push(a, b, c)\n    }\n\n    //\n\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n    simplifiedGeometry.setIndex(index)\n\n    return simplifiedGeometry\n  }\n}\n\nexport { SimplifyModifier }\n", "import {\n  REVISION,\n  BufferAttribute,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  MathUtils,\n  Matrix4,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  PropertyBinding,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  Texture,\n  CompressedTexture,\n  Vector3,\n  PlaneGeometry,\n  ShaderMaterial,\n  Uniform,\n  Mesh,\n  PerspectiveCamera,\n  WebGLRenderer,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer()\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)))\n  return `data:${blob.type || ''};base64,${data}`\n}\n\nlet _renderer\nlet fullscreenQuadGeometry\nlet fullscreenQuadMaterial\nlet fullscreenQuad\n\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1)\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: /* glsl */ `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `,\n      fragmentShader: /* glsl */ `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `,\n    })\n\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture\n  fullscreenQuadMaterial.defines.IS_SRGB =\n    'colorSpace' in texture ? texture.colorSpace === 'srgb' : texture.encoding === 3001\n  fullscreenQuadMaterial.needsUpdate = true\n\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial)\n    fullscreenQuad.frustrumCulled = false\n  }\n\n  const _camera = new PerspectiveCamera()\n  const _scene = new Scene()\n  _scene.add(fullscreenQuad)\n\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false })\n  }\n\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize))\n  renderer.clear()\n  renderer.render(_scene, _camera)\n\n  const readableTexture = new Texture(renderer.domElement)\n\n  readableTexture.minFilter = texture.minFilter\n  readableTexture.magFilter = texture.magFilter\n  readableTexture.wrapS = texture.wrapS\n  readableTexture.wrapT = texture.wrapT\n  readableTexture.name = texture.name\n\n  if (_renderer) {\n    _renderer.dispose()\n    _renderer = null\n  }\n\n  return readableTexture\n}\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    'byte',\n    'byte normalized',\n    'unsigned byte',\n    'unsigned byte normalized',\n    'short',\n    'short normalized',\n    'unsigned short',\n    'unsigned short normalized',\n  ],\n  NORMAL: ['byte normalized', 'short normalized'],\n  TANGENT: ['byte normalized', 'short normalized'],\n  TEXCOORD: ['byte', 'byte normalized', 'unsigned byte', 'short', 'short normalized', 'unsigned short'],\n}\n\nclass GLTFExporter {\n  /**\n   * Static utility functions\n   */\n  static Utils = {\n    insertKeyframe: function (track, time) {\n      const tolerance = 0.001 // 1ms\n      const valueSize = track.getValueSize()\n\n      const times = new track.TimeBufferType(track.times.length + 1)\n      const values = new track.ValueBufferType(track.values.length + valueSize)\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize))\n\n      let index\n\n      if (track.times.length === 0) {\n        times[0] = time\n\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0\n        }\n\n        index = 0\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0\n\n        times[0] = time\n        times.set(track.times, 1)\n\n        values.set(interpolant.evaluate(time), 0)\n        values.set(track.values, valueSize)\n\n        index = 0\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1\n        }\n\n        times[times.length - 1] = time\n        times.set(track.times, 0)\n\n        values.set(track.values, 0)\n        values.set(interpolant.evaluate(time), track.values.length)\n\n        index = times.length - 1\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i\n\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0)\n            times[i + 1] = time\n            times.set(track.times.slice(i + 1), i + 2)\n\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0)\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize)\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize)\n\n            index = i + 1\n\n            break\n          }\n        }\n      }\n\n      track.times = times\n      track.values = values\n\n      return index\n    },\n\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = []\n      const mergedTracks = {}\n      const sourceTracks = clip.tracks\n\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i]\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name)\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName)\n\n        if (\n          sourceTrackBinding.propertyName !== 'morphTargetInfluences' ||\n          sourceTrackBinding.propertyIndex === undefined\n        ) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack)\n          continue\n        }\n\n        if (\n          sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete &&\n          sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear\n        ) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.')\n          }\n\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.')\n\n          sourceTrack = sourceTrack.clone()\n          sourceTrack.setInterpolation(InterpolateLinear)\n        }\n\n        const targetCount = sourceTrackNode.morphTargetInfluences.length\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex]\n\n        if (targetIndex === undefined) {\n          throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex)\n        }\n\n        let mergedTrack\n\n        // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone()\n\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length)\n\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j]\n          }\n\n          // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n          mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences'\n          mergedTrack.values = values\n\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack\n          tracks.push(mergedTrack)\n\n          continue\n        }\n\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1))\n\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]\n\n        // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j])\n        }\n\n        // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j])\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j]\n        }\n      }\n\n      clip.tracks = tracks\n\n      return clip\n    },\n  }\n\n  constructor() {\n    this.pluginCallbacks = []\n\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer)\n    })\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter()\n    const plugins = []\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer))\n    }\n\n    writer.setPlugins(plugins)\n    writer.write(input, onDone, options).catch(onError)\n  }\n\n  parseAsync(input, options) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options)\n    })\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497,\n}\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization'\n\nconst THREE_TO_WEBGL = {}\n\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights',\n}\n\nconst DEFAULT_SPECULAR_COLOR = new Color()\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12\nconst GLB_HEADER_MAGIC = 0x46546c67\nconst GLB_VERSION = 2\n\nconst GLB_CHUNK_PREFIX_BYTES = 8\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return (\n    array1.length === array2.length &&\n    array1.every(function (element, index) {\n      return element === array2[index]\n    })\n  )\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY),\n  }\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a]\n      } else {\n        if (a === 0) value = attribute.getX(i)\n        else if (a === 1) value = attribute.getY(i)\n        else if (a === 2) value = attribute.getZ(i)\n        else if (a === 3) value = attribute.getW(i)\n\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array)\n        }\n      }\n\n      output.min[a] = Math.min(output.min[a], value)\n      output.max[a] = Math.max(output.max[a], value)\n    }\n  }\n\n  return output\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength)\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength)\n    array.set(new Uint8Array(arrayBuffer))\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte\n      }\n    }\n\n    return array.buffer\n  }\n\n  return arrayBuffer\n}\n\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1)\n  }\n\n  return document.createElement('canvas')\n}\n\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType))\n  }\n\n  let quality\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8\n  }\n\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality,\n  })\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = []\n\n    this.options = {}\n    this.pending = []\n    this.buffers = []\n\n    this.byteOffset = 0\n    this.buffers = []\n    this.nodeMap = new Map()\n    this.skins = []\n\n    this.extensionsUsed = {}\n    this.extensionsRequired = {}\n\n    this.uids = new Map()\n    this.uid = 0\n\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter',\n      },\n    }\n\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map(),\n    }\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false,\n      },\n      options,\n    )\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true\n    }\n\n    this.processInput(input)\n\n    await Promise.all(this.pending)\n\n    const writer = this\n    const buffers = writer.buffers\n    const json = writer.json\n    options = writer.options\n\n    const extensionsUsed = writer.extensionsUsed\n    const extensionsRequired = writer.extensionsRequired\n\n    // Merge buffers.\n    const blob = new Blob(buffers, { type: 'application/octet-stream' })\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed)\n    const extensionsRequiredList = Object.keys(extensionsRequired)\n\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size\n\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      blob.arrayBuffer().then((result) => {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(result)\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true)\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true)\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20)\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true)\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true)\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES)\n        const headerView = new DataView(header)\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true)\n        headerView.setUint32(4, GLB_VERSION, true)\n        const totalByteLength =\n          GLB_HEADER_BYTES +\n          jsonChunkPrefix.byteLength +\n          jsonChunk.byteLength +\n          binaryChunkPrefix.byteLength +\n          binaryChunk.byteLength\n        headerView.setUint32(8, totalByteLength, true)\n\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream',\n        })\n\n        glbBlob.arrayBuffer().then(onDone)\n      })\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then((uri) => {\n          json.buffers[0].uri = uri\n          onDone(json)\n        })\n      } else {\n        onDone(json)\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return\n\n    const options = this.options\n    const extensionsUsed = this.extensionsUsed\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData))\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {}\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName]\n          extensionsUsed[extensionName] = true\n        }\n\n        delete json.gltfExtensions\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" +\n          object.name +\n          \"' \" +\n          \"won't be serialized because of JSON.stringify error - \" +\n          error.message,\n      )\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map()\n\n      uids.set(true, this.uid++)\n      uids.set(false, this.uid++)\n\n      this.uids.set(attribute, uids)\n    }\n\n    const uids = this.uids.get(attribute)\n\n    return uids.get(isRelativeCopy)\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return false\n\n    const v = new Vector3()\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false\n    }\n\n    return true\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal)\n\n    const attribute = normal.clone()\n    const v = new Vector3()\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i)\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0)\n      } else {\n        v.normalize()\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z)\n    }\n\n    cache.attributesNormalized.set(normal, attribute)\n\n    return attribute\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false\n    const transformDef = {}\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray()\n      didTransform = true\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation\n      didTransform = true\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray()\n      didTransform = true\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {}\n      mapDef.extensions['KHR_texture_transform'] = transformDef\n      this.extensionsUsed['KHR_texture_transform'] = true\n    }\n  }\n\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap\n\n    function getEncodingConversion(map) {\n      if ('colorSpace' in map ? map.colorSpace === 'srgb' : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)\n        }\n      }\n\n      return function LinearToLinear(c) {\n        return c\n      }\n    }\n\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.')\n\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap)\n    }\n\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap)\n    }\n\n    const metalness = metalnessMap ? metalnessMap.image : null\n    const roughness = roughnessMap ? roughnessMap.image : null\n\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0)\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0)\n\n    const canvas = getCanvas()\n    canvas.width = width\n    canvas.height = height\n\n    const context = canvas.getContext('2d')\n    context.fillStyle = '#00ffff'\n    context.fillRect(0, 0, width, height)\n\n    const composite = context.getImageData(0, 0, width, height)\n\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(metalnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(roughnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    context.putImageData(composite, 0, 0)\n\n    //\n\n    const reference = metalnessMap || roughnessMap\n\n    const texture = reference.clone()\n\n    // TODO Use new Source() instead?\n    texture.source = new Texture(canvas).source\n    if ('colorSpace' in texture) texture.colorSpace = ''\n    else texture.encoding = 3000\n    texture.channel = (metalnessMap || roughnessMap).channel\n\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn('THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.')\n    }\n\n    return texture\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json\n    const buffers = this.buffers\n\n    if (!json.buffers) json.buffers = [{ byteLength: 0 }]\n\n    // All buffers are merged before export.\n    buffers.push(buffer)\n\n    return 0\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize\n\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1\n\n        break\n\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2\n\n        break\n\n      default:\n        componentSize = 4\n    }\n\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize)\n    const dataView = new DataView(new ArrayBuffer(byteLength))\n    let offset = 0\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a]\n        } else {\n          if (a === 0) value = attribute.getX(i)\n          else if (a === 1) value = attribute.getY(i)\n          else if (a === 2) value = attribute.getZ(i)\n          else if (a === 3) value = attribute.getW(i)\n\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array)\n          }\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value)\n        }\n\n        offset += componentSize\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength,\n    }\n\n    if (target !== undefined) bufferViewDef.target = target\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize\n    }\n\n    this.byteOffset += byteLength\n\n    json.bufferViews.push(bufferViewDef)\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0,\n    }\n\n    return output\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this\n    const json = writer.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    return blob.arrayBuffer().then((result) => {\n      const buffer = getPaddedArrayBuffer(result)\n\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength,\n      }\n\n      writer.byteOffset += buffer.byteLength\n      return json.bufferViews.push(bufferViewDef) - 1\n    })\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json\n\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      9: 'MAT3',\n      16: 'MAT4',\n    }\n\n    let componentType\n\n    // Detect the component type of the attribute array\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE\n    } else {\n      throw new Error(\n        'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name,\n      )\n    }\n\n    if (start === undefined) start = 0\n    if (count === undefined) count = attribute.count\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null\n\n    const minMax = getMinMax(attribute, start, count)\n    let bufferViewTarget\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget =\n        attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER\n    }\n\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget)\n\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize],\n    }\n\n    if (attribute.normalized === true) accessorDef.normalized = true\n    if (!json.accessors) json.accessors = []\n\n    return json.accessors.push(accessorDef) - 1\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    if (image !== null) {\n      const writer = this\n      const cache = writer.cache\n      const json = writer.json\n      const options = writer.options\n      const pending = writer.pending\n\n      if (!cache.images.has(image)) cache.images.set(image, {})\n\n      const cachedImages = cache.images.get(image)\n\n      const key = mimeType + ':flipY/' + flipY.toString()\n\n      if (cachedImages[key] !== undefined) return cachedImages[key]\n\n      if (!json.images) json.images = []\n\n      const imageDef = { mimeType: mimeType }\n\n      const canvas = getCanvas()\n\n      canvas.width = Math.min(image.width, options.maxTextureSize)\n      canvas.height = Math.min(image.height, options.maxTextureSize)\n\n      const ctx = canvas.getContext('2d')\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height)\n        ctx.scale(1, -1)\n      }\n\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.', format)\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image)\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4)\n\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0]\n          data[i + 1] = image.data[i + 1]\n          data[i + 2] = image.data[i + 2]\n          data[i + 3] = image.data[i + 3]\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0)\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height)\n      }\n\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType)\n            .then((blob) => writer.processBufferViewImage(blob))\n            .then((bufferViewIndex) => {\n              imageDef.bufferView = bufferViewIndex\n            }),\n        )\n      } else {\n        if (canvas.toDataURL !== undefined) {\n          imageDef.uri = canvas.toDataURL(mimeType)\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType)\n              .then(readAsDataURL)\n              .then((uri) => {\n                imageDef.uri = uri\n              }),\n          )\n        }\n      }\n\n      const index = json.images.push(imageDef) - 1\n      cachedImages[key] = index\n      return index\n    } else {\n      throw new Error('THREE.GLTFExporter: No valid image data found. Unable to process texture.')\n    }\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json\n\n    if (!json.samplers) json.samplers = []\n\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT],\n    }\n\n    return json.samplers.push(samplerDef) - 1\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this\n    const options = writer.options\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.textures.has(map)) return cache.textures.get(map)\n\n    if (!json.textures) json.textures = []\n\n    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize)\n    }\n\n    let mimeType = map.userData.mimeType\n\n    if (mimeType === 'image/webp') mimeType = 'image/png'\n\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType),\n    }\n\n    if (map.name) textureDef.name = map.name\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef)\n    })\n\n    const index = json.textures.push(textureDef) - 1\n    cache.textures.set(map, index)\n    return index\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.materials.has(material)) return cache.materials.get(material)\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.')\n      return null\n    }\n\n    if (!json.materials) json.materials = []\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = { pbrMetallicRoughness: {} }\n\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.')\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity])\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap)\n\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel,\n      }\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture)\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef\n    }\n\n    // pbrMetallicRoughness.baseColorTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel,\n      }\n      this.applyTextureTransform(baseColorMapDef, material.map)\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef\n    }\n\n    if (material.emissive) {\n      const emissive = material.emissive\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b)\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray()\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel,\n        }\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap)\n        materialDef.emissiveTexture = emissiveMapDef\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel,\n      }\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap)\n      materialDef.normalTexture = normalMapDef\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel,\n      }\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap)\n      materialDef.occlusionTexture = occlusionMapDef\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND'\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK'\n        materialDef.alphaCutoff = material.alphaTest\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true\n    if (material.name !== '') materialDef.name = material.name\n\n    this.serializeUserData(material, materialDef)\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef)\n    })\n\n    const index = json.materials.push(materialDef) - 1\n    cache.materials.set(material, index)\n    return index\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache\n    const json = this.json\n\n    const meshCacheKeyParts = [mesh.geometry.uuid]\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid)\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid)\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':')\n\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey)\n\n    const geometry = mesh.geometry\n\n    let mode\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES\n    }\n\n    const meshDef = {}\n    const attributes = {}\n    const primitives = []\n    const targets = []\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      ...(version >= 152\n        ? {\n            uv: 'TEXCOORD_0',\n            uv1: 'TEXCOORD_1',\n            uv2: 'TEXCOORD_2',\n            uv3: 'TEXCOORD_3',\n          }\n        : {\n            uv: 'TEXCOORD_0',\n            uv2: 'TEXCOORD_1',\n          }),\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0',\n    }\n\n    const originalNormal = geometry.getAttribute('normal')\n\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.')\n\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal))\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue\n\n      const attribute = geometry.attributes[attributeName]\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase()\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/\n\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute))\n        continue\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null\n      const array = attribute.array\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.')\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized)\n      }\n\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry)\n\n      if (accessor !== null) {\n        if (!attributeName.startsWith('_')) {\n          this.detectMeshQuantization(attributeName, attribute)\n        }\n\n        attributes[attributeName] = accessor\n        cache.attributes.set(this.getUID(attribute), accessor)\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal)\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = []\n      const targetNames = []\n      const reverseDictionary = {}\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {}\n        let warned = false\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.')\n              warned = true\n            }\n\n            continue\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i]\n          const gltfAttributeName = attributeName.toUpperCase()\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName]\n\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true))\n            continue\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone()\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j))\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j))\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j))\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j))\n              }\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry)\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName])\n        }\n\n        targets.push(target)\n\n        weights.push(mesh.morphTargetInfluences[i])\n\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i])\n      }\n\n      meshDef.weights = weights\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {}\n        meshDef.extras.targetNames = targetNames\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material)\n\n    if (isMultiMaterial && geometry.groups.length === 0) return null\n\n    const materials = isMultiMaterial ? mesh.material : [mesh.material]\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }]\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes,\n      }\n\n      this.serializeUserData(geometry, primitive)\n\n      if (targets.length > 0) primitive.targets = targets\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index)\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey)\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count)\n          cache.attributes.set(cacheKey, primitive.indices)\n        }\n\n        if (primitive.indices === null) delete primitive.indices\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex])\n\n      if (material !== null) primitive.material = material\n\n      primitives.push(primitive)\n    }\n\n    meshDef.primitives = primitives\n\n    if (!json.meshes) json.meshes = []\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef)\n    })\n\n    const index = json.meshes.push(meshDef) - 1\n    cache.meshes.set(meshCacheKey, index)\n    return index\n  }\n\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return\n\n    let attrType = undefined\n\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = 'byte'\n\n        break\n\n      case Uint8Array:\n        attrType = 'unsigned byte'\n\n        break\n\n      case Int16Array:\n        attrType = 'short'\n\n        break\n\n      case Uint16Array:\n        attrType = 'unsigned short'\n\n        break\n\n      default:\n        return\n    }\n\n    if (attribute.normalized) attrType += ' normalized'\n\n    const attrNamePrefix = attributeName.split('_', 1)[0]\n\n    if (\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] &&\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)\n    ) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true\n    }\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json\n\n    if (!json.cameras) json.cameras = []\n\n    const isOrtho = camera.isOrthographicCamera\n\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective',\n    }\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type\n\n    return json.cameras.push(cameraDef) - 1\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    if (!json.animations) json.animations = []\n\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root)\n\n    const tracks = clip.tracks\n    const channels = []\n    const samplers = []\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i]\n      const trackBinding = PropertyBinding.parseTrackName(track.name)\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName)\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName]\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex)\n        } else {\n          trackNode = undefined\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name)\n        return null\n      }\n\n      const inputItemSize = 1\n      let outputItemSize = track.values.length / track.times.length\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length\n      }\n\n      let interpolation\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE'\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP'\n      } else {\n        interpolation = 'LINEAR'\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation,\n      })\n\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty,\n        },\n      })\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels,\n    })\n\n    return json.animations.length - 1\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    const node = json.nodes[nodeMap.get(object)]\n\n    const skeleton = object.skeleton\n\n    if (skeleton === undefined) return null\n\n    const rootJoint = object.skeleton.bones[0]\n\n    if (rootJoint === undefined) return null\n\n    const joints = []\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16)\n    const temporaryBoneInverse = new Matrix4()\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]))\n      temporaryBoneInverse.copy(skeleton.boneInverses[i])\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16)\n    }\n\n    if (json.skins === undefined) json.skins = []\n\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint),\n    })\n\n    const skinIndex = (node.skin = json.skins.length - 1)\n\n    return skinIndex\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json\n    const options = this.options\n    const nodeMap = this.nodeMap\n\n    if (!json.nodes) json.nodes = []\n\n    const nodeDef = {}\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray()\n      const position = object.position.toArray()\n      const scale = object.scale.toArray()\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix()\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name)\n\n    this.serializeUserData(object, nodeDef)\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object)\n\n      if (meshIndex !== null) nodeDef.mesh = meshIndex\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object)\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object)\n\n    if (object.children.length > 0) {\n      const children = []\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i]\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child)\n\n          if (nodeIndex !== null) children.push(nodeIndex)\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef)\n    })\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1\n    nodeMap.set(object, nodeIndex)\n    return nodeIndex\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json\n    const options = this.options\n\n    if (!json.scenes) {\n      json.scenes = []\n      json.scene = 0\n    }\n\n    const sceneDef = {}\n\n    if (scene.name !== '') sceneDef.name = scene.name\n\n    json.scenes.push(sceneDef)\n\n    const nodes = []\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i]\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child)\n\n        if (nodeIndex !== null) nodes.push(nodeIndex)\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes\n\n    this.serializeUserData(scene, sceneDef)\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene()\n    scene.name = 'AuxScene'\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i])\n    }\n\n    this.processScene(scene)\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options\n\n    input = input instanceof Array ? input : [input]\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input)\n    })\n\n    const objectsWithoutScene = []\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i])\n      } else {\n        objectsWithoutScene.push(input[i])\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene)\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i])\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0])\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input)\n    })\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i])\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_lights_punctual'\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return\n\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light)\n      return\n    }\n\n    const writer = this.writer\n    const json = writer.json\n    const extensionsUsed = writer.extensionsUsed\n\n    const lightDef = {}\n\n    if (light.name) lightDef.name = light.name\n\n    lightDef.color = light.color.toArray()\n\n    lightDef.intensity = light.intensity\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional'\n    } else if (light.isPointLight) {\n      lightDef.type = 'point'\n\n      if (light.distance > 0) lightDef.range = light.distance\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot'\n\n      if (light.distance > 0) lightDef.range = light.distance\n\n      lightDef.spot = {}\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0\n      lightDef.spot.outerConeAngle = light.angle\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn(\n        'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.',\n      )\n    }\n\n    if (\n      light.target &&\n      (light.target.parent !== light ||\n        light.target.position.x !== 0 ||\n        light.target.position.y !== 0 ||\n        light.target.position.z !== -1)\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Light direction may be lost. For best results, ' +\n          'make light.target a child of the light with position 0,0,-1.',\n      )\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {}\n      json.extensions[this.name] = { lights: [] }\n      extensionsUsed[this.name] = true\n    }\n\n    const lights = json.extensions[this.name].lights\n    lights.push(lightDef)\n\n    nodeDef.extensions = nodeDef.extensions || {}\n    nodeDef.extensions[this.name] = { light: lights.length - 1 }\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_unlit'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = {}\n\n    extensionsUsed[this.name] = true\n\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_clearcoat'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.clearcoatFactor = material.clearcoat\n\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap)\n      extensionDef.clearcoatTexture = clearcoatMapDef\n    }\n\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness\n\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap)\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef\n    }\n\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap)\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_iridescence'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.iridescenceFactor = material.iridescence\n\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap)\n      extensionDef.iridescenceTexture = iridescenceMapDef\n    }\n\n    extensionDef.iridescenceIor = material.iridescenceIOR\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0]\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1]\n\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap)\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_transmission'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.transmissionFactor = material.transmission\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel,\n      }\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap)\n      extensionDef.transmissionTexture = transmissionMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_volume'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.thicknessFactor = material.thickness\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel,\n      }\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap)\n      extensionDef.thicknessTexture = thicknessMapDef\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance\n    extensionDef.attenuationColor = material.attenuationColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_ior'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.ior = material.ior\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_specular'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (\n      !material.isMeshPhysicalMaterial ||\n      (material.specularIntensity === 1.0 &&\n        material.specularColor.equals(DEFAULT_SPECULAR_COLOR) &&\n        !material.specularIntensityMap &&\n        !material.specularColorTexture)\n    )\n      return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel,\n      }\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap)\n      extensionDef.specularTexture = specularIntensityMapDef\n    }\n\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel,\n      }\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap)\n      extensionDef.specularColorTexture = specularColorMapDef\n    }\n\n    extensionDef.specularFactor = material.specularIntensity\n    extensionDef.specularColorFactor = material.specularColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_sheen'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap)\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef\n    }\n\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel,\n      }\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap)\n      extensionDef.sheenColorTexture = sheenColorMapDef\n    }\n\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness\n    extensionDef.sheenColorFactor = material.sheenColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_anisotropy'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) }\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap)\n      extensionDef.anisotropyTexture = anisotropyMapDef\n    }\n\n    extensionDef.anisotropyStrength = material.anisotropy\n    extensionDef.anisotropyRotation = material.anisotropyRotation\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_emissive_strength'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.emissiveStrength = material.emissiveIntensity\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\nexport { GLTFExporter }\n", "import type { EncoderModule } from 'draco3d'\nimport { BufferGeometry, Mesh, Points } from 'three'\n\n/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\ndeclare const DracoEncoderModule: () => EncoderModule\n\nclass DRACOExporter {\n  // Encoder methods\n\n  public static MESH_EDGEBREAKER_ENCODING = 1\n  public static MESH_SEQUENTIAL_ENCODING = 0\n\n  // Geometry type\n\n  public static POINT_CLOUD = 0\n  public static TRIANGULAR_MESH = 1\n\n  // Attribute type\n  public static INVALID = -1\n  public static POSITION = 0\n  public static NORMAL = 1\n  public static COLOR = 2\n  public static TEX_COORD = 3\n  public static GENERIC = 4\n\n  public parse(\n    object: Mesh | Points,\n    options = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false,\n    },\n  ): Int8Array {\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.')\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_encoder to work.')\n    }\n\n    const geometry = object.geometry\n\n    const dracoEncoder = DracoEncoderModule()\n    const encoder = new dracoEncoder.Encoder()\n    let builder\n    let dracoObject\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.')\n    }\n\n    if (object instanceof Mesh && object.isMesh) {\n      builder = new dracoEncoder.MeshBuilder()\n      dracoObject = new dracoEncoder.Mesh()\n\n      const vertices = geometry.getAttribute('position')\n      // @ts-ignore\n      builder.AddFloatAttributeToMesh(\n        dracoObject,\n        dracoEncoder.POSITION,\n        vertices.count,\n        vertices.itemSize,\n        vertices.array,\n      )\n\n      const faces = geometry.getIndex()\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array as Uint16Array | Uint32Array)\n      } else {\n        const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count)\n\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces)\n      }\n\n      if (options.exportNormals) {\n        const normals = geometry.getAttribute('normal')\n\n        if (normals !== undefined) {\n          // @ts-ignore\n          builder.AddFloatAttributeToMesh(\n            dracoObject,\n            dracoEncoder.NORMAL,\n            normals.count,\n            normals.itemSize,\n            normals.array,\n          )\n        }\n      }\n\n      if (options.exportUvs) {\n        const uvs = geometry.getAttribute('uv')\n\n        if (uvs !== undefined) {\n          // @ts-ignore\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array)\n        }\n      }\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute('color')\n\n        if (colors !== undefined) {\n          // @ts-ignore\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array)\n        }\n      }\n    } else if (object instanceof Points && object.isPoints) {\n      // @ts-ignore\n      builder = new dracoEncoder.PointCloudBuilder()\n      // @ts-ignore\n      dracoObject = new dracoEncoder.PointCloud()\n\n      const vertices = geometry.getAttribute('position')\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array)\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute('color')\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array)\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.')\n    }\n\n    //Compress using draco encoder\n\n    const encodedData = new dracoEncoder.DracoInt8Array()\n\n    //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5\n\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed)\n\n    // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod)\n    }\n\n    // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i])\n        }\n      }\n    }\n\n    let length\n\n    if (object instanceof Mesh && object.isMesh) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData)\n    } else {\n      // @ts-ignore\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData)\n    }\n\n    dracoEncoder.destroy(dracoObject)\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.')\n    }\n\n    //Copy encoded data to buffer.\n    const outputData = new Int8Array(new ArrayBuffer(length))\n\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i)\n    }\n\n    dracoEncoder.destroy(encodedData)\n    dracoEncoder.destroy(encoder)\n    dracoEncoder.destroy(builder)\n\n    return outputData\n  }\n}\n\nexport { DRACOExporter }\n", "import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  Line,\n  LineBasicMaterial,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Quaternion,\n  SphereGeometry,\n  Vector3,\n} from 'three'\n\nconst _q = new Quaternion()\nconst _targetPos = new Vector3()\nconst _targetVec = new Vector3()\nconst _effectorPos = new Vector3()\nconst _effectorVec = new Vector3()\nconst _linkPos = new Vector3()\nconst _invLinkQ = new Quaternion()\nconst _linkScale = new Vector3()\nconst _axis = new Vector3()\nconst _vector = new Vector3()\nconst _matrix = new Matrix4()\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh\n    this.iks = iks\n\n    this._valid()\n  }\n\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i])\n    }\n\n    return this\n  }\n\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones\n\n    // for reference overhead reduction in loop\n    const math = Math\n\n    const effector = bones[ik.effector]\n    const target = bones[ik.target]\n\n    // don't use getWorldPosition() here for the performance\n    // because it calls updateMatrixWorld( true ) inside.\n    _targetPos.setFromMatrixPosition(target.matrixWorld)\n\n    const links = ik.links\n    const iteration = ik.iteration !== undefined ? ik.iteration : 1\n\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index]\n\n        // skip this link and following links.\n        // this skip is used for MMD performance optimization.\n        if (links[j].enabled === false) break\n\n        const limitation = links[j].limitation\n        const rotationMin = links[j].rotationMin\n        const rotationMax = links[j].rotationMax\n\n        // don't use getWorldPosition/Quaternion() here for the performance\n        // because they call updateMatrixWorld( true ) inside.\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale)\n        _invLinkQ.invert()\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld)\n\n        // work in link world\n        _effectorVec.subVectors(_effectorPos, _linkPos)\n        _effectorVec.applyQuaternion(_invLinkQ)\n        _effectorVec.normalize()\n\n        _targetVec.subVectors(_targetPos, _linkPos)\n        _targetVec.applyQuaternion(_invLinkQ)\n        _targetVec.normalize()\n\n        let angle = _targetVec.dot(_effectorVec)\n\n        if (angle > 1.0) {\n          angle = 1.0\n        } else if (angle < -1.0) {\n          angle = -1.0\n        }\n\n        angle = math.acos(angle)\n\n        // skip if changing angle is too small to prevent vibration of bone\n        if (angle < 1e-5) continue\n\n        if (ik.minAngle !== undefined && angle < ik.minAngle) {\n          angle = ik.minAngle\n        }\n\n        if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n          angle = ik.maxAngle\n        }\n\n        _axis.crossVectors(_effectorVec, _targetVec)\n        _axis.normalize()\n\n        _q.setFromAxisAngle(_axis, angle)\n        link.quaternion.multiply(_q)\n\n        // TODO: re-consider the limitation specification\n        if (limitation !== undefined) {\n          let c = link.quaternion.w\n\n          if (c > 1.0) c = 1.0\n\n          const c2 = math.sqrt(1 - c * c)\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c)\n        }\n\n        if (rotationMin !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin))\n        }\n\n        if (rotationMax !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax))\n        }\n\n        link.updateMatrixWorld(true)\n\n        rotated = true\n      }\n\n      if (!rotated) break\n    }\n\n    return this\n  }\n\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks)\n  }\n\n  // private methods\n\n  _valid() {\n    const iks = this.iks\n    const bones = this.mesh.skeleton.bones\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n      const effector = bones[ik.effector]\n      const links = ik.links\n      let link0, link1\n\n      link0 = effector\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index]\n\n        if (link0.parent !== link1) {\n          console.warn('THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name)\n        }\n\n        link0 = link1\n      }\n    }\n  }\n}\n\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv)\n}\n\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv)\n\n  array[index * 3 + 0] = v.x\n  array[index * 3 + 1] = v.y\n  array[index * 3 + 2] = v.z\n}\n\n/**\n * Visualize IK bones\n *\n * @param {SkinnedMesh} mesh\n * @param {Array<Object>} iks\n */\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super()\n\n    this.root = mesh\n    this.iks = iks\n\n    this.matrix.copy(mesh.matrixWorld)\n    this.matrixAutoUpdate = false\n\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8)\n\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this._init()\n  }\n\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root\n\n    if (this.visible) {\n      let offset = 0\n\n      const iks = this.iks\n      const bones = mesh.skeleton.bones\n\n      _matrix.copy(mesh.matrixWorld).invert()\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i]\n\n        const targetBone = bones[ik.target]\n        const effectorBone = bones[ik.effector]\n\n        const targetMesh = this.children[offset++]\n        const effectorMesh = this.children[offset++]\n\n        targetMesh.position.copy(getPosition(targetBone, _matrix))\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix))\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j]\n          const linkBone = bones[link.index]\n\n          const linkMesh = this.children[offset++]\n\n          linkMesh.position.copy(getPosition(linkBone, _matrix))\n        }\n\n        const line = this.children[offset++]\n        const array = line.geometry.attributes.position.array\n\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix)\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix)\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j]\n          const linkBone = bones[link.index]\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix)\n        }\n\n        line.geometry.attributes.position.needsUpdate = true\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld)\n\n    super.updateMatrixWorld(force)\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose()\n\n    this.targetSphereMaterial.dispose()\n    this.effectorSphereMaterial.dispose()\n    this.linkSphereMaterial.dispose()\n    this.lineMaterial.dispose()\n\n    const children = this.children\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i]\n\n      if (child.isLine) child.geometry.dispose()\n    }\n  }\n\n  // private method\n\n  _init() {\n    const scope = this\n    const iks = this.iks\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry()\n      const vertices = new Float32Array((2 + ik.links.length) * 3)\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3))\n\n      return geometry\n    }\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial)\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial)\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial)\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial)\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n\n      this.add(createTargetMesh())\n      this.add(createEffectorMesh())\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh())\n      }\n\n      this.add(createLine(ik))\n    }\n  }\n}\n\nexport { CCDIKSolver, CCDIKHelper }\n", "import {\n  Bone,\n  BoxGeometry,\n  Color,\n  Euler,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Quaternion,\n  SphereGeometry,\n  Vector3,\n} from 'three'\nimport { CapsuleGeometry } from '../_polyfill/CapsuleGeometry'\n\n/**\n * Dependencies\n *  - Ammo.js https://github.com/kripken/ammo.js\n *\n * MMDPhysics calculates physics with Ammo(Bullet based JavaScript Physics engine)\n * for MMD model loaded by MMDLoader.\n *\n * TODO\n *  - Physics in Worker\n */\n\n/* global Ammo */\n\nclass MMDPhysics {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} rigidBodyParams\n   * @param {Array<Object>} (optional) constraintParams\n   * @param {Object} params - (optional)\n   * @param {Number} params.unitStep - Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Default is 3.\n   * @param {Vector3} params.gravity - Default is ( 0, - 9.8 * 10, 0 )\n   */\n  constructor(mesh, rigidBodyParams, constraintParams = [], params = {}) {\n    if (typeof Ammo === 'undefined') {\n      throw new Error('THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js')\n    }\n\n    this.manager = new ResourceManager()\n\n    this.mesh = mesh\n\n    /*\n     * I don't know why but 1/60 unitStep easily breaks models\n     * so I set it 1/65 so far.\n     * Don't set too small unitStep because\n     * the smaller unitStep can make the performance worse.\n     */\n    this.unitStep = params.unitStep !== undefined ? params.unitStep : 1 / 65\n    this.maxStepNum = params.maxStepNum !== undefined ? params.maxStepNum : 3\n    this.gravity = new Vector3(0, -9.8 * 10, 0)\n\n    if (params.gravity !== undefined) this.gravity.copy(params.gravity)\n\n    this.world = params.world !== undefined ? params.world : null // experimental\n\n    this.bodies = []\n    this.constraints = []\n\n    this._init(mesh, rigidBodyParams, constraintParams)\n  }\n\n  /**\n   * Advances Physics calculation and updates bones.\n   *\n   * @param {Number} delta - time in second\n   * @return {MMDPhysics}\n   */\n  update(delta) {\n    const manager = this.manager\n    const mesh = this.mesh\n\n    // rigid bodies and constrains are for\n    // mesh's world scale (1, 1, 1).\n    // Convert to (1, 1, 1) if it isn't.\n\n    let isNonDefaultScale = false\n\n    const position = manager.allocThreeVector3()\n    const quaternion = manager.allocThreeQuaternion()\n    const scale = manager.allocThreeVector3()\n\n    mesh.matrixWorld.decompose(position, quaternion, scale)\n\n    if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {\n      isNonDefaultScale = true\n    }\n\n    let parent\n\n    if (isNonDefaultScale) {\n      parent = mesh.parent\n\n      if (parent !== null) mesh.parent = null\n\n      scale.copy(this.mesh.scale)\n\n      mesh.scale.set(1, 1, 1)\n      mesh.updateMatrixWorld(true)\n    }\n\n    // calculate physics and update bones\n\n    this._updateRigidBodies()\n    this._stepSimulation(delta)\n    this._updateBones()\n\n    // restore mesh if converted above\n\n    if (isNonDefaultScale) {\n      if (parent !== null) mesh.parent = parent\n\n      mesh.scale.copy(scale)\n    }\n\n    manager.freeThreeVector3(scale)\n    manager.freeThreeQuaternion(quaternion)\n    manager.freeThreeVector3(position)\n\n    return this\n  }\n\n  /**\n   * Resets rigid bodies transorm to current bone's.\n   *\n   * @return {MMDPhysics}\n   */\n  reset() {\n    for (let i = 0, il = this.bodies.length; i < il; i++) {\n      this.bodies[i].reset()\n    }\n\n    return this\n  }\n\n  /**\n   * Warm ups Rigid bodies. Calculates cycles steps.\n   *\n   * @param {Integer} cycles\n   * @return {MMDPhysics}\n   */\n  warmup(cycles) {\n    for (let i = 0; i < cycles; i++) {\n      this.update(1 / 60)\n    }\n\n    return this\n  }\n\n  /**\n   * Sets gravity.\n   *\n   * @param {Vector3} gravity\n   * @return {MMDPhysicsHelper}\n   */\n  setGravity(gravity) {\n    this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z))\n    this.gravity.copy(gravity)\n\n    return this\n  }\n\n  /**\n   * Creates MMDPhysicsHelper\n   *\n   * @return {MMDPhysicsHelper}\n   */\n  createHelper() {\n    return new MMDPhysicsHelper(this.mesh, this)\n  }\n\n  // private methods\n\n  _init(mesh, rigidBodyParams, constraintParams) {\n    const manager = this.manager\n\n    // rigid body/constraint parameters are for\n    // mesh's default world transform as position(0, 0, 0),\n    // quaternion(0, 0, 0, 1) and scale(0, 0, 0)\n\n    const parent = mesh.parent\n\n    if (parent !== null) mesh.parent = null\n\n    const currentPosition = manager.allocThreeVector3()\n    const currentQuaternion = manager.allocThreeQuaternion()\n    const currentScale = manager.allocThreeVector3()\n\n    currentPosition.copy(mesh.position)\n    currentQuaternion.copy(mesh.quaternion)\n    currentScale.copy(mesh.scale)\n\n    mesh.position.set(0, 0, 0)\n    mesh.quaternion.set(0, 0, 0, 1)\n    mesh.scale.set(1, 1, 1)\n\n    mesh.updateMatrixWorld(true)\n\n    if (this.world === null) {\n      this.world = this._createWorld()\n      this.setGravity(this.gravity)\n    }\n\n    this._initRigidBodies(rigidBodyParams)\n    this._initConstraints(constraintParams)\n\n    if (parent !== null) mesh.parent = parent\n\n    mesh.position.copy(currentPosition)\n    mesh.quaternion.copy(currentQuaternion)\n    mesh.scale.copy(currentScale)\n\n    mesh.updateMatrixWorld(true)\n\n    this.reset()\n\n    manager.freeThreeVector3(currentPosition)\n    manager.freeThreeQuaternion(currentQuaternion)\n    manager.freeThreeVector3(currentScale)\n  }\n\n  _createWorld() {\n    const config = new Ammo.btDefaultCollisionConfiguration()\n    const dispatcher = new Ammo.btCollisionDispatcher(config)\n    const cache = new Ammo.btDbvtBroadphase()\n    const solver = new Ammo.btSequentialImpulseConstraintSolver()\n    const world = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config)\n    return world\n  }\n\n  _initRigidBodies(rigidBodies) {\n    for (let i = 0, il = rigidBodies.length; i < il; i++) {\n      this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i], this.manager))\n    }\n  }\n\n  _initConstraints(constraints) {\n    for (let i = 0, il = constraints.length; i < il; i++) {\n      const params = constraints[i]\n      const bodyA = this.bodies[params.rigidBodyIndex1]\n      const bodyB = this.bodies[params.rigidBodyIndex2]\n      this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager))\n    }\n  }\n\n  _stepSimulation(delta) {\n    const unitStep = this.unitStep\n    let stepTime = delta\n    let maxStepNum = ((delta / unitStep) | 0) + 1\n\n    if (stepTime < unitStep) {\n      stepTime = unitStep\n      maxStepNum = 1\n    }\n\n    if (maxStepNum > this.maxStepNum) {\n      maxStepNum = this.maxStepNum\n    }\n\n    this.world.stepSimulation(stepTime, maxStepNum, unitStep)\n  }\n\n  _updateRigidBodies() {\n    for (let i = 0, il = this.bodies.length; i < il; i++) {\n      this.bodies[i].updateFromBone()\n    }\n  }\n\n  _updateBones() {\n    for (let i = 0, il = this.bodies.length; i < il; i++) {\n      this.bodies[i].updateBone()\n    }\n  }\n}\n\n/**\n * This manager's responsibilies are\n *\n * 1. manage Ammo.js and Three.js object resources and\n *    improve the performance and the memory consumption by\n *    reusing objects.\n *\n * 2. provide simple Ammo object operations.\n */\nclass ResourceManager {\n  constructor() {\n    // for Three.js\n    this.threeVector3s = []\n    this.threeMatrix4s = []\n    this.threeQuaternions = []\n    this.threeEulers = []\n\n    // for Ammo.js\n    this.transforms = []\n    this.quaternions = []\n    this.vector3s = []\n  }\n\n  allocThreeVector3() {\n    return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3()\n  }\n\n  freeThreeVector3(v) {\n    this.threeVector3s.push(v)\n  }\n\n  allocThreeMatrix4() {\n    return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4()\n  }\n\n  freeThreeMatrix4(m) {\n    this.threeMatrix4s.push(m)\n  }\n\n  allocThreeQuaternion() {\n    return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion()\n  }\n\n  freeThreeQuaternion(q) {\n    this.threeQuaternions.push(q)\n  }\n\n  allocThreeEuler() {\n    return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler()\n  }\n\n  freeThreeEuler(e) {\n    this.threeEulers.push(e)\n  }\n\n  allocTransform() {\n    return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform()\n  }\n\n  freeTransform(t) {\n    this.transforms.push(t)\n  }\n\n  allocQuaternion() {\n    return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion()\n  }\n\n  freeQuaternion(q) {\n    this.quaternions.push(q)\n  }\n\n  allocVector3() {\n    return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3()\n  }\n\n  freeVector3(v) {\n    this.vector3s.push(v)\n  }\n\n  setIdentity(t) {\n    t.setIdentity()\n  }\n\n  getBasis(t) {\n    var q = this.allocQuaternion()\n    t.getBasis().getRotation(q)\n    return q\n  }\n\n  getBasisAsMatrix3(t) {\n    var q = this.getBasis(t)\n    var m = this.quaternionToMatrix3(q)\n    this.freeQuaternion(q)\n    return m\n  }\n\n  getOrigin(t) {\n    return t.getOrigin()\n  }\n\n  setOrigin(t, v) {\n    t.getOrigin().setValue(v.x(), v.y(), v.z())\n  }\n\n  copyOrigin(t1, t2) {\n    var o = t2.getOrigin()\n    this.setOrigin(t1, o)\n  }\n\n  setBasis(t, q) {\n    t.setRotation(q)\n  }\n\n  setBasisFromMatrix3(t, m) {\n    var q = this.matrix3ToQuaternion(m)\n    this.setBasis(t, q)\n    this.freeQuaternion(q)\n  }\n\n  setOriginFromArray3(t, a) {\n    t.getOrigin().setValue(a[0], a[1], a[2])\n  }\n\n  setOriginFromThreeVector3(t, v) {\n    t.getOrigin().setValue(v.x, v.y, v.z)\n  }\n\n  setBasisFromArray3(t, a) {\n    var thQ = this.allocThreeQuaternion()\n    var thE = this.allocThreeEuler()\n    thE.set(a[0], a[1], a[2])\n    this.setBasisFromThreeQuaternion(t, thQ.setFromEuler(thE))\n\n    this.freeThreeEuler(thE)\n    this.freeThreeQuaternion(thQ)\n  }\n\n  setBasisFromThreeQuaternion(t, a) {\n    var q = this.allocQuaternion()\n\n    q.setX(a.x)\n    q.setY(a.y)\n    q.setZ(a.z)\n    q.setW(a.w)\n    this.setBasis(t, q)\n\n    this.freeQuaternion(q)\n  }\n\n  multiplyTransforms(t1, t2) {\n    var t = this.allocTransform()\n    this.setIdentity(t)\n\n    var m1 = this.getBasisAsMatrix3(t1)\n    var m2 = this.getBasisAsMatrix3(t2)\n\n    var o1 = this.getOrigin(t1)\n    var o2 = this.getOrigin(t2)\n\n    var v1 = this.multiplyMatrix3ByVector3(m1, o2)\n    var v2 = this.addVector3(v1, o1)\n    this.setOrigin(t, v2)\n\n    var m3 = this.multiplyMatrices3(m1, m2)\n    this.setBasisFromMatrix3(t, m3)\n\n    this.freeVector3(v1)\n    this.freeVector3(v2)\n\n    return t\n  }\n\n  inverseTransform(t) {\n    var t2 = this.allocTransform()\n\n    var m1 = this.getBasisAsMatrix3(t)\n    var o = this.getOrigin(t)\n\n    var m2 = this.transposeMatrix3(m1)\n    var v1 = this.negativeVector3(o)\n    var v2 = this.multiplyMatrix3ByVector3(m2, v1)\n\n    this.setOrigin(t2, v2)\n    this.setBasisFromMatrix3(t2, m2)\n\n    this.freeVector3(v1)\n    this.freeVector3(v2)\n\n    return t2\n  }\n\n  multiplyMatrices3(m1, m2) {\n    var m3 = []\n\n    var v10 = this.rowOfMatrix3(m1, 0)\n    var v11 = this.rowOfMatrix3(m1, 1)\n    var v12 = this.rowOfMatrix3(m1, 2)\n\n    var v20 = this.columnOfMatrix3(m2, 0)\n    var v21 = this.columnOfMatrix3(m2, 1)\n    var v22 = this.columnOfMatrix3(m2, 2)\n\n    m3[0] = this.dotVectors3(v10, v20)\n    m3[1] = this.dotVectors3(v10, v21)\n    m3[2] = this.dotVectors3(v10, v22)\n    m3[3] = this.dotVectors3(v11, v20)\n    m3[4] = this.dotVectors3(v11, v21)\n    m3[5] = this.dotVectors3(v11, v22)\n    m3[6] = this.dotVectors3(v12, v20)\n    m3[7] = this.dotVectors3(v12, v21)\n    m3[8] = this.dotVectors3(v12, v22)\n\n    this.freeVector3(v10)\n    this.freeVector3(v11)\n    this.freeVector3(v12)\n    this.freeVector3(v20)\n    this.freeVector3(v21)\n    this.freeVector3(v22)\n\n    return m3\n  }\n\n  addVector3(v1, v2) {\n    var v = this.allocVector3()\n    v.setValue(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z())\n    return v\n  }\n\n  dotVectors3(v1, v2) {\n    return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z()\n  }\n\n  rowOfMatrix3(m, i) {\n    var v = this.allocVector3()\n    v.setValue(m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2])\n    return v\n  }\n\n  columnOfMatrix3(m, i) {\n    var v = this.allocVector3()\n    v.setValue(m[i + 0], m[i + 3], m[i + 6])\n    return v\n  }\n\n  negativeVector3(v) {\n    var v2 = this.allocVector3()\n    v2.setValue(-v.x(), -v.y(), -v.z())\n    return v2\n  }\n\n  multiplyMatrix3ByVector3(m, v) {\n    var v4 = this.allocVector3()\n\n    var v0 = this.rowOfMatrix3(m, 0)\n    var v1 = this.rowOfMatrix3(m, 1)\n    var v2 = this.rowOfMatrix3(m, 2)\n    var x = this.dotVectors3(v0, v)\n    var y = this.dotVectors3(v1, v)\n    var z = this.dotVectors3(v2, v)\n\n    v4.setValue(x, y, z)\n\n    this.freeVector3(v0)\n    this.freeVector3(v1)\n    this.freeVector3(v2)\n\n    return v4\n  }\n\n  transposeMatrix3(m) {\n    var m2 = []\n    m2[0] = m[0]\n    m2[1] = m[3]\n    m2[2] = m[6]\n    m2[3] = m[1]\n    m2[4] = m[4]\n    m2[5] = m[7]\n    m2[6] = m[2]\n    m2[7] = m[5]\n    m2[8] = m[8]\n    return m2\n  }\n\n  quaternionToMatrix3(q) {\n    var m = []\n\n    var x = q.x()\n    var y = q.y()\n    var z = q.z()\n    var w = q.w()\n\n    var xx = x * x\n    var yy = y * y\n    var zz = z * z\n\n    var xy = x * y\n    var yz = y * z\n    var zx = z * x\n\n    var xw = x * w\n    var yw = y * w\n    var zw = z * w\n\n    m[0] = 1 - 2 * (yy + zz)\n    m[1] = 2 * (xy - zw)\n    m[2] = 2 * (zx + yw)\n    m[3] = 2 * (xy + zw)\n    m[4] = 1 - 2 * (zz + xx)\n    m[5] = 2 * (yz - xw)\n    m[6] = 2 * (zx - yw)\n    m[7] = 2 * (yz + xw)\n    m[8] = 1 - 2 * (xx + yy)\n\n    return m\n  }\n\n  matrix3ToQuaternion(m) {\n    var t = m[0] + m[4] + m[8]\n    var s, x, y, z, w\n\n    if (t > 0) {\n      s = Math.sqrt(t + 1.0) * 2\n      w = 0.25 * s\n      x = (m[7] - m[5]) / s\n      y = (m[2] - m[6]) / s\n      z = (m[3] - m[1]) / s\n    } else if (m[0] > m[4] && m[0] > m[8]) {\n      s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2\n      w = (m[7] - m[5]) / s\n      x = 0.25 * s\n      y = (m[1] + m[3]) / s\n      z = (m[2] + m[6]) / s\n    } else if (m[4] > m[8]) {\n      s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2\n      w = (m[2] - m[6]) / s\n      x = (m[1] + m[3]) / s\n      y = 0.25 * s\n      z = (m[5] + m[7]) / s\n    } else {\n      s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2\n      w = (m[3] - m[1]) / s\n      x = (m[2] + m[6]) / s\n      y = (m[5] + m[7]) / s\n      z = 0.25 * s\n    }\n\n    var q = this.allocQuaternion()\n    q.setX(x)\n    q.setY(y)\n    q.setZ(z)\n    q.setW(w)\n    return q\n  }\n}\n\n/**\n * @param {THREE.SkinnedMesh} mesh\n * @param {Ammo.btDiscreteDynamicsWorld} world\n * @param {Object} params\n * @param {ResourceManager} manager\n */\nclass RigidBody {\n  constructor(mesh, world, params, manager) {\n    this.mesh = mesh\n    this.world = world\n    this.params = params\n    this.manager = manager\n\n    this.body = null\n    this.bone = null\n    this.boneOffsetForm = null\n    this.boneOffsetFormInverse = null\n\n    this._init()\n  }\n\n  /**\n   * Resets rigid body transform to the current bone's.\n   *\n   * @return {RigidBody}\n   */\n  reset() {\n    this._setTransformFromBone()\n    return this\n  }\n\n  /**\n   * Updates rigid body's transform from the current bone.\n   *\n   * @return {RidigBody}\n   */\n  updateFromBone() {\n    if (this.params.boneIndex !== -1 && this.params.type === 0) {\n      this._setTransformFromBone()\n    }\n\n    return this\n  }\n\n  /**\n   * Updates bone from the current ridid body's transform.\n   *\n   * @return {RidigBody}\n   */\n  updateBone() {\n    if (this.params.type === 0 || this.params.boneIndex === -1) {\n      return this\n    }\n\n    this._updateBoneRotation()\n\n    if (this.params.type === 1) {\n      this._updateBonePosition()\n    }\n\n    this.bone.updateMatrixWorld(true)\n\n    if (this.params.type === 2) {\n      this._setPositionFromBone()\n    }\n\n    return this\n  }\n\n  // private methods\n\n  _init() {\n    function generateShape(p) {\n      switch (p.shapeType) {\n        case 0:\n          return new Ammo.btSphereShape(p.width)\n\n        case 1:\n          return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth))\n\n        case 2:\n          return new Ammo.btCapsuleShape(p.width, p.height)\n\n        default:\n          throw new Error('unknown shape type ' + p.shapeType)\n      }\n    }\n\n    const manager = this.manager\n    const params = this.params\n    const bones = this.mesh.skeleton.bones\n    const bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex]\n\n    const shape = generateShape(params)\n    const weight = params.type === 0 ? 0 : params.weight\n    const localInertia = manager.allocVector3()\n    localInertia.setValue(0, 0, 0)\n\n    if (weight !== 0) {\n      shape.calculateLocalInertia(weight, localInertia)\n    }\n\n    const boneOffsetForm = manager.allocTransform()\n    manager.setIdentity(boneOffsetForm)\n    manager.setOriginFromArray3(boneOffsetForm, params.position)\n    manager.setBasisFromArray3(boneOffsetForm, params.rotation)\n\n    const vector = manager.allocThreeVector3()\n    const boneForm = manager.allocTransform()\n    manager.setIdentity(boneForm)\n    manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector))\n\n    const form = manager.multiplyTransforms(boneForm, boneOffsetForm)\n    const state = new Ammo.btDefaultMotionState(form)\n\n    const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia)\n    info.set_m_friction(params.friction)\n    info.set_m_restitution(params.restitution)\n\n    const body = new Ammo.btRigidBody(info)\n\n    if (params.type === 0) {\n      body.setCollisionFlags(body.getCollisionFlags() | 2)\n\n      /*\n       * It'd be better to comment out this line though in general I should call this method\n       * because I'm not sure why but physics will be more like MMD's\n       * if I comment out.\n       */\n      body.setActivationState(4)\n    }\n\n    body.setDamping(params.positionDamping, params.rotationDamping)\n    body.setSleepingThresholds(0, 0)\n\n    this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget)\n\n    this.body = body\n    this.bone = bone\n    this.boneOffsetForm = boneOffsetForm\n    this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm)\n\n    manager.freeVector3(localInertia)\n    manager.freeTransform(form)\n    manager.freeTransform(boneForm)\n    manager.freeThreeVector3(vector)\n  }\n\n  _getBoneTransform() {\n    const manager = this.manager\n    const p = manager.allocThreeVector3()\n    const q = manager.allocThreeQuaternion()\n    const s = manager.allocThreeVector3()\n\n    this.bone.matrixWorld.decompose(p, q, s)\n\n    const tr = manager.allocTransform()\n    manager.setOriginFromThreeVector3(tr, p)\n    manager.setBasisFromThreeQuaternion(tr, q)\n\n    const form = manager.multiplyTransforms(tr, this.boneOffsetForm)\n\n    manager.freeTransform(tr)\n    manager.freeThreeVector3(s)\n    manager.freeThreeQuaternion(q)\n    manager.freeThreeVector3(p)\n\n    return form\n  }\n\n  _getWorldTransformForBone() {\n    const manager = this.manager\n    const tr = this.body.getCenterOfMassTransform()\n    return manager.multiplyTransforms(tr, this.boneOffsetFormInverse)\n  }\n\n  _setTransformFromBone() {\n    const manager = this.manager\n    const form = this._getBoneTransform()\n\n    // TODO: check the most appropriate way to set\n    //this.body.setWorldTransform( form );\n    this.body.setCenterOfMassTransform(form)\n    this.body.getMotionState().setWorldTransform(form)\n\n    manager.freeTransform(form)\n  }\n\n  _setPositionFromBone() {\n    const manager = this.manager\n    const form = this._getBoneTransform()\n\n    const tr = manager.allocTransform()\n    this.body.getMotionState().getWorldTransform(tr)\n    manager.copyOrigin(tr, form)\n\n    // TODO: check the most appropriate way to set\n    //this.body.setWorldTransform( tr );\n    this.body.setCenterOfMassTransform(tr)\n    this.body.getMotionState().setWorldTransform(tr)\n\n    manager.freeTransform(tr)\n    manager.freeTransform(form)\n  }\n\n  _updateBoneRotation() {\n    const manager = this.manager\n\n    const tr = this._getWorldTransformForBone()\n    const q = manager.getBasis(tr)\n\n    const thQ = manager.allocThreeQuaternion()\n    const thQ2 = manager.allocThreeQuaternion()\n    const thQ3 = manager.allocThreeQuaternion()\n\n    thQ.set(q.x(), q.y(), q.z(), q.w())\n    thQ2.setFromRotationMatrix(this.bone.matrixWorld)\n    thQ2.conjugate()\n    thQ2.multiply(thQ)\n\n    //this.bone.quaternion.multiply( thQ2 );\n\n    thQ3.setFromRotationMatrix(this.bone.matrix)\n\n    // Renormalizing quaternion here because repeatedly transforming\n    // quaternion continuously accumulates floating point error and\n    // can end up being overflow. See #15335\n    this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize())\n\n    manager.freeThreeQuaternion(thQ)\n    manager.freeThreeQuaternion(thQ2)\n    manager.freeThreeQuaternion(thQ3)\n\n    manager.freeQuaternion(q)\n    manager.freeTransform(tr)\n  }\n\n  _updateBonePosition() {\n    const manager = this.manager\n\n    const tr = this._getWorldTransformForBone()\n\n    const thV = manager.allocThreeVector3()\n\n    const o = manager.getOrigin(tr)\n    thV.set(o.x(), o.y(), o.z())\n\n    if (this.bone.parent) {\n      this.bone.parent.worldToLocal(thV)\n    }\n\n    this.bone.position.copy(thV)\n\n    manager.freeThreeVector3(thV)\n\n    manager.freeTransform(tr)\n  }\n}\n\n//\n\nclass Constraint {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Ammo.btDiscreteDynamicsWorld} world\n   * @param {RigidBody} bodyA\n   * @param {RigidBody} bodyB\n   * @param {Object} params\n   * @param {ResourceManager} manager\n   */\n  constructor(mesh, world, bodyA, bodyB, params, manager) {\n    this.mesh = mesh\n    this.world = world\n    this.bodyA = bodyA\n    this.bodyB = bodyB\n    this.params = params\n    this.manager = manager\n\n    this.constraint = null\n\n    this._init()\n  }\n\n  // private method\n\n  _init() {\n    const manager = this.manager\n    const params = this.params\n    const bodyA = this.bodyA\n    const bodyB = this.bodyB\n\n    const form = manager.allocTransform()\n    manager.setIdentity(form)\n    manager.setOriginFromArray3(form, params.position)\n    manager.setBasisFromArray3(form, params.rotation)\n\n    const formA = manager.allocTransform()\n    const formB = manager.allocTransform()\n\n    bodyA.body.getMotionState().getWorldTransform(formA)\n    bodyB.body.getMotionState().getWorldTransform(formB)\n\n    const formInverseA = manager.inverseTransform(formA)\n    const formInverseB = manager.inverseTransform(formB)\n\n    const formA2 = manager.multiplyTransforms(formInverseA, form)\n    const formB2 = manager.multiplyTransforms(formInverseB, form)\n\n    const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true)\n\n    const lll = manager.allocVector3()\n    const lul = manager.allocVector3()\n    const all = manager.allocVector3()\n    const aul = manager.allocVector3()\n\n    lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2])\n    lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2])\n    all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2])\n    aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2])\n\n    constraint.setLinearLowerLimit(lll)\n    constraint.setLinearUpperLimit(lul)\n    constraint.setAngularLowerLimit(all)\n    constraint.setAngularUpperLimit(aul)\n\n    for (let i = 0; i < 3; i++) {\n      if (params.springPosition[i] !== 0) {\n        constraint.enableSpring(i, true)\n        constraint.setStiffness(i, params.springPosition[i])\n      }\n    }\n\n    for (let i = 0; i < 3; i++) {\n      if (params.springRotation[i] !== 0) {\n        constraint.enableSpring(i + 3, true)\n        constraint.setStiffness(i + 3, params.springRotation[i])\n      }\n    }\n\n    /*\n     * Currently(10/31/2016) official ammo.js doesn't support\n     * btGeneric6DofSpringConstraint.setParam method.\n     * You need custom ammo.js (add the method into idl) if you wanna use.\n     * By setting this parameter, physics will be more like MMD's\n     */\n    if (constraint.setParam !== undefined) {\n      for (let i = 0; i < 6; i++) {\n        constraint.setParam(2, 0.475, i)\n      }\n    }\n\n    this.world.addConstraint(constraint, true)\n    this.constraint = constraint\n\n    manager.freeTransform(form)\n    manager.freeTransform(formA)\n    manager.freeTransform(formB)\n    manager.freeTransform(formInverseA)\n    manager.freeTransform(formInverseB)\n    manager.freeTransform(formA2)\n    manager.freeTransform(formB2)\n    manager.freeVector3(lll)\n    manager.freeVector3(lul)\n    manager.freeVector3(all)\n    manager.freeVector3(aul)\n  }\n}\n\nconst _position = new Vector3()\nconst _quaternion = new Quaternion()\nconst _scale = new Vector3()\nconst _matrixWorldInv = new Matrix4()\n\nclass MMDPhysicsHelper extends Object3D {\n  /**\n   * Visualize Rigid bodies\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Physics} physics\n   */\n  constructor(mesh, physics) {\n    super()\n\n    this.root = mesh\n    this.physics = physics\n\n    this.matrix.copy(mesh.matrixWorld)\n    this.matrixAutoUpdate = false\n\n    this.materials = []\n\n    this.materials.push(\n      new MeshBasicMaterial({\n        color: new Color(0xff8888),\n        wireframe: true,\n        depthTest: false,\n        depthWrite: false,\n        opacity: 0.25,\n        transparent: true,\n      }),\n    )\n\n    this.materials.push(\n      new MeshBasicMaterial({\n        color: new Color(0x88ff88),\n        wireframe: true,\n        depthTest: false,\n        depthWrite: false,\n        opacity: 0.25,\n        transparent: true,\n      }),\n    )\n\n    this.materials.push(\n      new MeshBasicMaterial({\n        color: new Color(0x8888ff),\n        wireframe: true,\n        depthTest: false,\n        depthWrite: false,\n        opacity: 0.25,\n        transparent: true,\n      }),\n    )\n\n    this._init()\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    const materials = this.materials\n    const children = this.children\n\n    for (let i = 0; i < materials.length; i++) {\n      materials[i].dispose()\n    }\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i]\n\n      if (child.isMesh) child.geometry.dispose()\n    }\n  }\n\n  /**\n   * Updates Rigid Bodies visualization.\n   */\n  updateMatrixWorld(force) {\n    var mesh = this.root\n\n    if (this.visible) {\n      var bodies = this.physics.bodies\n\n      _matrixWorldInv\n        .copy(mesh.matrixWorld)\n        .decompose(_position, _quaternion, _scale)\n        .compose(_position, _quaternion, _scale.set(1, 1, 1))\n        .invert()\n\n      for (var i = 0, il = bodies.length; i < il; i++) {\n        var body = bodies[i].body\n        var child = this.children[i]\n\n        var tr = body.getCenterOfMassTransform()\n        var origin = tr.getOrigin()\n        var rotation = tr.getRotation()\n\n        child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(_matrixWorldInv)\n\n        child.quaternion\n          .setFromRotationMatrix(_matrixWorldInv)\n          .multiply(_quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()))\n      }\n    }\n\n    this.matrix\n      .copy(mesh.matrixWorld)\n      .decompose(_position, _quaternion, _scale)\n      .compose(_position, _quaternion, _scale.set(1, 1, 1))\n\n    super.updateMatrixWorld(force)\n  }\n\n  // private method\n\n  _init() {\n    var bodies = this.physics.bodies\n\n    function createGeometry(param) {\n      switch (param.shapeType) {\n        case 0:\n          return new SphereGeometry(param.width, 16, 8)\n\n        case 1:\n          return new BoxGeometry(param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8)\n\n        case 2:\n          return new CapsuleGeometry(param.width, param.height, 8, 16)\n\n        default:\n          return null\n      }\n    }\n\n    for (var i = 0, il = bodies.length; i < il; i++) {\n      var param = bodies[i].params\n      this.add(new Mesh(createGeometry(param), this.materials[param.type]))\n    }\n  }\n}\n\nexport { MMDPhysics }\n", "import { AnimationMixer, Object3D, Quaternion, Vector3 } from 'three'\nimport { CCDIKSolver } from '../animation/CCDIKSolver'\nimport { MMDPhysics } from '../animation/MMDPhysics'\n\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = []\n\n    this.camera = null\n    this.cameraTarget = new Object3D()\n    this.cameraTarget.name = 'target'\n\n    this.audio = null\n    this.audioManager = null\n\n    this.objects = new WeakMap()\n\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== undefined ? params.pmxAnimation : false,\n    }\n\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true,\n    }\n\n    this.onBeforePhysics = function (/* mesh */) {}\n\n    // experimental\n    this.sharedPhysics = false\n    this.masterPhysics = null\n  }\n\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params)\n    } else if (object.isCamera) {\n      this._setupCamera(object, params)\n    } else if (object.type === 'Audio') {\n      this._setupAudio(object, params)\n    } else {\n      throw new Error(\n        'THREE.MMDAnimationHelper.add: ' +\n          'accepts only ' +\n          'THREE.SkinnedMesh or ' +\n          'THREE.Camera or ' +\n          'THREE.Audio instance.',\n      )\n    }\n\n    if (this.configuration.sync) this._syncDuration()\n\n    return this\n  }\n\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object)\n    } else if (object.isCamera) {\n      this._clearCamera(object)\n    } else if (object.type === 'Audio') {\n      this._clearAudio(object)\n    } else {\n      throw new Error(\n        'THREE.MMDAnimationHelper.remove: ' +\n          'accepts only ' +\n          'THREE.SkinnedMesh or ' +\n          'THREE.Camera or ' +\n          'THREE.Audio instance.',\n      )\n    }\n\n    if (this.configuration.sync) this._syncDuration()\n\n    return this\n  }\n\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n  update(delta) {\n    if (this.audioManager !== null) this.audioManager.control(delta)\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta)\n    }\n\n    if (this.sharedPhysics) this._updateSharedPhysics(delta)\n\n    if (this.camera !== null) this._animateCamera(this.camera, delta)\n\n    return this\n  }\n\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false) mesh.pose()\n\n    const bones = mesh.skeleton.bones\n    const boneParams = vpd.bones\n\n    const boneNameDictionary = {}\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i\n    }\n\n    const vector = new Vector3()\n    const quaternion = new Quaternion()\n\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i]\n      const boneIndex = boneNameDictionary[boneParam.name]\n\n      if (boneIndex === undefined) continue\n\n      const bone = bones[boneIndex]\n      bone.position.add(vector.fromArray(boneParam.translation))\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion))\n    }\n\n    mesh.updateMatrixWorld(true)\n\n    // PMX animation system special path\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === 'pmx') {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice())\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver)\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update()\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n  enable(key, enabled) {\n    if (this.enabled[key] === undefined) {\n      throw new Error('THREE.MMDAnimationHelper.enable: ' + 'unknown key ' + key)\n    }\n\n    this.enabled[key] = enabled\n\n    if (key === 'physics') {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants)\n  }\n\n  // private methods\n\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error('THREE.MMDAnimationHelper._addMesh: ' + \"SkinnedMesh '\" + mesh.name + \"' has already been added.\")\n    }\n\n    this.meshes.push(mesh)\n    this.objects.set(mesh, { looped: false })\n\n    this._setupMeshAnimation(mesh, params.animation)\n\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params)\n    }\n\n    return this\n  }\n\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error('THREE.MMDAnimationHelper._setupCamera: ' + \"Camera '\" + camera.name + \"' has already been set.\")\n    }\n\n    if (this.camera) this.clearCamera(this.camera)\n\n    this.camera = camera\n\n    camera.add(this.cameraTarget)\n\n    this.objects.set(camera, {})\n\n    if (params.animation !== undefined) {\n      this._setupCameraAnimation(camera, params.animation)\n    }\n\n    return this\n  }\n\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error('THREE.MMDAnimationHelper._setupAudio: ' + \"Audio '\" + audio.name + \"' has already been set.\")\n    }\n\n    if (this.audio) this.clearAudio(this.audio)\n\n    this.audio = audio\n    this.audioManager = new AudioManager(audio, params)\n\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration,\n    })\n\n    return this\n  }\n\n  _removeMesh(mesh) {\n    let found = false\n    let writeIndex = 0\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh)\n        found = true\n\n        continue\n      }\n\n      this.meshes[writeIndex++] = this.meshes[i]\n    }\n\n    if (!found) {\n      throw new Error(\n        'THREE.MMDAnimationHelper._removeMesh: ' + \"SkinnedMesh '\" + mesh.name + \"' has not been added yet.\",\n      )\n    }\n\n    this.meshes.length = writeIndex\n\n    return this\n  }\n\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error('THREE.MMDAnimationHelper._clearCamera: ' + \"Camera '\" + camera.name + \"' has not been set yet.\")\n    }\n\n    this.camera.remove(this.cameraTarget)\n\n    this.objects.delete(this.camera)\n    this.camera = null\n\n    return this\n  }\n\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error('THREE.MMDAnimationHelper._clearAudio: ' + \"Audio '\" + audio.name + \"' has not been set yet.\")\n    }\n\n    this.objects.delete(this.audioManager)\n\n    this.audio = null\n    this.audioManager = null\n\n    return this\n  }\n\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh)\n\n    if (animation !== undefined) {\n      const animations = Array.isArray(animation) ? animation : [animation]\n\n      objects.mixer = new AnimationMixer(mesh)\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play()\n      }\n\n      // TODO: find a workaround not to access ._clip looking like a private property\n      objects.mixer.addEventListener('loop', function (event) {\n        const tracks = event.action._clip.tracks\n\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return\n\n        objects.looped = true\n      })\n    }\n\n    objects.ikSolver = this._createCCDIKSolver(mesh)\n    objects.grantSolver = this.createGrantSolver(mesh)\n\n    return this\n  }\n\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation]\n\n    const objects = this.objects.get(camera)\n\n    objects.mixer = new AnimationMixer(camera)\n\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play()\n    }\n  }\n\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh)\n\n    // shared physics is experimental\n\n    if (params.world === undefined && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics()\n\n      if (masterPhysics !== null) world = masterPhysics.world // eslint-disable-line no-undef\n    }\n\n    objects.physics = this._createMMDPhysics(mesh, params)\n\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0)\n      objects.physics.reset()\n    }\n\n    objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60)\n\n    this._optimizeIK(mesh, true)\n  }\n\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh)\n\n    const mixer = objects.mixer\n    const ikSolver = objects.ikSolver\n    const grantSolver = objects.grantSolver\n    const physics = objects.physics\n    const looped = objects.looped\n\n    if (mixer && this.enabled.animation) {\n      // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      this._restoreBones(mesh)\n\n      mixer.update(delta)\n\n      this._saveBones(mesh)\n\n      // PMX animation system special path\n      if (\n        this.configuration.pmxAnimation &&\n        mesh.geometry.userData.MMD &&\n        mesh.geometry.userData.MMD.format === 'pmx'\n      ) {\n        if (!objects.sortedBonesData)\n          objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice())\n\n        this._animatePMXMesh(\n          mesh,\n          objects.sortedBonesData,\n          ikSolver && this.enabled.ik ? ikSolver : null,\n          grantSolver && this.enabled.grant ? grantSolver : null,\n        )\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true)\n          ikSolver.update()\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update()\n        }\n      }\n    }\n\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop) physics.reset()\n\n      objects.looped = false\n    }\n\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh)\n      physics.update(delta)\n    }\n  }\n\n  // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function (a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass\n      } else {\n        return a.index - b.index\n      }\n    })\n  }\n\n  // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0\n    _grantResultMap.clear()\n\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver)\n    }\n\n    mesh.updateMatrixWorld(true)\n    return this\n  }\n\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer\n\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta)\n\n      camera.updateProjectionMatrix()\n\n      camera.up.set(0, 1, 0)\n      camera.up.applyQuaternion(camera.quaternion)\n      camera.lookAt(this.cameraTarget.position)\n    }\n  }\n\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks\n    const bones = mesh.geometry.userData.MMD.bones\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n      const links = ik.links\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j]\n\n        if (physicsEnabled === true) {\n          // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n          // because its rotation will be overriden by physics\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true\n        } else {\n          link.enabled = true\n        }\n      }\n    }\n  }\n\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === undefined) {\n      throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.')\n    }\n\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks)\n  }\n\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === undefined) {\n      throw new Error('THREE.MMDPhysics: Import MMDPhysics.')\n    }\n\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params)\n  }\n\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n  _syncDuration() {\n    let max = 0.0\n\n    const objects = this.objects\n    const meshes = this.meshes\n    const camera = this.camera\n    const audioManager = this.audioManager\n\n    // get the longest duration\n\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer\n\n      if (mixer === undefined) continue\n\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip\n\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration,\n          })\n        }\n\n        max = Math.max(max, objects.get(clip).duration)\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer\n\n      if (mixer !== undefined) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration,\n            })\n          }\n\n          max = Math.max(max, objects.get(clip).duration)\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration)\n    }\n\n    max += this.configuration.afterglow\n\n    // update the duration\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer\n\n      if (mixer === undefined) continue\n\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer\n\n      if (mixer !== undefined) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      audioManager.duration = max\n    }\n  }\n\n  // workaround\n\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer\n\n    const propertyMixers = mixer._bindings\n    const accuIndex = mixer._accuIndex\n\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i]\n      const buffer = propertyMixer.buffer\n      const stride = propertyMixer.valueSize\n      const offset = (accuIndex + 1) * stride\n\n      propertyMixer.binding.getValue(buffer, offset)\n    }\n  }\n\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh)\n\n    const bones = mesh.skeleton.bones\n\n    let backupBones = objects.backupBones\n\n    if (backupBones === undefined) {\n      backupBones = new Float32Array(bones.length * 7)\n      objects.backupBones = backupBones\n    }\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      bone.position.toArray(backupBones, i * 7)\n      bone.quaternion.toArray(backupBones, i * 7 + 3)\n    }\n  }\n\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh)\n\n    const backupBones = objects.backupBones\n\n    if (backupBones === undefined) return\n\n    const bones = mesh.skeleton.bones\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      bone.position.fromArray(backupBones, i * 7)\n      bone.quaternion.fromArray(backupBones, i * 7 + 3)\n    }\n  }\n\n  // experimental\n\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null) return this.masterPhysics\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics\n\n      if (physics !== undefined && physics !== null) {\n        this.masterPhysics = physics\n        return this.masterPhysics\n      }\n    }\n\n    return null\n  }\n\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return\n\n    const physics = this._getMasterPhysics()\n\n    if (physics === null) return\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics\n\n      if (p !== null && p !== undefined) {\n        p.updateRigidBodies()\n      }\n    }\n\n    physics.stepSimulation(delta)\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics\n\n      if (p !== null && p !== undefined) {\n        p.updateBones()\n      }\n    }\n  }\n}\n\n// Keep working quaternions for less GC\nconst _quaternions = []\nlet _quaternionIndex = 0\n\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion())\n  }\n\n  return _quaternions[_quaternionIndex++]\n}\n\n// Save rotation whose grant and IK are already applied\n// used by grant children\nconst _grantResultMap = new Map()\n\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones\n  const bonesData = mesh.geometry.userData.MMD.bones\n  const boneData = bonesData[boneIndex]\n  const bone = bones[boneIndex]\n\n  // Return if already updated by being referred as a grant parent.\n  if (_grantResultMap.has(boneIndex)) return\n\n  const quaternion = getQuaternion()\n\n  // Initialize grant result here to prevent infinite loop.\n  // If it's referred before updating with actual result later\n  // result without applyting IK or grant is gotten\n  // but better than composing of infinite loop.\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion))\n\n  // @TODO: Support global grant and grant position\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex\n    const ratio = boneData.grant.ratio\n\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver)\n    }\n\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio)\n  }\n\n  if (ikSolver && boneData.ik) {\n    // @TODO: Updating world matrices every time solving an IK bone is\n    // costly. Optimize if possible.\n    mesh.updateMatrixWorld(true)\n    ikSolver.updateOne(boneData.ik)\n\n    // No confident, but it seems the grant results with ik links should be updated?\n    const links = boneData.ik.links\n\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i]\n\n      if (link.enabled === false) continue\n\n      const linkIndex = link.index\n\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion))\n      }\n    }\n  }\n\n  // Update with the actual result here\n  quaternion.copy(bone.quaternion)\n}\n\n//\n\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio\n\n    this.elapsedTime = 0.0\n    this.currentTime = 0.0\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0\n\n    this.audioDuration = this.audio.buffer.duration\n    this.duration = this.audioDuration + this.delayTime\n  }\n\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  control(delta) {\n    this.elapsed += delta\n    this.currentTime += delta\n\n    if (this._shouldStopAudio()) this.audio.stop()\n    if (this._shouldStartAudio()) this.audio.play()\n\n    return this\n  }\n\n  // private methods\n\n  _shouldStartAudio() {\n    if (this.audio.isPlaying) return false\n\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration\n    }\n\n    if (this.currentTime < this.delayTime) return false\n\n    // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n    if (this.currentTime - this.delayTime > this.audioDuration) return false\n\n    return true\n  }\n\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration\n  }\n}\n\nconst _q = new Quaternion()\n\n/**\n * Solver for Grant (Fuyo in Japanese. I just google translated because\n * Fuyo may be MMD specific term and may not be common word in 3D CG terms.)\n * Grant propagates a bone's transform to other bones transforms even if\n * they are not children.\n * @param {THREE.SkinnedMesh} mesh\n * @param {Array<Object>} grants\n */\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh\n    this.grants = grants\n  }\n\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  update() {\n    const grants = this.grants\n\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i])\n    }\n\n    return this\n  }\n\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones\n    const bone = bones[grant.index]\n    const parentBone = bones[grant.parentIndex]\n\n    if (grant.isLocal) {\n      // TODO: implement\n      if (grant.affectPosition) {\n      }\n\n      // TODO: implement\n      if (grant.affectRotation) {\n      }\n    } else {\n      // TODO: implement\n      if (grant.affectPosition) {\n      }\n\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio)\n      }\n    }\n\n    return this\n  }\n\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1)\n    _q.slerp(q, ratio)\n    bone.quaternion.multiply(_q)\n\n    return this\n  }\n}\n\nexport { MMDAnimationHelper }\n", "import {\n  Matrix4,\n  BufferAttribute,\n  InterleavedBufferAttribute,\n  Mesh,\n  BufferGeometry,\n  Material,\n  DataTexture,\n  IUniform,\n  MathUtils,\n  RGBAFormat,\n  FloatType,\n} from 'three'\n\nconst ID_ATTR_NAME = '_batch_id_'\nconst _identityMatrix = new Matrix4()\nconst _zeroScaleMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1)\n\n// Custom shaders\nconst batchingParsVertex = /* glsl */ `\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`\n\nconst batchingbaseVertex = /* glsl */ `\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`\n\nconst batchingnormalVertex = /* glsl */ `\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`\n\nconst batchingVertex = /* glsl */ `\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`\n\n// @TODO: SkinnedMesh support?\n// @TODO: Future work if needed. Move into the core. Can be optimized more with WEBGL_multi_draw.\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData(\n  src: BufferAttribute | InterleavedBufferAttribute,\n  target: BufferAttribute | InterleavedBufferAttribute,\n  targetOffset = 0,\n): void {\n  const itemSize = target.itemSize\n  if (\n    (src as InterleavedBufferAttribute).isInterleavedBufferAttribute ||\n    src.array.constructor !== target.array.constructor\n  ) {\n    // use the component getters and setters if the array data cannot\n    // be copied directly\n    const vertexCount = src.count\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        // @ts-ignore\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c))\n      }\n    }\n  } else {\n    // faster copy approach using typed array set function\n    // @ts-ignore\n    target.array.set(src.array, targetOffset * itemSize)\n  }\n\n  target.needsUpdate = true\n}\n\nclass BatchedMesh extends Mesh<BufferGeometry, Material> {\n  _vertexStarts: number[]\n  _vertexCounts: number[]\n  _indexStarts: number[]\n  _indexCounts: number[]\n  _reservedRanges: { vertexStart: number; vertexCount: number; indexStart: number; indexCount: number }[]\n  _visible: boolean[]\n  _active: boolean[]\n  _maxGeometryCount: number\n  _maxVertexCount: number\n  _maxIndexCount: number\n  _geometryInitialized: boolean\n  _geometryCount: number\n  _matrices: Matrix4[]\n  _matricesTexture: DataTexture | null\n  _customUniforms: Record<string, IUniform>\n\n  constructor(\n    maxGeometryCount: number,\n    maxVertexCount: number,\n    maxIndexCount = maxVertexCount * 2,\n    material?: Material,\n  ) {\n    super(new BufferGeometry(), material)\n\n    this._vertexStarts = []\n    this._vertexCounts = []\n    this._indexStarts = []\n    this._indexCounts = []\n    this._reservedRanges = []\n\n    this._visible = []\n    this._active = []\n\n    this._maxGeometryCount = maxGeometryCount\n    this._maxVertexCount = maxVertexCount\n    this._maxIndexCount = maxIndexCount\n\n    this._geometryInitialized = false\n    this._geometryCount = 0\n\n    // Local matrix per geometry by using data texture\n    // @TODO: Support uniform parameter per geometry\n\n    this._matrices = []\n    this._matricesTexture = null!\n\n    // @TODO: Calculate the entire binding box and make frustumCulled true\n    this.frustumCulled = false\n\n    this._customUniforms = {\n      batchingTexture: { value: null },\n    }\n\n    this._initMatricesTexture()\n    this._initShader()\n\n    this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true\n      }\n\n      // @TODO: Implement frustum culling for each geometry\n    }\n\n    this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false\n      }\n    }\n  }\n\n  _initMatricesTexture(): void {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this._maxGeometryCount * 4) // 4 pixels needed for 1 matrix\n    size = MathUtils.ceilPowerOfTwo(size)\n    size = Math.max(size, 4)\n\n    const matricesArray = new Float32Array(size * size * 4) // 4 floats per RGBA pixel\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType)\n\n    this._matricesTexture = matricesTexture\n    this._customUniforms.batchingTexture.value = this._matricesTexture\n  }\n\n  _initShader(): void {\n    const material = this.material\n    const currentOnBeforeCompile = material.onBeforeCompile\n    const customUniforms = this._customUniforms\n\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      // Is this replacement stable across any materials?\n      parameters.vertexShader = parameters.vertexShader\n        .replace('#include <skinning_pars_vertex>', '#include <skinning_pars_vertex>\\n' + batchingParsVertex)\n        .replace('#include <uv_vertex>', '#include <uv_vertex>\\n' + batchingbaseVertex)\n        .replace('#include <skinnormal_vertex>', '#include <skinnormal_vertex>\\n' + batchingnormalVertex)\n        .replace('#include <skinning_vertex>', '#include <skinning_vertex>\\n' + batchingVertex)\n\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName]\n      }\n\n      currentOnBeforeCompile.call(this, parameters, renderer)\n    }\n\n    material.defines = material.defines || {}\n    material.defines.BATCHING = false\n  }\n\n  _initializeGeometry(reference: BufferGeometry): void {\n    // @TODO: geometry.groups support?\n    // @TODO: geometry.drawRange support?\n    // @TODO: geometry.morphAttributes support?\n\n    const geometry = this.geometry\n    const maxVertexCount = this._maxVertexCount\n    const maxGeometryCount = this._maxGeometryCount\n    const maxIndexCount = this._maxIndexCount\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName)\n        const { array, itemSize, normalized } = srcAttribute\n\n        const dstArray = new (array.constructor as Float32ArrayConstructor)(maxVertexCount * itemSize)\n        const dstAttribute = new (srcAttribute.constructor as any)(dstArray, itemSize, normalized)\n\n        // TODO: add usage in @types/three\n        // @ts-ignore\n        dstAttribute.setUsage(srcAttribute.usage)\n\n        geometry.setAttribute(attributeName, dstAttribute)\n      }\n\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount)\n\n        geometry.setIndex(new BufferAttribute(indexArray, 1))\n      }\n\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount)\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1))\n\n      this._geometryInitialized = true\n    }\n  }\n\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry: BufferGeometry): void {\n    // check that the geometry doesn't have a version of our reserved id attribute\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`)\n    }\n\n    // check to ensure the geometries are using consistent attributes and indices\n    const batchGeometry = this.geometry\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".')\n    }\n\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue\n      }\n\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(\n          `BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`,\n        )\n      }\n\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = batchGeometry.getAttribute(attributeName)\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.')\n      }\n    }\n  }\n\n  getGeometryCount(): number {\n    return this._geometryCount\n  }\n\n  getVertexCount(): number {\n    const reservedRanges = this._reservedRanges\n    if (reservedRanges.length === 0) {\n      return 0\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1]\n      return finalRange.vertexStart + finalRange.vertexCount\n    }\n  }\n\n  getIndexCount(): number {\n    const reservedRanges = this._reservedRanges\n    const geometry = this.geometry\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1]\n      return finalRange.indexStart + finalRange.indexCount\n    }\n  }\n\n  addGeometry(geometry: BufferGeometry, vertexCount = -1, indexCount = -1): number {\n    this._initializeGeometry(geometry)\n\n    this._validateGeometry(geometry)\n\n    // ensure we're not over geometry\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error('BatchedMesh: Maximum geometry count reached.')\n    }\n\n    // get the necessary range fo the geometry\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1,\n    }\n\n    let lastRange = null\n    const reservedRanges = this._reservedRanges\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1]\n    }\n\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute('position').count\n    } else {\n      range.vertexCount = vertexCount\n    }\n\n    if (lastRange === null) {\n      range.vertexStart = 0\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount\n    }\n\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex()!.count\n      } else {\n        range.indexCount = indexCount\n      }\n\n      if (lastRange === null) {\n        range.indexStart = 0\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount\n      }\n    }\n\n    if (\n      (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount) ||\n      range.vertexStart + range.vertexCount > this._maxVertexCount\n    ) {\n      throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.')\n    }\n\n    const indexCounts = this._indexCounts\n    const indexStarts = this._indexStarts\n    const vertexCounts = this._vertexCounts\n    const vertexStarts = this._vertexStarts\n\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture\n    const matrices = this._matrices\n    const matricesArray = this._matricesTexture!.image.data\n\n    // push new visibility states\n    visible.push(true)\n    active.push(true)\n\n    // update id\n    const geometryId = this._geometryCount\n    this._geometryCount++\n\n    // initialize matrix information\n    matrices.push(new Matrix4())\n    _identityMatrix.toArray(matricesArray, geometryId * 16)\n    matricesTexture!.needsUpdate = true\n\n    // add the reserved range\n    reservedRanges.push(range)\n\n    // push new geometry data range\n    vertexStarts.push(range.vertexStart)\n    vertexCounts.push(range.vertexCount)\n\n    if (geometry.getIndex() !== null) {\n      // push new index range\n      indexStarts.push(range.indexCount)\n      indexCounts.push(range.indexCount)\n    }\n\n    // set the id for the geometry\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME)\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId)\n    }\n\n    idAttribute.needsUpdate = true\n\n    // update the geometry\n    this.setGeometryAt(geometryId, geometry)\n\n    return geometryId\n  }\n\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry: BufferGeometry): number {\n    return this.addGeometry(geometry)\n  }\n\n  setGeometryAt(id: number, geometry: BufferGeometry): number {\n    if (id >= this._geometryCount) {\n      throw new Error('BatchedMesh: Maximum geometry count reached.')\n    }\n\n    this._validateGeometry(geometry)\n\n    const range = this._reservedRanges[id]\n    if (\n      (geometry.getIndex() !== null && geometry.getIndex()!.count > range.indexCount) ||\n      geometry.attributes.position.count > range.vertexCount\n    ) {\n      throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.')\n    }\n\n    // copy geometry over\n    const batchGeometry = this.geometry\n    const srcPositionAttribute = geometry.getAttribute('position')\n    const hasIndex = batchGeometry.getIndex() !== null\n    const dstIndex = batchGeometry.getIndex()!\n    const srcIndex = geometry.getIndex()!\n\n    // copy attribute data over\n    const vertexStart = range.vertexStart\n    const vertexCount = range.vertexCount\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue\n      }\n\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = batchGeometry.getAttribute(attributeName)\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart)\n\n      // fill the rest in with zeroes\n      const itemSize = srcAttribute.itemSize\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i\n        for (let c = 0; c < itemSize; c++) {\n          // @ts-ignore\n          dstAttribute.setComponent(index, c, 0)\n        }\n      }\n\n      dstAttribute.needsUpdate = true\n    }\n\n    this._vertexCounts[id] = srcPositionAttribute.count\n\n    if (hasIndex) {\n      // fill the rest in with zeroes\n      const indexStart = range.indexStart\n\n      // copy index data over\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i))\n      }\n\n      // fill the rest in with zeroes\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart)\n      }\n\n      dstIndex.needsUpdate = true\n      this._indexCounts[id] = srcIndex.count\n    }\n\n    return id\n  }\n\n  deleteGeometry(geometryId: number): this {\n    // Note: User needs to call optimize() afterward to pack the data.\n\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matricesArray = matricesTexture.image.data\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this\n    }\n\n    active[geometryId] = false\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16)\n    matricesTexture!.needsUpdate = true\n\n    return this\n  }\n\n  optimize(): never {\n    throw new Error('BatchedMesh: Optimize function not implemented.')\n  }\n\n  setMatrixAt(geometryId: number, matrix: Matrix4): this {\n    // @TODO: Map geometryId to index of the arrays because\n    //        optimize() can make geometryId mismatch the index\n\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matrices = this._matrices\n    const matricesArray = matricesTexture.image.data\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this\n    }\n\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16)\n      matricesTexture.needsUpdate = true\n    }\n\n    matrices[geometryId].copy(matrix)\n\n    return this\n  }\n\n  getMatrixAt(geometryId: number, matrix: Matrix4): Matrix4 {\n    const matrices = this._matrices\n    const active = this._active\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix\n    }\n\n    return matrix.copy(matrices[geometryId])\n  }\n\n  setVisibleAt(geometryId: number, value: boolean): this {\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matrices = this._matrices\n    const matricesArray = matricesTexture.image.data\n\n    // if the geometry is out of range, not active, or visibility state\n    // does not change then return early\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this\n    }\n\n    // scale the matrix to zero if it's hidden\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16)\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16)\n    }\n\n    matricesTexture.needsUpdate = true\n    visible[geometryId] = value\n\n    return this\n  }\n\n  getVisibleAt(geometryId: number): boolean {\n    const visible = this._visible\n    const active = this._active\n\n    // return early if the geometry is out of range or not active\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false\n    }\n\n    return visible[geometryId]\n  }\n\n  raycast(): void {\n    console.warn('BatchedMesh: Raycast function not implemented.')\n  }\n\n  copy(): never {\n    // super.copy( source );\n\n    throw new Error('BatchedMesh: Copy function not implemented.')\n  }\n\n  toJSON(): never {\n    throw new Error('BatchedMesh: toJSON function not implemented.')\n  }\n\n  dispose(): this {\n    // Assuming the geometry is not shared with other meshes\n    this.geometry.dispose()\n\n    this._matricesTexture!.dispose()\n    this._matricesTexture = null!\n\n    return this\n  }\n}\n\nexport { BatchedMesh }\n", "import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  HalfFloatType,\n  NoToneMapping,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass Reflector extends Mesh {\n  static ReflectorShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      tDiffuse: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isReflector = true\n\n    this.type = 'Reflector'\n    this.camera = new PerspectiveCamera()\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || Reflector.ReflectorShader\n    const multisample = options.multisample !== undefined ? options.multisample : 4\n\n    //\n\n    const reflectorPlane = new Plane()\n    const normal = new Vector3()\n    const reflectorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n    const clipPlane = new Vector4()\n\n    const view = new Vector3()\n    const target = new Vector3()\n    const q = new Vector4()\n\n    const textureMatrix = new Matrix4()\n    const virtualCamera = this.camera\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType,\n    })\n\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader,\n    })\n\n    material.uniforms['tDiffuse'].value = renderTarget.texture\n    material.uniforms['color'].value = color\n    material.uniforms['textureMatrix'].value = textureMatrix\n\n    this.material = material\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(reflectorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(reflectorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(reflectorWorldPosition)\n\n      virtualCamera.position.copy(view)\n      virtualCamera.up.set(0, 1, 0)\n      virtualCamera.up.applyMatrix4(rotationMatrix)\n      virtualCamera.up.reflect(normal)\n      virtualCamera.lookAt(target)\n\n      virtualCamera.far = camera.far // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld()\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(virtualCamera.projectionMatrix)\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition)\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse)\n\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant)\n\n      const projectionMatrix = virtualCamera.projectionMatrix\n\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n      q.z = -1.0\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q))\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x\n      projectionMatrix.elements[6] = clipPlane.y\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias\n      projectionMatrix.elements[14] = clipPlane.w\n\n      // Render\n      scope.visible = false\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentToneMapping = renderer.toneMapping\n\n      let isSRGB = false\n      if ('outputColorSpace' in renderer) isSRGB = renderer.outputColorSpace === 'srgb'\n      else isSRGB = renderer.outputEncoding === 3001 // sRGBEncoding\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.outputEncoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.toneMapping = currentToneMapping\n\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = isSRGB ? 'srgb' : 'srgb-linear'\n      else renderer.outputEncoding = isSRGB ? 3001 : 3000\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      scope.visible = true\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n\n    this.dispose = function () {\n      renderTarget.dispose()\n      scope.material.dispose()\n    }\n  }\n}\n\nexport { Reflector }\n", "import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  Quaternion,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  NoToneMapping,\n  HalfFloatType,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass Refractor extends Mesh {\n  static RefractorShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      tDiffuse: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isRefractor = true\n\n    this.type = 'Refractor'\n    this.camera = new PerspectiveCamera()\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || Refractor.RefractorShader\n    const multisample = options.multisample !== undefined ? options.multisample : 4\n\n    //\n\n    const virtualCamera = this.camera\n    virtualCamera.matrixAutoUpdate = false\n    virtualCamera.userData.refractor = true\n\n    //\n\n    const refractorPlane = new Plane()\n    const textureMatrix = new Matrix4()\n\n    // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType,\n    })\n\n    // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true, // ensures, refractors are drawn from farthest to closest\n    })\n\n    this.material.uniforms['color'].value = color\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture\n    this.material.uniforms['textureMatrix'].value = textureMatrix\n\n    // functions\n\n    const visible = (function () {\n      const refractorWorldPosition = new Vector3()\n      const cameraWorldPosition = new Vector3()\n      const rotationMatrix = new Matrix4()\n\n      const view = new Vector3()\n      const normal = new Vector3()\n\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n        view.subVectors(refractorWorldPosition, cameraWorldPosition)\n\n        rotationMatrix.extractRotation(scope.matrixWorld)\n\n        normal.set(0, 0, 1)\n        normal.applyMatrix4(rotationMatrix)\n\n        return view.dot(normal) < 0\n      }\n    })()\n\n    const updateRefractorPlane = (function () {\n      const normal = new Vector3()\n      const position = new Vector3()\n      const quaternion = new Quaternion()\n      const scale = new Vector3()\n\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale)\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize()\n\n        // flip the normal because we want to cull everything above the plane\n\n        normal.negate()\n\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position)\n      }\n    })()\n\n    const updateVirtualCamera = (function () {\n      const clipPlane = new Plane()\n      const clipVector = new Vector4()\n      const q = new Vector4()\n\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld)\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert()\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n        virtualCamera.far = camera.far // used in WebGLBackground\n\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. Oblique View Frustum Depth Projection and Clipping.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 516\n\n        clipPlane.copy(refractorPlane)\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse)\n\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant)\n\n        // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix\n\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n        q.z = -1.0\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n        // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q))\n\n        // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x\n        projectionMatrix.elements[6] = clipVector.y\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias\n        projectionMatrix.elements[14] = clipVector.w\n      }\n    })()\n\n    // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n\n      // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix)\n      textureMatrix.multiply(camera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n    }\n\n    //\n\n    function render(renderer, scene, camera) {\n      scope.visible = false\n\n      const currentRenderTarget = renderer.getRenderTarget()\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentToneMapping = renderer.toneMapping\n\n      let isSRGB = false\n      if ('outputColorSpace' in renderer) isSRGB = renderer.outputColorSpace === 'srgb'\n      else isSRGB = renderer.outputEncoding === 3001 // sRGBEncoding\n\n      renderer.xr.enabled = false // avoid camera modification\n      renderer.shadowMap.autoUpdate = false // avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.outputEncoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      renderer.setRenderTarget(renderTarget)\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.toneMapping = currentToneMapping\n      renderer.setRenderTarget(currentRenderTarget)\n\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = isSRGB ? 'srgb' : 'srgb-linear'\n      else renderer.outputEncoding = isSRGB ? 3001 : 3000\n\n      // restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      scope.visible = true\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return\n\n      // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return\n\n      // update\n\n      updateRefractorPlane()\n\n      updateTextureMatrix(camera)\n\n      updateVirtualCamera(camera)\n\n      render(renderer, scene, camera)\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n\n    this.dispose = function () {\n      renderTarget.dispose()\n      scope.material.dispose()\n    }\n  }\n}\n\nexport { Refractor }\n", "import { Matrix4, Mesh, MeshBasicMaterial, EqualStencilFunc, IncrementStencilOp } from 'three'\n\n/**\n * A shadow Mesh that follows a shadow-casting Mesh in the scene, but is confined to a single plane.\n */\n\nconst _shadowMatrix = new Matrix4()\n\nclass ShadowMesh extends Mesh {\n  constructor(mesh) {\n    const shadowMaterial = new MeshBasicMaterial({\n      color: 0x000000,\n      transparent: true,\n      opacity: 0.6,\n      depthWrite: false,\n      stencilWrite: true,\n      stencilFunc: EqualStencilFunc,\n      stencilRef: 0,\n      stencilZPass: IncrementStencilOp,\n    })\n\n    super(mesh.geometry, shadowMaterial)\n\n    this.isShadowMesh = true\n\n    this.meshMatrix = mesh.matrixWorld\n\n    this.frustumCulled = false\n    this.matrixAutoUpdate = false\n  }\n\n  update(plane, lightPosition4D) {\n    // based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm\n\n    const dot =\n      plane.normal.x * lightPosition4D.x +\n      plane.normal.y * lightPosition4D.y +\n      plane.normal.z * lightPosition4D.z +\n      -plane.constant * lightPosition4D.w\n\n    const sme = _shadowMatrix.elements\n\n    sme[0] = dot - lightPosition4D.x * plane.normal.x\n    sme[4] = -lightPosition4D.x * plane.normal.y\n    sme[8] = -lightPosition4D.x * plane.normal.z\n    sme[12] = -lightPosition4D.x * -plane.constant\n\n    sme[1] = -lightPosition4D.y * plane.normal.x\n    sme[5] = dot - lightPosition4D.y * plane.normal.y\n    sme[9] = -lightPosition4D.y * plane.normal.z\n    sme[13] = -lightPosition4D.y * -plane.constant\n\n    sme[2] = -lightPosition4D.z * plane.normal.x\n    sme[6] = -lightPosition4D.z * plane.normal.y\n    sme[10] = dot - lightPosition4D.z * plane.normal.z\n    sme[14] = -lightPosition4D.z * -plane.constant\n\n    sme[3] = -lightPosition4D.w * plane.normal.x\n    sme[7] = -lightPosition4D.w * plane.normal.y\n    sme[11] = -lightPosition4D.w * plane.normal.z\n    sme[15] = dot - lightPosition4D.w * -plane.constant\n\n    this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix)\n  }\n}\n\nexport { ShadowMesh }\n", "import {\n  AdditiveBlending,\n  Box2,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DataTexture,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Mesh,\n  MeshBasicMaterial,\n  NearestFilter,\n  RGBAFormat,\n  RawShaderMaterial,\n  Vector2,\n  Vector3,\n  Vector4,\n} from 'three'\n\nconst geometry = new BufferGeometry()\n\nconst float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1])\n\nconst interleavedBuffer = new InterleavedBuffer(float32Array, 5)\n\ngeometry.setIndex([0, 1, 2, 0, 2, 3])\ngeometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false))\ngeometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false))\n\nclass Lensflare extends Mesh {\n  static Geometry = geometry\n\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({ opacity: 0, transparent: true }))\n\n    this.isLensflare = true\n\n    this.type = 'Lensflare'\n    this.frustumCulled = false\n    this.renderOrder = Infinity\n\n    //\n\n    const positionScreen = new Vector3()\n    const positionView = new Vector3()\n\n    // textures\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat)\n    tempMap.minFilter = NearestFilter\n    tempMap.magFilter = NearestFilter\n    tempMap.wrapS = ClampToEdgeWrapping\n    tempMap.wrapT = ClampToEdgeWrapping\n\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat)\n    occlusionMap.minFilter = NearestFilter\n    occlusionMap.magFilter = NearestFilter\n    occlusionMap.wrapS = ClampToEdgeWrapping\n    occlusionMap.wrapT = ClampToEdgeWrapping\n\n    // material\n\n    const geometry = Lensflare.Geometry\n\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: { value: null },\n        screenPosition: { value: null },\n      },\n      vertexShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false,\n    })\n\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: { value: tempMap },\n        scale: { value: null },\n        screenPosition: { value: null },\n      },\n      vertexShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: /* glsl */ `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false,\n    })\n\n    // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a)\n\n    //\n\n    const elements = []\n\n    const shader = LensflareElement.Shader\n\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: { value: null },\n        occlusionMap: { value: occlusionMap },\n        color: { value: new Color(0xffffff) },\n        scale: { value: new Vector2() },\n        screenPosition: { value: new Vector3() },\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false,\n    })\n\n    const mesh2 = new Mesh(geometry, material2)\n\n    this.addElement = function (element) {\n      elements.push(element)\n    }\n\n    //\n\n    const scale = new Vector2()\n    const screenPositionPixels = new Vector2()\n    const validArea = new Box2()\n    const viewport = new Vector4()\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport)\n\n      const invAspect = viewport.w / viewport.z\n      const halfViewportWidth = viewport.z / 2.0\n      const halfViewportHeight = viewport.w / 2.0\n\n      let size = 16 / viewport.w\n      scale.set(size * invAspect, size)\n\n      validArea.min.set(viewport.x, viewport.y)\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16))\n\n      // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld)\n      positionView.applyMatrix4(camera.matrixWorldInverse)\n\n      if (positionView.z > 0) return // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix)\n\n      // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8\n\n      // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap)\n\n        // render pink quad\n\n        let uniforms = material1a.uniforms\n        uniforms['scale'].value = scale\n        uniforms['screenPosition'].value = positionScreen\n\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null)\n\n        // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap)\n\n        // restore graphics\n\n        uniforms = material1b.uniforms\n        uniforms['scale'].value = scale\n        uniforms['screenPosition'].value = positionScreen\n\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null)\n\n        // render elements\n\n        const vecX = -positionScreen.x * 2\n        const vecY = -positionScreen.y * 2\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i]\n\n          const uniforms = material2.uniforms\n\n          uniforms['color'].value.copy(element.color)\n          uniforms['map'].value = element.texture\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance\n\n          size = element.size / viewport.w\n          const invAspect = viewport.w / viewport.z\n\n          uniforms['scale'].value.set(size * invAspect, size)\n\n          material2.uniformsNeedUpdate = true\n\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null)\n        }\n      }\n    }\n\n    this.dispose = function () {\n      material1a.dispose()\n      material1b.dispose()\n      material2.dispose()\n\n      tempMap.dispose()\n      occlusionMap.dispose()\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose()\n      }\n    }\n  }\n}\n\n//\n\nclass LensflareElement {\n  static Shader = {\n    uniforms: {\n      map: { value: null },\n      occlusionMap: { value: null },\n      color: { value: null },\n      scale: { value: null },\n      screenPosition: { value: null },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`,\n  }\n\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture\n    this.size = size\n    this.distance = distance\n    this.color = color\n  }\n}\n\nexport { Lensflare, LensflareElement }\n", "import { BufferAttribute, BufferGeometry, Color, DynamicDrawUsage, Mesh, Sphere, Vector3 } from 'three'\n\n/**\n * Port of http://webglsamples.org/blob/blob.html\n */\n\nclass MarchingCubes extends Mesh {\n  constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 10000) {\n    const geometry = new BufferGeometry()\n\n    super(geometry, material)\n\n    this.isMarchingCubes = true\n\n    const scope = this\n\n    // temp buffers used in polygonize\n\n    const vlist = new Float32Array(12 * 3)\n    const nlist = new Float32Array(12 * 3)\n    const clist = new Float32Array(12 * 3)\n\n    this.enableUvs = enableUvs\n    this.enableColors = enableColors\n\n    // functions have to be object properties\n    // prototype functions kill performance\n    // (tested and it was 4x slower !!!)\n\n    this.init = function (resolution) {\n      this.resolution = resolution\n\n      // parameters\n\n      this.isolation = 80.0\n\n      // size of field, 32 is pushing it in Javascript :)\n\n      this.size = resolution\n      this.size2 = this.size * this.size\n      this.size3 = this.size2 * this.size\n      this.halfsize = this.size / 2.0\n\n      // deltas\n\n      this.delta = 2.0 / this.size\n      this.yd = this.size\n      this.zd = this.size2\n\n      this.field = new Float32Array(this.size3)\n      this.normal_cache = new Float32Array(this.size3 * 3)\n      this.palette = new Float32Array(this.size3 * 3)\n\n      //\n\n      this.count = 0\n\n      const maxVertexCount = maxPolyCount * 3\n\n      this.positionArray = new Float32Array(maxVertexCount * 3)\n      const positionAttribute = new BufferAttribute(this.positionArray, 3)\n      positionAttribute.setUsage(DynamicDrawUsage)\n      geometry.setAttribute('position', positionAttribute)\n\n      this.normalArray = new Float32Array(maxVertexCount * 3)\n      const normalAttribute = new BufferAttribute(this.normalArray, 3)\n      normalAttribute.setUsage(DynamicDrawUsage)\n      geometry.setAttribute('normal', normalAttribute)\n\n      if (this.enableUvs) {\n        this.uvArray = new Float32Array(maxVertexCount * 2)\n        const uvAttribute = new BufferAttribute(this.uvArray, 2)\n        uvAttribute.setUsage(DynamicDrawUsage)\n        geometry.setAttribute('uv', uvAttribute)\n      }\n\n      if (this.enableColors) {\n        this.colorArray = new Float32Array(maxVertexCount * 3)\n        const colorAttribute = new BufferAttribute(this.colorArray, 3)\n        colorAttribute.setUsage(DynamicDrawUsage)\n        geometry.setAttribute('color', colorAttribute)\n      }\n\n      geometry.boundingSphere = new Sphere(new Vector3(), 1)\n    }\n\n    ///////////////////////\n    // Polygonization\n    ///////////////////////\n\n    function lerp(a, b, t) {\n      return a + (b - a) * t\n    }\n\n    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      const mu = (isol - valp1) / (valp2 - valp1),\n        nc = scope.normal_cache\n\n      vlist[offset + 0] = x + mu * scope.delta\n      vlist[offset + 1] = y\n      vlist[offset + 2] = z\n\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu)\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu)\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu)\n\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu)\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu)\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu)\n    }\n\n    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      const mu = (isol - valp1) / (valp2 - valp1),\n        nc = scope.normal_cache\n\n      vlist[offset + 0] = x\n      vlist[offset + 1] = y + mu * scope.delta\n      vlist[offset + 2] = z\n\n      const q2 = q + scope.yd * 3\n\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu)\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu)\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu)\n\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu)\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu)\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu)\n    }\n\n    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      const mu = (isol - valp1) / (valp2 - valp1),\n        nc = scope.normal_cache\n\n      vlist[offset + 0] = x\n      vlist[offset + 1] = y\n      vlist[offset + 2] = z + mu * scope.delta\n\n      const q2 = q + scope.zd * 3\n\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu)\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu)\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu)\n\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu)\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu)\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu)\n    }\n\n    function compNorm(q) {\n      const q3 = q * 3\n\n      if (scope.normal_cache[q3] === 0.0) {\n        scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1]\n        scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd]\n        scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd]\n      }\n    }\n\n    // Returns total number of triangles. Fills triangles.\n    // (this is where most of time is spent - it's inner work of O(n3) loop )\n\n    function polygonize(fx, fy, fz, q, isol) {\n      // cache indices\n      const q1 = q + 1,\n        qy = q + scope.yd,\n        qz = q + scope.zd,\n        q1y = q1 + scope.yd,\n        q1z = q1 + scope.zd,\n        qyz = q + scope.yd + scope.zd,\n        q1yz = q1 + scope.yd + scope.zd\n\n      let cubeindex = 0\n      const field0 = scope.field[q],\n        field1 = scope.field[q1],\n        field2 = scope.field[qy],\n        field3 = scope.field[q1y],\n        field4 = scope.field[qz],\n        field5 = scope.field[q1z],\n        field6 = scope.field[qyz],\n        field7 = scope.field[q1yz]\n\n      if (field0 < isol) cubeindex |= 1\n      if (field1 < isol) cubeindex |= 2\n      if (field2 < isol) cubeindex |= 8\n      if (field3 < isol) cubeindex |= 4\n      if (field4 < isol) cubeindex |= 16\n      if (field5 < isol) cubeindex |= 32\n      if (field6 < isol) cubeindex |= 128\n      if (field7 < isol) cubeindex |= 64\n\n      // if cube is entirely in/out of the surface - bail, nothing to draw\n\n      const bits = edgeTable[cubeindex]\n      if (bits === 0) return 0\n\n      const d = scope.delta,\n        fx2 = fx + d,\n        fy2 = fy + d,\n        fz2 = fz + d\n\n      // top of the cube\n\n      if (bits & 1) {\n        compNorm(q)\n        compNorm(q1)\n        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1)\n      }\n\n      if (bits & 2) {\n        compNorm(q1)\n        compNorm(q1y)\n        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y)\n      }\n\n      if (bits & 4) {\n        compNorm(qy)\n        compNorm(q1y)\n        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y)\n      }\n\n      if (bits & 8) {\n        compNorm(q)\n        compNorm(qy)\n        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy)\n      }\n\n      // bottom of the cube\n\n      if (bits & 16) {\n        compNorm(qz)\n        compNorm(q1z)\n        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z)\n      }\n\n      if (bits & 32) {\n        compNorm(q1z)\n        compNorm(q1yz)\n        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz)\n      }\n\n      if (bits & 64) {\n        compNorm(qyz)\n        compNorm(q1yz)\n        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz)\n      }\n\n      if (bits & 128) {\n        compNorm(qz)\n        compNorm(qyz)\n        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz)\n      }\n\n      // vertical lines of the cube\n      if (bits & 256) {\n        compNorm(q)\n        compNorm(qz)\n        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz)\n      }\n\n      if (bits & 512) {\n        compNorm(q1)\n        compNorm(q1z)\n        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z)\n      }\n\n      if (bits & 1024) {\n        compNorm(q1y)\n        compNorm(q1yz)\n        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz)\n      }\n\n      if (bits & 2048) {\n        compNorm(qy)\n        compNorm(qyz)\n        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz)\n      }\n\n      cubeindex <<= 4 // re-purpose cubeindex into an offset into triTable\n\n      let o1,\n        o2,\n        o3,\n        numtris = 0,\n        i = 0\n\n      // here is where triangles are created\n\n      while (triTable[cubeindex + i] != -1) {\n        o1 = cubeindex + i\n        o2 = o1 + 1\n        o3 = o1 + 2\n\n        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3])\n\n        i += 3\n        numtris++\n      }\n\n      return numtris\n    }\n\n    function posnormtriv(pos, norm, colors, o1, o2, o3) {\n      const c = scope.count * 3\n\n      // positions\n\n      scope.positionArray[c + 0] = pos[o1]\n      scope.positionArray[c + 1] = pos[o1 + 1]\n      scope.positionArray[c + 2] = pos[o1 + 2]\n\n      scope.positionArray[c + 3] = pos[o2]\n      scope.positionArray[c + 4] = pos[o2 + 1]\n      scope.positionArray[c + 5] = pos[o2 + 2]\n\n      scope.positionArray[c + 6] = pos[o3]\n      scope.positionArray[c + 7] = pos[o3 + 1]\n      scope.positionArray[c + 8] = pos[o3 + 2]\n\n      // normals\n\n      if (scope.material.flatShading === true) {\n        const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3\n        const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3\n        const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3\n\n        scope.normalArray[c + 0] = nx\n        scope.normalArray[c + 1] = ny\n        scope.normalArray[c + 2] = nz\n\n        scope.normalArray[c + 3] = nx\n        scope.normalArray[c + 4] = ny\n        scope.normalArray[c + 5] = nz\n\n        scope.normalArray[c + 6] = nx\n        scope.normalArray[c + 7] = ny\n        scope.normalArray[c + 8] = nz\n      } else {\n        scope.normalArray[c + 0] = norm[o1 + 0]\n        scope.normalArray[c + 1] = norm[o1 + 1]\n        scope.normalArray[c + 2] = norm[o1 + 2]\n\n        scope.normalArray[c + 3] = norm[o2 + 0]\n        scope.normalArray[c + 4] = norm[o2 + 1]\n        scope.normalArray[c + 5] = norm[o2 + 2]\n\n        scope.normalArray[c + 6] = norm[o3 + 0]\n        scope.normalArray[c + 7] = norm[o3 + 1]\n        scope.normalArray[c + 8] = norm[o3 + 2]\n      }\n\n      // uvs\n\n      if (scope.enableUvs) {\n        const d = scope.count * 2\n\n        scope.uvArray[d + 0] = pos[o1 + 0]\n        scope.uvArray[d + 1] = pos[o1 + 2]\n\n        scope.uvArray[d + 2] = pos[o2 + 0]\n        scope.uvArray[d + 3] = pos[o2 + 2]\n\n        scope.uvArray[d + 4] = pos[o3 + 0]\n        scope.uvArray[d + 5] = pos[o3 + 2]\n      }\n\n      // colors\n\n      if (scope.enableColors) {\n        scope.colorArray[c + 0] = colors[o1 + 0]\n        scope.colorArray[c + 1] = colors[o1 + 1]\n        scope.colorArray[c + 2] = colors[o1 + 2]\n\n        scope.colorArray[c + 3] = colors[o2 + 0]\n        scope.colorArray[c + 4] = colors[o2 + 1]\n        scope.colorArray[c + 5] = colors[o2 + 2]\n\n        scope.colorArray[c + 6] = colors[o3 + 0]\n        scope.colorArray[c + 7] = colors[o3 + 1]\n        scope.colorArray[c + 8] = colors[o3 + 2]\n      }\n\n      scope.count += 3\n    }\n\n    /////////////////////////////////////\n    // Metaballs\n    /////////////////////////////////////\n\n    // Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\n    // a fixed distance, determined by strength and subtract.\n\n    this.addBall = function (ballx, bally, ballz, strength, subtract, colors) {\n      const sign = Math.sign(strength)\n      strength = Math.abs(strength)\n      const userDefineColor = !(colors === undefined || colors === null)\n      let ballColor = new Color(ballx, bally, ballz)\n\n      if (userDefineColor) {\n        try {\n          ballColor =\n            colors instanceof Color\n              ? colors\n              : Array.isArray(colors)\n              ? new Color(\n                  Math.min(Math.abs(colors[0]), 1),\n                  Math.min(Math.abs(colors[1]), 1),\n                  Math.min(Math.abs(colors[2]), 1),\n                )\n              : new Color(colors)\n        } catch (err) {\n          ballColor = new Color(ballx, bally, ballz)\n        }\n      }\n\n      // Let's solve the equation to find the radius:\n      // 1.0 / (0.000001 + radius^2) * strength - subtract = 0\n      // strength / (radius^2) = subtract\n      // strength = subtract * radius^2\n      // radius^2 = strength / subtract\n      // radius = sqrt(strength / subtract)\n\n      const radius = this.size * Math.sqrt(strength / subtract),\n        zs = ballz * this.size,\n        ys = bally * this.size,\n        xs = ballx * this.size\n\n      let min_z = Math.floor(zs - radius)\n      if (min_z < 1) min_z = 1\n      let max_z = Math.floor(zs + radius)\n      if (max_z > this.size - 1) max_z = this.size - 1\n      let min_y = Math.floor(ys - radius)\n      if (min_y < 1) min_y = 1\n      let max_y = Math.floor(ys + radius)\n      if (max_y > this.size - 1) max_y = this.size - 1\n      let min_x = Math.floor(xs - radius)\n      if (min_x < 1) min_x = 1\n      let max_x = Math.floor(xs + radius)\n      if (max_x > this.size - 1) max_x = this.size - 1\n\n      // Don't polygonize in the outer layer because normals aren't\n      // well-defined there.\n\n      let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val\n\n      for (z = min_z; z < max_z; z++) {\n        z_offset = this.size2 * z\n        fz = z / this.size - ballz\n        fz2 = fz * fz\n\n        for (y = min_y; y < max_y; y++) {\n          y_offset = z_offset + this.size * y\n          fy = y / this.size - bally\n          fy2 = fy * fy\n\n          for (x = min_x; x < max_x; x++) {\n            fx = x / this.size - ballx\n            val = strength / (0.000001 + fx * fx + fy2 + fz2) - subtract\n            if (val > 0.0) {\n              this.field[y_offset + x] += val * sign\n\n              // optimization\n              // http://www.geisswerks.com/ryan/BLOBS/blobs.html\n              const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius\n              const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10)\n              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib\n              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib\n              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib\n            }\n          }\n        }\n      }\n    }\n\n    this.addPlaneX = function (strength, subtract) {\n      // cache attribute lookups\n      const size = this.size,\n        yd = this.yd,\n        zd = this.zd,\n        field = this.field\n\n      let x,\n        y,\n        z,\n        xx,\n        val,\n        xdiv,\n        cxy,\n        dist = size * Math.sqrt(strength / subtract)\n\n      if (dist > size) dist = size\n\n      for (x = 0; x < dist; x++) {\n        xdiv = x / size\n        xx = xdiv * xdiv\n        val = strength / (0.0001 + xx) - subtract\n\n        if (val > 0.0) {\n          for (y = 0; y < size; y++) {\n            cxy = x + y * yd\n\n            for (z = 0; z < size; z++) {\n              field[zd * z + cxy] += val\n            }\n          }\n        }\n      }\n    }\n\n    this.addPlaneY = function (strength, subtract) {\n      // cache attribute lookups\n      const size = this.size,\n        yd = this.yd,\n        zd = this.zd,\n        field = this.field\n\n      let x,\n        y,\n        z,\n        yy,\n        val,\n        ydiv,\n        cy,\n        cxy,\n        dist = size * Math.sqrt(strength / subtract)\n\n      if (dist > size) dist = size\n\n      for (y = 0; y < dist; y++) {\n        ydiv = y / size\n        yy = ydiv * ydiv\n        val = strength / (0.0001 + yy) - subtract\n\n        if (val > 0.0) {\n          cy = y * yd\n\n          for (x = 0; x < size; x++) {\n            cxy = cy + x\n\n            for (z = 0; z < size; z++) field[zd * z + cxy] += val\n          }\n        }\n      }\n    }\n\n    this.addPlaneZ = function (strength, subtract) {\n      // cache attribute lookups\n\n      const size = this.size,\n        yd = this.yd,\n        zd = this.zd,\n        field = this.field\n\n      let x,\n        y,\n        z,\n        zz,\n        val,\n        zdiv,\n        cz,\n        cyz,\n        dist = size * Math.sqrt(strength / subtract)\n\n      if (dist > size) dist = size\n\n      for (z = 0; z < dist; z++) {\n        zdiv = z / size\n        zz = zdiv * zdiv\n        val = strength / (0.0001 + zz) - subtract\n        if (val > 0.0) {\n          cz = zd * z\n\n          for (y = 0; y < size; y++) {\n            cyz = cz + y * yd\n\n            for (x = 0; x < size; x++) field[cyz + x] += val\n          }\n        }\n      }\n    }\n\n    /////////////////////////////////////\n    // Updates\n    /////////////////////////////////////\n\n    this.setCell = function (x, y, z, value) {\n      const index = this.size2 * z + this.size * y + x\n      this.field[index] = value\n    }\n\n    this.getCell = function (x, y, z) {\n      const index = this.size2 * z + this.size * y + x\n      return this.field[index]\n    }\n\n    this.blur = function (intensity = 1) {\n      const field = this.field\n      const fieldCopy = field.slice()\n      const size = this.size\n      const size2 = this.size2\n      for (let x = 0; x < size; x++) {\n        for (let y = 0; y < size; y++) {\n          for (let z = 0; z < size; z++) {\n            const index = size2 * z + size * y + x\n            let val = fieldCopy[index]\n            let count = 1\n\n            for (let x2 = -1; x2 <= 1; x2 += 2) {\n              const x3 = x2 + x\n              if (x3 < 0 || x3 >= size) continue\n\n              for (let y2 = -1; y2 <= 1; y2 += 2) {\n                const y3 = y2 + y\n                if (y3 < 0 || y3 >= size) continue\n\n                for (let z2 = -1; z2 <= 1; z2 += 2) {\n                  const z3 = z2 + z\n                  if (z3 < 0 || z3 >= size) continue\n\n                  const index2 = size2 * z3 + size * y3 + x3\n                  const val2 = fieldCopy[index2]\n\n                  count++\n                  val += (intensity * (val2 - val)) / count\n                }\n              }\n            }\n\n            field[index] = val\n          }\n        }\n      }\n    }\n\n    this.reset = function () {\n      // wipe the normal cache\n\n      for (let i = 0; i < this.size3; i++) {\n        this.normal_cache[i * 3] = 0.0\n        this.field[i] = 0.0\n        this.palette[i * 3] = this.palette[i * 3 + 1] = this.palette[i * 3 + 2] = 0.0\n      }\n    }\n\n    this.update = function () {\n      this.count = 0\n\n      // Triangulate. Yeah, this is slow.\n\n      const smin2 = this.size - 2\n\n      for (let z = 1; z < smin2; z++) {\n        const z_offset = this.size2 * z\n        const fz = (z - this.halfsize) / this.halfsize //+ 1\n\n        for (let y = 1; y < smin2; y++) {\n          const y_offset = z_offset + this.size * y\n          const fy = (y - this.halfsize) / this.halfsize //+ 1\n\n          for (let x = 1; x < smin2; x++) {\n            const fx = (x - this.halfsize) / this.halfsize //+ 1\n            const q = y_offset + x\n\n            polygonize(fx, fy, fz, q, this.isolation)\n          }\n        }\n      }\n\n      // set the draw range to only the processed triangles\n\n      this.geometry.setDrawRange(0, this.count)\n\n      // update geometry data\n\n      geometry.getAttribute('position').needsUpdate = true\n      geometry.getAttribute('normal').needsUpdate = true\n\n      if (this.enableUvs) geometry.getAttribute('uv').needsUpdate = true\n      if (this.enableColors) geometry.getAttribute('color').needsUpdate = true\n\n      // safety check\n\n      if (this.count / 3 > maxPolyCount)\n        console.warn(\n          'THREE.MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.',\n        )\n    }\n\n    this.init(resolution)\n  }\n}\n\n/////////////////////////////////////\n// Marching cubes lookup tables\n/////////////////////////////////////\n\n// These tables are straight from Paul Bourke's page:\n// http://paulbourke.net/geometry/polygonise/\n// who in turn got them from Cory Gene Bloyd.\n\n// prettier-ignore\nconst edgeTable = new Int32Array( [\n\t0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,\n\t0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,\n\t0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,\n\t0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,\n\t0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,\n\t0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,\n\t0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,\n\t0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,\n\t0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,\n\t0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,\n\t0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,\n\t0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,\n\t0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,\n\t0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,\n\t0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,\n\t0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,\n\t0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,\n\t0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,\n\t0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,\n\t0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,\n\t0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,\n\t0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,\n\t0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,\n\t0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,\n\t0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,\n\t0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,\n\t0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,\n\t0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,\n\t0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,\n\t0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,\n\t0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,\n\t0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0 ] );\n\n// prettier-ignore\nconst triTable = new Int32Array( [\n\t- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 8, 3, 9, 8, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 3, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 2, 10, 0, 2, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 8, 3, 2, 10, 8, 10, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 11, 2, 8, 11, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 9, 0, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 11, 2, 1, 9, 11, 9, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 10, 1, 11, 10, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 10, 1, 0, 8, 10, 8, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 9, 0, 3, 11, 9, 11, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 3, 0, 7, 3, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 1, 9, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 1, 9, 4, 7, 1, 7, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 10, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 4, 7, 3, 0, 4, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 2, 10, 9, 0, 2, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,\n\t8, 4, 7, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t11, 4, 7, 11, 2, 4, 2, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 0, 1, 8, 4, 7, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, - 1, - 1, - 1, - 1,\n\t3, 10, 1, 3, 11, 10, 7, 8, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, - 1, - 1, - 1, - 1,\n\t4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,\n\t4, 7, 11, 4, 11, 9, 9, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 5, 4, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 5, 4, 1, 5, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 5, 4, 8, 3, 5, 3, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 10, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 0, 8, 1, 2, 10, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 2, 10, 5, 4, 2, 4, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, - 1, - 1, - 1, - 1,\n\t9, 5, 4, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 11, 2, 0, 8, 11, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 5, 4, 0, 1, 5, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, - 1, - 1, - 1, - 1,\n\t10, 3, 11, 10, 1, 3, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, - 1, - 1, - 1, - 1,\n\t5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,\n\t5, 4, 8, 5, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 7, 8, 5, 7, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 3, 0, 9, 5, 3, 5, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 7, 8, 0, 1, 7, 1, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 7, 8, 9, 5, 7, 10, 1, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, - 1, - 1, - 1, - 1,\n\t8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, - 1, - 1, - 1, - 1,\n\t2, 10, 5, 2, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t7, 9, 5, 7, 8, 9, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,\n\t2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, - 1, - 1, - 1, - 1,\n\t11, 2, 1, 11, 1, 7, 7, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, - 1, - 1, - 1, - 1,\n\t5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, - 1,\n\t11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, - 1,\n\t11, 10, 5, 7, 11, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 3, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 0, 1, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 8, 3, 1, 9, 8, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 6, 5, 2, 6, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 6, 5, 1, 2, 6, 3, 0, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 6, 5, 9, 0, 6, 0, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, - 1, - 1, - 1, - 1,\n\t2, 3, 11, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t11, 0, 8, 11, 2, 0, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 1, 9, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, - 1, - 1, - 1, - 1,\n\t6, 3, 11, 6, 5, 3, 5, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,\n\t3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, - 1, - 1, - 1, - 1,\n\t6, 5, 9, 6, 9, 11, 11, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 10, 6, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 3, 0, 4, 7, 3, 6, 5, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 9, 0, 5, 10, 6, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,\n\t6, 1, 2, 6, 5, 1, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, - 1, - 1, - 1, - 1,\n\t8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, - 1, - 1, - 1, - 1,\n\t7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, - 1,\n\t3, 11, 2, 7, 8, 4, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,\n\t0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1,\n\t9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, - 1,\n\t8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,\n\t5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, - 1,\n\t0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, - 1,\n\t6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, - 1, - 1, - 1, - 1,\n\t10, 4, 9, 6, 4, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 10, 6, 4, 9, 10, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 0, 1, 10, 6, 0, 6, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,\n\t1, 4, 9, 1, 2, 4, 2, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, - 1, - 1, - 1, - 1,\n\t0, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 3, 2, 8, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 4, 9, 10, 6, 4, 11, 2, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, - 1, - 1, - 1, - 1,\n\t3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,\n\t6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, - 1,\n\t9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, - 1, - 1, - 1, - 1,\n\t8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, - 1,\n\t3, 11, 6, 3, 6, 0, 0, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t6, 4, 8, 11, 6, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t7, 10, 6, 7, 8, 10, 8, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, - 1, - 1, - 1, - 1,\n\t10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, - 1, - 1, - 1, - 1,\n\t10, 6, 7, 10, 7, 1, 1, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,\n\t2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, - 1,\n\t7, 8, 0, 7, 0, 6, 6, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t7, 3, 2, 6, 7, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,\n\t2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, - 1,\n\t1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, - 1,\n\t11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, - 1, - 1, - 1, - 1,\n\t8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, - 1,\n\t0, 9, 1, 11, 6, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, - 1, - 1, - 1, - 1,\n\t7, 11, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 0, 8, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 1, 9, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 1, 9, 8, 3, 1, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 1, 2, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 10, 3, 0, 8, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 9, 0, 2, 10, 9, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, - 1, - 1, - 1, - 1,\n\t7, 2, 3, 6, 2, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t7, 0, 8, 7, 6, 0, 6, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 7, 6, 2, 3, 7, 0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, - 1, - 1, - 1, - 1,\n\t10, 7, 6, 10, 1, 7, 1, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, - 1, - 1, - 1, - 1,\n\t0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, - 1, - 1, - 1, - 1,\n\t7, 6, 10, 7, 10, 8, 8, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t6, 8, 4, 11, 8, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 6, 11, 3, 0, 6, 0, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 6, 11, 8, 4, 6, 9, 0, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, - 1, - 1, - 1, - 1,\n\t6, 8, 4, 6, 11, 8, 2, 10, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, - 1, - 1, - 1, - 1,\n\t4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, - 1, - 1, - 1, - 1,\n\t10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, - 1,\n\t8, 2, 3, 8, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, - 1, - 1, - 1, - 1,\n\t1, 9, 4, 1, 4, 2, 2, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, - 1, - 1, - 1, - 1,\n\t10, 1, 0, 10, 0, 6, 6, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, - 1,\n\t10, 9, 4, 6, 10, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 9, 5, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 3, 4, 9, 5, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 0, 1, 5, 4, 0, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, - 1, - 1, - 1, - 1,\n\t9, 5, 4, 10, 1, 2, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, - 1, - 1, - 1, - 1,\n\t7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, - 1, - 1, - 1, - 1,\n\t3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, - 1,\n\t7, 2, 3, 7, 6, 2, 5, 4, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, - 1, - 1, - 1, - 1,\n\t3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, - 1, - 1, - 1, - 1,\n\t6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, - 1,\n\t9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, - 1, - 1, - 1, - 1,\n\t1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, - 1,\n\t4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, - 1,\n\t7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, - 1, - 1, - 1, - 1,\n\t6, 9, 5, 6, 11, 9, 11, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, - 1, - 1, - 1, - 1,\n\t0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, - 1, - 1, - 1, - 1,\n\t6, 11, 3, 6, 3, 5, 5, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, - 1, - 1, - 1, - 1,\n\t0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, - 1,\n\t11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, - 1,\n\t6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, - 1, - 1, - 1, - 1,\n\t5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, - 1, - 1, - 1, - 1,\n\t9, 5, 6, 9, 6, 0, 0, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, - 1,\n\t1, 5, 6, 2, 1, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, - 1,\n\t10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, - 1, - 1, - 1, - 1,\n\t0, 3, 8, 5, 6, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 5, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t11, 5, 10, 7, 5, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t11, 5, 10, 11, 7, 5, 8, 3, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 11, 7, 5, 10, 11, 1, 9, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, - 1, - 1, - 1, - 1,\n\t11, 1, 2, 11, 7, 1, 7, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, - 1, - 1, - 1, - 1,\n\t9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, - 1, - 1, - 1, - 1,\n\t7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, - 1,\n\t2, 5, 10, 2, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, - 1, - 1, - 1, - 1,\n\t9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, - 1, - 1, - 1, - 1,\n\t9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, - 1,\n\t1, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 7, 0, 7, 1, 1, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 0, 3, 9, 3, 5, 5, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 8, 7, 5, 9, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 8, 4, 5, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, - 1, - 1, - 1, - 1,\n\t0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, - 1, - 1, - 1, - 1,\n\t10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, - 1,\n\t2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, - 1, - 1, - 1, - 1,\n\t0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, - 1,\n\t0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, - 1,\n\t9, 4, 5, 2, 11, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, - 1, - 1, - 1, - 1,\n\t5, 10, 2, 5, 2, 4, 4, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, - 1,\n\t5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, - 1, - 1, - 1, - 1,\n\t8, 4, 5, 8, 5, 3, 3, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 4, 5, 1, 0, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, - 1, - 1, - 1, - 1,\n\t9, 4, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 11, 7, 4, 9, 11, 9, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, - 1, - 1, - 1, - 1,\n\t1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, - 1, - 1, - 1, - 1,\n\t3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, - 1,\n\t4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, - 1, - 1, - 1, - 1,\n\t9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, - 1,\n\t11, 7, 4, 11, 4, 2, 2, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, - 1, - 1, - 1, - 1,\n\t2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, - 1, - 1, - 1, - 1,\n\t9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, - 1,\n\t3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, - 1,\n\t1, 10, 2, 8, 7, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 9, 1, 4, 1, 7, 7, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, - 1, - 1, - 1, - 1,\n\t4, 0, 3, 7, 4, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t4, 8, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 0, 9, 3, 9, 11, 11, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 1, 10, 0, 10, 8, 8, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 1, 10, 11, 3, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 2, 11, 1, 11, 9, 9, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, - 1, - 1, - 1, - 1,\n\t0, 2, 11, 8, 0, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t3, 2, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 3, 8, 2, 8, 10, 10, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t9, 10, 2, 0, 9, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, - 1, - 1, - 1, - 1,\n\t1, 10, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t1, 3, 8, 9, 1, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 9, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t0, 3, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\n\t- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1 ] );\n\nexport { MarchingCubes, edgeTable, triTable }\n", "// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n//\n\nexport interface NumberGenerator {\n  random: () => number\n}\n\n// Added 4D noise\nexport class SimplexNoise {\n  private grad3 = [\n    [1, 1, 0],\n    [-1, 1, 0],\n    [1, -1, 0],\n    [-1, -1, 0],\n    [1, 0, 1],\n    [-1, 0, 1],\n    [1, 0, -1],\n    [-1, 0, -1],\n    [0, 1, 1],\n    [0, -1, 1],\n    [0, 1, -1],\n    [0, -1, -1],\n  ]\n\n  private grad4 = [\n    [0, 1, 1, 1],\n    [0, 1, 1, -1],\n    [0, 1, -1, 1],\n    [0, 1, -1, -1],\n    [0, -1, 1, 1],\n    [0, -1, 1, -1],\n    [0, -1, -1, 1],\n    [0, -1, -1, -1],\n    [1, 0, 1, 1],\n    [1, 0, 1, -1],\n    [1, 0, -1, 1],\n    [1, 0, -1, -1],\n    [-1, 0, 1, 1],\n    [-1, 0, 1, -1],\n    [-1, 0, -1, 1],\n    [-1, 0, -1, -1],\n    [1, 1, 0, 1],\n    [1, 1, 0, -1],\n    [1, -1, 0, 1],\n    [1, -1, 0, -1],\n    [-1, 1, 0, 1],\n    [-1, 1, 0, -1],\n    [-1, -1, 0, 1],\n    [-1, -1, 0, -1],\n    [1, 1, 1, 0],\n    [1, 1, -1, 0],\n    [1, -1, 1, 0],\n    [1, -1, -1, 0],\n    [-1, 1, 1, 0],\n    [-1, 1, -1, 0],\n    [-1, -1, 1, 0],\n    [-1, -1, -1, 0],\n  ]\n\n  private p: number[] = []\n\n  // To remove the need for index wrapping, double the permutation table length\n  private perm: number[] = []\n\n  // A lookup table to traverse the simplex around a given point in 4D.\n  // Details can be found where this table is used, in the 4D noise method.\n  private simplex = [\n    [0, 1, 2, 3],\n    [0, 1, 3, 2],\n    [0, 0, 0, 0],\n    [0, 2, 3, 1],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [1, 2, 3, 0],\n    [0, 2, 1, 3],\n    [0, 0, 0, 0],\n    [0, 3, 1, 2],\n    [0, 3, 2, 1],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [1, 3, 2, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [1, 2, 0, 3],\n    [0, 0, 0, 0],\n    [1, 3, 0, 2],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [2, 3, 0, 1],\n    [2, 3, 1, 0],\n    [1, 0, 2, 3],\n    [1, 0, 3, 2],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [2, 0, 3, 1],\n    [0, 0, 0, 0],\n    [2, 1, 3, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [2, 0, 1, 3],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [3, 0, 1, 2],\n    [3, 0, 2, 1],\n    [0, 0, 0, 0],\n    [3, 1, 2, 0],\n    [2, 1, 0, 3],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [3, 1, 0, 2],\n    [0, 0, 0, 0],\n    [3, 2, 0, 1],\n    [3, 2, 1, 0],\n  ]\n\n  /**\n   * You can pass in a random number generator object if you like.\n   * It is assumed to have a random() method.\n   */\n  constructor(r: NumberGenerator = Math) {\n    for (let i = 0; i < 256; i++) {\n      this.p[i] = Math.floor(r.random() * 256)\n    }\n\n    for (let i = 0; i < 512; i++) {\n      this.perm[i] = this.p[i & 255]\n    }\n  }\n\n  public dot = (g: number[], x: number, y: number): number => {\n    return g[0] * x + g[1] * y\n  }\n\n  public dot3 = (g: number[], x: number, y: number, z: number): number => {\n    return g[0] * x + g[1] * y + g[2] * z\n  }\n\n  public dot4 = (g: number[], x: number, y: number, z: number, w: number): number => {\n    return g[0] * x + g[1] * y + g[2] * z + g[3] * w\n  }\n\n  public noise = (xin: number, yin: number): number => {\n    let n0\n    let n1\n    let n2 // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    const F2 = 0.5 * (Math.sqrt(3.0) - 1.0)\n    const s = (xin + yin) * F2 // Hairy factor for 2D\n    const i = Math.floor(xin + s)\n    const j = Math.floor(yin + s)\n    const G2 = (3.0 - Math.sqrt(3.0)) / 6.0\n    const t = (i + j) * G2\n    const X0 = i - t // Unskew the cell origin back to (x,y) space\n    const Y0 = j - t\n    const x0 = xin - X0 // The x,y distances from the cell origin\n    const y0 = yin - Y0\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    let i1 = 0\n    // Offsets for second (middle) corner of simplex in (i,j) coords\n    let j1 = 1\n    if (x0 > y0) {\n      i1 = 1\n      j1 = 0\n    }\n\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    const x1 = x0 - i1 + G2 // Offsets for middle corner in (x,y) unskewed coords\n    const y1 = y0 - j1 + G2\n    const x2 = x0 - 1.0 + 2.0 * G2 // Offsets for last corner in (x,y) unskewed coords\n    const y2 = y0 - 1.0 + 2.0 * G2\n    // Work out the hashed gradient indices of the three simplex corners\n    const ii = i & 255\n    const jj = j & 255\n    const gi0 = this.perm[ii + this.perm[jj]] % 12\n    const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12\n    const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12\n    // Calculate the contribution from the three corners\n    let t0 = 0.5 - x0 * x0 - y0 * y0\n    if (t0 < 0) {\n      n0 = 0.0\n    } else {\n      t0 *= t0\n      n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0) // (x,y) of grad3 used for 2D gradient\n    }\n\n    let t1 = 0.5 - x1 * x1 - y1 * y1\n    if (t1 < 0) {\n      n1 = 0.0\n    } else {\n      t1 *= t1\n      n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1)\n    }\n\n    let t2 = 0.5 - x2 * x2 - y2 * y2\n    if (t2 < 0) {\n      n2 = 0.0\n    } else {\n      t2 *= t2\n      n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2)\n    }\n\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70.0 * (n0 + n1 + n2)\n  }\n\n  // 3D simplex noise\n  private noise3d = (xin: number, yin: number, zin: number): number => {\n    // Noise contributions from the four corners\n    let n0\n    let n1\n    let n2\n    let n3\n    // Skew the input space to determine which simplex cell we're in\n    const F3 = 1.0 / 3.0\n    const s = (xin + yin + zin) * F3 // Very nice and simple skew factor for 3D\n    const i = Math.floor(xin + s)\n    const j = Math.floor(yin + s)\n    const k = Math.floor(zin + s)\n    const G3 = 1.0 / 6.0 // Very nice and simple unskew factor, too\n    const t = (i + j + k) * G3\n    const X0 = i - t // Unskew the cell origin back to (x,y,z) space\n    const Y0 = j - t\n    const Z0 = k - t\n    const x0 = xin - X0 // The x,y,z distances from the cell origin\n    const y0 = yin - Y0\n    const z0 = zin - Z0\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    let i1\n    let j1\n    let k1 // Offsets for second corner of simplex in (i,j,k) coords\n    let i2\n    let j2\n    let k2 // Offsets for third corner of simplex in (i,j,k) coords\n    if (x0 >= y0) {\n      if (y0 >= z0) {\n        i1 = 1\n        j1 = 0\n        k1 = 0\n        i2 = 1\n        j2 = 1\n        k2 = 0\n\n        // X Y Z order\n      } else if (x0 >= z0) {\n        i1 = 1\n        j1 = 0\n        k1 = 0\n        i2 = 1\n        j2 = 0\n        k2 = 1\n\n        // X Z Y order\n      } else {\n        i1 = 0\n        j1 = 0\n        k1 = 1\n        i2 = 1\n        j2 = 0\n        k2 = 1\n      } // Z X Y order\n    } else {\n      // x0<y0\n\n      if (y0 < z0) {\n        i1 = 0\n        j1 = 0\n        k1 = 1\n        i2 = 0\n        j2 = 1\n        k2 = 1\n\n        // Z Y X order\n      } else if (x0 < z0) {\n        i1 = 0\n        j1 = 1\n        k1 = 0\n        i2 = 0\n        j2 = 1\n        k2 = 1\n\n        // Y Z X order\n      } else {\n        i1 = 0\n        j1 = 1\n        k1 = 0\n        i2 = 1\n        j2 = 1\n        k2 = 0\n      } // Y X Z order\n    }\n\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    const x1 = x0 - i1 + G3 // Offsets for second corner in (x,y,z) coords\n    const y1 = y0 - j1 + G3\n    const z1 = z0 - k1 + G3\n    const x2 = x0 - i2 + 2.0 * G3 // Offsets for third corner in (x,y,z) coords\n    const y2 = y0 - j2 + 2.0 * G3\n    const z2 = z0 - k2 + 2.0 * G3\n    const x3 = x0 - 1.0 + 3.0 * G3 // Offsets for last corner in (x,y,z) coords\n    const y3 = y0 - 1.0 + 3.0 * G3\n    const z3 = z0 - 1.0 + 3.0 * G3\n    // Work out the hashed gradient indices of the four simplex corners\n    const ii = i & 255\n    const jj = j & 255\n    const kk = k & 255\n    const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12\n    const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12\n    const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12\n    const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12\n    // Calculate the contribution from the four corners\n    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0\n    if (t0 < 0) {\n      n0 = 0.0\n    } else {\n      t0 *= t0\n      n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0)\n    }\n\n    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1\n    if (t1 < 0) {\n      n1 = 0.0\n    } else {\n      t1 *= t1\n      n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1)\n    }\n\n    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2\n    if (t2 < 0) {\n      n2 = 0.0\n    } else {\n      t2 *= t2\n      n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2)\n    }\n\n    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3\n    if (t3 < 0) {\n      n3 = 0.0\n    } else {\n      t3 *= t3\n      n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3)\n    }\n\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to stay just inside [-1,1]\n    return 32.0 * (n0 + n1 + n2 + n3)\n  }\n\n  // 4D simplex noise\n  public noise4d = (x: number, y: number, z: number, w: number): number => {\n    // For faster and easier lookups\n    const grad4 = this.grad4\n    const simplex = this.simplex\n    const perm = this.perm\n\n    // The skewing and unskewing factors are hairy again for the 4D case\n    const F4 = (Math.sqrt(5.0) - 1.0) / 4.0\n    const G4 = (5.0 - Math.sqrt(5.0)) / 20.0\n    let n0\n    let n1\n    let n2\n    let n3\n    let n4 // Noise contributions from the five corners\n    // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n    const s = (x + y + z + w) * F4 // Factor for 4D skewing\n    const i = Math.floor(x + s)\n    const j = Math.floor(y + s)\n    const k = Math.floor(z + s)\n    const l = Math.floor(w + s)\n    const t = (i + j + k + l) * G4 // Factor for 4D unskewing\n    const X0 = i - t // Unskew the cell origin back to (x,y,z,w) space\n    const Y0 = j - t\n    const Z0 = k - t\n    const W0 = l - t\n    const x0 = x - X0 // The x,y,z,w distances from the cell origin\n    const y0 = y - Y0\n    const z0 = z - Z0\n    const w0 = w - W0\n\n    // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n    // To find out which of the 24 possible simplices we're in, we need to\n    // determine the magnitude ordering of x0, y0, z0 and w0.\n    // The method below is a good way of finding the ordering of x,y,z,w and\n    // then find the correct traversal order for the simplex were in.\n    // First, six pair-wise comparisons are performed between each possible pair\n    // of the four coordinates, and the results are used to add up binary bits\n    // for an integer index.\n    const c1 = x0 > y0 ? 32 : 0\n    const c2 = x0 > z0 ? 16 : 0\n    const c3 = y0 > z0 ? 8 : 0\n    const c4 = x0 > w0 ? 4 : 0\n    const c5 = y0 > w0 ? 2 : 0\n    const c6 = z0 > w0 ? 1 : 0\n    const c = c1 + c2 + c3 + c4 + c5 + c6\n    // The integer offsets for the second simplex corner\n    let i1\n    let j1\n    let k1\n    let l1\n\n    // The integer offsets for the third simplex corner\n    let i2\n    let j2\n    let k2\n    let l2\n\n    // The integer offsets for the fourth simplex corner\n    let i3\n    let j3\n    let k3\n    let l3\n    // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n    // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n    // impossible. Only the 24 indices which have non-zero entries make any sense.\n    // We use a thresholding to set the coordinates in turn from the largest magnitude.\n    // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n    i1 = simplex[c][0] >= 3 ? 1 : 0\n    j1 = simplex[c][1] >= 3 ? 1 : 0\n    k1 = simplex[c][2] >= 3 ? 1 : 0\n    l1 = simplex[c][3] >= 3 ? 1 : 0\n    // The number 2 in the \"simplex\" array is at the second largest coordinate.\n    i2 = simplex[c][0] >= 2 ? 1 : 0\n    j2 = simplex[c][1] >= 2 ? 1 : 0\n    k2 = simplex[c][2] >= 2 ? 1 : 0\n    l2 = simplex[c][3] >= 2 ? 1 : 0\n    // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n    i3 = simplex[c][0] >= 1 ? 1 : 0\n    j3 = simplex[c][1] >= 1 ? 1 : 0\n    k3 = simplex[c][2] >= 1 ? 1 : 0\n    l3 = simplex[c][3] >= 1 ? 1 : 0\n    // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n    const x1 = x0 - i1 + G4 // Offsets for second corner in (x,y,z,w) coords\n    const y1 = y0 - j1 + G4\n    const z1 = z0 - k1 + G4\n    const w1 = w0 - l1 + G4\n    const x2 = x0 - i2 + 2.0 * G4 // Offsets for third corner in (x,y,z,w) coords\n    const y2 = y0 - j2 + 2.0 * G4\n    const z2 = z0 - k2 + 2.0 * G4\n    const w2 = w0 - l2 + 2.0 * G4\n    const x3 = x0 - i3 + 3.0 * G4 // Offsets for fourth corner in (x,y,z,w) coords\n    const y3 = y0 - j3 + 3.0 * G4\n    const z3 = z0 - k3 + 3.0 * G4\n    const w3 = w0 - l3 + 3.0 * G4\n    const x4 = x0 - 1.0 + 4.0 * G4 // Offsets for last corner in (x,y,z,w) coords\n    const y4 = y0 - 1.0 + 4.0 * G4\n    const z4 = z0 - 1.0 + 4.0 * G4\n    const w4 = w0 - 1.0 + 4.0 * G4\n    // Work out the hashed gradient indices of the five simplex corners\n    const ii = i & 255\n    const jj = j & 255\n    const kk = k & 255\n    const ll = l & 255\n    const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32\n    const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32\n    const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32\n    const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32\n    const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32\n    // Calculate the contribution from the five corners\n    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0\n    if (t0 < 0) {\n      n0 = 0.0\n    } else {\n      t0 *= t0\n      n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0)\n    }\n\n    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1\n    if (t1 < 0) {\n      n1 = 0.0\n    } else {\n      t1 *= t1\n      n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1)\n    }\n\n    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2\n    if (t2 < 0) {\n      n2 = 0.0\n    } else {\n      t2 *= t2\n      n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2)\n    }\n\n    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3\n    if (t3 < 0) {\n      n3 = 0.0\n    } else {\n      t3 *= t3\n      n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3)\n    }\n\n    let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4\n    if (t4 < 0) {\n      n4 = 0.0\n    } else {\n      t4 *= t4\n      n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4)\n    }\n\n    // Sum up and scale the result to cover the range [-1,1]\n    return 27.0 * (n0 + n1 + n2 + n3 + n4)\n  }\n}\n", "import {\n  BufferGeometry,\n  DynamicDrawUsage,\n  Float32BufferAttribute,\n  MathUtils,\n  Uint32BufferAttribute,\n  Vector3,\n} from 'three'\nimport { SimplexNoise } from '../math/SimplexNoise'\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  // Ray states\n  static RAY_INITIALIZED = 0\n  static RAY_UNBORN = 1\n  static RAY_PROPAGATING = 2\n  static RAY_STEADY = 3\n  static RAY_VANISHING = 4\n  static RAY_EXTINGUISHED = 5\n\n  static COS30DEG = Math.cos((30 * Math.PI) / 180)\n  static SIN30DEG = Math.sin((30 * Math.PI) / 180)\n\n  constructor(rayParameters = {}) {\n    super()\n\n    this.isLightningStrike = true\n\n    this.type = 'LightningStrike'\n\n    // Set parameters, and set undefined parameters to default values\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters))\n\n    // Creates and populates the mesh\n    this.createMesh()\n  }\n\n  static createRandomGenerator() {\n    const numSeeds = 2053\n    const seeds = []\n\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random())\n    }\n\n    const generator = {\n      currentSeed: 0,\n\n      random: function () {\n        const value = seeds[generator.currentSeed]\n\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds\n\n        return value\n      },\n\n      getSeed: function () {\n        return generator.currentSeed / numSeeds\n      },\n\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds\n      },\n    }\n\n    return generator\n  }\n\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v\n      } else {\n        return v.clone()\n      }\n    }\n\n    ;(dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0)),\n      (dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0)),\n      (dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1),\n      (dest.roughness = source.roughness !== undefined ? source.roughness : 0.9),\n      (dest.straightness = source.straightness !== undefined ? source.straightness : 0.7),\n      (dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1))\n    ;(dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1)),\n      (dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1),\n      (dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1),\n      (dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5),\n      (dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2),\n      (dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2),\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n\n      (dest.isEternal =\n        source.isEternal !== undefined\n          ? source.isEternal\n          : source.birthTime === undefined || source.deathTime === undefined),\n      (dest.birthTime = source.birthTime),\n      (dest.deathTime = source.deathTime),\n      (dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1),\n      (dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9),\n      (dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4),\n      (dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6)\n\n    // These parameters cannot change after lightning creation:\n\n    dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9\n    dest.isStatic = source.isStatic !== undefined ? source.isStatic : false\n    dest.ramification = source.ramification !== undefined ? source.ramification : 5\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3\n    dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6\n    dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false\n    ;(dest.randomGenerator = source.randomGenerator),\n      (dest.noiseSeed = source.noiseSeed),\n      (dest.onDecideSubrayCreation = source.onDecideSubrayCreation),\n      (dest.onSubrayCreation = source.onSubrayCreation)\n\n    return dest\n  }\n\n  update(time) {\n    if (this.isStatic) return\n\n    if (\n      this.rayParameters.isEternal ||\n      (this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime)\n    ) {\n      this.updateMesh(time)\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING\n      } else {\n        this.state = LightningStrike.RAY_STEADY\n      }\n\n      this.visible = true\n    } else {\n      this.visible = false\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED\n      }\n    }\n  }\n\n  init(rayParameters) {\n    // Init all the state from the parameters\n\n    this.rayParameters = rayParameters\n\n    // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9\n    rayParameters.maxIterations = this.maxIterations\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false\n    rayParameters.isStatic = this.isStatic\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5\n    rayParameters.ramification = this.ramification\n    this.maxSubrayRecursion =\n      rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion\n    this.recursionProbability =\n      rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6\n    rayParameters.recursionProbability = this.recursionProbability\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false\n    rayParameters.generateUVs = this.generateUVs\n\n    // Random generator\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator\n      this.seedGenerator = rayParameters.randomGenerator\n\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed)\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator()\n      this.seedGenerator = Math\n    }\n\n    // Ray creation callbacks\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation\n    } else {\n      this.createDefaultSubrayCreationCallbacks()\n\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation\n      }\n    }\n\n    // Internal state\n\n    this.state = LightningStrike.RAY_INITIALIZED\n\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)))\n    rayParameters.maxSubrays = this.maxSubrays\n\n    this.maxRaySegments = 2 * (1 << this.maxIterations)\n\n    this.subrays = []\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray())\n    }\n\n    this.raySegments = []\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment())\n    }\n\n    this.time = 0\n    this.timeFraction = 0\n    this.currentSegmentCallback = null\n    this.currentCreateTriangleVertices = this.generateUVs\n      ? this.createTriangleVerticesWithUVs\n      : this.createTriangleVerticesWithoutUVs\n    this.numSubrays = 0\n    this.currentSubray = null\n    this.currentSegmentIndex = 0\n    this.isInitialSegment = false\n    this.subrayProbability = 0\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n    this.vertices = null\n    this.uvs = null\n    this.indices = null\n    this.positionAttribute = null\n    this.uvsAttribute = null\n\n    this.simplexX = new SimplexNoise(this.seedGenerator)\n    this.simplexY = new SimplexNoise(this.seedGenerator)\n    this.simplexZ = new SimplexNoise(this.seedGenerator)\n\n    // Temp vectors\n    this.forwards = new Vector3()\n    this.forwardsFill = new Vector3()\n    this.side = new Vector3()\n    this.down = new Vector3()\n    this.middlePos = new Vector3()\n    this.middleLinPos = new Vector3()\n    this.newPos = new Vector3()\n    this.vPos = new Vector3()\n    this.cross1 = new Vector3()\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations\n\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays\n\n    this.vertices = new Float32Array(maxVerts * 3)\n    this.indices = new Uint32Array(maxIndices)\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2)\n    }\n\n    // Populate the mesh\n    this.fillMesh(0)\n\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1))\n\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3)\n    this.setAttribute('position', this.positionAttribute)\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2)\n      this.setAttribute('uv', this.uvsAttribute)\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage\n      this.positionAttribute.usage = DynamicDrawUsage\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage\n      }\n    }\n\n    // Store buffers for later modification\n    this.vertices = this.positionAttribute.array\n    this.indices = this.index.array\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time)\n\n    this.drawRange.count = this.currentIndex\n\n    this.index.needsUpdate = true\n\n    this.positionAttribute.needsUpdate = true\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray\n\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n\n        return\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n\n          scope.createPrism(segment)\n\n          scope.onDecideSubrayCreation(segment, scope)\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n\n          scope.createPrism(segment)\n        }\n\n        scope.onDecideSubrayCreation(segment, scope)\n      }\n    })\n  }\n\n  addNewSubray(/*rayParameters*/) {\n    return this.subrays[this.numSubrays++]\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset)\n    subray.pos1.copy(rayParameters.destOffset)\n    subray.up0.copy(rayParameters.up0)\n    subray.up1.copy(rayParameters.up1)\n    subray.radius0 = rayParameters.radius0\n    subray.radius1 = rayParameters.radius1\n    subray.birthTime = rayParameters.birthTime\n    subray.deathTime = rayParameters.deathTime\n    subray.timeScale = rayParameters.timeScale\n    subray.roughness = rayParameters.roughness\n    subray.straightness = rayParameters.straightness\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor\n\n    subray.maxIterations = this.maxIterations\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0\n    subray.recursion = 0\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time\n    this.currentSegmentCallback = segmentCallback\n    this.numSubrays = 0\n\n    // Add the top level subray\n    this.initSubray(this.addNewSubray(), this.rayParameters)\n\n    // Process all subrays that are being generated until consuming all of them\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex]\n      this.currentSubray = subray\n\n      this.randomGenerator.setSeed(subray.seed)\n\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor)\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor)\n\n      const random1 = this.randomGenerator.random\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime)\n\n      this.currentSegmentIndex = 0\n      this.isInitialSegment = true\n\n      const segment = this.getNewSegment()\n      segment.iteration = 0\n      segment.pos0.copy(subray.pos0)\n      segment.pos1.copy(subray.pos1)\n      segment.linPos0.copy(subray.linPos0)\n      segment.linPos1.copy(subray.linPos1)\n      segment.up0.copy(subray.up0)\n      segment.up1.copy(subray.up1)\n      segment.radius0 = subray.radius0\n      segment.radius1 = subray.radius1\n      segment.fraction0 = 0\n      segment.fraction1 = 1\n      segment.positionVariationFactor = 1 - subray.straightness\n\n      this.subrayProbability =\n        (this.ramification * Math.pow(this.recursionProbability, subray.recursion)) / (1 << subray.maxIterations)\n\n      this.fractalRayRecursive(segment)\n    }\n\n    this.currentSegmentCallback = null\n    this.currentSubray = null\n  }\n\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment)\n\n      return\n    }\n\n    // Interpolation\n    this.forwards.subVectors(segment.pos1, segment.pos0)\n    let lForwards = this.forwards.length()\n\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01)\n      lForwards = this.forwards.length()\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5\n\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration)\n\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5)\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5)\n    const p = this.middleLinPos\n\n    // Noise\n    this.newPos.set(\n      this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension),\n    )\n\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards)\n    this.newPos.add(this.middlePos)\n\n    // Recursion\n\n    const newSegment1 = this.getNewSegment()\n    newSegment1.pos0.copy(segment.pos0)\n    newSegment1.pos1.copy(this.newPos)\n    newSegment1.linPos0.copy(segment.linPos0)\n    newSegment1.linPos1.copy(this.middleLinPos)\n    newSegment1.up0.copy(segment.up0)\n    newSegment1.up1.copy(segment.up1)\n    newSegment1.radius0 = segment.radius0\n    newSegment1.radius1 = middleRadius\n    newSegment1.fraction0 = segment.fraction0\n    newSegment1.fraction1 = middleFraction\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment1.iteration = segment.iteration + 1\n\n    const newSegment2 = this.getNewSegment()\n    newSegment2.pos0.copy(this.newPos)\n    newSegment2.pos1.copy(segment.pos1)\n    newSegment2.linPos0.copy(this.middleLinPos)\n    newSegment2.linPos1.copy(segment.linPos1)\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize())\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize()\n    newSegment2.up1.copy(segment.up1)\n    newSegment2.radius0 = middleRadius\n    newSegment2.radius1 = segment.radius1\n    newSegment2.fraction0 = middleFraction\n    newSegment2.fraction1 = segment.fraction1\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment2.iteration = segment.iteration + 1\n\n    this.fractalRayRecursive(newSegment1)\n\n    this.fractalRayRecursive(newSegment2)\n  }\n\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize()\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0)\n\n      this.isInitialSegment = false\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1)\n\n    this.createPrismFaces()\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    this.currentVertex += 3\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n    const uv = this.uvs\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0.5\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 1\n\n    this.currentVertex += 3\n  }\n\n  createPrismFaces(vertex /*, index*/) {\n    const indices = this.indices\n    vertex = this.currentVertex - 6\n\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 5\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random\n\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      // Decide subrays creation at parent (sub)ray segment\n\n      const subray = lightningStrike.currentSubray\n\n      const period = lightningStrike.rayParameters.subrayPeriod\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle\n\n      const phase0 =\n        lightningStrike.rayParameters.isEternal && subray.recursion == 0\n          ? -random1() * period\n          : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period\n\n      const phase = lightningStrike.time - phase0\n      const currentCycle = Math.floor(phase / period)\n\n      const childSubraySeed = random1() * (currentCycle + 1)\n\n      const isActive = phase % period <= dutyCycle * period\n\n      let probability = 0\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability\n        // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (\n        subray.recursion < lightningStrike.maxSubrayRecursion &&\n        lightningStrike.numSubrays < lightningStrike.maxSubrays &&\n        random1() < probability\n      ) {\n        const childSubray = lightningStrike.addNewSubray()\n\n        const parentSeed = lightningStrike.randomGenerator.getSeed()\n        childSubray.seed = childSubraySeed\n        lightningStrike.randomGenerator.setSeed(childSubraySeed)\n\n        childSubray.recursion = subray.recursion + 1\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1)\n\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.up0.copy(subray.up0)\n        childSubray.up1.copy(subray.up1)\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor\n        childSubray.radius1 = Math.min(\n          lightningStrike.rayParameters.minRadius,\n          segment.radius1 * lightningStrike.rayParameters.radius1Factor,\n        )\n\n        childSubray.birthTime = phase0 + currentCycle * period\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime)\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime)\n        }\n\n        childSubray.timeScale = subray.timeScale * 2\n        childSubray.roughness = subray.roughness\n        childSubray.straightness = subray.straightness\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor\n\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike)\n\n        lightningStrike.randomGenerator.setSeed(parentSeed)\n      }\n    }\n\n    const vec1Pos = new Vector3()\n    const vec2Forward = new Vector3()\n    const vec3Side = new Vector3()\n    const vec4Up = new Vector3()\n\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2)\n    }\n\n    this.subrayConePosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cone\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n\n    this.subrayCylinderPosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cylinder\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0,\n    }\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0,\n    }\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++]\n  }\n\n  copy(source) {\n    super.copy(source)\n\n    this.init(LightningStrike.copyParameters({}, source.rayParameters))\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters))\n  }\n}\n\nexport { LightningStrike }\n", "import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderTarget,\n  DepthTexture,\n  UnsignedShortType,\n  NearestFilter,\n  Plane,\n  HalfFloatType,\n} from 'three'\n\nclass ReflectorForSSRPass extends Mesh {\n  static ReflectorShader = {\n    defines: {\n      DISTANCE_ATTENUATION: true,\n      FRESNEL: true,\n    },\n\n    uniforms: {\n      color: { value: null },\n      tDiffuse: { value: null },\n      tDepth: { value: null },\n      textureMatrix: { value: new Matrix4() },\n      maxDistance: { value: 180 },\n      opacity: { value: 0.5 },\n      fresnelCoe: { value: null },\n      virtualCameraNear: { value: null },\n      virtualCameraFar: { value: null },\n      virtualCameraProjectionMatrix: { value: new Matrix4() },\n      virtualCameraMatrixWorld: { value: new Matrix4() },\n      virtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n      resolution: { value: new Vector2() },\n    },\n\n    vertexShader: /* glsl */ `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isReflectorForSSRPass = true\n\n    this.type = 'ReflectorForSSRPass'\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader\n    const useDepthTexture = options.useDepthTexture === true\n    const yAxis = new Vector3(0, 1, 0)\n    const vecTemp0 = new Vector3()\n    const vecTemp1 = new Vector3()\n\n    //\n\n    scope.needsUpdate = false\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value\n    scope.color = color\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight)\n\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return\n        scope._distanceAttenuation = val\n        scope.material.defines.DISTANCE_ATTENUATION = val\n        scope.material.needsUpdate = true\n      },\n    })\n\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel\n      },\n      set(val) {\n        if (scope._fresnel === val) return\n        scope._fresnel = val\n        scope.material.defines.FRESNEL = val\n        scope.material.needsUpdate = true\n      },\n    })\n\n    const normal = new Vector3()\n    const reflectorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n\n    const view = new Vector3()\n    const target = new Vector3()\n\n    const textureMatrix = new Matrix4()\n    const virtualCamera = new PerspectiveCamera()\n\n    let depthTexture\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture()\n      depthTexture.type = UnsignedShortType\n      depthTexture.minFilter = NearestFilter\n      depthTexture.magFilter = NearestFilter\n    }\n\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType,\n    }\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters)\n\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture,\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader,\n    })\n\n    material.uniforms['tDiffuse'].value = renderTarget.texture\n    material.uniforms['color'].value = scope.color\n    material.uniforms['textureMatrix'].value = textureMatrix\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture\n    }\n\n    this.material = material\n\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias)\n    const globalPlanes = [globalPlane]\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance\n      material.uniforms['color'].value = scope.color\n      material.uniforms['opacity'].value = scope.opacity\n\n      vecTemp0.copy(camera.position).normalize()\n      vecTemp1.copy(vecTemp0).reflect(yAxis)\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2 // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(reflectorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(reflectorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(reflectorWorldPosition)\n\n      virtualCamera.position.copy(view)\n      virtualCamera.up.set(0, 1, 0)\n      virtualCamera.up.applyMatrix4(rotationMatrix)\n      virtualCamera.up.reflect(normal)\n      virtualCamera.lookAt(target)\n\n      virtualCamera.far = camera.far // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld()\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      material.uniforms['virtualCameraNear'].value = camera.near\n      material.uniforms['virtualCameraFar'].value = camera.far\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse\n      material.uniforms['resolution'].value = scope.resolution\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(virtualCamera.projectionMatrix)\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n\n      // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentClippingPlanes = renderer.clippingPlanes\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      renderer.clippingPlanes = globalPlanes\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.clippingPlanes = currentClippingPlanes\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      // scope.visible = true;\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n  }\n}\n\nexport { ReflectorForSSRPass }\n", "import { BackSide, BoxGeometry, Mesh, ShaderMaterial, UniformsUtils, Vector3 } from 'three'\nimport { version } from '../_polyfill/constants'\n\nconst SkyShader = {\n  uniforms: {\n    turbidity: { value: 2 },\n    rayleigh: { value: 1 },\n    mieCoefficient: { value: 0.005 },\n    mieDirectionalG: { value: 0.8 },\n    sunPosition: { value: new Vector3() },\n    up: { value: new Vector3(0, 1, 0) },\n  },\n\n  vertexShader: /* glsl */ `\n      uniform vec3 sunPosition;\n      uniform float rayleigh;\n      uniform float turbidity;\n      uniform float mieCoefficient;\n      uniform vec3 up;\n\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      // constants for atmospheric scattering\n      const float e = 2.71828182845904523536028747135266249775724709369995957;\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      // wavelength of used primaries, according to preetham\n      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n      // mie stuff\n      // K coefficient for the primaries\n      const float v = 4.0;\n      const vec3 K = vec3( 0.686, 0.678, 0.666 );\n      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n      // earth shadow hack\n      // cutoffAngle = pi / 1.95;\n      const float cutoffAngle = 1.6110731556870734;\n      const float steepness = 1.5;\n      const float EE = 1000.0;\n\n      float sunIntensity( float zenithAngleCos ) {\n        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n      }\n\n      vec3 totalMie( float T ) {\n        float c = ( 0.2 * T ) * 10E-18;\n        return 0.434 * c * MieConst;\n      }\n\n      void main() {\n\n        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        gl_Position.z = gl_Position.w; // set z to camera.far\n\n        vSunDirection = normalize( sunPosition );\n\n        vSunE = sunIntensity( dot( vSunDirection, up ) );\n\n        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n      // extinction (absorbtion + out scattering)\n      // rayleigh coefficients\n        vBetaR = totalRayleigh * rayleighCoefficient;\n\n      // mie coefficients\n        vBetaM = totalMie( turbidity ) * mieCoefficient;\n\n      }\n    `,\n\n  fragmentShader: /* glsl */ `\n      varying vec3 vWorldPosition;\n      varying vec3 vSunDirection;\n      varying float vSunfade;\n      varying vec3 vBetaR;\n      varying vec3 vBetaM;\n      varying float vSunE;\n\n      uniform float mieDirectionalG;\n      uniform vec3 up;\n\n      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n      // constants for atmospheric scattering\n      const float pi = 3.141592653589793238462643383279502884197169;\n\n      const float n = 1.0003; // refractive index of air\n      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n      // optical length at zenith for molecules\n      const float rayleighZenithLength = 8.4E3;\n      const float mieZenithLength = 1.25E3;\n      // 66 arc seconds -> degrees, and the cosine of that\n      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n      // 3.0 / ( 16.0 * pi )\n      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n      // 1.0 / ( 4.0 * pi )\n      const float ONE_OVER_FOURPI = 0.07957747154594767;\n\n      float rayleighPhase( float cosTheta ) {\n        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n      }\n\n      float hgPhase( float cosTheta, float g ) {\n        float g2 = pow( g, 2.0 );\n        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n      }\n\n      void main() {\n\n        vec3 direction = normalize( vWorldPosition - cameraPos );\n\n      // optical length\n      // cutoff angle at 90 to avoid singularity in next formula.\n        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n        float sR = rayleighZenithLength * inverse;\n        float sM = mieZenithLength * inverse;\n\n      // combined extinction factor\n        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n      // in scattering\n        float cosTheta = dot( direction, vSunDirection );\n\n        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n        vec3 betaRTheta = vBetaR * rPhase;\n\n        float mPhase = hgPhase( cosTheta, mieDirectionalG );\n        vec3 betaMTheta = vBetaM * mPhase;\n\n        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n      // nightsky\n        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n        vec3 L0 = vec3( 0.1 ) * Fex;\n\n      // composition + solar disc\n        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n        gl_FragColor = vec4( retColor, 1.0 );\n\n      #include <tonemapping_fragment>\n      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n      }\n    `,\n}\n\nconst material = new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: SkyShader.fragmentShader,\n  vertexShader: SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false,\n})\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\nclass Sky extends Mesh {\n  constructor() {\n    super(new BoxGeometry(1, 1, 1), material)\n  }\n\n  static SkyShader = SkyShader\n  public static material = material\n}\n\nexport { Sky }\n", "import {\n  Clock,\n  Color,\n  Matrix4,\n  Mesh,\n  RepeatWrapping,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2,\n  Vector4,\n} from 'three'\nimport { Reflector } from './Reflector'\nimport { Refractor } from './Refractor'\nimport { version } from '../_polyfill/constants'\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nclass Water2 extends Mesh {\n  static WaterShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      reflectivity: {\n        value: 0,\n      },\n\n      tReflectionMap: {\n        value: null,\n      },\n\n      tRefractionMap: {\n        value: null,\n      },\n\n      tNormalMap0: {\n        value: null,\n      },\n\n      tNormalMap1: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n\n      config: {\n        value: new Vector4(),\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t#include <fog_fragment>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isWater = true\n\n    this.type = 'Water'\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const flowDirection = options.flowDirection || new Vector2(1, 0)\n    const flowSpeed = options.flowSpeed || 0.03\n    const reflectivity = options.reflectivity || 0.02\n    const scale = options.scale || 1\n    const shader = options.shader || Water2.WaterShader\n    const encoding = options.encoding !== undefined ? options.encoding : 3000\n\n    const flowMap = options.flowMap || undefined\n    const normalMap0 = options.normalMap0\n    const normalMap1 = options.normalMap1\n\n    const cycle = 0.15 // a cycle of a flow map phase\n    const halfCycle = cycle * 0.5\n    const textureMatrix = new Matrix4()\n    const clock = new Clock()\n\n    // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.')\n      return\n    }\n\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.')\n      return\n    }\n\n    const reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding,\n    })\n\n    const refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding,\n    })\n\n    reflector.matrixAutoUpdate = false\n    refractor.matrixAutoUpdate = false\n\n    // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true,\n    })\n\n    if (flowMap !== undefined) {\n      this.material.defines.USE_FLOWMAP = ''\n      this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap,\n      }\n    } else {\n      this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection,\n      }\n    }\n\n    // maps\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping\n\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture\n    this.material.uniforms['tNormalMap0'].value = normalMap0\n    this.material.uniforms['tNormalMap1'].value = normalMap1\n\n    // water\n\n    this.material.uniforms['color'].value = color\n    this.material.uniforms['reflectivity'].value = reflectivity\n    this.material.uniforms['textureMatrix'].value = textureMatrix\n\n    // inital values\n\n    this.material.uniforms['config'].value.x = 0 // flowMapOffset0\n    this.material.uniforms['config'].value.y = halfCycle // flowMapOffset1\n    this.material.uniforms['config'].value.z = halfCycle // halfCycle\n    this.material.uniforms['config'].value.w = scale // scale\n\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n\n      textureMatrix.multiply(camera.projectionMatrix)\n      textureMatrix.multiply(camera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n    }\n\n    function updateFlow() {\n      const delta = clock.getDelta()\n      const config = scope.material.uniforms['config']\n\n      config.value.x += flowSpeed * delta // flowMapOffset0\n      config.value.y = config.value.x + halfCycle // flowMapOffset1\n\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0\n        config.value.y = halfCycle\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle\n      }\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera)\n      updateFlow()\n\n      scope.visible = false\n\n      reflector.matrixWorld.copy(scope.matrixWorld)\n      refractor.matrixWorld.copy(scope.matrixWorld)\n\n      reflector.onBeforeRender(renderer, scene, camera)\n      refractor.onBeforeRender(renderer, scene, camera)\n\n      scope.visible = true\n    }\n  }\n}\n\nexport { Water2 }\n", "/**\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\n\nimport {\n  MathUtils,\n  Mesh,\n  NoBlending,\n  OrthographicCamera,\n  PlaneGeometry,\n  RawShaderMaterial,\n  Vector2,\n  WebGLRenderTarget,\n} from 'three'\n\nvar _mipmapMaterial = _getMipmapMaterial()\n\nvar _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial)\n\nvar _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1)\n\nvar _tempTarget = null\n\nclass RoughnessMipmapper {\n  constructor(renderer) {\n    this._renderer = renderer\n\n    this._renderer.compile(_mesh, _flatCamera)\n  }\n\n  generateMipmaps = function (material) {\n    if ('roughnessMap' in material === false) return\n\n    var { roughnessMap, normalMap } = material\n\n    if (\n      roughnessMap === null ||\n      normalMap === null ||\n      !roughnessMap.generateMipmaps ||\n      material.userData.roughnessUpdated\n    ) {\n      return\n    }\n\n    material.userData.roughnessUpdated = true\n\n    var width = Math.max(roughnessMap.image.width, normalMap.image.width)\n\n    var height = Math.max(roughnessMap.image.height, normalMap.image.height)\n\n    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) return\n\n    var oldTarget = this._renderer.getRenderTarget()\n\n    var autoClear = this._renderer.autoClear\n\n    this._renderer.autoClear = false\n\n    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {\n      if (_tempTarget !== null) _tempTarget.dispose()\n\n      _tempTarget = new WebGLRenderTarget(width, height, {\n        depthBuffer: false,\n      })\n\n      _tempTarget.scissorTest = true\n    }\n\n    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n      var params = {\n        wrapS: roughnessMap.wrapS,\n        wrapT: roughnessMap.wrapT,\n        magFilter: roughnessMap.magFilter,\n        minFilter: roughnessMap.minFilter,\n        depthBuffer: false,\n      }\n\n      var newRoughnessTarget = new WebGLRenderTarget(width, height, params)\n\n      newRoughnessTarget.texture.generateMipmaps = true\n\n      // Setting the render target causes the memory to be allocated.\n\n      this._renderer.setRenderTarget(newRoughnessTarget)\n\n      material.roughnessMap = newRoughnessTarget.texture\n\n      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap\n\n      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap\n    }\n\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap\n\n    _mipmapMaterial.uniforms.normalMap.value = normalMap\n\n    var position = new Vector2(0, 0)\n\n    var texelSize = _mipmapMaterial.uniforms.texelSize.value\n\n    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\n      // up a secondary texture to write the result to, then copy it back to the\n      // proper mipmap level.\n\n      texelSize.set(1.0 / width, 1.0 / height)\n\n      if (mip == 0) texelSize.set(0.0, 0.0)\n\n      _tempTarget.viewport.set(position.x, position.y, width, height)\n\n      _tempTarget.scissor.set(position.x, position.y, width, height)\n\n      this._renderer.setRenderTarget(_tempTarget)\n\n      this._renderer.render(_mesh, _flatCamera)\n\n      this._renderer.copyFramebufferToTexture(position, material.roughnessMap, mip)\n\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap\n    }\n\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose()\n\n    this._renderer.setRenderTarget(oldTarget)\n\n    this._renderer.autoClear = autoClear\n  }\n\n  dispose = function () {\n    _mipmapMaterial.dispose()\n\n    _mesh.geometry.dispose()\n\n    if (_tempTarget != null) _tempTarget.dispose()\n  }\n}\n\nfunction _getMipmapMaterial() {\n  var shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      roughnessMap: { value: null },\n      normalMap: { value: null },\n      texelSize: { value: new Vector2(1, 1) },\n    },\n\n    vertexShader: /* glsl */ `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n    fragmentShader: /* glsl */ `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t`,\n\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false,\n  })\n\n  shaderMaterial.type = 'RoughnessMipmapper'\n\n  return shaderMaterial\n}\n\nexport { RoughnessMipmapper }\n", "/**\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nexport const UnpackDepthRGBAShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float opacity;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    '#include <packing>',\n\n    'void main() {',\n\n    '\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );',\n    '\tgl_FragColor = vec4( vec3( depth ), opacity );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { IUniform, Texture, Vector2 } from 'three'\n\nexport interface BokehShader2Uniforms {\n  textureWidth: IUniform<number>\n  textureHeight: IUniform<number>\n\n  focalDepth: IUniform<number>\n  focalLength: IUniform<number>\n  fstop: IUniform<number>\n\n  tColor: IUniform<Texture | null>\n  tDepth: IUniform<Texture | null>\n\n  maxblur: IUniform<number>\n\n  showFocus: IUniform<number>\n  manualdof: IUniform<number>\n  vignetting: IUniform<number>\n  depthblur: IUniform<number>\n\n  threshold: IUniform<number>\n  gain: IUniform<number>\n  bias: IUniform<number>\n  fringe: IUniform<number>\n\n  znear: IUniform<number>\n  zfar: IUniform<number>\n\n  noise: IUniform<number>\n  dithering: IUniform<number>\n  pentagon: IUniform<number>\n\n  shaderFocus: IUniform<number>\n  focusCoords: IUniform<Vector2>\n}\n\n/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nexport const BokehShader2: {\n  uniforms: BokehShader2Uniforms\n  vertexShader: string\n  fragmentShader: string\n} = {\n  uniforms: {\n    textureWidth: { value: 1.0 },\n    textureHeight: { value: 1.0 },\n\n    focalDepth: { value: 1.0 },\n    focalLength: { value: 24.0 },\n    fstop: { value: 0.9 },\n\n    tColor: { value: null },\n    tDepth: { value: null },\n\n    maxblur: { value: 1.0 },\n\n    showFocus: { value: 0 },\n    manualdof: { value: 0 },\n    vignetting: { value: 0 },\n    depthblur: { value: 0 },\n\n    threshold: { value: 0.5 },\n    gain: { value: 2.0 },\n    bias: { value: 0.5 },\n    fringe: { value: 0.7 },\n\n    znear: { value: 0.1 },\n    zfar: { value: 100 },\n\n    noise: { value: 1 },\n    dithering: { value: 0.0001 },\n    pentagon: { value: 0 },\n\n    shaderFocus: { value: 1 },\n    focusCoords: { value: new Vector2() },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#include <common>',\n\n    'varying vec2 vUv;',\n\n    'uniform sampler2D tColor;',\n    'uniform sampler2D tDepth;',\n    'uniform float textureWidth;',\n    'uniform float textureHeight;',\n\n    'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below',\n    'uniform float focalLength; //focal length in mm',\n    'uniform float fstop; //f-stop value',\n    'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)',\n\n    '/*',\n    'make sure that these two values are the same for your camera, otherwise distances will be wrong.',\n    '*/',\n\n    'uniform float znear; // camera clipping start',\n    'uniform float zfar; // camera clipping end',\n\n    '//------------------------------------------',\n    '//user variables',\n\n    'const int samples = SAMPLES; //samples on the first ring',\n    'const int rings = RINGS; //ring count',\n\n    'const int maxringsamples = rings * samples;',\n\n    'uniform bool manualdof; // manual dof calculation',\n    'float ndofstart = 1.0; // near dof blur start',\n    'float ndofdist = 2.0; // near dof blur falloff distance',\n    'float fdofstart = 1.0; // far dof blur start',\n    'float fdofdist = 3.0; // far dof blur falloff distance',\n\n    'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)',\n\n    'uniform bool vignetting; // use optical lens vignetting',\n\n    'float vignout = 1.3; // vignetting outer border',\n    'float vignin = 0.0; // vignetting inner border',\n    'float vignfade = 22.0; // f-stops till vignete fades',\n\n    'uniform bool shaderFocus;',\n    '// disable if you use external focalDepth value',\n\n    'uniform vec2 focusCoords;',\n    '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)',\n    '// if center of screen use vec2(0.5, 0.5);',\n\n    'uniform float maxblur;',\n    '//clamp value of max blur (0.0 = no blur, 1.0 default)',\n\n    'uniform float threshold; // highlight threshold;',\n    'uniform float gain; // highlight gain;',\n\n    'uniform float bias; // bokeh edge bias',\n    'uniform float fringe; // bokeh chromatic aberration / fringing',\n\n    'uniform bool noise; //use noise instead of pattern for sample dithering',\n\n    'uniform float dithering;',\n\n    'uniform bool depthblur; // blur the depth buffer',\n    'float dbsize = 1.25; // depth blur size',\n\n    '/*',\n    'next part is experimental',\n    'not looking good with small sample and ring count',\n    'looks okay starting from samples = 4, rings = 4',\n    '*/',\n\n    'uniform bool pentagon; //use pentagon as bokeh shape?',\n    'float feather = 0.4; //pentagon shape feather',\n\n    '//------------------------------------------',\n\n    'float penta(vec2 coords) {',\n    '\t//pentagonal shape',\n    '\tfloat scale = float(rings) - 1.3;',\n    '\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);',\n    '\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);',\n    '\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);',\n    '\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);',\n    '\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);',\n    '\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);',\n\n    '\tvec4  one = vec4( 1.0 );',\n\n    '\tvec4 P = vec4((coords),vec2(scale, scale));',\n\n    '\tvec4 dist = vec4(0.0);',\n    '\tfloat inorout = -4.0;',\n\n    '\tdist.x = dot( P, HS0 );',\n    '\tdist.y = dot( P, HS1 );',\n    '\tdist.z = dot( P, HS2 );',\n    '\tdist.w = dot( P, HS3 );',\n\n    '\tdist = smoothstep( -feather, feather, dist );',\n\n    '\tinorout += dot( dist, one );',\n\n    '\tdist.x = dot( P, HS4 );',\n    '\tdist.y = HS5.w - abs( P.z );',\n\n    '\tdist = smoothstep( -feather, feather, dist );',\n    '\tinorout += dist.x;',\n\n    '\treturn clamp( inorout, 0.0, 1.0 );',\n    '}',\n\n    'float bdepth(vec2 coords) {',\n    '\t// Depth buffer blur',\n    '\tfloat d = 0.0;',\n    '\tfloat kernel[9];',\n    '\tvec2 offset[9];',\n\n    '\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;',\n\n    '\toffset[0] = vec2(-wh.x,-wh.y);',\n    '\toffset[1] = vec2( 0.0, -wh.y);',\n    '\toffset[2] = vec2( wh.x -wh.y);',\n\n    '\toffset[3] = vec2(-wh.x,  0.0);',\n    '\toffset[4] = vec2( 0.0,   0.0);',\n    '\toffset[5] = vec2( wh.x,  0.0);',\n\n    '\toffset[6] = vec2(-wh.x, wh.y);',\n    '\toffset[7] = vec2( 0.0,  wh.y);',\n    '\toffset[8] = vec2( wh.x, wh.y);',\n\n    '\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;',\n    '\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;',\n    '\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;',\n\n    '\tfor( int i=0; i<9; i++ ) {',\n    '\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;',\n    '\t\td += tmp * kernel[i];',\n    '\t}',\n\n    '\treturn d;',\n    '}',\n\n    'vec3 color(vec2 coords,float blur) {',\n    '\t//processing the sample',\n\n    '\tvec3 col = vec3(0.0);',\n    '\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);',\n\n    '\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;',\n    '\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;',\n    '\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;',\n\n    '\tvec3 lumcoeff = vec3(0.299,0.587,0.114);',\n    '\tfloat lum = dot(col.rgb, lumcoeff);',\n    '\tfloat thresh = max((lum-threshold)*gain, 0.0);',\n    '\treturn col+mix(vec3(0.0),col,thresh*blur);',\n    '}',\n\n    'vec3 debugFocus(vec3 col, float blur, float depth) {',\n    '\tfloat edge = 0.002*depth; //distance based edge smoothing',\n    '\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);',\n    '\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);',\n\n    '\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);',\n    '\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);',\n\n    '\treturn col;',\n    '}',\n\n    'float linearize(float depth) {',\n    '\treturn -zfar * znear / (depth * (zfar - znear) - zfar);',\n    '}',\n\n    'float vignette() {',\n    '\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));',\n    '\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);',\n    '\treturn clamp(dist,0.0,1.0);',\n    '}',\n\n    'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {',\n    '\tfloat rings2 = float(rings);',\n    '\tfloat step = PI*2.0 / float(ringsamples);',\n    '\tfloat pw = cos(j*step)*i;',\n    '\tfloat ph = sin(j*step)*i;',\n    '\tfloat p = 1.0;',\n    '\tif (pentagon) {',\n    '\t\tp = penta(vec2(pw,ph));',\n    '\t}',\n    '\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;',\n    '\treturn 1.0 * mix(1.0, i /rings2, bias) * p;',\n    '}',\n\n    'void main() {',\n    '\t//scene depth calculation',\n\n    '\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);',\n\n    '\t// Blur depth?',\n    '\tif ( depthblur ) {',\n    '\t\tdepth = linearize(bdepth(vUv.xy));',\n    '\t}',\n\n    '\t//focal plane calculation',\n\n    '\tfloat fDepth = focalDepth;',\n\n    '\tif (shaderFocus) {',\n\n    '\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);',\n\n    '\t}',\n\n    '\t// dof blur factor calculation',\n\n    '\tfloat blur = 0.0;',\n\n    '\tif (manualdof) {',\n    '\t\tfloat a = depth-fDepth; // Focal plane',\n    '\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF',\n    '\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof',\n    '\t\tblur = (a>0.0) ? b : c;',\n    '\t} else {',\n    '\t\tfloat f = focalLength; // focal length in mm',\n    '\t\tfloat d = fDepth*1000.0; // focal plane in mm',\n    '\t\tfloat o = depth*1000.0; // depth in mm',\n\n    '\t\tfloat a = (o*f)/(o-f);',\n    '\t\tfloat b = (d*f)/(d-f);',\n    '\t\tfloat c = (d-f)/(d*fstop*CoC);',\n\n    '\t\tblur = abs(a-b)*c;',\n    '\t}',\n\n    '\tblur = clamp(blur,0.0,1.0);',\n\n    '\t// calculation of pattern for dithering',\n\n    '\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;',\n\n    '\t// getting blur x and y step factor',\n\n    '\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;',\n    '\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;',\n\n    '\t// calculation of final color',\n\n    '\tvec3 col = vec3(0.0);',\n\n    '\tif(blur < 0.05) {',\n    '\t\t//some optimization thingy',\n    '\t\tcol = texture2D(tColor, vUv.xy).rgb;',\n    '\t} else {',\n    '\t\tcol = texture2D(tColor, vUv.xy).rgb;',\n    '\t\tfloat s = 1.0;',\n    '\t\tint ringsamples;',\n\n    '\t\tfor (int i = 1; i <= rings; i++) {',\n    '\t\t\t/*unboxstart*/',\n    '\t\t\tringsamples = i * samples;',\n\n    '\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {',\n    '\t\t\t\tif (j >= ringsamples) break;',\n    '\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);',\n    '\t\t\t}',\n    '\t\t\t/*unboxend*/',\n    '\t\t}',\n\n    '\t\tcol /= s; //divide by sample count',\n    '\t}',\n\n    '\tif (showFocus) {',\n    '\t\tcol = debugFocus(col, blur, depth);',\n    '\t}',\n\n    '\tif (vignetting) {',\n    '\t\tcol *= vignette();',\n    '\t}',\n\n    '\tgl_FragColor.rgb = col;',\n    '\tgl_FragColor.a = 1.0;',\n    '} ',\n  ].join('\\n'),\n}\n\nexport const BokehDepthShader = {\n  uniforms: {\n    mNear: { value: 1.0 },\n    mFar: { value: 1000.0 },\n  },\n\n  vertexShader: [\n    'varying float vViewZDepth;',\n\n    'void main() {',\n\n    '\t#include <begin_vertex>',\n    '\t#include <project_vertex>',\n\n    '\tvViewZDepth = - mvPosition.z;',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float mNear;',\n    'uniform float mFar;',\n\n    'varying float vViewZDepth;',\n\n    'void main() {',\n\n    '\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );',\n    '\tgl_FragColor = vec4( vec3( color ), 1.0 );',\n\n    '} ',\n  ].join('\\n'),\n}\n", "import { Triangle, Vector3 } from 'three'\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nconst _face = new Triangle()\nconst _color = new Vector3()\n\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.')\n\n      geometry = geometry.toNonIndexed()\n    }\n\n    this.geometry = geometry\n    this.randomFunction = Math.random\n\n    this.positionAttribute = this.geometry.getAttribute('position')\n    this.colorAttribute = this.geometry.getAttribute('color')\n    this.weightAttribute = null\n\n    this.distribution = null\n  }\n\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null\n\n    return this\n  }\n\n  build() {\n    const positionAttribute = this.positionAttribute\n    const weightAttribute = this.weightAttribute\n\n    const faceWeights = new Float32Array(positionAttribute.count / 3)\n\n    // Accumulate weights for each mesh face.\n\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1\n\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2)\n      }\n\n      _face.a.fromBufferAttribute(positionAttribute, i)\n      _face.b.fromBufferAttribute(positionAttribute, i + 1)\n      _face.c.fromBufferAttribute(positionAttribute, i + 2)\n      faceWeight *= _face.getArea()\n\n      faceWeights[i / 3] = faceWeight\n    }\n\n    // Store cumulative total face weights in an array, where weight index\n    // corresponds to face index.\n\n    this.distribution = new Float32Array(positionAttribute.count / 3)\n\n    let cumulativeTotal = 0\n\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i]\n\n      this.distribution[i] = cumulativeTotal\n    }\n\n    return this\n  }\n\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction\n    return this\n  }\n\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex()\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor)\n  }\n\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1]\n    return this.binarySearch(this.randomFunction() * cumulativeTotal)\n  }\n\n  binarySearch(x) {\n    const dist = this.distribution\n    let start = 0\n    let end = dist.length - 1\n\n    let index = -1\n\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2)\n\n      if (mid === 0 || (dist[mid - 1] <= x && dist[mid] > x)) {\n        index = mid\n\n        break\n      } else if (x < dist[mid]) {\n        end = mid - 1\n      } else {\n        start = mid + 1\n      }\n    }\n\n    return index\n  }\n\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction()\n    let v = this.randomFunction()\n\n    if (u + v > 1) {\n      u = 1 - u\n      v = 1 - v\n    }\n\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3)\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1)\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2)\n\n    targetPosition\n      .set(0, 0, 0)\n      .addScaledVector(_face.a, u)\n      .addScaledVector(_face.b, v)\n      .addScaledVector(_face.c, 1 - (u + v))\n\n    if (targetNormal !== undefined) {\n      _face.getNormal(targetNormal)\n    }\n\n    if (targetColor !== undefined && this.colorAttribute !== undefined) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3)\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1)\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2)\n\n      _color\n        .set(0, 0, 0)\n        .addScaledVector(_face.a, u)\n        .addScaledVector(_face.b, v)\n        .addScaledVector(_face.c, 1 - (u + v))\n\n      targetColor.r = _color.x\n      targetColor.g = _color.y\n      targetColor.b = _color.z\n    }\n\n    return this\n  }\n}\n\nexport { MeshSurfaceSampler }\n", "import { Box3, MathUtils, Matrix4, Matrix3, Ray, Vector3 } from 'three'\n\n// module scope helper variables\n\nconst a = {\n  c: null, // center\n  u: [new Vector3(), new Vector3(), new Vector3()], // basis vectors\n  e: [], // half width\n}\n\nconst b = {\n  c: null, // center\n  u: [new Vector3(), new Vector3(), new Vector3()], // basis vectors\n  e: [], // half width\n}\n\nconst R = [[], [], []]\nconst AbsR = [[], [], []]\nconst t = []\n\nconst xAxis = new Vector3()\nconst yAxis = new Vector3()\nconst zAxis = new Vector3()\nconst v1 = new Vector3()\nconst size = new Vector3()\nconst closestPoint = new Vector3()\nconst rotationMatrix = new Matrix3()\nconst aabb = new Box3()\nconst matrix = new Matrix4()\nconst inverse = new Matrix4()\nconst localRay = new Ray()\n\n// OBB\n\nclass OBB {\n  constructor(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\n    this.center = center\n    this.halfSize = halfSize\n    this.rotation = rotation\n  }\n\n  set(center, halfSize, rotation) {\n    this.center = center\n    this.halfSize = halfSize\n    this.rotation = rotation\n\n    return this\n  }\n\n  copy(obb) {\n    this.center.copy(obb.center)\n    this.halfSize.copy(obb.halfSize)\n    this.rotation.copy(obb.rotation)\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n\n  getSize(result) {\n    return result.copy(this.halfSize).multiplyScalar(2)\n  }\n\n  /**\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.1.4)\n   */\n  clampPoint(point, result) {\n    const halfSize = this.halfSize\n\n    v1.subVectors(point, this.center)\n    this.rotation.extractBasis(xAxis, yAxis, zAxis)\n\n    // start at the center position of the OBB\n\n    result.copy(this.center)\n\n    // project the target onto the OBB axes and walk towards that point\n\n    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x)\n    result.add(xAxis.multiplyScalar(x))\n\n    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y)\n    result.add(yAxis.multiplyScalar(y))\n\n    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z)\n    result.add(zAxis.multiplyScalar(z))\n\n    return result\n  }\n\n  containsPoint(point) {\n    v1.subVectors(point, this.center)\n    this.rotation.extractBasis(xAxis, yAxis, zAxis)\n\n    // project v1 onto each axis and check if these points lie inside the OBB\n\n    return (\n      Math.abs(v1.dot(xAxis)) <= this.halfSize.x &&\n      Math.abs(v1.dot(yAxis)) <= this.halfSize.y &&\n      Math.abs(v1.dot(zAxis)) <= this.halfSize.z\n    )\n  }\n\n  intersectsBox3(box3) {\n    return this.intersectsOBB(obb.fromBox3(box3))\n  }\n\n  intersectsSphere(sphere) {\n    // find the point on the OBB closest to the sphere center\n\n    this.clampPoint(sphere.center, closestPoint)\n\n    // if that point is inside the sphere, the OBB and sphere intersect\n\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius\n  }\n\n  /**\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n   * by Christer Ericson (chapter 4.4.1)\n   *\n   */\n  intersectsOBB(obb, epsilon = Number.EPSILON) {\n    // prepare data structures (the code uses the same nomenclature like the reference)\n\n    a.c = this.center\n    a.e[0] = this.halfSize.x\n    a.e[1] = this.halfSize.y\n    a.e[2] = this.halfSize.z\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2])\n\n    b.c = obb.center\n    b.e[0] = obb.halfSize.x\n    b.e[1] = obb.halfSize.y\n    b.e[2] = obb.halfSize.z\n    obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2])\n\n    // compute rotation matrix expressing b in a's coordinate frame\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j])\n      }\n    }\n\n    // compute translation vector\n\n    v1.subVectors(b.c, a.c)\n\n    // bring translation into a's coordinate frame\n\n    t[0] = v1.dot(a.u[0])\n    t[1] = v1.dot(a.u[1])\n    t[2] = v1.dot(a.u[2])\n\n    // compute common subexpressions. Add in an epsilon term to\n    // counteract arithmetic errors when two edges are parallel and\n    // their cross product is (near) null\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon\n      }\n    }\n\n    let ra, rb\n\n    // test axes L = A0, L = A1, L = A2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[i]\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2]\n      if (Math.abs(t[i]) > ra + rb) return false\n    }\n\n    // test axes L = B0, L = B1, L = B2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i]\n      rb = b.e[i]\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false\n    }\n\n    // test axis L = A0 x B0\n\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0]\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1]\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false\n\n    // test axis L = A0 x B1\n\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1]\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0]\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false\n\n    // test axis L = A0 x B2\n\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2]\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0]\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false\n\n    // test axis L = A1 x B0\n\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0]\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1]\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false\n\n    // test axis L = A1 x B1\n\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1]\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0]\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false\n\n    // test axis L = A1 x B2\n\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2]\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0]\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false\n\n    // test axis L = A2 x B0\n\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0]\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1]\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false\n\n    // test axis L = A2 x B1\n\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1]\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0]\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false\n\n    // test axis L = A2 x B2\n\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2]\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0]\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false\n\n    // since no separating axis is found, the OBBs must be intersecting\n\n    return true\n  }\n\n  /**\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.2.3)\n   */\n  intersectsPlane(plane) {\n    this.rotation.extractBasis(xAxis, yAxis, zAxis)\n\n    // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n    const r =\n      this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) +\n      this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) +\n      this.halfSize.z * Math.abs(plane.normal.dot(zAxis))\n\n    // compute distance of the OBB's center from the plane\n\n    const d = plane.normal.dot(this.center) - plane.constant\n\n    // Intersection occurs when distance d falls within [-r,+r] interval\n\n    return Math.abs(d) <= r\n  }\n\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\n   */\n  intersectRay(ray, result) {\n    // the idea is to perform the intersection test in the local space\n    // of the OBB.\n\n    this.getSize(size)\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size)\n\n    // create a 4x4 transformation matrix\n\n    matrix.setFromMatrix3(this.rotation)\n    matrix.setPosition(this.center)\n\n    // transform ray to the local space of the OBB\n\n    inverse.copy(matrix).invert()\n    localRay.copy(ray).applyMatrix4(inverse)\n\n    // perform ray <-> AABB intersection test\n\n    if (localRay.intersectBox(aabb, result)) {\n      // transform the intersection point back to world space\n\n      return result.applyMatrix4(matrix)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Performs a ray/OBB intersection test. Returns either true or false if\n   * there is a intersection or not.\n   */\n  intersectsRay(ray) {\n    return this.intersectRay(ray, v1) !== null\n  }\n\n  fromBox3(box3) {\n    box3.getCenter(this.center)\n\n    box3.getSize(this.halfSize).multiplyScalar(0.5)\n\n    this.rotation.identity()\n\n    return this\n  }\n\n  equals(obb) {\n    return obb.center.equals(this.center) && obb.halfSize.equals(this.halfSize) && obb.rotation.equals(this.rotation)\n  }\n\n  applyMatrix4(matrix) {\n    const e = matrix.elements\n\n    let sx = v1.set(e[0], e[1], e[2]).length()\n    const sy = v1.set(e[4], e[5], e[6]).length()\n    const sz = v1.set(e[8], e[9], e[10]).length()\n\n    const det = matrix.determinant()\n    if (det < 0) sx = -sx\n\n    rotationMatrix.setFromMatrix4(matrix)\n\n    const invSX = 1 / sx\n    const invSY = 1 / sy\n    const invSZ = 1 / sz\n\n    rotationMatrix.elements[0] *= invSX\n    rotationMatrix.elements[1] *= invSX\n    rotationMatrix.elements[2] *= invSX\n\n    rotationMatrix.elements[3] *= invSY\n    rotationMatrix.elements[4] *= invSY\n    rotationMatrix.elements[5] *= invSY\n\n    rotationMatrix.elements[6] *= invSZ\n    rotationMatrix.elements[7] *= invSZ\n    rotationMatrix.elements[8] *= invSZ\n\n    this.rotation.multiply(rotationMatrix)\n\n    this.halfSize.x *= sx\n    this.halfSize.y *= sy\n    this.halfSize.z *= sz\n\n    v1.setFromMatrixPosition(matrix)\n    this.center.add(v1)\n\n    return this\n  }\n}\n\nconst obb = new OBB()\n\nexport { OBB }\n", "import { Vector3 } from 'three'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\nconst _v3 = new Vector3()\n\nconst EPS = 1e-10\n\nclass Capsule {\n  constructor(start = new Vector3(0, 0, 0), end = new Vector3(0, 1, 0), radius = 1) {\n    this.start = start\n    this.end = end\n    this.radius = radius\n  }\n\n  clone() {\n    return new Capsule(this.start.clone(), this.end.clone(), this.radius)\n  }\n\n  set(start, end, radius) {\n    this.start.copy(start)\n    this.end.copy(end)\n    this.radius = radius\n  }\n\n  copy(capsule) {\n    this.start.copy(capsule.start)\n    this.end.copy(capsule.end)\n    this.radius = capsule.radius\n  }\n\n  getCenter(target) {\n    return target.copy(this.end).add(this.start).multiplyScalar(0.5)\n  }\n\n  translate(v) {\n    this.start.add(v)\n    this.end.add(v)\n  }\n\n  checkAABBAxis(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {\n    return (\n      (minx - p1x < radius || minx - p2x < radius) &&\n      (p1x - maxx < radius || p2x - maxx < radius) &&\n      (miny - p1y < radius || miny - p2y < radius) &&\n      (p1y - maxy < radius || p2y - maxy < radius)\n    )\n  }\n\n  intersectsBox(box) {\n    return (\n      this.checkAABBAxis(\n        this.start.x,\n        this.start.y,\n        this.end.x,\n        this.end.y,\n        box.min.x,\n        box.max.x,\n        box.min.y,\n        box.max.y,\n        this.radius,\n      ) &&\n      this.checkAABBAxis(\n        this.start.x,\n        this.start.z,\n        this.end.x,\n        this.end.z,\n        box.min.x,\n        box.max.x,\n        box.min.z,\n        box.max.z,\n        this.radius,\n      ) &&\n      this.checkAABBAxis(\n        this.start.y,\n        this.start.z,\n        this.end.y,\n        this.end.z,\n        box.min.y,\n        box.max.y,\n        box.min.z,\n        box.max.z,\n        this.radius,\n      )\n    )\n  }\n\n  lineLineMinimumPoints(line1, line2) {\n    const r = _v1.copy(line1.end).sub(line1.start)\n    const s = _v2.copy(line2.end).sub(line2.start)\n    const w = _v3.copy(line2.start).sub(line1.start)\n\n    const a = r.dot(s),\n      b = r.dot(r),\n      c = s.dot(s),\n      d = s.dot(w),\n      e = r.dot(w)\n\n    let t1, t2\n    const divisor = b * c - a * a\n\n    if (Math.abs(divisor) < EPS) {\n      const d1 = -d / c\n      const d2 = (a - d) / c\n\n      if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {\n        t1 = 0\n        t2 = d1\n      } else {\n        t1 = 1\n        t2 = d2\n      }\n    } else {\n      t1 = (d * a + e * c) / divisor\n      t2 = (t1 * a - d) / c\n    }\n\n    t2 = Math.max(0, Math.min(1, t2))\n    t1 = Math.max(0, Math.min(1, t1))\n\n    const point1 = r.multiplyScalar(t1).add(line1.start)\n    const point2 = s.multiplyScalar(t2).add(line2.start)\n\n    return [point1, point2]\n  }\n}\n\nexport { Capsule }\n", "// https://cs.nyu.edu/~perlin/noise/\n\nfunction init() {\n  // prettier-ignore\n  const _p = [ 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10,\n    23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87,\n    174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,\n    133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,\n    89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5,\n    202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119,\n    248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232,\n    178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249,\n    14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205,\n    93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180 ];\n\n  for (let i = 0; i < 256; i++) {\n    _p[256 + i] = _p[i]\n  }\n\n  return _p\n}\n\nconst _p = init()\n\nfunction fade(t) {\n  return t * t * t * (t * (t * 6 - 15) + 10)\n}\n\nfunction lerp(t, a, b) {\n  return a + t * (b - a)\n}\n\nfunction grad(hash, x, y, z) {\n  const h = hash & 15\n  const u = h < 8 ? x : y,\n    v = h < 4 ? y : h == 12 || h == 14 ? x : z\n  return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v)\n}\n\nclass ImprovedNoise {\n  noise(x, y, z) {\n    const floorX = Math.floor(x),\n      floorY = Math.floor(y),\n      floorZ = Math.floor(z)\n\n    const X = floorX & 255,\n      Y = floorY & 255,\n      Z = floorZ & 255\n\n    x -= floorX\n    y -= floorY\n    z -= floorZ\n\n    const xMinus1 = x - 1,\n      yMinus1 = y - 1,\n      zMinus1 = z - 1\n\n    const u = fade(x),\n      v = fade(y),\n      w = fade(z)\n\n    const A = _p[X] + Y,\n      AA = _p[A] + Z,\n      AB = _p[A + 1] + Z,\n      B = _p[X + 1] + Y,\n      BA = _p[B] + Z,\n      BB = _p[B + 1] + Z\n\n    return lerp(\n      w,\n      lerp(\n        v,\n        lerp(u, grad(_p[AA], x, y, z), grad(_p[BA], xMinus1, y, z)),\n        lerp(u, grad(_p[AB], x, yMinus1, z), grad(_p[BB], xMinus1, yMinus1, z)),\n      ),\n      lerp(\n        v,\n        lerp(u, grad(_p[AA + 1], x, y, zMinus1), grad(_p[BA + 1], xMinus1, y, zMinus1)),\n        lerp(u, grad(_p[AB + 1], x, yMinus1, zMinus1), grad(_p[BB + 1], xMinus1, yMinus1, zMinus1)),\n      ),\n    )\n  }\n}\n\nexport { ImprovedNoise }\n", "import { Box3, Line3, Plane, Sphere, Triangle, Vector3 } from 'three'\nimport { Capsule } from '../math/Capsule'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\nconst _plane = new Plane()\nconst _line1 = new Line3()\nconst _line2 = new Line3()\nconst _sphere = new Sphere()\nconst _capsule = new Capsule()\n\nclass Octree {\n  constructor(box) {\n    this.triangles = []\n    this.box = box\n    this.subTrees = []\n  }\n\n  addTriangle(triangle) {\n    if (!this.bounds) this.bounds = new Box3()\n\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x)\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y)\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z)\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x)\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y)\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z)\n\n    this.triangles.push(triangle)\n\n    return this\n  }\n\n  calcBox() {\n    this.box = this.bounds.clone()\n\n    // offset small amount to account for regular grid\n    this.box.min.x -= 0.01\n    this.box.min.y -= 0.01\n    this.box.min.z -= 0.01\n\n    return this\n  }\n\n  split(level) {\n    if (!this.box) return\n\n    const subTrees = []\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5)\n\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3()\n          const v = _v1.set(x, y, z)\n\n          box.min.copy(this.box.min).add(v.multiply(halfsize))\n          box.max.copy(box.min).add(halfsize)\n\n          subTrees.push(new Octree(box))\n        }\n      }\n    }\n\n    let triangle\n\n    while ((triangle = this.triangles.pop())) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle)\n        }\n      }\n    }\n\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length\n\n      if (len > 8 && level < 16) {\n        subTrees[i].split(level + 1)\n      }\n\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i])\n      }\n    }\n\n    return this\n  }\n\n  build() {\n    this.calcBox()\n    this.split(0)\n\n    return this\n  }\n\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n      if (!ray.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles)\n      }\n    }\n\n    return triangles\n  }\n\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane)\n\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius\n\n    if ((d1 > 0 && d2 > 0) || (d1 < -capsule.radius && d2 < -capsule.radius)) {\n      return false\n    }\n\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)))\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta)\n\n    if (triangle.containsPoint(intersectPoint)) {\n      return { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs(Math.min(d1, d2)) }\n    }\n\n    const r2 = capsule.radius * capsule.radius\n\n    const line1 = _line1.set(capsule.start, capsule.end)\n\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a],\n    ]\n\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1])\n\n      const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2)\n\n      if (point1.distanceToSquared(point2) < r2) {\n        return {\n          normal: point1.clone().sub(point2).normalize(),\n          point: point2.clone(),\n          depth: capsule.radius - point1.distanceTo(point2),\n        }\n      }\n    }\n\n    return false\n  }\n\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane)\n\n    if (!sphere.intersectsPlane(_plane)) return false\n\n    const depth = Math.abs(_plane.distanceToSphere(sphere))\n    const r2 = sphere.radius * sphere.radius - depth * depth\n\n    const plainPoint = _plane.projectPoint(sphere.center, _v1)\n\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere)),\n      }\n    }\n\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a],\n    ]\n\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1])\n      _line1.closestPointToPoint(plainPoint, true, _v2)\n\n      const d = _v2.distanceToSquared(sphere.center)\n\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d),\n        }\n      }\n    }\n\n    return false\n  }\n\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n\n      if (!sphere.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles)\n      }\n    }\n  }\n\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n\n      if (!capsule.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles)\n      }\n    }\n  }\n\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere)\n\n    const triangles = []\n    let result,\n      hit = false\n\n    this.getSphereTriangles(sphere, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      if ((result = this.triangleSphereIntersect(_sphere, triangles[i]))) {\n        hit = true\n\n        _sphere.center.add(result.normal.multiplyScalar(result.depth))\n      }\n    }\n\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center)\n      const depth = collisionVector.length()\n\n      return { normal: collisionVector.normalize(), depth: depth }\n    }\n\n    return false\n  }\n\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule)\n\n    const triangles = []\n    let result,\n      hit = false\n\n    this.getCapsuleTriangles(_capsule, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      if ((result = this.triangleCapsuleIntersect(_capsule, triangles[i]))) {\n        hit = true\n\n        _capsule.translate(result.normal.multiplyScalar(result.depth))\n      }\n    }\n\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1))\n      const depth = collisionVector.length()\n\n      return { normal: collisionVector.normalize(), depth: depth }\n    }\n\n    return false\n  }\n\n  rayIntersect(ray) {\n    if (ray.direction.length() === 0) return\n\n    const triangles = []\n    let triangle,\n      position,\n      distance = 1e100\n\n    this.getRayTriangles(ray, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1)\n\n      if (result) {\n        const newdistance = result.sub(ray.origin).length()\n\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin)\n          distance = newdistance\n          triangle = triangles[i]\n        }\n      }\n    }\n\n    return distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false\n  }\n\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true)\n\n    group.traverse((obj) => {\n      if (obj.isMesh === true) {\n        let geometry,\n          isTemp = false\n\n        if (obj.geometry.index !== null) {\n          isTemp = true\n          geometry = obj.geometry.toNonIndexed()\n        } else {\n          geometry = obj.geometry\n        }\n\n        const positionAttribute = geometry.getAttribute('position')\n\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const v1 = new Vector3().fromBufferAttribute(positionAttribute, i)\n          const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1)\n          const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2)\n\n          v1.applyMatrix4(obj.matrixWorld)\n          v2.applyMatrix4(obj.matrixWorld)\n          v3.applyMatrix4(obj.matrixWorld)\n\n          this.addTriangle(new Triangle(v1, v2, v3))\n        }\n\n        if (isTemp) {\n          geometry.dispose()\n        }\n      }\n    })\n\n    this.build()\n\n    return this\n  }\n}\n\nexport { Octree }\n", "import { MathUtils, Spherical, Vector3, Camera } from 'three'\nimport { EventDispatcher } from './EventDispatcher'\nimport { StandardControlsEventMap } from './StandardControlsEventMap'\n\nconst targetPosition = new Vector3()\n\nexport class FirstPersonControls extends EventDispatcher<{}> {\n  public object: Camera\n  public domElement?: HTMLElement | null\n\n  public enabled = true\n\n  public movementSpeed = 1.0\n  public lookSpeed = 0.005\n\n  public lookVertical = true\n  public autoForward = false\n\n  public activeLook = true\n\n  public heightSpeed = false\n  public heightCoef = 1.0\n  public heightMin = 0.0\n  public heightMax = 1.0\n\n  public constrainVertical = false\n  public verticalMin = 0\n  public verticalMax = Math.PI\n\n  public mouseDragOn = false\n\n  // internals\n\n  private autoSpeedFactor = 0.0\n\n  private mouseX = 0\n  private mouseY = 0\n\n  private moveForward = false\n  private moveBackward = false\n  private moveLeft = false\n  private moveRight = false\n  private moveUp = false\n  private moveDown = false\n\n  private viewHalfX = 0\n  private viewHalfY = 0\n\n  private lat = 0\n  private lon = 0\n\n  private lookDirection = new Vector3()\n  private spherical = new Spherical()\n  readonly target = new Vector3()\n\n  constructor(object: Camera, domElement?: HTMLElement | null) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    this.setOrientation()\n\n    if (domElement) this.connect(domElement)\n  }\n\n  public connect = (domElement: HTMLElement): void => {\n    domElement.setAttribute('tabindex', '-1')\n\n    domElement.style.touchAction = 'none'\n\n    domElement.addEventListener('contextmenu', this.contextmenu)\n    domElement.addEventListener('mousemove', this.onMouseMove)\n    domElement.addEventListener('mousedown', this.onMouseDown)\n    domElement.addEventListener('mouseup', this.onMouseUp)\n\n    this.domElement = domElement\n\n    window.addEventListener('keydown', this.onKeyDown)\n    window.addEventListener('keyup', this.onKeyUp)\n\n    this.handleResize()\n  }\n\n  public dispose = (): void => {\n    this.domElement?.removeEventListener('contextmenu', this.contextmenu)\n    this.domElement?.removeEventListener('mousedown', this.onMouseDown)\n    this.domElement?.removeEventListener('mousemove', this.onMouseMove)\n    this.domElement?.removeEventListener('mouseup', this.onMouseUp)\n\n    window.removeEventListener('keydown', this.onKeyDown)\n    window.removeEventListener('keyup', this.onKeyUp)\n  }\n\n  public handleResize = (): void => {\n    if (this.domElement) {\n      this.viewHalfX = this.domElement.offsetWidth / 2\n      this.viewHalfY = this.domElement.offsetHeight / 2\n    }\n  }\n\n  private onMouseDown = (event: MouseEvent): void => {\n    this.domElement?.focus()\n\n    if (this.activeLook) {\n      switch (event.button) {\n        case 0:\n          this.moveForward = true\n          break\n        case 2:\n          this.moveBackward = true\n          break\n      }\n    }\n\n    this.mouseDragOn = true\n  }\n\n  private onMouseUp = (event: MouseEvent): void => {\n    if (this.activeLook) {\n      switch (event.button) {\n        case 0:\n          this.moveForward = false\n          break\n        case 2:\n          this.moveBackward = false\n          break\n      }\n    }\n\n    this.mouseDragOn = false\n  }\n\n  private onMouseMove = (event: MouseEvent): void => {\n    if (this.domElement) {\n      this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX\n      this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY\n    }\n  }\n\n  private onKeyDown = (event: KeyboardEvent): void => {\n    switch (event.code) {\n      case 'ArrowUp':\n      case 'KeyW':\n        this.moveForward = true\n        break\n\n      case 'ArrowLeft':\n      case 'KeyA':\n        this.moveLeft = true\n        break\n\n      case 'ArrowDown':\n      case 'KeyS':\n        this.moveBackward = true\n        break\n\n      case 'ArrowRight':\n      case 'KeyD':\n        this.moveRight = true\n        break\n\n      case 'KeyR':\n        this.moveUp = true\n        break\n      case 'KeyF':\n        this.moveDown = true\n        break\n    }\n  }\n\n  private onKeyUp = (event: KeyboardEvent): void => {\n    switch (event.code) {\n      case 'ArrowUp':\n      case 'KeyW':\n        this.moveForward = false\n        break\n\n      case 'ArrowLeft':\n      case 'KeyA':\n        this.moveLeft = false\n        break\n\n      case 'ArrowDown':\n      case 'KeyS':\n        this.moveBackward = false\n        break\n\n      case 'ArrowRight':\n      case 'KeyD':\n        this.moveRight = false\n        break\n\n      case 'KeyR':\n        this.moveUp = false\n        break\n      case 'KeyF':\n        this.moveDown = false\n        break\n    }\n  }\n\n  public lookAt = (x: Vector3 | number, y?: number, z?: number): this => {\n    if (x instanceof Vector3) {\n      this.target.copy(x)\n    } else if (y && z) {\n      this.target.set(x, y, z)\n    }\n\n    this.object.lookAt(this.target)\n\n    this.setOrientation()\n\n    return this\n  }\n\n  public update = (delta: number): void => {\n    if (!this.enabled) return\n\n    if (this.heightSpeed) {\n      const y = MathUtils.clamp(this.object.position.y, this.heightMin, this.heightMax)\n      const heightDelta = y - this.heightMin\n\n      this.autoSpeedFactor = delta * (heightDelta * this.heightCoef)\n    } else {\n      this.autoSpeedFactor = 0.0\n    }\n\n    const actualMoveSpeed = delta * this.movementSpeed\n\n    if (this.moveForward || (this.autoForward && !this.moveBackward)) {\n      this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor))\n    }\n    if (this.moveBackward) this.object.translateZ(actualMoveSpeed)\n\n    if (this.moveLeft) this.object.translateX(-actualMoveSpeed)\n    if (this.moveRight) this.object.translateX(actualMoveSpeed)\n\n    if (this.moveUp) this.object.translateY(actualMoveSpeed)\n    if (this.moveDown) this.object.translateY(-actualMoveSpeed)\n\n    let actualLookSpeed = delta * this.lookSpeed\n\n    if (!this.activeLook) {\n      actualLookSpeed = 0\n    }\n\n    let verticalLookRatio = 1\n\n    if (this.constrainVertical) {\n      verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin)\n    }\n\n    this.lon -= this.mouseX * actualLookSpeed\n    if (this.lookVertical) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio\n\n    this.lat = Math.max(-85, Math.min(85, this.lat))\n\n    let phi = MathUtils.degToRad(90 - this.lat)\n    const theta = MathUtils.degToRad(this.lon)\n\n    if (this.constrainVertical) {\n      phi = MathUtils.mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax)\n    }\n\n    const position = this.object.position\n\n    targetPosition.setFromSphericalCoords(1, phi, theta).add(position)\n\n    this.object.lookAt(targetPosition)\n  }\n\n  private contextmenu = (event: Event): void => event.preventDefault()\n\n  private setOrientation = (): void => {\n    this.lookDirection.set(0, 0, -1).applyQuaternion(this.object.quaternion)\n    this.spherical.setFromVector3(this.lookDirection)\n    this.lat = 90 - MathUtils.radToDeg(this.spherical.phi)\n    this.lon = MathUtils.radToDeg(this.spherical.theta)\n  }\n}\n", "import { Euler, Camera, Vector3 } from 'three'\nimport { EventDispatcher } from './EventDispatcher'\n\nconst _euler = new Euler(0, 0, 0, 'YXZ')\nconst _vector = new Vector3()\nconst _changeEvent = { type: 'change' }\nconst _lockEvent = { type: 'lock' }\nconst _unlockEvent = { type: 'unlock' }\nconst _PI_2 = Math.PI / 2\n\nexport interface PointerLockControlsEventMap {\n  /**\n   * Fires when the user moves the mouse.\n   */\n  change: {};\n\n  /**\n   * Fires when the pointer lock status is \"locked\" (in other words: the mouse is captured).\n   */\n  lock: {};\n\n  /**\n   * Fires when the pointer lock status is \"unlocked\" (in other words: the mouse is not captured anymore).\n   */\n  unlock: {};\n}\n\nclass PointerLockControls extends EventDispatcher<PointerLockControlsEventMap> {\n  public camera: Camera\n  public domElement?: HTMLElement\n  public isLocked: boolean\n  public minPolarAngle: number\n  public maxPolarAngle: number\n  public pointerSpeed: number\n\n  constructor(camera: Camera, domElement?: HTMLElement) {\n    super()\n\n    this.camera = camera\n    this.domElement = domElement\n    this.isLocked = false\n\n    // Set to constrain the pitch of the camera\n    // Range is 0 to Math.PI radians\n    this.minPolarAngle = 0 // radians\n    this.maxPolarAngle = Math.PI // radians\n\n    this.pointerSpeed = 1.0\n    if (domElement) this.connect(domElement)\n  }\n\n  private onMouseMove = (event: MouseEvent): void => {\n    if (!this.domElement || this.isLocked === false) return\n    _euler.setFromQuaternion(this.camera.quaternion)\n    _euler.y -= event.movementX * 0.002 * this.pointerSpeed\n    _euler.x -= event.movementY * 0.002 * this.pointerSpeed\n    _euler.x = Math.max(_PI_2 - this.maxPolarAngle, Math.min(_PI_2 - this.minPolarAngle, _euler.x))\n    this.camera.quaternion.setFromEuler(_euler)\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  private onPointerlockChange = (): void => {\n    if (!this.domElement) return\n    if (this.domElement.ownerDocument.pointerLockElement === this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_lockEvent)\n      this.isLocked = true\n    } else {\n      // @ts-ignore\n      this.dispatchEvent(_unlockEvent)\n      this.isLocked = false\n    }\n  }\n\n  private onPointerlockError = (): void => {\n    console.error('THREE.PointerLockControls: Unable to use Pointer Lock API')\n  }\n\n  public connect = (domElement: HTMLElement): void => {\n    this.domElement = domElement || this.domElement\n    if (!this.domElement) return\n    this.domElement.ownerDocument.addEventListener('mousemove', this.onMouseMove)\n    this.domElement.ownerDocument.addEventListener('pointerlockchange', this.onPointerlockChange)\n    this.domElement.ownerDocument.addEventListener('pointerlockerror', this.onPointerlockError)\n  }\n\n  public disconnect = (): void => {\n    if (!this.domElement) return\n    this.domElement.ownerDocument.removeEventListener('mousemove', this.onMouseMove)\n    this.domElement.ownerDocument.removeEventListener('pointerlockchange', this.onPointerlockChange)\n    this.domElement.ownerDocument.removeEventListener('pointerlockerror', this.onPointerlockError)\n  }\n\n  public dispose = (): void => {\n    this.disconnect()\n  }\n\n  public getObject = (): Camera => {\n    // retaining this method for backward compatibility\n    return this.camera\n  }\n\n  private direction = new Vector3(0, 0, -1)\n  public getDirection = (v: Vector3): Vector3 => {\n    return v.copy(this.direction).applyQuaternion(this.camera.quaternion)\n  }\n\n  public moveForward = (distance: number): void => {\n    // move forward parallel to the xz-plane\n    // assumes camera.up is y-up\n    _vector.setFromMatrixColumn(this.camera.matrix, 0)\n    _vector.crossVectors(this.camera.up, _vector)\n    this.camera.position.addScaledVector(_vector, distance)\n  }\n\n  public moveRight = (distance: number): void => {\n    _vector.setFromMatrixColumn(this.camera.matrix, 0)\n    this.camera.position.addScaledVector(_vector, distance)\n  }\n\n  public lock = (): void => {\n    if (this.domElement) this.domElement.requestPointerLock()\n  }\n\n  public unlock = (): void => {\n    if (this.domElement) this.domElement.ownerDocument.exitPointerLock()\n  }\n}\n\nexport { PointerLockControls }\n", "import {\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\nimport { EventDispatcher } from './EventDispatcher'\nimport { StandardControlsEventMap } from './StandardControlsEventMap'\n\nconst _ray = new Ray()\nconst _plane = new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher<StandardControlsEventMap> {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n  // Not used in most scenarios, however they can be useful for specific use cases\n  getZoomScale: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  // Dolly in programmatically\n  dollyIn: (dollyScale?: number) => void\n  // Dolly out programmatically\n  dollyOut: (dollyScale?: number) => void\n  // Get the current scale\n  getScale: () => number\n  // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n  setScale: (newScale: number) => void\n  \n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if ((scope.zoomToCursor && performCursorZoom) || (scope.object as OrthographicCamera).isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerUp)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      // Enabling touch scroll\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = 'auto'\n      }\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerUp)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function setScale(newScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale = newScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyOut(dollyScale: number) {\n      setScale(scale / dollyScale)\n    }\n\n    function dollyIn(dollyScale: number) {\n      setScale(scale * dollyScale)\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // Add dolly in/out methods for public API\n\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale)\n      scope.update()\n    }\n\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n        dollyOut(dollyScale)\n        scope.update()\n    }\n\n    this.getScale = () => {\n        return scale;\n    }\n\n    this.setScale = (newScale) => {\n        setScale(newScale)\n        scope.update()\n    }\n\n    this.getZoomScale = () => {\n        return getZoomScale();\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n", "import {\n  GridHelper,\n  EllipseCurve,\n  BufferGeometry,\n  Line,\n  LineBasicMaterial,\n  Raycaster,\n  Group,\n  Box3,\n  Sphere,\n  Quaternion,\n  Vector2,\n  Vector3,\n  Matrix4,\n  MathUtils,\n  Scene,\n  PerspectiveCamera,\n  OrthographicCamera,\n  Mesh,\n  Material,\n} from 'three'\nimport { EventDispatcher } from './EventDispatcher'\nimport { StandardControlsEventMap } from './StandardControlsEventMap'\n\ntype Camera = OrthographicCamera | PerspectiveCamera\ntype Operation = 'PAN' | 'ROTATE' | 'ZOOM' | 'FOV'\ntype MouseButtonType = number | 'WHEEL'\ntype ModifierKey = 'CTRL' | 'SHIFT'\ntype MouseAction = {\n  operation: Operation\n  mouse: MouseButtonType\n  key: ModifierKey | null\n}\n\ntype Transformation = {\n  camera: Matrix4 | null\n  gizmos: Matrix4 | null\n}\n\n//trackball state\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol(),\n}\n\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol(),\n}\n\n//cursor center coordinates\nconst _center = {\n  x: 0,\n  y: 0,\n}\n\n//transformation matrices for gizmos and camera\nconst _transformation: Transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4(),\n}\n\n//events\nconst _changeEvent = { type: 'change' }\nconst _startEvent = { type: 'start' }\nconst _endEvent = { type: 'end' }\n\n/**\n *\n * @param {CamOrthographicCamera | PerspectiveCameraera} camera Virtual camera used in the scene\n * @param {HTMLElement=null} domElement Renderer's dom element\n * @param {Scene=null} scene The scene to be rendered\n */\nclass ArcballControls extends EventDispatcher<StandardControlsEventMap> {\n  private camera: OrthographicCamera | PerspectiveCamera | null\n  private domElement: HTMLElement | null | undefined\n  private scene: Scene | null | undefined\n\n  private mouseActions: (MouseAction & { state: Symbol })[]\n  private _mouseOp: Operation | null\n\n  private _v2_1: Vector2\n  private _v3_1: Vector3\n  private _v3_2: Vector3\n\n  private _m4_1: Matrix4\n  private _m4_2: Matrix4\n\n  private _quat: Quaternion\n\n  private _translationMatrix: Matrix4\n  private _rotationMatrix: Matrix4\n  private _scaleMatrix: Matrix4\n\n  private _rotationAxis: Vector3\n\n  private _cameraMatrixState: Matrix4\n  private _cameraProjectionState: Matrix4\n\n  private _fovState: number\n  private _upState: Vector3\n  private _zoomState: number\n  private _nearPos: number\n  private _farPos: number\n\n  private _gizmoMatrixState: Matrix4\n\n  private _up0: Vector3\n  private _zoom0: number\n  private _fov0: number\n  private _initialNear: number\n  private _nearPos0: number\n  private _initialFar: number\n  private _farPos0: number\n  private _cameraMatrixState0: Matrix4\n  private _gizmoMatrixState0: Matrix4\n\n  private _button: MouseButtonType\n  private _touchStart: PointerEvent[]\n  private _touchCurrent: PointerEvent[]\n  private _input: Symbol\n\n  private _switchSensibility: number\n  private _startFingerDistance: number\n  private _currentFingerDistance: number\n  private _startFingerRotation: number\n  private _currentFingerRotation: number\n\n  private _devPxRatio: number\n  private _downValid: boolean\n  private _nclicks: number\n  private _downEvents: PointerEvent[]\n  private _clickStart: number\n  private _maxDownTime: number\n  private _maxInterval: number\n  private _posThreshold: number\n  private _movementThreshold: number\n\n  private _currentCursorPosition: Vector3\n  private _startCursorPosition: Vector3\n\n  private _grid: GridHelper | null\n  private _gridPosition: Vector3\n\n  private _gizmos: Group\n  private _curvePts: number\n\n  private _timeStart: number\n  private _animationId: number\n\n  public focusAnimationTime: number\n\n  private _timePrev: number\n  private _timeCurrent: number\n  private _anglePrev: number\n  private _angleCurrent: number\n  private _cursorPosPrev: Vector3\n  private _cursorPosCurr: Vector3\n  private _wPrev: number\n  private _wCurr: number\n\n  public adjustNearFar: boolean\n  public scaleFactor: number\n  public dampingFactor: number\n  public wMax: number\n  public enableAnimations: boolean\n  public enableGrid: boolean\n  public cursorZoom: boolean\n  public minFov: number\n  public maxFov: number\n\n  public enabled: boolean\n  public enablePan: boolean\n  public enableRotate: boolean\n  public enableZoom: boolean\n\n  public minDistance: number\n  public maxDistance: number\n  public minZoom: number\n  public maxZoom: number\n\n  readonly target: Vector3\n  private _currentTarget: Vector3\n\n  private _tbRadius: number\n\n  private _state: Symbol\n\n  constructor(\n    camera: Camera | null,\n    domElement: HTMLElement | null | undefined = null,\n    scene: Scene | null | undefined = null,\n  ) {\n    super()\n    this.camera = null\n    this.domElement = domElement\n    this.scene = scene\n\n    this.mouseActions = []\n    this._mouseOp = null\n\n    //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n    this._v2_1 = new Vector2()\n    this._v3_1 = new Vector3()\n    this._v3_2 = new Vector3()\n\n    this._m4_1 = new Matrix4()\n    this._m4_2 = new Matrix4()\n\n    this._quat = new Quaternion()\n\n    //transformation matrices\n    this._translationMatrix = new Matrix4() //matrix for translation operation\n    this._rotationMatrix = new Matrix4() //matrix for rotation operation\n    this._scaleMatrix = new Matrix4() //matrix for scaling operation\n\n    this._rotationAxis = new Vector3() //axis for rotate operation\n\n    //camera state\n    this._cameraMatrixState = new Matrix4()\n    this._cameraProjectionState = new Matrix4()\n\n    this._fovState = 1\n    this._upState = new Vector3()\n    this._zoomState = 1\n    this._nearPos = 0\n    this._farPos = 0\n\n    this._gizmoMatrixState = new Matrix4()\n\n    //initial values\n    this._up0 = new Vector3()\n    this._zoom0 = 1\n    this._fov0 = 0\n    this._initialNear = 0\n    this._nearPos0 = 0\n    this._initialFar = 0\n    this._farPos0 = 0\n    this._cameraMatrixState0 = new Matrix4()\n    this._gizmoMatrixState0 = new Matrix4()\n\n    //pointers array\n    this._button = -1\n    this._touchStart = []\n    this._touchCurrent = []\n    this._input = INPUT.NONE\n\n    //two fingers touch interaction\n    this._switchSensibility = 32 //minimum movement to be performed to fire single pan start after the second finger has been released\n    this._startFingerDistance = 0 //distance between two fingers\n    this._currentFingerDistance = 0\n    this._startFingerRotation = 0 //amount of rotation performed with two fingers\n    this._currentFingerRotation = 0\n\n    //double tap\n    this._devPxRatio = 0\n    this._downValid = true\n    this._nclicks = 0\n    this._downEvents = []\n    this._clickStart = 0 //first click time\n    this._maxDownTime = 250\n    this._maxInterval = 300\n    this._posThreshold = 24\n    this._movementThreshold = 24\n\n    //cursor positions\n    this._currentCursorPosition = new Vector3()\n    this._startCursorPosition = new Vector3()\n\n    //grid\n    this._grid = null //grid to be visualized during pan operation\n    this._gridPosition = new Vector3()\n\n    //gizmos\n    this._gizmos = new Group()\n    this._curvePts = 128\n\n    //animations\n    this._timeStart = -1 //initial time\n    this._animationId = -1\n\n    //focus animation\n    this.focusAnimationTime = 500 //duration of focus animation in ms\n\n    //rotate animation\n    this._timePrev = 0 //time at which previous rotate operation has been detected\n    this._timeCurrent = 0 //time at which current rotate operation has been detected\n    this._anglePrev = 0 //angle of previous rotation\n    this._angleCurrent = 0 //angle of current rotation\n    this._cursorPosPrev = new Vector3() //cursor position when previous rotate operation has been detected\n    this._cursorPosCurr = new Vector3() //cursor position when current rotate operation has been detected\n    this._wPrev = 0 //angular velocity of the previous rotate operation\n    this._wCurr = 0 //angular velocity of the current rotate operation\n\n    //parameters\n    this.adjustNearFar = false\n    this.scaleFactor = 1.1 //zoom/distance multiplier\n    this.dampingFactor = 25\n    this.wMax = 20 //maximum angular velocity allowed\n    this.enableAnimations = true //if animations should be performed\n    this.enableGrid = false //if grid should be showed during pan operation\n    this.cursorZoom = false //if wheel zoom should be cursor centered\n    this.minFov = 5\n    this.maxFov = 90\n\n    this.enabled = true\n    this.enablePan = true\n    this.enableRotate = true\n    this.enableZoom = true\n\n    this.minDistance = 0\n    this.maxDistance = Infinity\n    this.minZoom = 0\n    this.maxZoom = Infinity\n\n    //trackball parameters\n    this.target = new Vector3(0, 0, 0)\n    this._currentTarget = new Vector3(0, 0, 0)\n\n    this._tbRadius = 1\n\n    //FSA\n    this._state = STATE.IDLE\n\n    this.setCamera(camera)\n\n    if (this.scene) {\n      this.scene.add(this._gizmos)\n    }\n\n    this._devPxRatio = window.devicePixelRatio\n\n    this.initializeMouseActions()\n\n    if (this.domElement) this.connect(this.domElement)\n\n    window.addEventListener('resize', this.onWindowResize)\n  }\n\n  //listeners\n\n  private onWindowResize = (): void => {\n    const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3\n    if (this.camera) {\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n    }\n\n    const newRadius = this._tbRadius / scale\n    // @ts-ignore\n    const curve = new EllipseCurve(0, 0, newRadius, newRadius)\n    const points = curve.getPoints(this._curvePts)\n    const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n    for (const gizmo in this._gizmos.children) {\n      const child = this._gizmos.children[gizmo] as Mesh\n      child.geometry = curveGeometry\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  private onContextMenu = (event: MouseEvent): void => {\n    if (!this.enabled) {\n      return\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == 2) {\n        //prevent only if button 2 is actually used\n        event.preventDefault()\n        break\n      }\n    }\n  }\n\n  private onPointerCancel = (): void => {\n    this._touchStart.splice(0, this._touchStart.length)\n    this._touchCurrent.splice(0, this._touchCurrent.length)\n    this._input = INPUT.NONE\n  }\n\n  private onPointerDown = (event: PointerEvent): void => {\n    if (event.button == 0 && event.isPrimary) {\n      this._downValid = true\n      this._downEvents.push(event)\n    } else {\n      this._downValid = false\n    }\n\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      this._touchStart.push(event)\n      this._touchCurrent.push(event)\n\n      switch (this._input) {\n        case INPUT.NONE:\n          //singleStart\n          this._input = INPUT.ONE_FINGER\n          this.onSinglePanStart(event, 'ROTATE')\n\n          window.addEventListener('pointermove', this.onPointerMove)\n          window.addEventListener('pointerup', this.onPointerUp)\n\n          break\n\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //doubleStart\n          this._input = INPUT.TWO_FINGER\n\n          this.onRotateStart()\n          this.onPinchStart()\n          this.onDoublePanStart()\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //multipleStart\n          this._input = INPUT.MULT_FINGER\n          this.onTriplePanStart()\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      this._mouseOp = this.getOpFromAction(event.button, modifier)\n      if (this._mouseOp) {\n        window.addEventListener('pointermove', this.onPointerMove)\n        window.addEventListener('pointerup', this.onPointerUp)\n\n        //singleStart\n        this._input = INPUT.CURSOR\n        this._button = event.button\n        this.onSinglePanStart(event, this._mouseOp)\n      }\n    }\n  }\n\n  private onPointerMove = (event: PointerEvent): void => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n          //singleMove\n          this.updateTouchEvent(event)\n\n          this.onSinglePanMove(event, STATE.ROTATE)\n          break\n\n        case INPUT.ONE_FINGER_SWITCHED:\n          const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio\n\n          if (movement >= this._switchSensibility) {\n            //singleMove\n            this._input = INPUT.ONE_FINGER\n            this.updateTouchEvent(event)\n\n            this.onSinglePanStart(event, 'ROTATE')\n            break\n          }\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //rotate/pan/pinchMove\n          this.updateTouchEvent(event)\n\n          this.onRotateMove()\n          this.onPinchMove()\n          this.onDoublePanMove()\n\n          break\n\n        case INPUT.MULT_FINGER:\n          //multMove\n          this.updateTouchEvent(event)\n\n          this.onTriplePanMove()\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      const mouseOpState = this.getOpStateFromAction(this._button, modifier)\n\n      if (mouseOpState) {\n        this.onSinglePanMove(event, mouseOpState)\n      }\n    }\n\n    //checkDistance\n    if (this._downValid) {\n      const movement =\n        this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio\n      if (movement > this._movementThreshold) {\n        this._downValid = false\n      }\n    }\n  }\n\n  private onPointerUp = (event: PointerEvent): void => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      const nTouch = this._touchCurrent.length\n\n      for (let i = 0; i < nTouch; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1)\n          this._touchStart.splice(i, 1)\n          break\n        }\n      }\n\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //singleEnd\n          window.removeEventListener('pointermove', this.onPointerMove)\n          window.removeEventListener('pointerup', this.onPointerUp)\n\n          this._input = INPUT.NONE\n          this.onSinglePanEnd()\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //doubleEnd\n          this.onDoublePanEnd()\n          this.onPinchEnd()\n          this.onRotateEnd()\n\n          //switching to singleStart\n          this._input = INPUT.ONE_FINGER_SWITCHED\n\n          break\n\n        case INPUT.MULT_FINGER:\n          if (this._touchCurrent.length == 0) {\n            window.removeEventListener('pointermove', this.onPointerMove)\n            window.removeEventListener('pointerup', this.onPointerUp)\n\n            //multCancel\n            this._input = INPUT.NONE\n            this.onTriplePanEnd()\n          }\n\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      window.removeEventListener('pointermove', this.onPointerMove)\n      window.removeEventListener('pointerup', this.onPointerUp)\n\n      this._input = INPUT.NONE\n      this.onSinglePanEnd()\n      this._button = -1\n    }\n\n    if (event.isPrimary) {\n      if (this._downValid) {\n        const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp\n\n        if (downTime <= this._maxDownTime) {\n          if (this._nclicks == 0) {\n            //first valid click detected\n            this._nclicks = 1\n            this._clickStart = performance.now()\n          } else {\n            const clickInterval = event.timeStamp - this._clickStart\n            const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio\n\n            if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n              //second valid click detected\n              //fire double tap and reset values\n              this._nclicks = 0\n              this._downEvents.splice(0, this._downEvents.length)\n              this.onDoubleTap(event)\n            } else {\n              //new 'first click'\n              this._nclicks = 1\n              this._downEvents.shift()\n              this._clickStart = performance.now()\n            }\n          }\n        } else {\n          this._downValid = false\n          this._nclicks = 0\n          this._downEvents.splice(0, this._downEvents.length)\n        }\n      } else {\n        this._nclicks = 0\n        this._downEvents.splice(0, this._downEvents.length)\n      }\n    }\n  }\n\n  private onWheel = (event: WheelEvent): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      const mouseOp = this.getOpFromAction('WHEEL', modifier)\n\n      if (mouseOp) {\n        event.preventDefault()\n        // @ts-ignore\n        this.dispatchEvent(_startEvent)\n\n        const notchDeltaY = 125 //distance of one notch of mouse wheel\n        let sgn = event.deltaY / notchDeltaY\n\n        let size = 1\n\n        if (sgn > 0) {\n          size = 1 / this.scaleFactor\n        } else if (sgn < 0) {\n          size = this.scaleFactor\n        }\n\n        switch (mouseOp) {\n          case 'ZOOM':\n            this.updateTbState(STATE.SCALE, true)\n\n            if (sgn > 0) {\n              size = 1 / Math.pow(this.scaleFactor, sgn)\n            } else if (sgn < 0) {\n              size = Math.pow(this.scaleFactor, -sgn)\n            }\n\n            if (this.cursorZoom && this.enablePan) {\n              let scalePoint\n\n              if (this.camera instanceof OrthographicCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)\n                  ?.applyQuaternion(this.camera.quaternion)\n                  .multiplyScalar(1 / this.camera.zoom)\n                  .add(this._gizmos.position)\n              }\n\n              if (this.camera instanceof PerspectiveCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)\n                  ?.applyQuaternion(this.camera.quaternion)\n                  .add(this._gizmos.position)\n              }\n\n              if (scalePoint !== undefined) this.applyTransformMatrix(this.applyScale(size, scalePoint))\n            } else {\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n            }\n\n            if (this._grid) {\n              this.disposeGrid()\n              this.drawGrid()\n            }\n\n            this.updateTbState(STATE.IDLE, false)\n\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n            // @ts-ignore\n            this.dispatchEvent(_endEvent)\n\n            break\n\n          case 'FOV':\n            if (this.camera instanceof PerspectiveCamera) {\n              this.updateTbState(STATE.FOV, true)\n\n              //Vertigo effect\n\n              //\t  fov / 2\n              //\t\t|\\\n              //\t\t| \\\n              //\t\t|  \\\n              //\tx\t|\t\\\n              //\t\t| \t \\\n              //\t\t| \t  \\\n              //\t\t| _ _ _\\\n              //\t\t\ty\n\n              //check for iOs shift shortcut\n              if (event.deltaX != 0) {\n                sgn = event.deltaX / notchDeltaY\n\n                size = 1\n\n                if (sgn > 0) {\n                  size = 1 / Math.pow(this.scaleFactor, sgn)\n                } else if (sgn < 0) {\n                  size = Math.pow(this.scaleFactor, -sgn)\n                }\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n              const x = this._v3_1.distanceTo(this._gizmos.position)\n              let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n              const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5)\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n              //check min and max fov\n              if (newFov > this.maxFov) {\n                newFov = this.maxFov\n              } else if (newFov < this.minFov) {\n                newFov = this.minFov\n              }\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n              size = x / newDistance\n\n              this.setFov(newFov)\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false))\n            }\n\n            if (this._grid) {\n              this.disposeGrid()\n              this.drawGrid()\n            }\n\n            this.updateTbState(STATE.IDLE, false)\n\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n            // @ts-ignore\n            this.dispatchEvent(_endEvent)\n\n            break\n        }\n      }\n    }\n  }\n\n  private onSinglePanStart = (event: PointerEvent, operation: Operation): void => {\n    if (this.enabled && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.setCenter(event.clientX, event.clientY)\n\n      switch (operation) {\n        case 'PAN':\n          if (!this.enablePan) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n\n            this.activateGizmos(false)\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n          }\n\n          if (this.camera) {\n            this.updateTbState(STATE.PAN, true)\n            const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            if (rayDir !== undefined) {\n              this._startCursorPosition.copy(rayDir)\n            }\n            if (this.enableGrid) {\n              this.drawGrid()\n              // @ts-ignore\n              this.dispatchEvent(_changeEvent)\n            }\n          }\n\n          break\n\n        case 'ROTATE':\n          if (!this.enableRotate) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n          }\n\n          if (this.camera) {\n            this.updateTbState(STATE.ROTATE, true)\n            const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius)\n            if (rayDir !== undefined) {\n              this._startCursorPosition.copy(rayDir)\n            }\n            this.activateGizmos(true)\n            if (this.enableAnimations) {\n              this._timePrev = this._timeCurrent = performance.now()\n              this._angleCurrent = this._anglePrev = 0\n              this._cursorPosPrev.copy(this._startCursorPosition)\n              this._cursorPosCurr.copy(this._cursorPosPrev)\n              this._wCurr = 0\n              this._wPrev = this._wCurr\n            }\n          }\n\n          // @ts-ignore\n          this.dispatchEvent(_changeEvent)\n          break\n\n        case 'FOV':\n          if (!this.enableZoom) return\n\n          if (this.camera instanceof PerspectiveCamera) {\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId)\n              this._animationId = -1\n              this._timeStart = -1\n\n              this.activateGizmos(false)\n              // @ts-ignore\n              this.dispatchEvent(_changeEvent)\n            }\n\n            this.updateTbState(STATE.FOV, true)\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n            this._currentCursorPosition.copy(this._startCursorPosition)\n          }\n          break\n\n        case 'ZOOM':\n          if (!this.enableZoom) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n\n            this.activateGizmos(false)\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n          }\n\n          this.updateTbState(STATE.SCALE, true)\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n          this._currentCursorPosition.copy(this._startCursorPosition)\n          break\n      }\n    }\n  }\n\n  private onSinglePanMove = (event: PointerEvent, opState: Symbol): void => {\n    if (this.enabled && this.domElement) {\n      const restart = opState != this._state\n      this.setCenter(event.clientX, event.clientY)\n\n      switch (opState) {\n        case STATE.PAN:\n          if (this.enablePan && this.camera) {\n            if (restart) {\n              //switch to pan operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir)\n              }\n              if (this.enableGrid) {\n                this.drawGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with pan operation\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n              if (rayDir !== undefined) {\n                this._currentCursorPosition.copy(rayDir)\n              }\n              this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition))\n            }\n          }\n\n          break\n\n        case STATE.ROTATE:\n          if (this.enableRotate && this.camera) {\n            if (restart) {\n              //switch to rotate operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              const rayDir = this.unprojectOnTbSurface(\n                this.camera,\n                _center.x,\n                _center.y,\n                this.domElement,\n                this._tbRadius,\n              )\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir)\n              }\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(true)\n            } else {\n              //continue with rotate operation\n              const rayDir = this.unprojectOnTbSurface(\n                this.camera,\n                _center.x,\n                _center.y,\n                this.domElement,\n                this._tbRadius,\n              )\n              if (rayDir !== undefined) {\n                this._currentCursorPosition.copy(rayDir)\n              }\n\n              const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition)\n              const angle = this._startCursorPosition.angleTo(this._currentCursorPosition)\n              const amount = Math.max(distance / this._tbRadius, angle) //effective rotation angle\n\n              this.applyTransformMatrix(\n                this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount),\n              )\n\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent\n                this._timeCurrent = performance.now()\n                this._anglePrev = this._angleCurrent\n                this._angleCurrent = amount\n                this._cursorPosPrev.copy(this._cursorPosCurr)\n                this._cursorPosCurr.copy(this._currentCursorPosition)\n                this._wPrev = this._wCurr\n                this._wCurr = this.calculateAngularSpeed(\n                  this._anglePrev,\n                  this._angleCurrent,\n                  this._timePrev,\n                  this._timeCurrent,\n                )\n              }\n            }\n          }\n\n          break\n\n        case STATE.SCALE:\n          if (this.enableZoom) {\n            if (restart) {\n              //switch to zoom operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n              this._currentCursorPosition.copy(this._startCursorPosition)\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with zoom operation\n              const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n              let size = 1\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches)\n              }\n\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n            }\n          }\n\n          break\n\n        case STATE.FOV:\n          if (this.enableZoom && this.camera instanceof PerspectiveCamera) {\n            if (restart) {\n              //switch to fov operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n              this._currentCursorPosition.copy(this._startCursorPosition)\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with fov operation\n              const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n              let size = 1\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches)\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n              const x = this._v3_1.distanceTo(this._gizmos.position)\n              let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n              const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5)\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n              //check min and max fov\n              newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov)\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n              size = x / newDistance\n              this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n              this.setFov(newFov)\n              this.applyTransformMatrix(this.applyScale(size, this._v3_2, false))\n\n              //adjusting distance\n              const direction = this._gizmos.position\n                .clone()\n                .sub(this.camera.position)\n                .normalize()\n                .multiplyScalar(newDistance / x)\n              this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n            }\n          }\n\n          break\n      }\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onSinglePanEnd = (): void => {\n    if (this._state == STATE.ROTATE) {\n      if (!this.enableRotate) {\n        return\n      }\n\n      if (this.enableAnimations) {\n        //perform rotation animation\n        const deltaTime = performance.now() - this._timeCurrent\n        if (deltaTime < 120) {\n          const w = Math.abs((this._wPrev + this._wCurr) / 2)\n\n          const self = this\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_ROTATE, true)\n            const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr)\n\n            self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax))\n          })\n        } else {\n          //cursor has been standing still for over 120 ms since last movement\n          this.updateTbState(STATE.IDLE, false)\n          this.activateGizmos(false)\n          // @ts-ignore\n          this.dispatchEvent(_changeEvent)\n        }\n      } else {\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n      this.updateTbState(STATE.IDLE, false)\n\n      if (this.enableGrid) {\n        this.disposeGrid()\n      }\n\n      this.activateGizmos(false)\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onDoubleTap = (event: PointerEvent): void => {\n    if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.setCenter(event.clientX, event.clientY)\n      const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera)\n\n      if (hitP && this.enableAnimations) {\n        const self = this\n        if (this._animationId != -1) {\n          window.cancelAnimationFrame(this._animationId)\n        }\n\n        this._timeStart = -1\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.updateTbState(STATE.ANIMATION_FOCUS, true)\n          self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState)\n        })\n      } else if (hitP && !this.enableAnimations) {\n        this.updateTbState(STATE.FOCUS, true)\n        this.focus(hitP, this.scaleFactor)\n        this.updateTbState(STATE.IDLE, false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onDoublePanStart = (): void => {\n    if (this.enabled && this.enablePan && this.camera && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.PAN, true)\n\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n\n      const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true)\n      if (rayDir !== undefined) {\n        this._startCursorPosition.copy(rayDir)\n      }\n      this._currentCursorPosition.copy(this._startCursorPosition)\n\n      this.activateGizmos(false)\n    }\n  }\n\n  private onDoublePanMove = (): void => {\n    if (this.enabled && this.enablePan && this.camera && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n\n      if (this._state != STATE.PAN) {\n        this.updateTbState(STATE.PAN, true)\n        this._startCursorPosition.copy(this._currentCursorPosition)\n      }\n\n      const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true)\n      if (rayDir !== undefined) this._currentCursorPosition.copy(rayDir)\n      this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true))\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onDoublePanEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onRotateStart = (): void => {\n    if (this.enabled && this.enableRotate) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.ZROTATE, true)\n\n      //this._startFingerRotation = event.rotation;\n\n      this._startFingerRotation =\n        this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) +\n        this.getAngle(this._touchStart[1], this._touchStart[0])\n      this._currentFingerRotation = this._startFingerRotation\n\n      this.camera?.getWorldDirection(this._rotationAxis) //rotation axis\n\n      if (!this.enablePan && !this.enableZoom) {\n        this.activateGizmos(true)\n      }\n    }\n  }\n\n  private onRotateMove = (): void => {\n    if (this.enabled && this.enableRotate && this.camera && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n      let rotationPoint\n\n      if (this._state != STATE.ZROTATE) {\n        this.updateTbState(STATE.ZROTATE, true)\n        this._startFingerRotation = this._currentFingerRotation\n      }\n\n      //this._currentFingerRotation = event.rotation;\n      this._currentFingerRotation =\n        this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) +\n        this.getAngle(this._touchStart[1], this._touchStart[0])\n\n      if (!this.enablePan) {\n        rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState)\n      } else if (this.camera) {\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n        rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n          ?.applyQuaternion(this.camera.quaternion)\n          .multiplyScalar(1 / this.camera.zoom)\n          .add(this._v3_2)\n      }\n\n      const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation)\n\n      if (rotationPoint !== undefined) {\n        this.applyTransformMatrix(this.zRotate(rotationPoint, amount))\n      }\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onRotateEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    this.activateGizmos(false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onPinchStart = (): void => {\n    if (this.enabled && this.enableZoom) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n      this.updateTbState(STATE.SCALE, true)\n\n      this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1])\n      this._currentFingerDistance = this._startFingerDistance\n\n      this.activateGizmos(false)\n    }\n  }\n\n  private onPinchMove = (): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n      const minDistance = 12 //minimum distance between fingers (in css pixels)\n\n      if (this._state != STATE.SCALE) {\n        this._startFingerDistance = this._currentFingerDistance\n        this.updateTbState(STATE.SCALE, true)\n      }\n\n      this._currentFingerDistance = Math.max(\n        this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]),\n        minDistance * this._devPxRatio,\n      )\n      const amount = this._currentFingerDistance / this._startFingerDistance\n\n      let scalePoint\n\n      if (!this.enablePan) {\n        scalePoint = this._gizmos.position\n      } else {\n        if (this.camera instanceof OrthographicCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            ?.applyQuaternion(this.camera.quaternion)\n            .multiplyScalar(1 / this.camera.zoom)\n            .add(this._gizmos.position)\n        } else if (this.camera instanceof PerspectiveCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            ?.applyQuaternion(this.camera.quaternion)\n            .add(this._gizmos.position)\n        }\n      }\n\n      if (scalePoint !== undefined) {\n        this.applyTransformMatrix(this.applyScale(amount, scalePoint))\n      }\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onPinchEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onTriplePanStart = (): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.SCALE, true)\n\n      //const center = event.center;\n      let clientX = 0\n      let clientY = 0\n      const nFingers = this._touchCurrent.length\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX\n        clientY += this._touchCurrent[i].clientY\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers)\n\n      this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n      this._currentCursorPosition.copy(this._startCursorPosition)\n    }\n  }\n\n  private onTriplePanMove = (): void => {\n    if (this.enabled && this.enableZoom && this.camera && this.domElement) {\n      //\t  fov / 2\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\tx\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t\t| _ _ _\\\n      //\t\t\ty\n\n      //const center = event.center;\n      let clientX = 0\n      let clientY = 0\n      const nFingers = this._touchCurrent.length\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX\n        clientY += this._touchCurrent[i].clientY\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers)\n\n      const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n      this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n      const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n      let size = 1\n\n      if (movement < 0) {\n        size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n      } else if (movement > 0) {\n        size = Math.pow(this.scaleFactor, movement * screenNotches)\n      }\n\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n      const x = this._v3_1.distanceTo(this._gizmos.position)\n      let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n      //check min and max distance\n      xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n      const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5)\n\n      //calculate new fov\n      let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n      //check min and max fov\n      newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov)\n\n      const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n      size = x / newDistance\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n      this.setFov(newFov)\n      this.applyTransformMatrix(this.applyScale(size, this._v3_2, false))\n\n      //adjusting distance\n      const direction = this._gizmos.position\n        .clone()\n        .sub(this.camera.position)\n        .normalize()\n        .multiplyScalar(newDistance / x)\n      this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onTriplePanEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n    //this.dispatchEvent( _changeEvent );\n  }\n\n  /**\n   * Set _center's x/y coordinates\n   * @param {Number} clientX\n   * @param {Number} clientY\n   */\n  private setCenter = (clientX: number, clientY: number): void => {\n    _center.x = clientX\n    _center.y = clientY\n  }\n\n  /**\n   * Set default mouse actions\n   */\n  private initializeMouseActions = (): void => {\n    this.setMouseAction('PAN', 0, 'CTRL')\n    this.setMouseAction('PAN', 2)\n\n    this.setMouseAction('ROTATE', 0)\n\n    this.setMouseAction('ZOOM', 'WHEEL')\n    this.setMouseAction('ZOOM', 1)\n\n    this.setMouseAction('FOV', 'WHEEL', 'SHIFT')\n    this.setMouseAction('FOV', 1, 'SHIFT')\n  }\n\n  /**\n   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n   * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n   */\n  private setMouseAction = (operation: Operation, mouse: MouseButtonType, key: ModifierKey | null = null): boolean => {\n    const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV']\n    const mouseInput = [0, 1, 2, 'WHEEL']\n    const keyInput = ['CTRL', 'SHIFT', null]\n    let state\n\n    if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n      //invalid parameters\n      return false\n    }\n\n    if (mouse == 'WHEEL') {\n      if (operation != 'ZOOM' && operation != 'FOV') {\n        //cannot associate 2D operation to 1D input\n        return false\n      }\n    }\n\n    switch (operation) {\n      case 'PAN':\n        state = STATE.PAN\n        break\n\n      case 'ROTATE':\n        state = STATE.ROTATE\n        break\n\n      case 'ZOOM':\n        state = STATE.SCALE\n        break\n\n      case 'FOV':\n        state = STATE.FOV\n        break\n    }\n\n    const action = {\n      operation: operation,\n      mouse: mouse,\n      key: key,\n      state: state,\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n        this.mouseActions.splice(i, 1, action)\n        return true\n      }\n    }\n\n    this.mouseActions.push(action)\n    return true\n  }\n\n  /**\n   * Return the operation associated to a mouse/keyboard combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns The operation if it has been found, null otherwise\n   */\n  private getOpFromAction = (mouse: MouseButtonType, key: ModifierKey | null): Operation | null => {\n    let action\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i]\n      if (action.mouse == mouse && action.key == key) {\n        return action.operation\n      }\n    }\n\n    if (key) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i]\n        if (action.mouse == mouse && action.key == null) {\n          return action.operation\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n   * @param {Number} mouse Mouse button\n   * @param {String} key Keyboard modifier\n   * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n   */\n  private getOpStateFromAction = (mouse: MouseButtonType, key: ModifierKey | null): Symbol | null => {\n    let action\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i]\n      if (action.mouse == mouse && action.key == key) {\n        return action.state\n      }\n    }\n\n    if (key) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i]\n        if (action.mouse == mouse && action.key == null) {\n          return action.state\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Calculate the angle between two pointers\n   * @param {PointerEvent} p1\n   * @param {PointerEvent} p2\n   * @returns {Number} The angle between two pointers in degrees\n   */\n  private getAngle = (p1: PointerEvent, p2: PointerEvent): number => {\n    return (Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180) / Math.PI\n  }\n\n  /**\n   * Update a PointerEvent inside current pointerevents array\n   * @param {PointerEvent} event\n   */\n  private updateTouchEvent = (event: PointerEvent): void => {\n    for (let i = 0; i < this._touchCurrent.length; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1, event)\n        break\n      }\n    }\n  }\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  private applyTransformMatrix(transformation: Transformation | undefined): void {\n    if (transformation?.camera && this.camera) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera)\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n      this.camera.updateMatrix()\n\n      //update camera up vector\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion)\n      }\n    }\n\n    if (transformation?.gizmos) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos)\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n      this._gizmos.updateMatrix()\n    }\n\n    if (\n      (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) &&\n      this.camera\n    ) {\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position)\n\n        const bb = new Box3()\n        bb.setFromObject(this._gizmos)\n        const sphere = new Sphere()\n        bb.getBoundingSphere(sphere)\n\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length())\n        const regularNearPosition = cameraDistance - this._initialNear\n\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition)\n        this.camera.near = cameraDistance - minNearPos\n\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length())\n        const regularFarPosition = cameraDistance - this._initialFar\n\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition)\n        this.camera.far = cameraDistance - minFarPos\n\n        this.camera.updateProjectionMatrix()\n      } else {\n        let update = false\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear\n          update = true\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar\n          update = true\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix()\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n  private calculateAngularSpeed = (p0: number, p1: number, t0: number, t1: number): number => {\n    const s = p1 - p0\n    const t = (t1 - t0) / 1000\n    if (t == 0) {\n      return 0\n    }\n\n    return s / t\n  }\n\n  /**\n   * Calculate the distance between two pointers\n   * @param {PointerEvent} p0 The first pointer\n   * @param {PointerEvent} p1 The second pointer\n   * @returns {number} The distance between the two pointers\n   */\n  private calculatePointersDistance = (p0: PointerEvent, p1: PointerEvent): number => {\n    return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2))\n  }\n\n  /**\n   * Calculate the rotation axis as the vector perpendicular between two vectors\n   * @param {Vector3} vec1 The first vector\n   * @param {Vector3} vec2 The second vector\n   * @returns {Vector3} The normalized rotation axis\n   */\n  private calculateRotationAxis = (vec1: Vector3, vec2: Vector3): Vector3 => {\n    this._rotationMatrix.extractRotation(this._cameraMatrixState)\n    this._quat.setFromRotationMatrix(this._rotationMatrix)\n\n    this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat)\n    return this._rotationAxis.normalize().clone()\n  }\n\n  /**\n   * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n   * @param {Camera} camera\n   * @returns {Number} The trackball radius\n   */\n  private calculateTbRadius = (camera: Camera): number | undefined => {\n    const factor = 0.67\n    const distance = camera.position.distanceTo(this._gizmos.position)\n\n    if (camera instanceof PerspectiveCamera) {\n      const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5 //vertical fov/2 in radians\n      const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)) //horizontal fov/2 in radians\n      return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor\n    } else if (camera instanceof OrthographicCamera) {\n      return Math.min(camera.top, camera.right) * factor\n    }\n  }\n\n  /**\n   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n   * @param {Vector3} point The point of interest\n   * @param {Number} size Scale factor\n   * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n   */\n  private focus = (point: Vector3, size: number, amount = 1): void => {\n    if (this.camera) {\n      const focusPoint = point.clone()\n\n      //move center of camera (along with gizmos) towards point of interest\n      focusPoint.sub(this._gizmos.position).multiplyScalar(amount)\n      this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z)\n\n      const gizmoStateTemp = this._gizmoMatrixState.clone()\n      this._gizmoMatrixState.premultiply(this._translationMatrix)\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n      const cameraStateTemp = this._cameraMatrixState.clone()\n      this._cameraMatrixState.premultiply(this._translationMatrix)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n\n      //apply zoom\n      if (this.enableZoom) {\n        this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n      }\n\n      this._gizmoMatrixState.copy(gizmoStateTemp)\n      this._cameraMatrixState.copy(cameraStateTemp)\n    }\n  }\n\n  /**\n   * Draw a grid and add it to the scene\n   */\n  private drawGrid = (): void => {\n    if (this.scene) {\n      const color = 0x888888\n      const multiplier = 3\n      let size, divisions, maxLength, tick\n\n      if (this.camera instanceof OrthographicCamera) {\n        const width = this.camera.right - this.camera.left\n        const height = this.camera.bottom - this.camera.top\n\n        maxLength = Math.max(width, height)\n        tick = maxLength / 20\n\n        size = (maxLength / this.camera.zoom) * multiplier\n        divisions = (size / tick) * this.camera.zoom\n      } else if (this.camera instanceof PerspectiveCamera) {\n        const distance = this.camera.position.distanceTo(this._gizmos.position)\n        const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5\n        const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV))\n\n        maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2\n        tick = maxLength / 20\n\n        size = maxLength * multiplier\n        divisions = size / tick\n      }\n\n      if (this._grid == null && this.camera) {\n        this._grid = new GridHelper(size, divisions, color, color)\n        this._grid.position.copy(this._gizmos.position)\n        this._gridPosition.copy(this._grid.position)\n        this._grid.quaternion.copy(this.camera.quaternion)\n        this._grid.rotateX(Math.PI * 0.5)\n\n        this.scene.add(this._grid)\n      }\n    }\n  }\n\n  public connect = (domElement: HTMLElement): void => {\n    // https://github.com/mrdoob/three.js/issues/20575\n\n    if ((domElement as any) === document) {\n      console.error(\n        'THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.',\n      )\n    }\n    this.domElement = domElement\n    // disables touch scroll\n    // touch-action needs to be defined for pointer events to work on mobile\n    // https://stackoverflow.com/a/48254578\n    this.domElement.style.touchAction = 'none'\n    this.domElement.addEventListener('contextmenu', this.onContextMenu)\n    this.domElement.addEventListener('pointerdown', this.onPointerDown)\n    this.domElement.addEventListener('pointercancel', this.onPointerCancel)\n    this.domElement.addEventListener('wheel', this.onWheel)\n  }\n\n  /**\n   * Remove all listeners, stop animations and clean scene\n   */\n  public dispose = (): void => {\n    if (this._animationId != -1) {\n      window.cancelAnimationFrame(this._animationId)\n    }\n\n    this.domElement?.removeEventListener('pointerdown', this.onPointerDown)\n    this.domElement?.removeEventListener('pointercancel', this.onPointerCancel)\n    this.domElement?.removeEventListener('wheel', this.onWheel)\n    this.domElement?.removeEventListener('contextmenu', this.onContextMenu)\n\n    window.removeEventListener('pointermove', this.onPointerMove)\n    window.removeEventListener('pointerup', this.onPointerUp)\n\n    window.removeEventListener('resize', this.onWindowResize)\n\n    this.scene?.remove(this._gizmos)\n    this.disposeGrid()\n  }\n\n  /**\n   * remove the grid from the scene\n   */\n  private disposeGrid = (): void => {\n    if (this._grid && this.scene) {\n      this.scene.remove(this._grid)\n      this._grid = null\n    }\n  }\n\n  /**\n   * Compute the easing out cubic function for ease out effect in animation\n   * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n   * @returns {Number} Result of easing out cubic at time t\n   */\n  private easeOutCubic = (t: number): number => {\n    return 1 - Math.pow(1 - t, 3)\n  }\n\n  /**\n   * Make rotation gizmos more or less visible\n   * @param {Boolean} isActive If true, make gizmos more visible\n   */\n  private activateGizmos = (isActive: boolean): void => {\n    for (const gizmo of this._gizmos.children) {\n      ;(gizmo as Mesh<BufferGeometry, Material>).material.setValues({ opacity: isActive ? 1 : 0.6 })\n    }\n  }\n\n  /**\n   * Calculate the cursor position in NDC\n   * @param {number} x Cursor horizontal coordinate within the canvas\n   * @param {number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor normalized position inside the canvas\n   */\n  private getCursorNDC = (cursorX: number, cursorY: number, canvas: HTMLElement): Vector2 => {\n    const canvasRect = canvas.getBoundingClientRect()\n    this._v2_1.setX(((cursorX - canvasRect.left) / canvasRect.width) * 2 - 1)\n    this._v2_1.setY(((canvasRect.bottom - cursorY) / canvasRect.height) * 2 - 1)\n    return this._v2_1.clone()\n  }\n\n  /**\n   * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n   * @param {Number} x Cursor horizontal coordinate within the canvas\n   * @param {Number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor position inside the canvas\n   */\n  private getCursorPosition = (cursorX: number, cursorY: number, canvas: HTMLElement): Vector2 => {\n    this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n    if (this.camera instanceof OrthographicCamera) {\n      this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5\n      this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5\n    }\n    return this._v2_1.clone()\n  }\n\n  /**\n   * Set the camera to be controlled\n   * @param {Camera} camera The virtual camera to be controlled\n   */\n  private setCamera = (camera: Camera | null): void => {\n    if (camera) {\n      camera.lookAt(this.target)\n      camera.updateMatrix()\n\n      //setting state\n      if (camera instanceof PerspectiveCamera) {\n        this._fov0 = camera.fov\n        this._fovState = camera.fov\n      }\n\n      this._cameraMatrixState0.copy(camera.matrix)\n      this._cameraMatrixState.copy(this._cameraMatrixState0)\n      this._cameraProjectionState.copy(camera.projectionMatrix)\n      this._zoom0 = camera.zoom\n      this._zoomState = this._zoom0\n\n      this._initialNear = camera.near\n      this._nearPos0 = camera.position.distanceTo(this.target) - camera.near\n      this._nearPos = this._initialNear\n\n      this._initialFar = camera.far\n      this._farPos0 = camera.position.distanceTo(this.target) - camera.far\n      this._farPos = this._initialFar\n\n      this._up0.copy(camera.up)\n      this._upState.copy(camera.up)\n\n      this.camera = camera\n\n      this.camera.updateProjectionMatrix()\n\n      //making gizmos\n      const tbRadius = this.calculateTbRadius(camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n    }\n  }\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  public setGizmosVisible(value: boolean): void {\n    this._gizmos.visible = value\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n  private makeGizmos = (tbCenter: Vector3, tbRadius: number): void => {\n    // @ts-ignore\n    const curve = new EllipseCurve(0, 0, tbRadius, tbRadius)\n    const points = curve.getPoints(this._curvePts)\n\n    //geometry\n    const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n    //material\n    const curveMaterialX = new LineBasicMaterial({ color: 0xff8080, fog: false, transparent: true, opacity: 0.6 })\n    const curveMaterialY = new LineBasicMaterial({ color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 })\n    const curveMaterialZ = new LineBasicMaterial({ color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 })\n\n    //line\n    const gizmoX = new Line(curveGeometry, curveMaterialX)\n    const gizmoY = new Line(curveGeometry, curveMaterialY)\n    const gizmoZ = new Line(curveGeometry, curveMaterialZ)\n\n    const rotation = Math.PI * 0.5\n    gizmoX.rotation.x = rotation\n    gizmoY.rotation.y = rotation\n\n    //setting state\n    this._gizmoMatrixState0.identity().setPosition(tbCenter)\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0)\n\n    if (this.camera && this.camera.zoom != 1) {\n      //adapt gizmos size to camera zoom\n      const size = 1 / this.camera.zoom\n      this._scaleMatrix.makeScale(size, size, size)\n      this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z)\n\n      this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix)\n      this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z)\n      this._gizmoMatrixState.premultiply(this._translationMatrix)\n    }\n\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n    this._gizmos.clear()\n\n    this._gizmos.add(gizmoX)\n    this._gizmos.add(gizmoY)\n    this._gizmos.add(gizmoZ)\n  }\n\n  /**\n   * Perform animation for focus operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} point Point of interest for focus operation\n   * @param {Matrix4} cameraMatrix Camera matrix\n   * @param {Matrix4} gizmoMatrix Gizmos matrix\n   */\n  private onFocusAnim = (time: number, point: Vector3, cameraMatrix: Matrix4, gizmoMatrix: Matrix4): void => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._timeStart = time\n    }\n\n    if (this._state == STATE.ANIMATION_FOCUS) {\n      const deltaTime = time - this._timeStart\n      const animTime = deltaTime / this.focusAnimationTime\n\n      this._gizmoMatrixState.copy(gizmoMatrix)\n\n      if (animTime >= 1) {\n        //animation end\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n        this.focus(point, this.scaleFactor)\n\n        this._timeStart = -1\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      } else {\n        const amount = this.easeOutCubic(animTime)\n        const size = 1 - amount + this.scaleFactor * amount\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n        this.focus(point, size, amount)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n        const self = this\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone())\n        })\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1\n      this._timeStart = -1\n    }\n  }\n\n  /**\n   * Perform animation for rotation operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} rotationAxis Rotation axis\n   * @param {number} w0 Initial angular velocity\n   */\n  private onRotationAnim = (time: number, rotationAxis: Vector3, w0: number): void => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._anglePrev = 0\n      this._angleCurrent = 0\n      this._timeStart = time\n    }\n\n    if (this._state == STATE.ANIMATION_ROTATE) {\n      //w = w0 + alpha * t\n      const deltaTime = (time - this._timeStart) / 1000\n      const w = w0 + -this.dampingFactor * deltaTime\n\n      if (w > 0) {\n        //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n        this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0\n        this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent))\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n        const self = this\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onRotationAnim(t, rotationAxis, w0)\n        })\n      } else {\n        this._animationId = -1\n        this._timeStart = -1\n\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1\n      this._timeStart = -1\n\n      if (this._state != STATE.ROTATE) {\n        this.activateGizmos(false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    }\n  }\n\n  /**\n   * Perform pan operation moving camera between two points\n   * @param {Vector3} p0 Initial point\n   * @param {Vector3} p1 Ending point\n   * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n   */\n  private pan = (p0: Vector3, p1: Vector3, adjust = false): Transformation => {\n    if (this.camera) {\n      const movement = p0.clone().sub(p1)\n\n      if (this.camera instanceof OrthographicCamera) {\n        //adjust movement amount\n        movement.multiplyScalar(1 / this.camera.zoom)\n      }\n\n      if (this.camera instanceof PerspectiveCamera && adjust) {\n        //adjust movement amount\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState0) //camera's initial position\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0) //gizmo's initial position\n        const distanceFactor =\n          this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position)\n        movement.multiplyScalar(1 / distanceFactor)\n      }\n\n      this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion)\n\n      this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z)\n\n      this.setTransformationMatrices(this._m4_1, this._m4_1)\n    }\n    return _transformation\n  }\n\n  /**\n   * Reset trackball\n   */\n  public reset = (): void => {\n    if (this.camera) {\n      this.camera.zoom = this._zoom0\n\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = this._fov0\n      }\n\n      this.camera.near = this._nearPos\n      this.camera.far = this._farPos\n      this._cameraMatrixState.copy(this._cameraMatrixState0)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n      this.camera.up.copy(this._up0)\n\n      this.camera.updateMatrix()\n      this.camera.updateProjectionMatrix()\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0)\n      this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n      this._gizmos.updateMatrix()\n\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this._gizmos.position, this._tbRadius)\n\n      this.camera.lookAt(this._gizmos.position)\n\n      this.updateTbState(STATE.IDLE, false)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  /**\n   * Rotate the camera around an axis passing by trackball's center\n   * @param {Vector3} axis Rotation axis\n   * @param {number} angle Angle in radians\n   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n   */\n  private rotate = (axis: Vector3, angle: number): Transformation => {\n    const point = this._gizmos.position //rotation center\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z)\n    this._rotationMatrix.makeRotationAxis(axis, -angle)\n\n    //rotate camera\n    this._m4_1.makeTranslation(point.x, point.y, point.z)\n    this._m4_1.multiply(this._rotationMatrix)\n    this._m4_1.multiply(this._translationMatrix)\n\n    this.setTransformationMatrices(this._m4_1)\n\n    return _transformation\n  }\n\n  public copyState = (): void => {\n    if (this.camera) {\n      const state = JSON.stringify(\n        this.camera instanceof OrthographicCamera\n          ? {\n              arcballState: {\n                cameraFar: this.camera.far,\n                cameraMatrix: this.camera.matrix,\n                cameraNear: this.camera.near,\n                cameraUp: this.camera.up,\n                cameraZoom: this.camera.zoom,\n                gizmoMatrix: this._gizmos.matrix,\n              },\n            }\n          : {\n              arcballState: {\n                cameraFar: this.camera.far,\n                cameraFov: this.camera.fov,\n                cameraMatrix: this.camera.matrix,\n                cameraNear: this.camera.near,\n                cameraUp: this.camera.up,\n                cameraZoom: this.camera.zoom,\n                gizmoMatrix: this._gizmos.matrix,\n              },\n            },\n      )\n\n      navigator.clipboard.writeText(state)\n    }\n  }\n\n  public pasteState = (): void => {\n    const self = this\n    navigator.clipboard.readText().then(function resolved(value) {\n      self.setStateFromJSON(value)\n    })\n  }\n\n  /**\n   * Save the current state of the control. This can later be recovered with .reset\n   */\n  public saveState = (): void => {\n    if (!this.camera) return\n\n    this._cameraMatrixState0.copy(this.camera.matrix)\n    this._gizmoMatrixState0.copy(this._gizmos.matrix)\n    this._nearPos = this.camera.near\n    this._farPos = this.camera.far\n    this._zoom0 = this.camera.zoom\n    this._up0.copy(this.camera.up)\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._fov0 = this.camera.fov\n    }\n  }\n\n  /**\n   * Perform uniform scale operation around a given point\n   * @param {Number} size Scale factor\n   * @param {Vector3} point Point around which scale\n   * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n   */\n  private applyScale = (size: number, point: Vector3, scaleGizmos = true): Transformation | undefined => {\n    if (!this.camera) return\n\n    const scalePoint = point.clone()\n    let sizeInverse = 1 / size\n\n    if (this.camera instanceof OrthographicCamera) {\n      //camera zoom\n      this.camera.zoom = this._zoomState\n      this.camera.zoom *= size\n\n      //check min and max zoom\n      if (this.camera.zoom > this.maxZoom) {\n        this.camera.zoom = this.maxZoom\n        sizeInverse = this._zoomState / this.maxZoom\n      } else if (this.camera.zoom < this.minZoom) {\n        this.camera.zoom = this.minZoom\n        sizeInverse = this._zoomState / this.minZoom\n      }\n\n      this.camera.updateProjectionMatrix()\n\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState) //gizmos position\n\n      //scale gizmos so they appear in the same spot having the same dimension\n      this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse)\n      this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z)\n\n      this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix)\n      this._m4_2.multiply(this._translationMatrix)\n\n      //move camera and gizmos to obtain pinch effect\n      scalePoint.sub(this._v3_1)\n\n      const amount = scalePoint.clone().multiplyScalar(sizeInverse)\n      scalePoint.sub(amount)\n\n      this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z)\n      this._m4_2.premultiply(this._m4_1)\n\n      this.setTransformationMatrices(this._m4_1, this._m4_2)\n      return _transformation\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n      //move camera\n      let distance = this._v3_1.distanceTo(scalePoint)\n      let amount = distance - distance * sizeInverse\n\n      //check min and max distance\n      const newDistance = distance - amount\n      if (newDistance < this.minDistance) {\n        sizeInverse = this.minDistance / distance\n        amount = distance - distance * sizeInverse\n      } else if (newDistance > this.maxDistance) {\n        sizeInverse = this.maxDistance / distance\n        amount = distance - distance * sizeInverse\n      }\n\n      let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount)\n\n      this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n\n      if (scaleGizmos) {\n        //scale gizmos so they appear in the same spot having the same dimension\n        const pos = this._v3_2\n\n        distance = pos.distanceTo(scalePoint)\n        amount = distance - distance * sizeInverse\n        direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount)\n\n        this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z)\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse)\n\n        this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix)\n        this._m4_2.multiply(this._scaleMatrix)\n\n        this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z)\n\n        this._m4_2.multiply(this._translationMatrix)\n        this.setTransformationMatrices(this._m4_1, this._m4_2)\n      } else {\n        this.setTransformationMatrices(this._m4_1)\n      }\n\n      return _transformation\n    }\n  }\n\n  /**\n   * Set camera fov\n   * @param {Number} value fov to be setted\n   */\n  private setFov = (value: number): void => {\n    if (this.camera instanceof PerspectiveCamera) {\n      this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov)\n      this.camera.updateProjectionMatrix()\n    }\n  }\n\n  /**\n   * Set the trackball's center point\n   * @param {Number} x X coordinate\n   * @param {Number} y Y coordinate\n   * @param {Number} z Z coordinate\n   */\n  public setTarget = (x: number, y: number, z: number): void => {\n    if (this.camera) {\n      this.target.set(x, y, z)\n      this._gizmos.position.set(x, y, z) //for correct radius calculation\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n      this.camera.lookAt(this.target)\n    }\n  }\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  private setTransformationMatrices(camera: Matrix4 | null = null, gizmos: Matrix4 | null = null): void {\n    if (camera) {\n      if (_transformation.camera) {\n        _transformation.camera.copy(camera)\n      } else {\n        _transformation.camera = camera.clone()\n      }\n    } else {\n      _transformation.camera = null\n    }\n\n    if (gizmos) {\n      if (_transformation.gizmos) {\n        _transformation.gizmos.copy(gizmos)\n      } else {\n        _transformation.gizmos = gizmos.clone()\n      }\n    } else {\n      _transformation.gizmos = null\n    }\n  }\n\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n  private zRotate = (point: Vector3, angle: number): Transformation => {\n    this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle)\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z)\n\n    this._m4_1.makeTranslation(point.x, point.y, point.z)\n    this._m4_1.multiply(this._rotationMatrix)\n    this._m4_1.multiply(this._translationMatrix)\n\n    this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point) //vector from rotation center to gizmos position\n    this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle) //apply rotation\n    this._v3_2.sub(this._v3_1)\n\n    this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z)\n\n    this.setTransformationMatrices(this._m4_1, this._m4_2)\n    return _transformation\n  }\n\n  /**\n   * Unproject the cursor on the 3D object surface\n   * @param {Vector2} cursor Cursor coordinates in NDC\n   * @param {Camera} camera Virtual camera\n   * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n   */\n  private unprojectOnObj = (cursor: Vector2, camera: Camera): Vector3 | null => {\n    if (!this.scene) return null\n\n    const raycaster = new Raycaster()\n    raycaster.near = camera.near\n    raycaster.far = camera.far\n    raycaster.setFromCamera(cursor, camera)\n\n    const intersect = raycaster.intersectObjects(this.scene.children, true)\n    for (let i = 0; i < intersect.length; i++) {\n      if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face) {\n        return intersect[i].point.clone()\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Unproject the cursor on the trackball surface\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {number} tbRadius The trackball radius\n   * @returns {Vector3} The unprojected point on the trackball surface\n   */\n  private unprojectOnTbSurface = (\n    camera: Camera,\n    cursorX: number,\n    cursorY: number,\n    canvas: HTMLElement,\n    tbRadius: number,\n  ): Vector3 | undefined => {\n    if (camera instanceof OrthographicCamera) {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas))\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0)\n\n      const x2 = Math.pow(this._v2_1.x, 2)\n      const y2 = Math.pow(this._v2_1.y, 2)\n      const r2 = Math.pow(this._tbRadius, 2)\n\n      if (x2 + y2 <= r2 * 0.5) {\n        //intersection with sphere\n        this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)))\n      } else {\n        //intersection with hyperboloid\n        this._v3_1.setZ((r2 * 0.5) / Math.sqrt(x2 + y2))\n      }\n\n      return this._v3_1\n    }\n\n    if (camera instanceof PerspectiveCamera) {\n      //unproject cursor on the near plane\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1)\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse)\n\n      const rayDir = this._v3_1.clone().normalize() //unprojected ray direction\n      const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position)\n      const radius2 = Math.pow(tbRadius, 2)\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2))\n\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius)\n        return rayDir\n      }\n\n      const m = h / l\n      const q = cameraGizmoDistance\n\n      /*\n       * calculate intersection point between unprojected ray and trackball surface\n       *|y = m * x + q\n       *|x^2 + y^2 = r^2\n       *\n       * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n       */\n      let a = Math.pow(m, 2) + 1\n      let b = 2 * m * q\n      let c = Math.pow(q, 2) - radius2\n      let delta = Math.pow(b, 2) - 4 * a * c\n\n      if (delta >= 0) {\n        //intersection with sphere\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a))\n        this._v2_1.setY(m * this._v2_1.x + q)\n\n        const angle = MathUtils.RAD2DEG * this._v2_1.angle()\n\n        if (angle >= 45) {\n          //if angle between intersection point and X' axis is >= 45, return that point\n          //otherwise, calculate intersection point with hyperboloid\n\n          const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2))\n          rayDir.multiplyScalar(rayLength)\n          rayDir.z += cameraGizmoDistance\n          return rayDir\n        }\n      }\n\n      //intersection with hyperboloid\n      /*\n       *|y = m * x + q\n       *|y = (1 / x) * (r^2 / 2)\n       *\n       * m * x^2 + q * x - r^2 / 2 = 0\n       */\n\n      a = m\n      b = q\n      c = -radius2 * 0.5\n      delta = Math.pow(b, 2) - 4 * a * c\n      this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a))\n      this._v2_1.setY(m * this._v2_1.x + q)\n\n      const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2))\n\n      rayDir.multiplyScalar(rayLength)\n      rayDir.z += cameraGizmoDistance\n      return rayDir\n    }\n  }\n\n  /**\n   * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n   * @returns {Vector3} The unprojected point on the trackball plane\n   */\n  private unprojectOnTbPlane = (\n    camera: Camera,\n    cursorX: number,\n    cursorY: number,\n    canvas: HTMLElement,\n    initialDistance = false,\n  ): Vector3 | undefined => {\n    if (camera instanceof OrthographicCamera) {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas))\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0)\n\n      return this._v3_1.clone()\n    }\n\n    if (camera instanceof PerspectiveCamera) {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n\n      //unproject cursor on the near plane\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1)\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse)\n\n      const rayDir = this._v3_1.clone().normalize() //unprojected ray direction\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2))\n      let cameraGizmoDistance\n\n      if (initialDistance) {\n        cameraGizmoDistance = this._v3_1\n          .setFromMatrixPosition(this._cameraMatrixState0)\n          .distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0))\n      } else {\n        cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position)\n      }\n\n      /*\n       * calculate intersection point between unprojected ray and the plane\n       *|y = mx + q\n       *|y = 0\n       *\n       * x = -q/m\n       */\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(0, 0, 0)\n        return rayDir\n      }\n\n      const m = h / l\n      const q = cameraGizmoDistance\n      const x = -q / m\n\n      const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2))\n      rayDir.multiplyScalar(rayLength)\n      rayDir.z = 0\n      return rayDir\n    }\n  }\n\n  /**\n   * Update camera and gizmos state\n   */\n  private updateMatrixState = (): void => {\n    if (!this.camera) return\n\n    //update camera and gizmos state\n    this._cameraMatrixState.copy(this.camera.matrix)\n    this._gizmoMatrixState.copy(this._gizmos.matrix)\n\n    if (this.camera instanceof OrthographicCamera) {\n      this._cameraProjectionState.copy(this.camera.projectionMatrix)\n      this.camera.updateProjectionMatrix()\n      this._zoomState = this.camera.zoom\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._fovState = this.camera.fov\n    }\n  }\n\n  /**\n   * Update the trackball FSA\n   * @param {STATE} newState New state of the FSA\n   * @param {Boolean} updateMatrices If matriices state should be updated\n   */\n  private updateTbState = (newState: Symbol, updateMatrices: boolean): void => {\n    this._state = newState\n    if (updateMatrices) {\n      this.updateMatrixState()\n    }\n  }\n\n  public update = (): void => {\n    const EPS = 0.000001\n\n    // Update target and gizmos state\n    if (!this.target.equals(this._currentTarget) && this.camera) {\n      this._gizmos.position.set(this.target.x, this.target.y, this.target.z) //for correct radius calculation\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n      this._currentTarget.copy(this.target)\n    }\n\n    if (!this.camera) return\n\n    //check min/max parameters\n    if (this.camera instanceof OrthographicCamera) {\n      //check zoom\n      if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n        const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom)\n        this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true))\n      }\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      //check distance\n      const distance = this.camera.position.distanceTo(this._gizmos.position)\n\n      if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n        const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance)\n        this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position))\n        this.updateMatrixState()\n      }\n\n      //check fov\n      if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n        this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov)\n        this.camera.updateProjectionMatrix()\n      }\n\n      const oldRadius = this._tbRadius\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n\n      if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n        const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3\n        const newRadius = this._tbRadius / scale\n        // @ts-ignore\n        const curve = new EllipseCurve(0, 0, newRadius, newRadius)\n        const points = curve.getPoints(this._curvePts)\n        const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n        for (const gizmo in this._gizmos.children) {\n          const child = this._gizmos.children[gizmo] as Mesh\n          child.geometry = curveGeometry\n        }\n      }\n    }\n\n    this.camera.lookAt(this._gizmos.position)\n  }\n\n  private setStateFromJSON = (json: string): void => {\n    const state = JSON.parse(json)\n\n    if (state.arcballState && this.camera) {\n      this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n\n      this.camera.up.copy(state.arcballState.cameraUp)\n      this.camera.near = state.arcballState.cameraNear\n      this.camera.far = state.arcballState.cameraFar\n\n      this.camera.zoom = state.arcballState.cameraZoom\n\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = state.arcballState.cameraFov\n      }\n\n      this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements)\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n      this.camera.updateMatrix()\n      this.camera.updateProjectionMatrix()\n\n      this._gizmos.updateMatrix()\n\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0)\n      this.makeGizmos(this._gizmos.position, this._tbRadius)\n      this._gizmoMatrixState0.copy(gizmoTmp)\n\n      this.camera.lookAt(this._gizmos.position)\n      this.updateTbState(STATE.IDLE, false)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n}\n\nexport { ArcballControls }\n", "import { OrthographicCamera, PlaneGeometry, Mesh, Material, Renderer, WebGLRenderer, WebGLRenderTarget } from 'three'\n\nclass Pass {\n  // if set to true, the pass is processed by the composer\n  public enabled = true\n\n  // if set to true, the pass indicates to swap read and write buffer after rendering\n  public needsSwap = true\n\n  // if set to true, the pass clears its buffer before rendering\n  public clear = false\n\n  // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n  public renderToScreen = false\n\n  public setSize(width: number, height: number): void {}\n\n  public render(\n    renderer: WebGLRenderer,\n    writeBuffer: WebGLRenderTarget,\n    readBuffer: WebGLRenderTarget,\n    deltaTime: number,\n    maskActive?: unknown,\n  ): void {\n    console.error('THREE.Pass: .render() must be implemented in derived pass.')\n  }\n\n  public dispose() {}\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\nclass FullScreenQuad<TMaterial extends Material = Material> {\n  public camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)\n  public geometry = new PlaneGeometry(2, 2)\n  private mesh: Mesh<PlaneGeometry, TMaterial>\n\n  constructor(material: TMaterial) {\n    this.mesh = new Mesh(this.geometry, material)\n  }\n\n  public get material(): TMaterial {\n    return this.mesh.material\n  }\n\n  public set material(value: TMaterial) {\n    this.mesh.material = value\n  }\n\n  public dispose(): void {\n    this.mesh.geometry.dispose()\n  }\n\n  public render(renderer: Renderer): void {\n    renderer.render(this.mesh, this.camera)\n  }\n}\n\nexport { Pass, FullScreenQuad }\n", "/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\n\nexport const HalftoneShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    shape: { value: 1 },\n    radius: { value: 4 },\n    rotateR: { value: (Math.PI / 12) * 1 },\n    rotateG: { value: (Math.PI / 12) * 2 },\n    rotateB: { value: (Math.PI / 12) * 3 },\n    scatter: { value: 0 },\n    width: { value: 1 },\n    height: { value: 1 },\n    blending: { value: 1 },\n    blendingMode: { value: 1 },\n    greyscale: { value: false },\n    disable: { value: false },\n  },\n\n  vertexShader: [\n    'varying vec2 vUV;',\n\n    'void main() {',\n\n    '\tvUV = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#define SQRT2_MINUS_ONE 0.41421356',\n    '#define SQRT2_HALF_MINUS_ONE 0.20710678',\n    '#define PI2 6.28318531',\n    '#define SHAPE_DOT 1',\n    '#define SHAPE_ELLIPSE 2',\n    '#define SHAPE_LINE 3',\n    '#define SHAPE_SQUARE 4',\n    '#define BLENDING_LINEAR 1',\n    '#define BLENDING_MULTIPLY 2',\n    '#define BLENDING_ADD 3',\n    '#define BLENDING_LIGHTER 4',\n    '#define BLENDING_DARKER 5',\n    'uniform sampler2D tDiffuse;',\n    'uniform float radius;',\n    'uniform float rotateR;',\n    'uniform float rotateG;',\n    'uniform float rotateB;',\n    'uniform float scatter;',\n    'uniform float width;',\n    'uniform float height;',\n    'uniform int shape;',\n    'uniform bool disable;',\n    'uniform float blending;',\n    'uniform int blendingMode;',\n    'varying vec2 vUV;',\n    'uniform bool greyscale;',\n    'const int samples = 8;',\n\n    'float blend( float a, float b, float t ) {',\n\n    // linear blend\n    '\treturn a * ( 1.0 - t ) + b * t;',\n\n    '}',\n\n    'float hypot( float x, float y ) {',\n\n    // vector magnitude\n    '\treturn sqrt( x * x + y * y );',\n\n    '}',\n\n    'float rand( vec2 seed ){',\n\n    // get pseudo-random number\n    'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );',\n\n    '}',\n\n    'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {',\n\n    // apply shape-specific transforms\n    '\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );',\n    '\tfloat rad = channel;',\n\n    '\tif ( shape == SHAPE_DOT ) {',\n\n    '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;',\n\n    '\t} else if ( shape == SHAPE_ELLIPSE ) {',\n\n    '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;',\n\n    '\t\tif ( dist != 0.0 ) {',\n    '\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );',\n    '\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;',\n    '\t\t}',\n\n    '\t} else if ( shape == SHAPE_LINE ) {',\n\n    '\t\trad = pow( abs( rad ), 1.5) * rad_max;',\n    '\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;',\n    '\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );',\n\n    '\t} else if ( shape == SHAPE_SQUARE ) {',\n\n    '\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;',\n    '\t\tfloat sin_t = abs( sin( theta ) );',\n    '\t\tfloat cos_t = abs( cos( theta ) );',\n    '\t\trad = pow( abs( rad ), 1.4 );',\n    '\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );',\n\n    '\t}',\n\n    '\treturn rad - dist;',\n\n    '}',\n\n    'struct Cell {',\n\n    // grid sample positions\n    '\tvec2 normal;',\n    '\tvec2 p1;',\n    '\tvec2 p2;',\n    '\tvec2 p3;',\n    '\tvec2 p4;',\n    '\tfloat samp2;',\n    '\tfloat samp1;',\n    '\tfloat samp3;',\n    '\tfloat samp4;',\n\n    '};',\n\n    'vec4 getSample( vec2 point ) {',\n\n    // multi-sampled point\n    '\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );',\n    '\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;',\n    '\tfloat step = PI2 / float( samples );',\n    '\tfloat dist = radius * 0.66;',\n\n    '\tfor ( int i = 0; i < samples; ++i ) {',\n\n    '\t\tfloat r = base + step * float( i );',\n    '\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );',\n    '\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );',\n\n    '\t}',\n\n    '\ttex /= float( samples ) + 1.0;',\n    '\treturn tex;',\n\n    '}',\n\n    'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {',\n\n    // get colour for given point\n    '\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;',\n\n    '\tif ( channel == 0 ) {',\n\n    '\t\tc.samp1 = getSample( c.p1 ).r;',\n    '\t\tc.samp2 = getSample( c.p2 ).r;',\n    '\t\tc.samp3 = getSample( c.p3 ).r;',\n    '\t\tc.samp4 = getSample( c.p4 ).r;',\n\n    '\t} else if (channel == 1) {',\n\n    '\t\tc.samp1 = getSample( c.p1 ).g;',\n    '\t\tc.samp2 = getSample( c.p2 ).g;',\n    '\t\tc.samp3 = getSample( c.p3 ).g;',\n    '\t\tc.samp4 = getSample( c.p4 ).g;',\n\n    '\t} else {',\n\n    '\t\tc.samp1 = getSample( c.p1 ).b;',\n    '\t\tc.samp3 = getSample( c.p3 ).b;',\n    '\t\tc.samp2 = getSample( c.p2 ).b;',\n    '\t\tc.samp4 = getSample( c.p4 ).b;',\n\n    '\t}',\n\n    '\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );',\n    '\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );',\n    '\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );',\n    '\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );',\n    '\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;',\n    '\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;',\n    '\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;',\n    '\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;',\n    '\tres = clamp( res, 0.0, 1.0 );',\n\n    '\treturn res;',\n\n    '}',\n\n    'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {',\n\n    // get containing cell\n    '\tCell c;',\n\n    // calc grid\n    '\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );',\n    '\tfloat threshold = step * 0.5;',\n    '\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );',\n    '\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );',\n    '\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );',\n    '\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );',\n    '\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;',\n    '\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;',\n    '\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );',\n    '\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;',\n    '\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;',\n\n    // get closest corner\n    '\tc.normal = n;',\n    '\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;',\n    '\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;',\n\n    // scatter\n    '\tif ( scatter != 0.0 ) {',\n\n    '\t\tfloat off_mag = scatter * threshold * 0.5;',\n    '\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;',\n    '\t\tc.p1.x += cos( off_angle ) * off_mag;',\n    '\t\tc.p1.y += sin( off_angle ) * off_mag;',\n\n    '\t}',\n\n    // find corners\n    '\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );',\n    '\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );',\n    '\tc.p2.x = c.p1.x - n.x * normal_step;',\n    '\tc.p2.y = c.p1.y - n.y * normal_step;',\n    '\tc.p3.x = c.p1.x + n.y * line_step;',\n    '\tc.p3.y = c.p1.y - n.x * line_step;',\n    '\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;',\n    '\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;',\n\n    '\treturn c;',\n\n    '}',\n\n    'float blendColour( float a, float b, float t ) {',\n\n    // blend colours\n    '\tif ( blendingMode == BLENDING_LINEAR ) {',\n    '\t\treturn blend( a, b, 1.0 - t );',\n    '\t} else if ( blendingMode == BLENDING_ADD ) {',\n    '\t\treturn blend( a, min( 1.0, a + b ), t );',\n    '\t} else if ( blendingMode == BLENDING_MULTIPLY ) {',\n    '\t\treturn blend( a, max( 0.0, a * b ), t );',\n    '\t} else if ( blendingMode == BLENDING_LIGHTER ) {',\n    '\t\treturn blend( a, max( a, b ), t );',\n    '\t} else if ( blendingMode == BLENDING_DARKER ) {',\n    '\t\treturn blend( a, min( a, b ), t );',\n    '\t} else {',\n    '\t\treturn blend( a, b, 1.0 - t );',\n    '\t}',\n\n    '}',\n\n    'void main() {',\n\n    '\tif ( ! disable ) {',\n\n    // setup\n    '\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );',\n    '\t\tvec2 origin = vec2( 0, 0 );',\n    '\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;',\n\n    // get channel samples\n    '\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );',\n    '\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );',\n    '\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );',\n    '\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );',\n    '\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );',\n    '\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );',\n\n    // blend with original\n    '\t\tvec4 colour = texture2D( tDiffuse, vUV );',\n    '\t\tr = blendColour( r, colour.r, blending );',\n    '\t\tg = blendColour( g, colour.g, blending );',\n    '\t\tb = blendColour( b, colour.b, blending );',\n\n    '\t\tif ( greyscale ) {',\n    '\t\t\tr = g = b = (r + b + g) / 3.0;',\n    '\t\t}',\n\n    '\t\tgl_FragColor = vec4( r, g, b, 1.0 );',\n\n    '\t} else {',\n\n    '\t\tgl_FragColor = texture2D( tDiffuse, vUV );',\n\n    '\t}',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8\n * Preset: SMAA 1x Medium (with color edge detection)\n * https://github.com/iryoku/smaa/releases/tag/v2.8\n */\n\nexport const SMAAEdgesShader = {\n  defines: {\n    SMAA_THRESHOLD: '0.1',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: [\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vOffset[ 3 ];',\n\n    'void SMAAEdgeDetectionVS( vec2 texcoord ) {',\n    '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );', // WebGL port note: Changed sign in W component\n    '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );', // WebGL port note: Changed sign in W component\n    '\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );', // WebGL port note: Changed sign in W component\n    '}',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tSMAAEdgeDetectionVS( vUv );',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vOffset[ 3 ];',\n\n    'vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {',\n    '\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );',\n\n    // Calculate color deltas:\n    '\tvec4 delta;',\n    '\tvec3 C = texture2D( colorTex, texcoord ).rgb;',\n\n    '\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;',\n    '\tvec3 t = abs( C - Cleft );',\n    '\tdelta.x = max( max( t.r, t.g ), t.b );',\n\n    '\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;',\n    '\tt = abs( C - Ctop );',\n    '\tdelta.y = max( max( t.r, t.g ), t.b );',\n\n    // We do the usual threshold:\n    '\tvec2 edges = step( threshold, delta.xy );',\n\n    // Then discard if there is no edge:\n    '\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )',\n    '\t\tdiscard;',\n\n    // Calculate right and bottom deltas:\n    '\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;',\n    '\tt = abs( C - Cright );',\n    '\tdelta.z = max( max( t.r, t.g ), t.b );',\n\n    '\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;',\n    '\tt = abs( C - Cbottom );',\n    '\tdelta.w = max( max( t.r, t.g ), t.b );',\n\n    // Calculate the maximum delta in the direct neighborhood:\n    '\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );',\n\n    // Calculate left-left and top-top deltas:\n    '\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;',\n    '\tt = abs( C - Cleftleft );',\n    '\tdelta.z = max( max( t.r, t.g ), t.b );',\n\n    '\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;',\n    '\tt = abs( C - Ctoptop );',\n    '\tdelta.w = max( max( t.r, t.g ), t.b );',\n\n    // Calculate the final maximum delta:\n    '\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );',\n\n    // Local contrast adaptation in action:\n    '\tedges.xy *= step( 0.5 * maxDelta, delta.xy );',\n\n    '\treturn vec4( edges, 0.0, 0.0 );',\n    '}',\n\n    'void main() {',\n\n    '\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const SMAAWeightsShader = {\n  defines: {\n    SMAA_MAX_SEARCH_STEPS: '8',\n    SMAA_AREATEX_MAX_DISTANCE: '16',\n    SMAA_AREATEX_PIXEL_SIZE: '( 1.0 / vec2( 160.0, 560.0 ) )',\n    SMAA_AREATEX_SUBTEX_SIZE: '( 1.0 / 7.0 )',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tArea: { value: null },\n    tSearch: { value: null },\n    resolution: { value: new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: [\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vOffset[ 3 ];',\n    'varying vec2 vPixcoord;',\n\n    'void SMAABlendingWeightCalculationVS( vec2 texcoord ) {',\n    '\tvPixcoord = texcoord / resolution;',\n\n    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n    '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );', // WebGL port note: Changed sign in Y and W components\n    '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );', // WebGL port note: Changed sign in Y and W components\n\n    // And these for the searches, they indicate the ends of the loops:\n    '\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );',\n\n    '}',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tSMAABlendingWeightCalculationVS( vUv );',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tArea;',\n    'uniform sampler2D tSearch;',\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vOffset[3];',\n    'varying vec2 vPixcoord;',\n\n    '#if __VERSION__ == 100',\n    'vec2 round( vec2 x ) {',\n    '\treturn sign( x ) * floor( abs( x ) + 0.5 );',\n    '}',\n    '#endif',\n\n    'float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {',\n    // Not required if searchTex accesses are set to point:\n    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n    '\te.r = bias + e.r * scale;',\n    '\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;',\n    '}',\n\n    'float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n    /**\n     * @PSEUDO_GATHER4\n     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n     * sample between edge, thus fetching four edges in a row.\n     * Sampling with different offsets in each direction allows to disambiguate\n     * which edges are active from the four fetched ones.\n     */\n    '\tvec2 e = vec2( 0.0, 1.0 );',\n\n    '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n    '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n    '\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;',\n    '\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;',\n    '\t}',\n\n    // We correct the previous (-0.25, -0.125) offset we applied:\n    '\ttexcoord.x += 0.25 * resolution.x;',\n\n    // The searches are bias by 1, so adjust the coords accordingly:\n    '\ttexcoord.x += resolution.x;',\n\n    // Disambiguate the length added by the last step:\n    '\ttexcoord.x += 2.0 * resolution.x;', // Undo last step\n    '\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);',\n\n    '\treturn texcoord.x;',\n    '}',\n\n    'float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n    '\tvec2 e = vec2( 0.0, 1.0 );',\n\n    '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n    '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n    '\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;',\n    '\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;',\n    '\t}',\n\n    '\ttexcoord.x -= 0.25 * resolution.x;',\n    '\ttexcoord.x -= resolution.x;',\n    '\ttexcoord.x -= 2.0 * resolution.x;',\n    '\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );',\n\n    '\treturn texcoord.x;',\n    '}',\n\n    'float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n    '\tvec2 e = vec2( 1.0, 0.0 );',\n\n    '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n    '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n    '\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution;', // WebGL port note: Changed sign\n    '\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;',\n    '\t}',\n\n    '\ttexcoord.y -= 0.25 * resolution.y;', // WebGL port note: Changed sign\n    '\ttexcoord.y -= resolution.y;', // WebGL port note: Changed sign\n    '\ttexcoord.y -= 2.0 * resolution.y;', // WebGL port note: Changed sign\n    '\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );', // WebGL port note: Changed sign\n\n    '\treturn texcoord.y;',\n    '}',\n\n    'float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n    '\tvec2 e = vec2( 1.0, 0.0 );',\n\n    '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n    '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n    '\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution;', // WebGL port note: Changed sign\n    '\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;',\n    '\t}',\n\n    '\ttexcoord.y += 0.25 * resolution.y;', // WebGL port note: Changed sign\n    '\ttexcoord.y += resolution.y;', // WebGL port note: Changed sign\n    '\ttexcoord.y += 2.0 * resolution.y;', // WebGL port note: Changed sign\n    '\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );', // WebGL port note: Changed sign\n\n    '\treturn texcoord.y;',\n    '}',\n\n    'vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {',\n    // Rounding prevents precision errors of bilinear filtering:\n    '\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;',\n\n    // We do a scale and bias for mapping to texel space:\n    '\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );',\n\n    // Move to proper place, according to the subpixel offset:\n    '\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;',\n\n    '\treturn texture2D( areaTex, texcoord, 0.0 ).rg;',\n    '}',\n\n    'vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {',\n    '\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );',\n\n    '\tvec2 e = texture2D( edgesTex, texcoord ).rg;',\n\n    '\tif ( e.g > 0.0 ) {', // Edge at north\n    '\t\tvec2 d;',\n\n    // Find the distance to the left:\n    '\t\tvec2 coords;',\n    '\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );',\n    '\t\tcoords.y = offset[ 1 ].y;', // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n    '\t\td.x = coords.x;',\n\n    // Now fetch the left crossing edges, two at a time using bilinear\n    // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n    // discern what value each edge has:\n    '\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;',\n\n    // Find the distance to the right:\n    '\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );',\n    '\t\td.y = coords.x;',\n\n    // We want the distances to be in pixel units (doing this here allow to\n    // better interleave arithmetic and memory accesses):\n    '\t\td = d / resolution.x - pixcoord.x;',\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    '\t\tvec2 sqrt_d = sqrt( abs( d ) );',\n\n    // Fetch the right crossing edges:\n    '\t\tcoords.y -= 1.0 * resolution.y;', // WebGL port note: Added\n    '\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;',\n\n    // Ok, we know how this pattern looks like, now it is time for getting\n    // the actual area:\n    '\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );',\n    '\t}',\n\n    '\tif ( e.r > 0.0 ) {', // Edge at west\n    '\t\tvec2 d;',\n\n    // Find the distance to the top:\n    '\t\tvec2 coords;',\n\n    '\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );',\n    '\t\tcoords.x = offset[ 0 ].x;', // offset[1].x = texcoord.x - 0.25 * resolution.x;\n    '\t\td.x = coords.y;',\n\n    // Fetch the top crossing edges:\n    '\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;',\n\n    // Find the distance to the bottom:\n    '\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );',\n    '\t\td.y = coords.y;',\n\n    // We want the distances to be in pixel units:\n    '\t\td = d / resolution.y - pixcoord.y;',\n\n    // SMAAArea below needs a sqrt, as the areas texture is compressed\n    // quadratically:\n    '\t\tvec2 sqrt_d = sqrt( abs( d ) );',\n\n    // Fetch the bottom crossing edges:\n    '\t\tcoords.y -= 1.0 * resolution.y;', // WebGL port note: Added\n    '\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;',\n\n    // Get the area for this direction:\n    '\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );',\n    '\t}',\n\n    '\treturn weights;',\n    '}',\n\n    'void main() {',\n\n    '\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const SMAABlendShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    tColor: { value: null },\n    resolution: { value: new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: [\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vOffset[ 2 ];',\n\n    'void SMAANeighborhoodBlendingVS( vec2 texcoord ) {',\n    '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );', // WebGL port note: Changed sign in W component\n    '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );', // WebGL port note: Changed sign in W component\n    '}',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tSMAANeighborhoodBlendingVS( vUv );',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tColor;',\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vOffset[ 2 ];',\n\n    'vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {',\n    // Fetch the blending weights for current pixel:\n    '\tvec4 a;',\n    '\ta.xz = texture2D( blendTex, texcoord ).xz;',\n    '\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;',\n    '\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;',\n\n    // Is there any blending weight with a value greater than 0.0?\n    '\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {',\n    '\t\treturn texture2D( colorTex, texcoord, 0.0 );',\n    '\t} else {',\n    // Up to 4 lines can be crossing a pixel (one through each edge). We\n    // favor blending by choosing the line with the maximum weight for each\n    // direction:\n    '\t\tvec2 offset;',\n    '\t\toffset.x = a.a > a.b ? a.a : -a.b;', // left vs. right\n    '\t\toffset.y = a.g > a.r ? -a.g : a.r;', // top vs. bottom // WebGL port note: Changed signs\n\n    // Then we go in the direction that has the maximum weight:\n    '\t\tif ( abs( offset.x ) > abs( offset.y )) {', // horizontal vs. vertical\n    '\t\t\toffset.y = 0.0;',\n    '\t\t} else {',\n    '\t\t\toffset.x = 0.0;',\n    '\t\t}',\n\n    // Fetch the opposite color and lerp by hand:\n    '\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );',\n    '\t\ttexcoord += sign( offset ) * resolution;',\n    '\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );',\n    '\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );',\n\n    // WebGL port note: Added gamma correction\n    '\t\tC.xyz = pow(C.xyz, vec3(2.2));',\n    '\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));',\n    '\t\tvec4 mixed = mix(C, Cop, s);',\n    '\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));',\n\n    '\t\treturn mixed;',\n    '\t}',\n    '}',\n\n    'void main() {',\n\n    '\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nexport const FilmShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    time: { value: 0.0 },\n    nIntensity: { value: 0.5 },\n    sIntensity: { value: 0.05 },\n    sCount: { value: 4096 },\n    grayscale: { value: 1 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#include <common>',\n\n    // control parameter\n    'uniform float time;',\n\n    'uniform bool grayscale;',\n\n    // noise effect intensity value (0 = no effect, 1 = full effect)\n    'uniform float nIntensity;',\n\n    // scanlines effect intensity value (0 = no effect, 1 = full effect)\n    'uniform float sIntensity;',\n\n    // scanlines effect count value (0 = no effect, 4096 = full effect)\n    'uniform float sCount;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    // sample the source\n    '\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );',\n\n    // make some noise\n    '\tfloat dx = rand( vUv + time );',\n\n    // add noise\n    '\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );',\n\n    // get us a sine and cosine\n    '\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );',\n\n    // add scanlines\n    '\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;',\n\n    // interpolate between source and result by intensity\n    '\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );',\n\n    // convert to grayscale if desired\n    '\tif( grayscale ) {',\n\n    '\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );',\n\n    '\t}',\n\n    '\tgl_FragColor =  vec4( cResult, cTextureScreen.a );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Full-screen textured quad shader\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type CopyShaderUniforms = {\n  opacity: IUniform<number>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface ICopyShader extends IShader<CopyShaderUniforms> {}\n\nexport const CopyShader: ICopyShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float opacity;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 texel = texture2D( tDiffuse, vUv );',\n    '\tgl_FragColor = opacity * texel;',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Matrix4, Vector2 } from 'three'\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nexport const SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32,\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tDepth: { value: null },\n    tNoise: { value: null },\n    kernel: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: new Vector2() },\n    cameraProjectionMatrix: { value: new Matrix4() },\n    cameraInverseProjectionMatrix: { value: new Matrix4() },\n    kernelRadius: { value: 8 },\n    minDistance: { value: 0.005 },\n    maxDistance: { value: 0.05 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tNormal;',\n    'uniform sampler2D tDepth;',\n    'uniform sampler2D tNoise;',\n\n    'uniform vec3 kernel[ KERNEL_SIZE ];',\n\n    'uniform vec2 resolution;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n    'uniform mat4 cameraProjectionMatrix;',\n    'uniform mat4 cameraInverseProjectionMatrix;',\n\n    'uniform float kernelRadius;',\n    'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n    'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n\n    'varying vec2 vUv;',\n\n    '#include <packing>',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n\n    '}',\n\n    'float getLinearDepth( const in vec2 screenPosition ) {',\n\n    '\t#if PERSPECTIVE_CAMERA == 1',\n\n    '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;',\n    '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );',\n    '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );',\n\n    '\t#else',\n\n    '\t\treturn texture2D( tDepth, screenPosition ).x;',\n\n    '\t#endif',\n\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n\n    '\t#if PERSPECTIVE_CAMERA == 1',\n\n    '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n\n    '\t#else',\n\n    '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n\n    '\t#endif',\n\n    '}',\n\n    'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {',\n\n    '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];',\n\n    '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );',\n\n    '\tclipPosition *= clipW; // unprojection.',\n\n    '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;',\n\n    '}',\n\n    'vec3 getViewNormal( const in vec2 screenPosition ) {',\n\n    '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );',\n\n    '}',\n\n    'void main() {',\n\n    '\tfloat depth = getDepth( vUv );',\n    '\tfloat viewZ = getViewZ( depth );',\n\n    '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );',\n    '\tvec3 viewNormal = getViewNormal( vUv );',\n\n    ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );',\n    '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;',\n\n    // compute matrix used to reorient a kernel vector\n\n    '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );',\n    '\tvec3 bitangent = cross( viewNormal, tangent );',\n    '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );',\n\n    ' float occlusion = 0.0;',\n\n    ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {',\n\n    '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n    '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n\n    '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n    '\t\tsamplePointNDC /= samplePointNDC.w;',\n\n    '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n\n    '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n    '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n    '\t\tfloat delta = sampleDepth - realDepth;',\n\n    '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n\n    '\t\t\tocclusion += 1.0;',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );',\n\n    '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDepth;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n\n    'varying vec2 vUv;',\n\n    '#include <packing>',\n\n    'float getLinearDepth( const in vec2 screenPosition ) {',\n\n    '\t#if PERSPECTIVE_CAMERA == 1',\n\n    '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;',\n    '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );',\n    '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );',\n\n    '\t#else',\n\n    '\t\treturn texture2D( tDepth, screenPosition ).x;',\n\n    '\t#endif',\n\n    '}',\n\n    'void main() {',\n\n    '\tfloat depth = getLinearDepth( vUv );',\n    '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: new Vector2() },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n\n    'uniform vec2 resolution;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 texelSize = ( 1.0 / resolution );',\n    '\tfloat result = 0.0;',\n\n    '\tfor ( int i = - 2; i <= 2; i ++ ) {',\n\n    '\t\tfor ( int j = - 2; j <= 2; j ++ ) {',\n\n    '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;',\n    '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import {\n  AddEquation,\n  Color,\n  CustomBlending,\n  DataTexture,\n  DepthTexture,\n  DstAlphaFactor,\n  DstColorFactor,\n  FloatType,\n  MathUtils,\n  MeshNormalMaterial,\n  NearestFilter,\n  NoBlending,\n  RedFormat,\n  LuminanceFormat,\n  DepthStencilFormat,\n  UnsignedInt248Type,\n  RepeatWrapping,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector3,\n  WebGLRenderTarget,\n  ZeroFactor,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { SimplexNoise } from '../math/SimplexNoise'\nimport { SSAOShader, SSAOBlurShader, SSAODepthShader } from '../shaders/SSAOShader'\n\nimport { CopyShader } from '../shaders/CopyShader'\n\nclass SSAOPass extends Pass {\n  static OUTPUT = {\n    Default: 0,\n    SSAO: 1,\n    Blur: 2,\n    Beauty: 3,\n    Depth: 4,\n    Normal: 5,\n  }\n\n  constructor(scene, camera, width, height) {\n    super()\n\n    this.width = width !== undefined ? width : 512\n    this.height = height !== undefined ? height : 512\n\n    this.clear = true\n\n    this.camera = camera\n    this.scene = scene\n\n    this.kernelRadius = 8\n    this.kernelSize = 32\n    this.kernel = []\n    this.noiseTexture = null\n    this.output = 0\n\n    this.minDistance = 0.005\n    this.maxDistance = 0.1\n\n    this._visibilityCache = new Map()\n\n    //\n\n    this.generateSampleKernel()\n    this.generateRandomKernelRotations()\n\n    // beauty render target\n\n    const depthTexture = new DepthTexture()\n    depthTexture.format = DepthStencilFormat\n    depthTexture.type = UnsignedInt248Type\n\n    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height)\n\n    // normal render target with depth buffer\n\n    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      depthTexture: depthTexture,\n    })\n\n    // ssao render target\n\n    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height)\n\n    this.blurRenderTarget = this.ssaoRenderTarget.clone()\n\n    // ssao material\n\n    if (SSAOShader === undefined) {\n      console.error('THREE.SSAOPass: The pass relies on SSAOShader.')\n    }\n\n    this.ssaoMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSAOShader.defines),\n      uniforms: UniformsUtils.clone(SSAOShader.uniforms),\n      vertexShader: SSAOShader.vertexShader,\n      fragmentShader: SSAOShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.ssaoMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n    this.ssaoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture\n    this.ssaoMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture\n    this.ssaoMaterial.uniforms['tNoise'].value = this.noiseTexture\n    this.ssaoMaterial.uniforms['kernel'].value = this.kernel\n    this.ssaoMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.ssaoMaterial.uniforms['cameraFar'].value = this.camera.far\n    this.ssaoMaterial.uniforms['resolution'].value.set(this.width, this.height)\n    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix)\n    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)\n\n    // normal material\n\n    this.normalMaterial = new MeshNormalMaterial()\n    this.normalMaterial.blending = NoBlending\n\n    // blur material\n\n    this.blurMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSAOBlurShader.defines),\n      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),\n      vertexShader: SSAOBlurShader.vertexShader,\n      fragmentShader: SSAOBlurShader.fragmentShader,\n    })\n    this.blurMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture\n    this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height)\n\n    // material for rendering the depth\n\n    this.depthRenderMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSAODepthShader.defines),\n      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),\n      vertexShader: SSAODepthShader.vertexShader,\n      fragmentShader: SSAODepthShader.fragmentShader,\n      blending: NoBlending,\n    })\n    this.depthRenderMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture\n    this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far\n\n    // material for rendering the content of a render target\n\n    this.copyMaterial = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(CopyShader.uniforms),\n      vertexShader: CopyShader.vertexShader,\n      fragmentShader: CopyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      blendSrc: DstColorFactor,\n      blendDst: ZeroFactor,\n      blendEquation: AddEquation,\n      blendSrcAlpha: DstAlphaFactor,\n      blendDstAlpha: ZeroFactor,\n      blendEquationAlpha: AddEquation,\n    })\n\n    this.fsQuad = new FullScreenQuad(null)\n\n    this.originalClearColor = new Color()\n  }\n\n  dispose() {\n    // dispose render targets\n\n    this.beautyRenderTarget.dispose()\n    this.normalRenderTarget.dispose()\n    this.ssaoRenderTarget.dispose()\n    this.blurRenderTarget.dispose()\n\n    // dispose materials\n\n    this.normalMaterial.dispose()\n    this.blurMaterial.dispose()\n    this.copyMaterial.dispose()\n    this.depthRenderMaterial.dispose()\n\n    // dipsose full screen quad\n\n    this.fsQuad.dispose()\n  }\n\n  render(renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */) {\n    if (renderer.capabilities.isWebGL2 === false) this.noiseTexture.format = LuminanceFormat\n\n    // render beauty\n\n    renderer.setRenderTarget(this.beautyRenderTarget)\n    renderer.clear()\n    renderer.render(this.scene, this.camera)\n\n    // render normals and depth (honor only meshes, points and lines do not contribute to SSAO)\n\n    this.overrideVisibility()\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0)\n    this.restoreVisibility()\n\n    // render SSAO\n\n    this.ssaoMaterial.uniforms['kernelRadius'].value = this.kernelRadius\n    this.ssaoMaterial.uniforms['minDistance'].value = this.minDistance\n    this.ssaoMaterial.uniforms['maxDistance'].value = this.maxDistance\n    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget)\n\n    // render blur\n\n    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget)\n\n    // output result to screen\n\n    switch (this.output) {\n      case SSAOPass.OUTPUT.SSAO:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSAOPass.OUTPUT.Blur:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSAOPass.OUTPUT.Beauty:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSAOPass.OUTPUT.Depth:\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSAOPass.OUTPUT.Normal:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSAOPass.OUTPUT.Default:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture\n        this.copyMaterial.blending = CustomBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      default:\n        console.warn('THREE.SSAOPass: Unknown output type.')\n    }\n  }\n\n  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    renderer.getClearColor(this.originalClearColor)\n    const originalClearAlpha = renderer.getClearAlpha()\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n\n    // setup pass state\n    renderer.autoClear = false\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.fsQuad.material = passMaterial\n    this.fsQuad.render(renderer)\n\n    // restore original state\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    renderer.getClearColor(this.originalClearColor)\n    const originalClearAlpha = renderer.getClearAlpha()\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n    renderer.autoClear = false\n\n    clearColor = overrideMaterial.clearColor || clearColor\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.scene.overrideMaterial = overrideMaterial\n    renderer.render(this.scene, this.camera)\n    this.scene.overrideMaterial = null\n\n    // restore original state\n\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  setSize(width, height) {\n    this.width = width\n    this.height = height\n\n    this.beautyRenderTarget.setSize(width, height)\n    this.ssaoRenderTarget.setSize(width, height)\n    this.normalRenderTarget.setSize(width, height)\n    this.blurRenderTarget.setSize(width, height)\n\n    this.ssaoMaterial.uniforms['resolution'].value.set(width, height)\n    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix)\n    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)\n\n    this.blurMaterial.uniforms['resolution'].value.set(width, height)\n  }\n\n  generateSampleKernel() {\n    const kernelSize = this.kernelSize\n    const kernel = this.kernel\n\n    for (let i = 0; i < kernelSize; i++) {\n      const sample = new Vector3()\n      sample.x = Math.random() * 2 - 1\n      sample.y = Math.random() * 2 - 1\n      sample.z = Math.random()\n\n      sample.normalize()\n\n      let scale = i / kernelSize\n      scale = MathUtils.lerp(0.1, 1, scale * scale)\n      sample.multiplyScalar(scale)\n\n      kernel.push(sample)\n    }\n  }\n\n  generateRandomKernelRotations() {\n    const width = 4,\n      height = 4\n\n    if (SimplexNoise === undefined) {\n      console.error('THREE.SSAOPass: The pass relies on SimplexNoise.')\n    }\n\n    const simplex = new SimplexNoise()\n\n    const size = width * height\n    const data = new Float32Array(size)\n\n    for (let i = 0; i < size; i++) {\n      const x = Math.random() * 2 - 1\n      const y = Math.random() * 2 - 1\n      const z = 0\n\n      data[i] = simplex.noise3d(x, y, z)\n    }\n\n    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType)\n    this.noiseTexture.wrapS = RepeatWrapping\n    this.noiseTexture.wrapT = RepeatWrapping\n    this.noiseTexture.needsUpdate = true\n  }\n\n  overrideVisibility() {\n    const scene = this.scene\n    const cache = this._visibilityCache\n\n    scene.traverse(function (object) {\n      cache.set(object, object.visible)\n\n      if (object.isPoints || object.isLine) object.visible = false\n    })\n  }\n\n  restoreVisibility() {\n    const scene = this.scene\n    const cache = this._visibilityCache\n\n    scene.traverse(function (object) {\n      const visible = cache.get(object)\n      object.visible = visible\n    })\n\n    cache.clear()\n  }\n}\n\nexport { SSAOPass }\n", "/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type BokehShaderDefines = {\n  DEPTH_PACKING: number\n  PERSPECTIVE_CAMERA: number\n}\n\nexport type BokehShaderUniforms = {\n  aperture: IUniform<number>\n  aspect: IUniform<number>\n  farClip: IUniform<number>\n  focus: IUniform<number>\n  maxblur: IUniform<number>\n  nearClip: IUniform<number>\n  tColor: IUniform<Texture | null>\n  tDepth: IUniform<Texture | null>\n}\n\nexport interface IBokehShader extends IShader<BokehShaderUniforms, BokehShaderDefines> {}\n\nexport const BokehShader: IBokehShader = {\n  defines: {\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tColor: { value: null },\n    tDepth: { value: null },\n    focus: { value: 1.0 },\n    aspect: { value: 1.0 },\n    aperture: { value: 0.025 },\n    maxblur: { value: 0.01 },\n    nearClip: { value: 1.0 },\n    farClip: { value: 1000.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#include <common>',\n\n    'varying vec2 vUv;',\n\n    'uniform sampler2D tColor;',\n    'uniform sampler2D tDepth;',\n\n    'uniform float maxblur;', // max blur amount\n    'uniform float aperture;', // aperture - bigger values for shallower depth of field\n\n    'uniform float nearClip;',\n    'uniform float farClip;',\n\n    'uniform float focus;',\n    'uniform float aspect;',\n\n    '#include <packing>',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n    '\t#if DEPTH_PACKING == 1',\n    '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\n    '\t#else',\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n    '\t#endif',\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n    '\t#if PERSPECTIVE_CAMERA == 1',\n    '\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );',\n    '\t#else',\n    '\treturn orthographicDepthToViewZ( depth, nearClip, farClip );',\n    '\t#endif',\n    '}',\n\n    'void main() {',\n\n    '\tvec2 aspectcorrect = vec2( 1.0, aspect );',\n\n    '\tfloat viewZ = getViewZ( getDepth( vUv ) );',\n\n    '\tfloat factor = ( focus + viewZ );', // viewZ is <= 0, so this is a difference equation\n\n    '\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );',\n\n    '\tvec2 dofblur9 = dofblur * 0.9;',\n    '\tvec2 dofblur7 = dofblur * 0.7;',\n    '\tvec2 dofblur4 = dofblur * 0.4;',\n\n    '\tvec4 col = vec4( 0.0 );',\n\n    '\tcol += texture2D( tColor, vUv.xy );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );',\n\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );',\n\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );',\n\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );',\n    '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );',\n\n    '\tgl_FragColor = col / 41.0;',\n    '\tgl_FragColor.a = 1.0;',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nexport const LuminosityShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#include <common>',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 texel = texture2D( tDiffuse, vUv );',\n\n    '\tfloat l = linearToRelativeLuminance( texel.rgb );',\n\n    '\tgl_FragColor = vec4( l, l, l, texel.w );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n */\n\nexport const ToneMapShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    averageLuminance: { value: 1.0 },\n    luminanceMap: { value: null },\n    maxLuminance: { value: 16.0 },\n    minLuminance: { value: 0.01 },\n    middleGrey: { value: 0.6 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#include <common>',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'uniform float middleGrey;',\n    'uniform float minLuminance;',\n    'uniform float maxLuminance;',\n    '#ifdef ADAPTED_LUMINANCE',\n    '\tuniform sampler2D luminanceMap;',\n    '#else',\n    '\tuniform float averageLuminance;',\n    '#endif',\n\n    'vec3 ToneMap( vec3 vColor ) {',\n    '\t#ifdef ADAPTED_LUMINANCE',\n    // Get the calculated average luminance\n    '\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;',\n    '\t#else',\n    '\t\tfloat fLumAvg = averageLuminance;',\n    '\t#endif',\n\n    // Calculate the luminance of the current pixel\n    '\tfloat fLumPixel = linearToRelativeLuminance( vColor );',\n\n    // Apply the modified operator (Eq. 4)\n    '\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );',\n\n    '\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);',\n    '\treturn fLumCompressed * vColor;',\n    '}',\n\n    'void main() {',\n\n    '\tvec4 texel = texture2D( tDiffuse, vUv );',\n\n    '\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Color } from 'three'\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nexport const LuminosityHighPassShader = {\n  shaderID: 'luminosityHighPass',\n\n  uniforms: {\n    tDiffuse: { value: null },\n    luminosityThreshold: { value: 1.0 },\n    smoothWidth: { value: 1.0 },\n    defaultColor: { value: new Color(0x000000) },\n    defaultOpacity: { value: 0.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform vec3 defaultColor;',\n    'uniform float defaultOpacity;',\n    'uniform float luminosityThreshold;',\n    'uniform float smoothWidth;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 texel = texture2D( tDiffuse, vUv );',\n\n    '\tvec3 luma = vec3( 0.299, 0.587, 0.114 );',\n\n    '\tfloat v = dot( texel.xyz, luma );',\n\n    '\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );',\n\n    '\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );',\n\n    '\tgl_FragColor = mix( outputColor, texel, alpha );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import {\n  AdditiveBlending,\n  Color,\n  HalfFloatType,\n  MeshBasicMaterial,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderTarget,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { CopyShader } from '../shaders/CopyShader'\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader'\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n  static BlurDirectionX = new Vector2(1.0, 0.0)\n  static BlurDirectionY = new Vector2(0.0, 1.0)\n\n  constructor(resolution, strength, radius, threshold) {\n    super()\n\n    this.strength = strength !== undefined ? strength : 1\n    this.radius = radius\n    this.threshold = threshold\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)\n\n    // create color only once here, reuse it later inside the render function\n    this.clearColor = new Color(0, 0, 0)\n\n    // render targets\n    this.renderTargetsHorizontal = []\n    this.renderTargetsVertical = []\n    this.nMips = 5\n    let resx = Math.round(this.resolution.x / 2)\n    let resy = Math.round(this.resolution.y / 2)\n\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright'\n    this.renderTargetBright.texture.generateMipmaps = false\n\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i\n      renderTargetHorizonal.texture.generateMipmaps = false\n\n      this.renderTargetsHorizontal.push(renderTargetHorizonal)\n\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i\n      renderTargetVertical.texture.generateMipmaps = false\n\n      this.renderTargetsVertical.push(renderTargetVertical)\n\n      resx = Math.round(resx / 2)\n\n      resy = Math.round(resy / 2)\n    }\n\n    // luminosity high pass material\n\n    const highPassShader = LuminosityHighPassShader\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms)\n\n    this.highPassUniforms['luminosityThreshold'].value = threshold\n    this.highPassUniforms['smoothWidth'].value = 0.01\n\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {},\n    })\n\n    // Gaussian Blur Materials\n    this.separableBlurMaterials = []\n    const kernelSizeArray = [3, 5, 7, 9, 11]\n    resx = Math.round(this.resolution.x / 2)\n    resy = Math.round(this.resolution.y / 2)\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]))\n\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)\n\n      resx = Math.round(resx / 2)\n\n      resy = Math.round(resy / 2)\n    }\n\n    // Composite material\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips)\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1\n    this.compositeMaterial.needsUpdate = true\n\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2]\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors\n    this.bloomTintColors = [\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n    ]\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors\n\n    // copy material\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n    this.copyUniforms['opacity'].value = 1.0\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.enabled = true\n    this.needsSwap = false\n\n    this._oldClearColor = new Color()\n    this.oldClearAlpha = 1\n\n    this.basic = new MeshBasicMaterial()\n\n    this.fsQuad = new FullScreenQuad(null)\n  }\n\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose()\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose()\n    }\n\n    this.renderTargetBright.dispose()\n\n    //\n\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose()\n    }\n\n    this.compositeMaterial.dispose()\n    this.materialCopy.dispose()\n    this.basic.dispose()\n\n    //\n\n    this.fsQuad.dispose()\n  }\n\n  setSize(width, height) {\n    let resx = Math.round(width / 2)\n    let resy = Math.round(height / 2)\n\n    this.renderTargetBright.setSize(resx, resy)\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy)\n      this.renderTargetsVertical[i].setSize(resx, resy)\n\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)\n\n      resx = Math.round(resx / 2)\n      resy = Math.round(resy / 2)\n    }\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor)\n    this.oldClearAlpha = renderer.getClearAlpha()\n    const oldAutoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    renderer.setClearColor(this.clearColor, 0)\n\n    if (maskActive) renderer.state.buffers.stencil.setTest(false)\n\n    // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic\n      this.basic.map = readBuffer.texture\n\n      renderer.setRenderTarget(null)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n    }\n\n    // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold\n    this.fsQuad.material = this.materialHighPassFilter\n\n    renderer.setRenderTarget(this.renderTargetBright)\n    renderer.clear()\n    this.fsQuad.render(renderer)\n\n    // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i]\n\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i])\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetsVertical[i])\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      inputRenderTarget = this.renderTargetsVertical[i]\n    }\n\n    // Composite All the mips\n\n    this.fsQuad.material = this.compositeMaterial\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors\n\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0])\n    renderer.clear()\n    this.fsQuad.render(renderer)\n\n    // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture\n\n    if (maskActive) renderer.state.buffers.stencil.setTest(true)\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    } else {\n      renderer.setRenderTarget(readBuffer)\n      this.fsQuad.render(renderer)\n    }\n\n    // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)\n    renderer.autoClear = oldAutoClear\n  }\n\n  getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius,\n      },\n\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`,\n    })\n  }\n\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips,\n      },\n\n      uniforms: {\n        blurTexture1: { value: null },\n        blurTexture2: { value: null },\n        blurTexture3: { value: null },\n        blurTexture4: { value: null },\n        blurTexture5: { value: null },\n        bloomStrength: { value: 1.0 },\n        bloomFactors: { value: null },\n        bloomTintColors: { value: null },\n        bloomRadius: { value: 0.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`,\n    })\n  }\n}\n\nexport { UnrealBloomPass }\n", "import { Matrix4, Vector2 } from 'three'\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type SAOShaderDefines = Record<\n  'DEPTH_PACKING' | 'DIFFUSE_TEXTURE' | 'NORMAL_TEXTURE' | 'NUM_RINGS' | 'NUM_SAMPLES' | 'PERSPECTIVE_CAMERA',\n  number\n>\n\nexport type SAOShaderUniforms = {\n  bias: IUniform<number>\n  cameraFar: IUniform<number>\n  cameraInverseProjectionMatrix: IUniform<Matrix4>\n  cameraNear: IUniform<number>\n  cameraProjectionMatrix: IUniform<Matrix4>\n  intensity: IUniform<number>\n  kernelRadius: IUniform<number>\n  minResolution: IUniform<number>\n  randomSeed: IUniform<number>\n  scale: IUniform<number>\n  size: IUniform<Vector2>\n  tDepth: IUniform<Texture | null>\n  tDiffuse: IUniform<Texture | null>\n  tNormal: IUniform<Texture | null>\n}\n\nexport interface ISAOShader extends IShader<SAOShaderUniforms, SAOShaderDefines> {\n  defines: SAOShaderDefines\n  needsUpdate?: boolean\n}\n\nexport const SAOShader: ISAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n  uniforms: {\n    tDepth: { value: null },\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    size: { value: new Vector2(512, 512) },\n\n    cameraNear: { value: 1 },\n    cameraFar: { value: 100 },\n    cameraProjectionMatrix: { value: new Matrix4() },\n    cameraInverseProjectionMatrix: { value: new Matrix4() },\n\n    scale: { value: 1.0 },\n    intensity: { value: 0.1 },\n    bias: { value: 0.5 },\n\n    minResolution: { value: 0.0 },\n    kernelRadius: { value: 100.0 },\n    randomSeed: { value: 0.0 },\n  },\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '}',\n  ].join('\\n'),\n  fragmentShader: [\n    '#include <common>',\n\n    'varying vec2 vUv;',\n\n    '#if DIFFUSE_TEXTURE == 1',\n    'uniform sampler2D tDiffuse;',\n    '#endif',\n\n    'uniform sampler2D tDepth;',\n\n    '#if NORMAL_TEXTURE == 1',\n    'uniform sampler2D tNormal;',\n    '#endif',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n    'uniform mat4 cameraProjectionMatrix;',\n    'uniform mat4 cameraInverseProjectionMatrix;',\n\n    'uniform float scale;',\n    'uniform float intensity;',\n    'uniform float bias;',\n    'uniform float kernelRadius;',\n    'uniform float minResolution;',\n    'uniform vec2 size;',\n    'uniform float randomSeed;',\n\n    '// RGBA depth',\n\n    '#include <packing>',\n\n    'vec4 getDefaultColor( const in vec2 screenPosition ) {',\n    '\t#if DIFFUSE_TEXTURE == 1',\n    '\treturn texture2D( tDiffuse, vUv );',\n    '\t#else',\n    '\treturn vec4( 1.0 );',\n    '\t#endif',\n    '}',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n    '\t#if DEPTH_PACKING == 1',\n    '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\n    '\t#else',\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n    '\t#endif',\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n    '\t#if PERSPECTIVE_CAMERA == 1',\n    '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#else',\n    '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#endif',\n    '}',\n\n    'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {',\n    '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];',\n    '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );',\n    '\tclipPosition *= clipW; // unprojection.',\n\n    '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;',\n    '}',\n\n    'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {',\n    '\t#if NORMAL_TEXTURE == 1',\n    '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );',\n    '\t#else',\n    '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );',\n    '\t#endif',\n    '}',\n\n    'float scaleDividedByCameraFar;',\n    'float minResolutionMultipliedByCameraFar;',\n\n    'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {',\n    '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;',\n    '\tfloat viewDistance = length( viewDelta );',\n    '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;',\n\n    '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );',\n    '}',\n\n    '// moving costly divides into consts',\n    'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );',\n    'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );',\n\n    'float getAmbientOcclusion( const in vec3 centerViewPosition ) {',\n    '\t// precompute some variables require in getOcclusion.',\n    '\tscaleDividedByCameraFar = scale / cameraFar;',\n    '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;',\n    '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );',\n\n    '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/',\n    '\tfloat angle = rand( vUv + randomSeed ) * PI2;',\n    '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;',\n    '\tvec2 radiusStep = radius;',\n\n    '\tfloat occlusionSum = 0.0;',\n    '\tfloat weightSum = 0.0;',\n\n    '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {',\n    '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;',\n    '\t\tradius += radiusStep;',\n    '\t\tangle += ANGLE_STEP;',\n\n    '\t\tfloat sampleDepth = getDepth( sampleUv );',\n    '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {',\n    '\t\t\tcontinue;',\n    '\t\t}',\n\n    '\t\tfloat sampleViewZ = getViewZ( sampleDepth );',\n    '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );',\n    '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );',\n    '\t\tweightSum += 1.0;',\n    '\t}',\n\n    '\tif( weightSum == 0.0 ) discard;',\n\n    '\treturn occlusionSum * ( intensity / weightSum );',\n    '}',\n\n    'void main() {',\n    '\tfloat centerDepth = getDepth( vUv );',\n    '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {',\n    '\t\tdiscard;',\n    '\t}',\n\n    '\tfloat centerViewZ = getViewZ( centerDepth );',\n    '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );',\n\n    '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );',\n\n    '\tgl_FragColor = getDefaultColor( vUv );',\n    '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;',\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type DepthLimitedBlurShaderDefines = {\n  DEPTH_PACKING: number\n  KERNEL_RADIUS: number\n  PERSPECTIVE_CAMERA: number\n}\n\nexport type DepthLimitedBlurShaderUniforms = {\n  cameraFar: IUniform<number>\n  cameraNear: IUniform<number>\n  depthCutoff: IUniform<number>\n  sampleUvOffsets: IUniform<Vector2[]>\n  sampleWeights: IUniform<number[]>\n  size: IUniform<Vector2>\n  tDepth: IUniform<Texture | null>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IDepthLimitedBlurShader\n  extends IShader<DepthLimitedBlurShaderUniforms, DepthLimitedBlurShaderDefines> {\n  defines: DepthLimitedBlurShaderDefines\n  needsUpdate?: boolean\n}\n\nexport const DepthLimitedBlurShader: IDepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1,\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: new Vector2(512, 512) },\n    sampleUvOffsets: { value: [new Vector2(0, 0)] },\n    sampleWeights: { value: [1.0] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1000 },\n    depthCutoff: { value: 10 },\n  },\n  vertexShader: [\n    '#include <common>',\n\n    'uniform vec2 size;',\n\n    'varying vec2 vUv;',\n    'varying vec2 vInvSize;',\n\n    'void main() {',\n    '\tvUv = uv;',\n    '\tvInvSize = 1.0 / size;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '}',\n  ].join('\\n'),\n  fragmentShader: [\n    '#include <common>',\n    '#include <packing>',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tDepth;',\n\n    'uniform float cameraNear;',\n    'uniform float cameraFar;',\n    'uniform float depthCutoff;',\n\n    'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];',\n    'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];',\n\n    'varying vec2 vUv;',\n    'varying vec2 vInvSize;',\n\n    'float getDepth( const in vec2 screenPosition ) {',\n    '\t#if DEPTH_PACKING == 1',\n    '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\n    '\t#else',\n    '\treturn texture2D( tDepth, screenPosition ).x;',\n    '\t#endif',\n    '}',\n\n    'float getViewZ( const in float depth ) {',\n    '\t#if PERSPECTIVE_CAMERA == 1',\n    '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#else',\n    '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n    '\t#endif',\n    '}',\n\n    'void main() {',\n    '\tfloat depth = getDepth( vUv );',\n    '\tif( depth >= ( 1.0 - EPSILON ) ) {',\n    '\t\tdiscard;',\n    '\t}',\n\n    '\tfloat centerViewZ = -getViewZ( depth );',\n    '\tbool rBreak = false, lBreak = false;',\n\n    '\tfloat weightSum = sampleWeights[0];',\n    '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;',\n\n    '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {',\n\n    '\t\tfloat sampleWeight = sampleWeights[i];',\n    '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;',\n\n    '\t\tvec2 sampleUv = vUv + sampleUvOffset;',\n    '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );',\n\n    '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;',\n\n    '\t\tif( ! rBreak ) {',\n    '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n    '\t\t\tweightSum += sampleWeight;',\n    '\t\t}',\n\n    '\t\tsampleUv = vUv - sampleUvOffset;',\n    '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );',\n\n    '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;',\n\n    '\t\tif( ! lBreak ) {',\n    '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n    '\t\t\tweightSum += sampleWeight;',\n    '\t\t}',\n\n    '\t}',\n\n    '\tgl_FragColor = diffuseSum / weightSum;',\n    '}',\n  ].join('\\n'),\n}\n\nexport const BlurShaderUtils = {\n  createSampleWeights: (kernelRadius: number, stdDev: number): number[] => {\n    const gaussian = (x: number, stdDev: number): number => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev)\n    }\n\n    const weights: number[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev))\n    }\n\n    return weights\n  },\n\n  createSampleOffsets: (kernelRadius: number, uvIncrement: Vector2): Vector2[] => {\n    const offsets: Vector2[] = []\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i))\n    }\n\n    return offsets\n  },\n\n  configure: (shader: IDepthLimitedBlurShader, kernelRadius: number, stdDev: number, uvIncrement: Vector2): void => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement)\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev)\n    shader.needsUpdate = true\n  },\n}\n", "import {\n  AddEquation,\n  Color,\n  CustomBlending,\n  DepthTexture,\n  DstAlphaFactor,\n  DstColorFactor,\n  HalfFloatType,\n  MeshDepthMaterial,\n  MeshNormalMaterial,\n  NearestFilter,\n  NoBlending,\n  RGBADepthPacking,\n  ShaderMaterial,\n  UniformsUtils,\n  UnsignedShortType,\n  Vector2,\n  WebGLRenderTarget,\n  ZeroFactor,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { SAOShader } from '../shaders/SAOShader'\nimport { DepthLimitedBlurShader } from '../shaders/DepthLimitedBlurShader'\nimport { BlurShaderUtils } from '../shaders/DepthLimitedBlurShader'\nimport { CopyShader } from '../shaders/CopyShader'\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader'\n\n/**\n * SAO implementation inspired from bhouston previous SAO work\n */\nclass SAOPass extends Pass {\n  static OUTPUT = {\n    Beauty: 1,\n    Default: 0,\n    SAO: 2,\n    Depth: 3,\n    Normal: 4,\n  }\n\n  constructor(scene, camera, useDepthTexture = false, useNormals = false, resolution = new Vector2(256, 256)) {\n    super()\n\n    this.scene = scene\n    this.camera = camera\n\n    this.clear = true\n    this.needsSwap = false\n\n    this.supportsDepthTextureExtension = useDepthTexture\n    this.supportsNormalTexture = useNormals\n\n    this.originalClearColor = new Color()\n    this._oldClearColor = new Color()\n    this.oldClearAlpha = 1\n\n    this.params = {\n      output: 0,\n      saoBias: 0.5,\n      saoIntensity: 0.18,\n      saoScale: 1,\n      saoKernelRadius: 100,\n      saoMinResolution: 0,\n      saoBlur: true,\n      saoBlurRadius: 8,\n      saoBlurStdDev: 4,\n      saoBlurDepthCutoff: 0.01,\n    }\n\n    this.resolution = new Vector2(resolution.x, resolution.y)\n\n    this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, { type: HalfFloatType })\n    this.blurIntermediateRenderTarget = this.saoRenderTarget.clone()\n    this.beautyRenderTarget = this.saoRenderTarget.clone()\n\n    this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      type: HalfFloatType,\n    })\n    this.depthRenderTarget = this.normalRenderTarget.clone()\n\n    let depthTexture\n\n    if (this.supportsDepthTextureExtension) {\n      depthTexture = new DepthTexture()\n      depthTexture.type = UnsignedShortType\n\n      this.beautyRenderTarget.depthTexture = depthTexture\n      this.beautyRenderTarget.depthBuffer = true\n    }\n\n    this.depthMaterial = new MeshDepthMaterial()\n    this.depthMaterial.depthPacking = RGBADepthPacking\n    this.depthMaterial.blending = NoBlending\n\n    this.normalMaterial = new MeshNormalMaterial()\n    this.normalMaterial.blending = NoBlending\n\n    this.saoMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SAOShader.defines),\n      fragmentShader: SAOShader.fragmentShader,\n      vertexShader: SAOShader.vertexShader,\n      uniforms: UniformsUtils.clone(SAOShader.uniforms),\n    })\n    this.saoMaterial.extensions.derivatives = true\n    this.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1\n    this.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0\n    this.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0\n    this.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension\n      ? depthTexture\n      : this.depthRenderTarget.texture\n    this.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture\n    this.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y)\n    this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)\n    this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix\n    this.saoMaterial.blending = NoBlending\n\n    this.vBlurMaterial = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\n      defines: Object.assign({}, DepthLimitedBlurShader.defines),\n      vertexShader: DepthLimitedBlurShader.vertexShader,\n      fragmentShader: DepthLimitedBlurShader.fragmentShader,\n    })\n    this.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1\n    this.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0\n    this.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture\n    this.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension\n      ? depthTexture\n      : this.depthRenderTarget.texture\n    this.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y)\n    this.vBlurMaterial.blending = NoBlending\n\n    this.hBlurMaterial = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\n      defines: Object.assign({}, DepthLimitedBlurShader.defines),\n      vertexShader: DepthLimitedBlurShader.vertexShader,\n      fragmentShader: DepthLimitedBlurShader.fragmentShader,\n    })\n    this.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1\n    this.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0\n    this.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture\n    this.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension\n      ? depthTexture\n      : this.depthRenderTarget.texture\n    this.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y)\n    this.hBlurMaterial.blending = NoBlending\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(CopyShader.uniforms),\n      vertexShader: CopyShader.vertexShader,\n      fragmentShader: CopyShader.fragmentShader,\n      blending: NoBlending,\n    })\n    this.materialCopy.transparent = true\n    this.materialCopy.depthTest = false\n    this.materialCopy.depthWrite = false\n    this.materialCopy.blending = CustomBlending\n    this.materialCopy.blendSrc = DstColorFactor\n    this.materialCopy.blendDst = ZeroFactor\n    this.materialCopy.blendEquation = AddEquation\n    this.materialCopy.blendSrcAlpha = DstAlphaFactor\n    this.materialCopy.blendDstAlpha = ZeroFactor\n    this.materialCopy.blendEquationAlpha = AddEquation\n\n    this.depthCopy = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),\n      vertexShader: UnpackDepthRGBAShader.vertexShader,\n      fragmentShader: UnpackDepthRGBAShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.fsQuad = new FullScreenQuad(null)\n  }\n\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive*/) {\n    // Rendering readBuffer first when rendering to screen\n    if (this.renderToScreen) {\n      this.materialCopy.blending = NoBlending\n      this.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture\n      this.materialCopy.needsUpdate = true\n      this.renderPass(renderer, this.materialCopy, null)\n    }\n\n    if (this.params.output === 1) {\n      return\n    }\n\n    renderer.getClearColor(this._oldClearColor)\n    this.oldClearAlpha = renderer.getClearAlpha()\n    const oldAutoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    renderer.setRenderTarget(this.depthRenderTarget)\n    renderer.clear()\n\n    this.saoMaterial.uniforms['bias'].value = this.params.saoBias\n    this.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity\n    this.saoMaterial.uniforms['scale'].value = this.params.saoScale\n    this.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius\n    this.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution\n    this.saoMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.saoMaterial.uniforms['cameraFar'].value = this.camera.far\n    // this.saoMaterial.uniforms['randomSeed'].value = Math.random();\n\n    const depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near)\n    this.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff\n    this.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff\n\n    this.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far\n    this.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far\n\n    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius)\n    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {\n      BlurShaderUtils.configure(\n        this.vBlurMaterial,\n        this.params.saoBlurRadius,\n        this.params.saoBlurStdDev,\n        new Vector2(0, 1),\n      )\n      BlurShaderUtils.configure(\n        this.hBlurMaterial,\n        this.params.saoBlurRadius,\n        this.params.saoBlurStdDev,\n        new Vector2(1, 0),\n      )\n      this.prevStdDev = this.params.saoBlurStdDev\n      this.prevNumSamples = this.params.saoBlurRadius\n    }\n\n    // Rendering scene to depth texture\n    renderer.setClearColor(0x000000)\n    renderer.setRenderTarget(this.beautyRenderTarget)\n    renderer.clear()\n    renderer.render(this.scene, this.camera)\n\n    // Re-render scene if depth texture extension is not supported\n    if (!this.supportsDepthTextureExtension) {\n      // Clear rule : far clipping plane in both RGBA and Basic encoding\n      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0)\n    }\n\n    if (this.supportsNormalTexture) {\n      // Clear rule : default normal is facing the camera\n      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0)\n    }\n\n    // Rendering SAO texture\n    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0)\n\n    // Blurring SAO texture\n    if (this.params.saoBlur) {\n      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0)\n      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0)\n    }\n\n    let outputMaterial = this.materialCopy\n    // Setting up SAO rendering\n    if (this.params.output === 3) {\n      if (this.supportsDepthTextureExtension) {\n        this.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture\n        this.materialCopy.needsUpdate = true\n      } else {\n        this.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture\n        this.depthCopy.needsUpdate = true\n        outputMaterial = this.depthCopy\n      }\n    } else if (this.params.output === 4) {\n      this.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture\n      this.materialCopy.needsUpdate = true\n    } else {\n      this.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture\n      this.materialCopy.needsUpdate = true\n    }\n\n    // Blending depends on output, only want a CustomBlending when showing SAO\n    if (this.params.output === 0) {\n      outputMaterial.blending = CustomBlending\n    } else {\n      outputMaterial.blending = NoBlending\n    }\n\n    // Rendering SAOPass result on top of previous pass\n    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer)\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)\n    renderer.autoClear = oldAutoClear\n  }\n\n  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    renderer.getClearColor(this.originalClearColor)\n    const originalClearAlpha = renderer.getClearAlpha()\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n\n    // setup pass state\n    renderer.autoClear = false\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.fsQuad.material = passMaterial\n    this.fsQuad.render(renderer)\n\n    // restore original state\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    renderer.getClearColor(this.originalClearColor)\n    const originalClearAlpha = renderer.getClearAlpha()\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n    renderer.autoClear = false\n\n    clearColor = overrideMaterial.clearColor || clearColor\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.scene.overrideMaterial = overrideMaterial\n    renderer.render(this.scene, this.camera)\n    this.scene.overrideMaterial = null\n\n    // restore original state\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  setSize(width, height) {\n    this.beautyRenderTarget.setSize(width, height)\n    this.saoRenderTarget.setSize(width, height)\n    this.blurIntermediateRenderTarget.setSize(width, height)\n    this.normalRenderTarget.setSize(width, height)\n    this.depthRenderTarget.setSize(width, height)\n\n    this.saoMaterial.uniforms['size'].value.set(width, height)\n    this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)\n    this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix\n    this.saoMaterial.needsUpdate = true\n\n    this.vBlurMaterial.uniforms['size'].value.set(width, height)\n    this.vBlurMaterial.needsUpdate = true\n\n    this.hBlurMaterial.uniforms['size'].value.set(width, height)\n    this.hBlurMaterial.needsUpdate = true\n  }\n\n  dispose() {\n    this.saoRenderTarget.dispose()\n    this.blurIntermediateRenderTarget.dispose()\n    this.beautyRenderTarget.dispose()\n    this.normalRenderTarget.dispose()\n    this.depthRenderTarget.dispose()\n\n    this.depthMaterial.dispose()\n    this.normalMaterial.dispose()\n    this.saoMaterial.dispose()\n    this.vBlurMaterial.dispose()\n    this.hBlurMaterial.dispose()\n    this.materialCopy.dispose()\n    this.depthCopy.dispose()\n\n    this.fsQuad.dispose()\n  }\n}\n\nexport { SAOPass }\n", "/**\n * Afterimage shader\n * I created this effect inspired by a demo on codepen:\n * https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type AfterimageShaderUniforms = {\n  damp: IUniform<number>\n  tNew: IUniform<Texture | null>\n  tOld: IUniform<Texture | null>\n}\n\nexport interface IAfterimageShader extends IShader<AfterimageShaderUniforms> {}\n\nexport const AfterimageShader: IAfterimageShader = {\n  uniforms: {\n    damp: { value: 0.96 },\n    tOld: { value: null },\n    tNew: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float damp;',\n\n    'uniform sampler2D tOld;',\n    'uniform sampler2D tNew;',\n\n    'varying vec2 vUv;',\n\n    'vec4 when_gt( vec4 x, float y ) {',\n\n    '\treturn max( sign( x - y ), 0.0 );',\n\n    '}',\n\n    'void main() {',\n\n    '\tvec4 texelOld = texture2D( tOld, vUv );',\n    '\tvec4 texelNew = texture2D( tNew, vUv );',\n\n    '\ttexelOld *= damp * when_gt( texelOld, 0.1 );',\n\n    '\tgl_FragColor = max(texelNew, texelOld);',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nexport const DotScreenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    tSize: { value: new Vector2(256, 256) },\n    center: { value: new Vector2(0.5, 0.5) },\n    angle: { value: 1.57 },\n    scale: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec2 center;',\n    'uniform float angle;',\n    'uniform float scale;',\n    'uniform vec2 tSize;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'float pattern() {',\n\n    '\tfloat s = sin( angle ), c = cos( angle );',\n\n    '\tvec2 tex = vUv * tSize - center;',\n    '\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;',\n\n    '\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;',\n\n    '}',\n\n    'void main() {',\n\n    '\tvec4 color = texture2D( tDiffuse, vUv );',\n\n    '\tfloat average = ( color.r + color.g + color.b ) / 3.0;',\n\n    '\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Matrix4, Vector2 } from 'three'\n/**\n * References:\n * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html\n */\n\nexport const SSRShader = {\n  defines: {\n    MAX_STEP: 0,\n    isPerspectiveCamera: true,\n    isDistanceAttenuation: true,\n    isFresnel: true,\n    isInfiniteThick: false,\n    isSelective: false,\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    tNormal: { value: null },\n    tMetalness: { value: null },\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n    resolution: { value: new Vector2() },\n    cameraProjectionMatrix: { value: new Matrix4() },\n    cameraInverseProjectionMatrix: { value: new Matrix4() },\n    opacity: { value: 0.5 },\n    maxDistance: { value: 180 },\n    cameraRange: { value: 0 },\n    surfDist: { value: 0.007 },\n    thickTolerance: { value: 0.03 },\n  },\n\n  vertexShader: /* glsl */ `\n\n    varying vec2 vUv;\n\n    void main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n\n  fragmentShader: /* glsl */ `\n\t\t// precision highp float;\n\t\tprecision highp sampler2D;\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tMetalness;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float cameraRange;\n\t\tuniform vec2 resolution;\n\t\tuniform float opacity;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float maxDistance;\n\t\tuniform float surfDist;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\t\tuniform float thickTolerance;\n\t\t#include <packing>\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\n\t\t}\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\n\t\t\tfloat d=-(a*x+b*y+c*z);\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\n\t\t\treturn distance;\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\n\t\t}\n\t\tvec3 getViewNormal( const in vec2 uv ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n\t\t}\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\n\t\t\tvec2 xy;\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\n\t\t\txy=clip.xy;//clip\n\t\t\tfloat clipW=clip.w;\n\t\t\txy/=clipW;//NDC\n\t\t\txy=(xy+1.)/2.;//uv\n\t\t\txy*=resolution;//screen\n\t\t\treturn xy;\n\t\t}\n\t\tvoid main(){\n\t\t\t#ifdef isSelective\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\n\t\t\t\tif(metalness==0.) return;\n\t\t\t#endif\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\tif(-viewZ>=cameraFar) return;\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\n\n\t\t\tvec2 d0=gl_FragCoord.xy;\n\t\t\tvec2 d1;\n\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\n\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tvec3 viewIncidenceDir=normalize(viewPosition);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#else\n\t\t\t\tvec3 viewIncidenceDir=vec3(0,0,-1);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#endif\n\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\n\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\td1=viewPositionToXY(d1viewPosition);\n\n\t\t\tfloat totalLen=length(d1-d0);\n\t\t\tfloat xLen=d1.x-d0.x;\n\t\t\tfloat yLen=d1.y-d0.y;\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\n\t\t\tfloat xSpan=xLen/totalStep;\n\t\t\tfloat ySpan=yLen/totalStep;\n\t\t\tfor(float i=0.;i<MAX_STEP;i++){\n\t\t\t\tif(i>=totalStep) break;\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\n\t\t\t\tvec2 uv=xy/resolution;\n\n\t\t\t\tfloat d = getDepth(uv);\n\t\t\t\tfloat vZ = getViewZ( d );\n\t\t\t\tif(-vZ>=cameraFar) continue;\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\n\n\t\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\t\t// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\n\t\t\t\t\tfloat sD=surfDist*cW;\n\t\t\t\t#else\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\n\t\t\t\t\tfloat sD=surfDist;\n\t\t\t\t#endif\n\t\t\t\tif(viewReflectRayZ-sD>vZ) continue;\n\n\t\t\t\t#ifdef isInfiniteThick\n\t\t\t\t\tif(viewReflectRayZ+thickTolerance*clipW<vP.z) break;\n\t\t\t\t#endif\n\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\n\n\t\t\t\tfloat op=opacity;\n\n\t\t\t\tif(away<sD){\n\t\t\t\t\tvec3 vN=getViewNormal( uv );\n\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\n\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\n\t\t\t\t\tif(distance>maxDistance) break;\n\t\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\n\t\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef isFresnel\n\t\t\t\t\t\tfloat fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;\n\t\t\t\t\t\top*=fresnel;\n\t\t\t\t\t#endif\n\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\n\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\n\t\t\t\t\tgl_FragColor.a=op;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`,\n}\n\nexport const SSRDepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n  },\n\n  uniforms: {\n    tDepth: { value: null },\n    cameraNear: { value: null },\n    cameraFar: { value: null },\n  },\n\n  vertexShader: /* glsl */ `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n\n  fragmentShader: /* glsl */ `\n\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 uv ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, uv ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n\t\t\tfloat d = 1.0 - depth;\n\t\t\t// d=(d-.999)*1000.;\n    \tgl_FragColor = vec4( vec3( d ), 1.0 );\n\n    }\n\n  `,\n}\n\nexport const SSRBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: new Vector2() },\n    opacity: { value: 0.5 },\n  },\n\n  vertexShader: /* glsl */ `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n\n  fragmentShader: /* glsl */ `\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n    void main() {\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\n\n\t\t\tvec2 offset;\n\n\t\t\toffset=(vec2(-1,0))*texelSize;\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(1,0))*texelSize;\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,-1))*texelSize;\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,1))*texelSize;\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\n\n\t\t\t// float coeCenter=.5;\n\t\t\t// float coeSide=.125;\n\t\t\tfloat coeCenter=.2;\n\t\t\tfloat coeSide=.2;\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\n\t\t\tgl_FragColor=vec4(rgb,a);\n\n\t\t}\n\t`,\n}\n", "import {\n  AddEquation,\n  Color,\n  NormalBlending,\n  DepthTexture,\n  SrcAlphaFactor,\n  OneMinusSrcAlphaFactor,\n  MeshNormalMaterial,\n  MeshBasicMaterial,\n  NearestFilter,\n  NoBlending,\n  ShaderMaterial,\n  UniformsUtils,\n  UnsignedShortType,\n  WebGLRenderTarget,\n  HalfFloatType,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { SSRShader } from '../shaders/SSRShader'\nimport { SSRBlurShader } from '../shaders/SSRShader'\nimport { SSRDepthShader } from '../shaders/SSRShader'\nimport { CopyShader } from '../shaders/CopyShader'\n\nclass SSRPass extends Pass {\n  static OUTPUT = {\n    Default: 0,\n    SSR: 1,\n    Beauty: 3,\n    Depth: 4,\n    Normal: 5,\n    Metalness: 7,\n  }\n  constructor({ renderer, scene, camera, width, height, selects, bouncing = false, groundReflector }) {\n    super()\n\n    this.width = width !== undefined ? width : 512\n    this.height = height !== undefined ? height : 512\n\n    this.clear = true\n\n    this.renderer = renderer\n    this.scene = scene\n    this.camera = camera\n    this.groundReflector = groundReflector\n\n    this.opacity = SSRShader.uniforms.opacity.value\n    this.output = 0\n\n    this.maxDistance = SSRShader.uniforms.maxDistance.value\n    this.thickness = SSRShader.uniforms.thickness.value\n\n    this.tempColor = new Color()\n\n    this._selects = selects\n    this.selective = Array.isArray(this._selects)\n    Object.defineProperty(this, 'selects', {\n      get() {\n        return this._selects\n      },\n      set(val) {\n        if (this._selects === val) return\n        this._selects = val\n        if (Array.isArray(val)) {\n          this.selective = true\n          this.ssrMaterial.defines.SELECTIVE = true\n          this.ssrMaterial.needsUpdate = true\n        } else {\n          this.selective = false\n          this.ssrMaterial.defines.SELECTIVE = false\n          this.ssrMaterial.needsUpdate = true\n        }\n      },\n    })\n\n    this._bouncing = bouncing\n    Object.defineProperty(this, 'bouncing', {\n      get() {\n        return this._bouncing\n      },\n      set(val) {\n        if (this._bouncing === val) return\n        this._bouncing = val\n        if (val) {\n          this.ssrMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture\n        } else {\n          this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n        }\n      },\n    })\n\n    this.blur = true\n\n    this._distanceAttenuation = SSRShader.defines.DISTANCE_ATTENUATION\n    Object.defineProperty(this, 'distanceAttenuation', {\n      get() {\n        return this._distanceAttenuation\n      },\n      set(val) {\n        if (this._distanceAttenuation === val) return\n        this._distanceAttenuation = val\n        this.ssrMaterial.defines.DISTANCE_ATTENUATION = val\n        this.ssrMaterial.needsUpdate = true\n      },\n    })\n\n    this._fresnel = SSRShader.defines.FRESNEL\n    Object.defineProperty(this, 'fresnel', {\n      get() {\n        return this._fresnel\n      },\n      set(val) {\n        if (this._fresnel === val) return\n        this._fresnel = val\n        this.ssrMaterial.defines.FRESNEL = val\n        this.ssrMaterial.needsUpdate = true\n      },\n    })\n\n    this._infiniteThick = SSRShader.defines.INFINITE_THICK\n    Object.defineProperty(this, 'infiniteThick', {\n      get() {\n        return this._infiniteThick\n      },\n      set(val) {\n        if (this._infiniteThick === val) return\n        this._infiniteThick = val\n        this.ssrMaterial.defines.INFINITE_THICK = val\n        this.ssrMaterial.needsUpdate = true\n      },\n    })\n\n    // beauty render target with depth buffer\n\n    const depthTexture = new DepthTexture()\n    depthTexture.type = UnsignedShortType\n    depthTexture.minFilter = NearestFilter\n    depthTexture.magFilter = NearestFilter\n\n    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      type: HalfFloatType,\n      depthTexture: depthTexture,\n      depthBuffer: true,\n    })\n\n    //for bouncing\n    this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n    })\n\n    // normal render target\n\n    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      type: HalfFloatType,\n    })\n\n    // metalness render target\n\n    this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      type: HalfFloatType,\n    })\n\n    // ssr render target\n\n    this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n    })\n\n    this.blurRenderTarget = this.ssrRenderTarget.clone()\n    this.blurRenderTarget2 = this.ssrRenderTarget.clone()\n    // this.blurRenderTarget3 = this.ssrRenderTarget.clone();\n\n    // ssr material\n\n    this.ssrMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSRShader.defines, {\n        MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height),\n      }),\n      uniforms: UniformsUtils.clone(SSRShader.uniforms),\n      vertexShader: SSRShader.vertexShader,\n      fragmentShader: SSRShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n    this.ssrMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture\n    this.ssrMaterial.defines.SELECTIVE = this.selective\n    this.ssrMaterial.needsUpdate = true\n    this.ssrMaterial.uniforms['tMetalness'].value = this.metalnessRenderTarget.texture\n    this.ssrMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture\n    this.ssrMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.ssrMaterial.uniforms['cameraFar'].value = this.camera.far\n    this.ssrMaterial.uniforms['thickness'].value = this.thickness\n    this.ssrMaterial.uniforms['resolution'].value.set(this.width, this.height)\n    this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix)\n    this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)\n\n    // normal material\n\n    this.normalMaterial = new MeshNormalMaterial()\n    this.normalMaterial.blending = NoBlending\n\n    // metalnessOn material\n\n    this.metalnessOnMaterial = new MeshBasicMaterial({\n      color: 'white',\n    })\n\n    // metalnessOff material\n\n    this.metalnessOffMaterial = new MeshBasicMaterial({\n      color: 'black',\n    })\n\n    // blur material\n\n    this.blurMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSRBlurShader.defines),\n      uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n      vertexShader: SSRBlurShader.vertexShader,\n      fragmentShader: SSRBlurShader.fragmentShader,\n    })\n    this.blurMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture\n    this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height)\n\n    // blur material 2\n\n    this.blurMaterial2 = new ShaderMaterial({\n      defines: Object.assign({}, SSRBlurShader.defines),\n      uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n      vertexShader: SSRBlurShader.vertexShader,\n      fragmentShader: SSRBlurShader.fragmentShader,\n    })\n    this.blurMaterial2.uniforms['tDiffuse'].value = this.blurRenderTarget.texture\n    this.blurMaterial2.uniforms['resolution'].value.set(this.width, this.height)\n\n    // // blur material 3\n\n    // this.blurMaterial3 = new ShaderMaterial({\n    //   defines: Object.assign({}, SSRBlurShader.defines),\n    //   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n    //   vertexShader: SSRBlurShader.vertexShader,\n    //   fragmentShader: SSRBlurShader.fragmentShader\n    // });\n    // this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;\n    // this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);\n\n    // material for rendering the depth\n\n    this.depthRenderMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSRDepthShader.defines),\n      uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),\n      vertexShader: SSRDepthShader.vertexShader,\n      fragmentShader: SSRDepthShader.fragmentShader,\n      blending: NoBlending,\n    })\n    this.depthRenderMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture\n    this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near\n    this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far\n\n    // material for rendering the content of a render target\n\n    this.copyMaterial = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(CopyShader.uniforms),\n      vertexShader: CopyShader.vertexShader,\n      fragmentShader: CopyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      blendSrc: SrcAlphaFactor,\n      blendDst: OneMinusSrcAlphaFactor,\n      blendEquation: AddEquation,\n      blendSrcAlpha: SrcAlphaFactor,\n      blendDstAlpha: OneMinusSrcAlphaFactor,\n      blendEquationAlpha: AddEquation,\n      // premultipliedAlpha:true,\n    })\n\n    this.fsQuad = new FullScreenQuad(null)\n\n    this.originalClearColor = new Color()\n  }\n\n  dispose() {\n    // dispose render targets\n\n    this.beautyRenderTarget.dispose()\n    this.prevRenderTarget.dispose()\n    this.normalRenderTarget.dispose()\n    this.metalnessRenderTarget.dispose()\n    this.ssrRenderTarget.dispose()\n    this.blurRenderTarget.dispose()\n    this.blurRenderTarget2.dispose()\n    // this.blurRenderTarget3.dispose();\n\n    // dispose materials\n\n    this.normalMaterial.dispose()\n    this.metalnessOnMaterial.dispose()\n    this.metalnessOffMaterial.dispose()\n    this.blurMaterial.dispose()\n    this.blurMaterial2.dispose()\n    this.copyMaterial.dispose()\n    this.depthRenderMaterial.dispose()\n\n    // dipsose full screen quad\n\n    this.fsQuad.dispose()\n  }\n\n  render(renderer, writeBuffer /*, readBuffer, deltaTime, maskActive */) {\n    // render beauty and depth\n\n    renderer.setRenderTarget(this.beautyRenderTarget)\n    renderer.clear()\n    if (this.groundReflector) {\n      this.groundReflector.visible = false\n      this.groundReflector.doRender(this.renderer, this.scene, this.camera)\n      this.groundReflector.visible = true\n    }\n\n    renderer.render(this.scene, this.camera)\n    if (this.groundReflector) this.groundReflector.visible = false\n\n    // render normals\n\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0)\n\n    // render metalnesses\n\n    if (this.selective) {\n      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0)\n    }\n\n    // render SSR\n\n    this.ssrMaterial.uniforms['opacity'].value = this.opacity\n    this.ssrMaterial.uniforms['maxDistance'].value = this.maxDistance\n    this.ssrMaterial.uniforms['thickness'].value = this.thickness\n    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget)\n\n    // render blur\n\n    if (this.blur) {\n      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget)\n      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2)\n      // this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);\n    }\n\n    // output result to screen\n\n    switch (this.output) {\n      case SSRPass.OUTPUT.Default:\n        if (this.bouncing) {\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n          this.copyMaterial.blending = NoBlending\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)\n\n          if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture\n          else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture\n          this.copyMaterial.blending = NormalBlending\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)\n\n          this.copyMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture\n          this.copyMaterial.blending = NoBlending\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n        } else {\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n          this.copyMaterial.blending = NoBlending\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n          if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture\n          else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture\n          this.copyMaterial.blending = NormalBlending\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n        }\n\n        break\n      case SSRPass.OUTPUT.SSR:\n        if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture\n        else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        if (this.bouncing) {\n          if (this.blur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture\n          else this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n          this.copyMaterial.blending = NoBlending\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)\n\n          this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture\n          this.copyMaterial.blending = NormalBlending\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget)\n        }\n\n        break\n\n      case SSRPass.OUTPUT.Beauty:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSRPass.OUTPUT.Depth:\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSRPass.OUTPUT.Normal:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      case SSRPass.OUTPUT.Metalness:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.metalnessRenderTarget.texture\n        this.copyMaterial.blending = NoBlending\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer)\n\n        break\n\n      default:\n        console.warn('THREE.SSRPass: Unknown output type.')\n    }\n  }\n\n  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor))\n    const originalClearAlpha = renderer.getClearAlpha(this.tempColor)\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n\n    // setup pass state\n    renderer.autoClear = false\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.fsQuad.material = passMaterial\n    this.fsQuad.render(renderer)\n\n    // restore original state\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor))\n    const originalClearAlpha = renderer.getClearAlpha(this.tempColor)\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n    renderer.autoClear = false\n\n    clearColor = overrideMaterial.clearColor || clearColor\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.scene.overrideMaterial = overrideMaterial\n    renderer.render(this.scene, this.camera)\n    this.scene.overrideMaterial = null\n\n    // restore original state\n\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  renderMetalness(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor))\n    const originalClearAlpha = renderer.getClearAlpha(this.tempColor)\n    const originalAutoClear = renderer.autoClear\n\n    renderer.setRenderTarget(renderTarget)\n    renderer.autoClear = false\n\n    clearColor = overrideMaterial.clearColor || clearColor\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor)\n      renderer.setClearAlpha(clearAlpha || 0.0)\n      renderer.clear()\n    }\n\n    this.scene.traverseVisible((child) => {\n      child._SSRPassBackupMaterial = child.material\n      if (this._selects.includes(child)) {\n        child.material = this.metalnessOnMaterial\n      } else {\n        child.material = this.metalnessOffMaterial\n      }\n    })\n    renderer.render(this.scene, this.camera)\n    this.scene.traverseVisible((child) => {\n      child.material = child._SSRPassBackupMaterial\n    })\n\n    // restore original state\n\n    renderer.autoClear = originalAutoClear\n    renderer.setClearColor(this.originalClearColor)\n    renderer.setClearAlpha(originalClearAlpha)\n  }\n\n  setSize(width, height) {\n    this.width = width\n    this.height = height\n\n    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height)\n    this.ssrMaterial.needsUpdate = true\n    this.beautyRenderTarget.setSize(width, height)\n    this.prevRenderTarget.setSize(width, height)\n    this.ssrRenderTarget.setSize(width, height)\n    this.normalRenderTarget.setSize(width, height)\n    this.metalnessRenderTarget.setSize(width, height)\n    this.blurRenderTarget.setSize(width, height)\n    this.blurRenderTarget2.setSize(width, height)\n    // this.blurRenderTarget3.setSize(width, height);\n\n    this.ssrMaterial.uniforms['resolution'].value.set(width, height)\n    this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix)\n    this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse)\n\n    this.blurMaterial.uniforms['resolution'].value.set(width, height)\n    this.blurMaterial2.uniforms['resolution'].value.set(width, height)\n  }\n}\n\nexport { SSRPass }\n", "import { Vector2 } from 'three'\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type ConvolutionShaderDefines = {\n  KERNEL_SIZE_FLOAT: string\n  KERNEL_SIZE_INT: string\n}\n\nexport type ConvolutionShaderUniforms = {\n  cKernel: IUniform<number[]>\n  tDiffuse: IUniform<Texture | null>\n  uImageIncrement: IUniform<Vector2>\n}\n\nexport interface IConvolutionShader extends IShader<ConvolutionShaderUniforms, ConvolutionShaderDefines> {\n  buildKernel: (sigma: number) => number[]\n}\n\nexport const ConvolutionShader: IConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25',\n  },\n\n  uniforms: {\n    tDiffuse: { value: null },\n    uImageIncrement: { value: new Vector2(0.001953125, 0.0) },\n    cKernel: { value: [] },\n  },\n\n  vertexShader: [\n    'uniform vec2 uImageIncrement;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float cKernel[ KERNEL_SIZE_INT ];',\n\n    'uniform sampler2D tDiffuse;',\n    'uniform vec2 uImageIncrement;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 imageCoord = vUv;',\n    '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );',\n\n    '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',\n\n    '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',\n    '\t\timageCoord += uImageIncrement;',\n\n    '\t}',\n\n    '\tgl_FragColor = sum;',\n\n    '}',\n  ].join('\\n'),\n\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n    function gauss(x: number, sigma: number): number {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma))\n    }\n\n    const kMaxKernelSize = 25\n\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3.0) + 1, kMaxKernelSize)\n\n    const halfWidth = (kernelSize - 1) * 0.5\n\n    const values: number[] = new Array(kernelSize)\n\n    let sum = 0.0\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma)\n      sum += values[i]\n    }\n\n    // normalize the kernel\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum\n\n    return values\n  },\n}\n", "export function decodeText(array) {\n  if (typeof TextDecoder !== 'undefined') {\n    return new TextDecoder().decode(array)\n  }\n\n  // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n  // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n  let s = ''\n\n  for (let i = 0, il = array.length; i < il; i++) {\n    // Implicitly assumes little-endian.\n    s += String.fromCharCode(array[i])\n  }\n\n  try {\n    // merges multi-byte utf-8 characters.\n\n    return decodeURIComponent(escape(s))\n  } catch (e) {\n    // see https://github.com/mrdoob/three.js/issues/16358\n\n    return s\n  }\n}\n", "import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n", "import * as THREE from 'three'\n\nconst PINCH_MAX = 0.05\nconst PINCH_THRESHOLD = 0.02\nconst PINCH_MIN = 0.01\nconst POINTER_ADVANCE_MAX = 0.02\nconst POINTER_OPACITY_MAX = 1\nconst POINTER_OPACITY_MIN = 0.4\nconst POINTER_FRONT_RADIUS = 0.002\nconst POINTER_REAR_RADIUS = 0.01\nconst POINTER_REAR_RADIUS_MIN = 0.003\nconst POINTER_LENGTH = 0.035\nconst POINTER_SEGMENTS = 16\nconst POINTER_RINGS = 12\nconst POINTER_HEMISPHERE_ANGLE = 110\nconst YAXIS = new THREE.Vector3(0, 1, 0)\nconst ZAXIS = new THREE.Vector3(0, 0, 1)\n\nconst CURSOR_RADIUS = 0.02\nconst CURSOR_MAX_DISTANCE = 1.5\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super()\n\n    this.hand = hand\n    this.controller = controller\n\n    // Unused\n    this.motionController = null\n    this.envMap = null\n    this.mesh = null\n\n    this.pointerGeometry = null\n    this.pointerMesh = null\n    this.pointerObject = null\n\n    this.pinched = false\n    this.attached = false\n\n    this.cursorObject = null\n\n    this.raycaster = null\n\n    this._onConnected = this._onConnected.bind(this)\n    this._onDisconnected = this._onDisconnected.bind(this)\n    this.hand.addEventListener('connected', this._onConnected)\n    this.hand.addEventListener('disconnected', this._onDisconnected)\n  }\n\n  _onConnected(event) {\n    const xrInputSource = event.data\n    if (xrInputSource.hand) {\n      this.visible = true\n      this.xrInputSource = xrInputSource\n\n      this.createPointer()\n    }\n  }\n\n  _onDisconnected() {\n    this.visible = false\n    this.xrInputSource = null\n\n    this.pointerGeometry?.dispose()\n    this.pointerMesh?.material.dispose()\n\n    this.clear()\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone()\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, (Math.PI * 2) / POINTER_SEGMENTS)\n      const vid = ringIndex * POINTER_SEGMENTS + i\n      vertices[3 * vid] = segmentVector.x\n      vertices[3 * vid + 1] = segmentVector.y\n      vertices[3 * vid + 2] = segmentVector.z\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array\n    // first ring for front face\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius))\n    this._drawVerticesRing(vertices, frontFaceBase, 0)\n\n    // rings for rear hemisphere\n    const rearBase = new THREE.Vector3(\n      Math.sin((Math.PI * POINTER_HEMISPHERE_ANGLE) / 180) * rearRadius,\n      Math.cos((Math.PI * POINTER_HEMISPHERE_ANGLE) / 180) * rearRadius,\n      0,\n    )\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1)\n      rearBase.applyAxisAngle(YAXIS, (Math.PI * POINTER_HEMISPHERE_ANGLE) / 180 / (POINTER_RINGS * -2))\n    }\n\n    // front and rear face center vertices\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS)\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius))\n    vertices[frontCenterIndex * 3] = frontCenter.x\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius)\n    vertices[rearCenterIndex * 3] = rearCenter.x\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z\n\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n    // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0)\n    // const vertices = [];\n    const indices = []\n    this.pointerGeometry = new THREE.BufferGeometry()\n\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS)\n\n    // construct faces to connect rings\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j)\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j)\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1)\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1)\n    }\n\n    // construct front and rear face\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS)\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i)\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1)\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1)\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS)\n\n    const material = new THREE.MeshBasicMaterial()\n    material.transparent = true\n    material.opacity = POINTER_OPACITY_MIN\n\n    this.pointerGeometry.setIndex(indices)\n\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material)\n\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS)\n    this.pointerObject = new THREE.Object3D()\n    this.pointerObject.add(this.pointerMesh)\n\n    this.raycaster = new THREE.Raycaster()\n\n    // create cursor\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10)\n    const cursorMaterial = new THREE.MeshBasicMaterial()\n    cursorMaterial.transparent = true\n    cursorMaterial.opacity = POINTER_OPACITY_MIN\n\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial)\n    this.pointerObject.add(this.cursorObject)\n\n    this.add(this.pointerObject)\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld\n      const tempMatrix = new THREE.Matrix4()\n      tempMatrix.identity().extractRotation(pointerMatrix)\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix)\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix)\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible\n    const indexTip = this.hand.joints['index-finger-tip']\n    const thumbTip = this.hand.joints['thumb-tip']\n    const distance = indexTip.position.distanceTo(thumbTip.position)\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5)\n    this.pointerObject.position.copy(position)\n    this.pointerObject.quaternion.copy(this.controller.quaternion)\n\n    this.pinched = distance <= PINCH_THRESHOLD\n\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN)\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN)\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS)\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS)\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN\n      this._updatePointerVertices(rearRadius)\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX)\n        this.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN)\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius)\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN)\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX)\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force)\n    if (this.pointerGeometry) {\n      this._updatePointer()\n      this._updateRaycaster()\n    }\n  }\n\n  isPinched() {\n    return this.pinched\n  }\n\n  setAttached(attached) {\n    this.attached = attached\n  }\n\n  isAttached() {\n    return this.attached\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive)\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive)\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive)\n      const direction = new THREE.Vector3(0, 0, -1)\n      if (intersections.length > 0) {\n        const intersection = intersections[0]\n        const distance = intersection.distance\n        this.cursorObject.position.copy(direction.multiplyScalar(distance))\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE))\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1)\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance))\n    }\n  }\n\n  dispose() {\n    this._onDisconnected()\n    this.hand.removeEventListener('connected', this._onConnected)\n    this.hand.removeEventListener('disconnected', this._onDisconnected)\n  }\n}\n\nexport { OculusHandPointerModel }\n", "import { WebGLRenderer } from 'three'\n\nclass VRButton {\n  static createButton(renderer: WebGLRenderer, sessionInit: XRSessionInit = {}): HTMLButtonElement | HTMLAnchorElement {\n    const button = document.createElement('button')\n\n    function showEnterVR(/*device*/): void {\n      let currentSession: XRSession | null = null\n\n      async function onSessionStarted(session: XRSession): Promise<void> {\n        session.addEventListener('end', onSessionEnded)\n\n        await renderer.xr.setSession(session as any)\n        button.textContent = 'EXIT VR'\n\n        currentSession = session\n      }\n\n      function onSessionEnded(/*event*/): void {\n        currentSession!.removeEventListener('end', onSessionEnded)\n\n        button.textContent = 'ENTER VR'\n\n        currentSession = null\n      }\n\n      //\n\n      button.style.display = ''\n\n      button.style.cursor = 'pointer'\n      button.style.left = 'calc(50% - 50px)'\n      button.style.width = '100px'\n\n      button.textContent = 'ENTER VR'\n\n      button.onmouseenter = (): void => {\n        button.style.opacity = '1.0'\n      }\n\n      button.onmouseleave = (): void => {\n        button.style.opacity = '0.5'\n      }\n\n      button.onclick = (): void => {\n        if (currentSession === null) {\n          // WebXR's requestReferenceSpace only works if the corresponding feature\n          // was requested at session creation time. For simplicity, just ask for\n          // the interesting ones as optional features, but be aware that the\n          // requestReferenceSpace call will fail if it turns out to be unavailable.\n          // ('local' is always available for immersive sessions and doesn't need to\n          // be requested separately.)\n\n          const optionalFeatures = [sessionInit.optionalFeatures, 'local-floor', 'bounded-floor', 'hand-tracking']\n            .flat()\n            .filter(Boolean) as string[]\n\n          ;(navigator as Navigator).xr\n            ?.requestSession('immersive-vr', { ...sessionInit, optionalFeatures })\n            .then(onSessionStarted)\n        } else {\n          currentSession.end()\n        }\n      }\n    }\n\n    function disableButton(): void {\n      button.style.display = ''\n\n      button.style.cursor = 'auto'\n      button.style.left = 'calc(50% - 75px)'\n      button.style.width = '150px'\n\n      button.onmouseenter = null\n      button.onmouseleave = null\n\n      button.onclick = null\n    }\n\n    function showWebXRNotFound(): void {\n      disableButton()\n\n      button.textContent = 'VR NOT SUPPORTED'\n    }\n\n    function stylizeElement(element: HTMLElement): void {\n      element.style.position = 'absolute'\n      element.style.bottom = '20px'\n      element.style.padding = '12px 6px'\n      element.style.border = '1px solid #fff'\n      element.style.borderRadius = '4px'\n      element.style.background = 'rgba(0,0,0,0.1)'\n      element.style.color = '#fff'\n      element.style.font = 'normal 13px sans-serif'\n      element.style.textAlign = 'center'\n      element.style.opacity = '0.5'\n      element.style.outline = 'none'\n      element.style.zIndex = '999'\n    }\n\n    if ('xr' in navigator) {\n      stylizeElement(button)\n      button.id = 'VRButton'\n      button.style.display = 'none'\n\n      // Query for session mode\n      navigator.xr!.isSessionSupported('immersive-vr').then((supported) => {\n        supported ? showEnterVR() : showWebXRNotFound()\n\n        if (supported && VRButton.xrSessionIsGranted) {\n          button.click()\n        }\n      })\n\n      return button\n    } else {\n      const message = document.createElement('a')\n\n      if (window.isSecureContext === false) {\n        message.href = document.location.href.replace(/^http:/, 'https:')\n        message.innerHTML = 'WEBXR NEEDS HTTPS' // TODO Improve message\n      } else {\n        message.href = 'https://immersiveweb.dev/'\n        message.innerHTML = 'WEBXR NOT AVAILABLE'\n      }\n\n      message.style.left = 'calc(50% - 90px)'\n      message.style.width = '180px'\n      message.style.textDecoration = 'none'\n\n      stylizeElement(message)\n\n      return message\n    }\n  }\n\n  static xrSessionIsGranted = false\n\n  static registerSessionGrantedListener(): void {\n    if (typeof navigator !== 'undefined' && 'xr' in navigator) {\n      ;(navigator as Navigator).xr!.addEventListener('sessiongranted', () => {\n        VRButton.xrSessionIsGranted = true\n      })\n    }\n  }\n}\n\nVRButton.registerSessionGrantedListener()\n\nexport { VRButton }\n", "/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\n\nimport type { Object3D } from 'three'\n\ninterface GamepadIndices {\n  button: number\n  xAxis?: number\n  yAxis?: number\n}\n\ninterface VisualResponseDescription {\n  componentProperty: string\n  states: string[]\n  valueNodeProperty: string\n  valueNodeName: string\n  minNodeName?: string\n  maxNodeName?: string\n}\n\ntype VisualResponses = Record<string, VisualResponseDescription>\n\ninterface ComponentDescription {\n  type: string\n  gamepadIndices: GamepadIndices\n  rootNodeName: string\n  visualResponses: VisualResponses\n  touchPointNodeName?: string\n}\n\ninterface Components {\n  [componentKey: string]: ComponentDescription\n}\n\ninterface LayoutDescription {\n  selectComponentId: string\n  components: Components\n  gamepadMapping: string\n  rootNodeName: string\n  assetPath: string\n}\n\ntype Layouts = Partial<Record<XRHandedness, LayoutDescription>>\n\nexport interface Profile {\n  profileId: string\n  fallbackProfileIds: string[]\n  layouts: Layouts\n}\n\ninterface ProfilesList {\n  [profileId: string]: { path: string; deprecated?: boolean } | undefined\n}\n\nconst MotionControllerConstants = {\n  Handedness: {\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right',\n  },\n\n  ComponentState: {\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed',\n  },\n\n  ComponentProperty: {\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state',\n  },\n\n  ComponentType: {\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button',\n  },\n\n  ButtonTouchThreshold: 0.05,\n\n  AxisTouchThreshold: 0.1,\n\n  VisualResponseProperty: {\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility',\n  },\n}\n\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\nasync function fetchJsonFile<T>(path: string): Promise<T> {\n  const response = await fetch(path)\n  if (!response.ok) {\n    throw new Error(response.statusText)\n  } else {\n    return response.json()\n  }\n}\n\nasync function fetchProfilesList(basePath: string): Promise<ProfilesList> {\n  if (!basePath) {\n    throw new Error('No basePath supplied')\n  }\n\n  const profileListFileName = 'profilesList.json'\n  const profilesList = await fetchJsonFile<ProfilesList>(`${basePath}/${profileListFileName}`)\n  return profilesList\n}\n\nasync function fetchProfile(\n  xrInputSource: XRInputSource,\n  basePath: string,\n  defaultProfile: string | null = null,\n  getAssetPath = true,\n): Promise<{ profile: Profile; assetPath: string | undefined }> {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied')\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied')\n  }\n\n  // Get the list of profiles\n  const supportedProfilesList = await fetchProfilesList(basePath)\n\n  // Find the relative path to the first requested profile that is recognized\n  let match: { profileId: string; profilePath: string; deprecated: boolean } | undefined = undefined\n  xrInputSource.profiles.some((profileId: string) => {\n    const supportedProfile = supportedProfilesList[profileId]\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated,\n      }\n    }\n    return !!match\n  })\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found')\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile]\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`)\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated,\n    }\n  }\n\n  const profile = await fetchJsonFile<Profile>(match.profilePath)\n\n  let assetPath: string | undefined = undefined\n  if (getAssetPath) {\n    let layout\n    if ((xrInputSource.handedness as string) === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0] as XRHandedness]\n    } else {\n      layout = profile.layouts[xrInputSource.handedness]\n    }\n    if (!layout) {\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`)\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath)\n    }\n  }\n\n  return { profile, assetPath }\n}\n\n/** @constant {Object} */\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: MotionControllerConstants.ComponentState.DEFAULT,\n}\n\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number | undefined} x The original x coordinate in the range -1 to 1\n * @param {number | undefined} y The original y coordinate in the range -1 to 1\n */\nfunction normalizeAxes(\n  x: number | undefined = 0,\n  y: number | undefined = 0,\n): { normalizedXAxis: number; normalizedYAxis: number } {\n  let xAxis = x\n  let yAxis = y\n\n  // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n  const hypotenuse = Math.sqrt(x * x + y * y)\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x)\n    xAxis = Math.cos(theta)\n    yAxis = Math.sin(theta)\n  }\n\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n  const result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5,\n  }\n  return result\n}\n\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\nclass VisualResponse implements VisualResponseDescription {\n  value: number | boolean\n  componentProperty: string\n  states: string[]\n  valueNodeName: string\n  valueNodeProperty: string\n  minNodeName?: string\n  maxNodeName?: string\n  valueNode: Object3D | undefined\n  minNode: Object3D | undefined\n  maxNode: Object3D | undefined\n  constructor(visualResponseDescription: VisualResponseDescription) {\n    this.componentProperty = visualResponseDescription.componentProperty\n    this.states = visualResponseDescription.states\n    this.valueNodeName = visualResponseDescription.valueNodeName\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty\n\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName\n      this.maxNodeName = visualResponseDescription.maxNodeName\n    }\n\n    // Initializes the response's current value based on default data\n    this.value = 0\n    this.updateFromComponent(defaultComponentValues)\n  }\n\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number | undefined} xAxis - The reported X axis value of the component\n   * @param {number | undefined} yAxis - The reported Y axis value of the component\n   * @param {number | undefined} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n  updateFromComponent({\n    xAxis,\n    yAxis,\n    button,\n    state,\n  }: {\n    xAxis?: number\n    yAxis?: number\n    button?: number\n    state: string\n  }): void {\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis)\n    switch (this.componentProperty) {\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5\n        break\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5\n        break\n      case MotionControllerConstants.ComponentProperty.BUTTON:\n        this.value = this.states.includes(state) && button ? button : 0\n        break\n      case MotionControllerConstants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\n          this.value = this.states.includes(state)\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0\n        }\n        break\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)\n    }\n  }\n}\n\nclass Component implements ComponentDescription {\n  id: string\n  values: {\n    state: string\n    button: number | undefined\n    xAxis: number | undefined\n    yAxis: number | undefined\n  }\n\n  type: string\n  gamepadIndices: GamepadIndices\n  rootNodeName: string\n  visualResponses: Record<string, VisualResponse>\n  touchPointNodeName?: string | undefined\n  touchPointNode?: Object3D\n\n  /**\n   * @param {string} componentId - Id of the component\n   * @param {InputProfileComponent} componentDescription - Description of the component to be created\n   */\n  constructor(componentId: string, componentDescription: ComponentDescription) {\n    if (\n      !componentId ||\n      !componentDescription ||\n      !componentDescription.visualResponses ||\n      !componentDescription.gamepadIndices ||\n      Object.keys(componentDescription.gamepadIndices).length === 0\n    ) {\n      throw new Error('Invalid arguments supplied')\n    }\n\n    this.id = componentId\n    this.type = componentDescription.type\n    this.rootNodeName = componentDescription.rootNodeName\n    this.touchPointNodeName = componentDescription.touchPointNodeName\n\n    // Build all the visual responses for this component\n    this.visualResponses = {}\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName])\n      this.visualResponses[responseName] = visualResponse\n    })\n\n    // Set default values\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices)\n\n    this.values = {\n      state: MotionControllerConstants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined,\n    }\n  }\n\n  get data(): { id: Component['id'] } & Component['values'] {\n    const data = { id: this.id, ...this.values }\n    return data\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n  updateFromGamepad(gamepad: Gamepad): void {\n    // Set the state to default before processing other data sources\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT\n\n    // Get and normalize button\n    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button]\n      this.values.button = gamepadButton.value\n      this.values.button = this.values.button! < 0 ? 0 : this.values.button\n      this.values.button = this.values.button! > 1 ? 1 : this.values.button\n\n      // Set the state based on the button\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED\n      } else if (gamepadButton.touched || this.values.button! > MotionControllerConstants.ButtonTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED\n      }\n    }\n\n    // Get and normalize x axis value\n    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis]\n      this.values.xAxis = this.values.xAxis! < -1 ? -1 : this.values.xAxis\n      this.values.xAxis = this.values.xAxis! > 1 ? 1 : this.values.xAxis\n\n      // If the state is still default, check if the xAxis makes it touched\n      if (\n        this.values.state === MotionControllerConstants.ComponentState.DEFAULT &&\n        Math.abs(this.values.xAxis!) > MotionControllerConstants.AxisTouchThreshold\n      ) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED\n      }\n    }\n\n    // Get and normalize Y axis value\n    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis]\n      this.values.yAxis = this.values.yAxis! < -1 ? -1 : this.values.yAxis\n      this.values.yAxis = this.values.yAxis! > 1 ? 1 : this.values.yAxis\n\n      // If the state is still default, check if the yAxis makes it touched\n      if (\n        this.values.state === MotionControllerConstants.ComponentState.DEFAULT &&\n        Math.abs(this.values.yAxis!) > MotionControllerConstants.AxisTouchThreshold\n      ) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED\n      }\n    }\n\n    // Update the visual response weights based on the current component data\n    Object.values(this.visualResponses).forEach((visualResponse) => {\n      visualResponse.updateFromComponent(this.values)\n    })\n  }\n}\n/**\n * @description Builds a motion controller with components and visual responses based on the\n * supplied profile description. Data is polled from the xrInputSource's gamepad.\n * @author Nell Waliczek / https://github.com/NellWaliczek\n */\nclass MotionController {\n  xrInputSource: XRInputSource\n  assetUrl: string\n  layoutDescription: LayoutDescription\n  id: string\n  components: Record<string, Component>\n  /**\n   * @param {XRInputSource} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Profile} profile - The best matched profile description for the supplied xrInputSource\n   * @param {string} assetUrl\n   */\n  constructor(xrInputSource: XRInputSource, profile: Profile, assetUrl: string) {\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied')\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied')\n    }\n\n    if (!profile.layouts[xrInputSource.handedness]) {\n      throw new Error('No layout for ' + xrInputSource.handedness + ' handedness')\n    }\n\n    this.xrInputSource = xrInputSource\n    this.assetUrl = assetUrl\n    this.id = profile.profileId\n\n    // Build child components as described in the profile description\n    this.layoutDescription = profile.layouts[xrInputSource.handedness]!\n\n    this.components = {}\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\n      const componentDescription = this.layoutDescription.components[componentId]\n      this.components[componentId] = new Component(componentId, componentDescription)\n    })\n\n    // Initialize components based on current gamepad state\n    this.updateFromGamepad()\n  }\n\n  get gripSpace(): XRInputSource['gripSpace'] {\n    return this.xrInputSource.gripSpace\n  }\n\n  get targetRaySpace(): XRInputSource['targetRaySpace'] {\n    return this.xrInputSource.targetRaySpace\n  }\n\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n  get data(): Array<Component['data']> {\n    const data: Array<Component['data']> = []\n    Object.values(this.components).forEach((component) => {\n      data.push(component.data)\n    })\n    return data\n  }\n\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n  updateFromGamepad(): void {\n    Object.values(this.components).forEach((component) => {\n      component.updateFromGamepad(this.xrInputSource.gamepad!)\n    })\n  }\n}\n\nexport { MotionControllerConstants, MotionController, fetchProfile, fetchProfilesList }\n", "import {\n  DynamicDrawUsage,\n  SphereGeometry,\n  BoxGeometry,\n  MeshStandardMaterial,\n  InstancedMesh,\n  Matrix4,\n  Vector3,\n} from 'three'\n\nconst _matrix = new Matrix4()\nconst _vector = new Vector3()\n\nclass XRHandPrimitiveModel {\n  constructor(handModel, controller, path, handedness, options) {\n    this.controller = controller\n    this.handModel = handModel\n    this.envMap = null\n\n    let geometry\n\n    if (!options || !options.primitive || options.primitive === 'sphere') {\n      geometry = new SphereGeometry(1, 10, 10)\n    } else if (options.primitive === 'box') {\n      geometry = new BoxGeometry(1, 1, 1)\n    }\n\n    const material = new MeshStandardMaterial()\n\n    this.handMesh = new InstancedMesh(geometry, material, 30)\n    this.handMesh.instanceMatrix.setUsage(DynamicDrawUsage) // will be updated every frame\n    this.handMesh.castShadow = true\n    this.handMesh.receiveShadow = true\n    this.handModel.add(this.handMesh)\n\n    this.joints = [\n      'wrist',\n      'thumb-metacarpal',\n      'thumb-phalanx-proximal',\n      'thumb-phalanx-distal',\n      'thumb-tip',\n      'index-finger-metacarpal',\n      'index-finger-phalanx-proximal',\n      'index-finger-phalanx-intermediate',\n      'index-finger-phalanx-distal',\n      'index-finger-tip',\n      'middle-finger-metacarpal',\n      'middle-finger-phalanx-proximal',\n      'middle-finger-phalanx-intermediate',\n      'middle-finger-phalanx-distal',\n      'middle-finger-tip',\n      'ring-finger-metacarpal',\n      'ring-finger-phalanx-proximal',\n      'ring-finger-phalanx-intermediate',\n      'ring-finger-phalanx-distal',\n      'ring-finger-tip',\n      'pinky-finger-metacarpal',\n      'pinky-finger-phalanx-proximal',\n      'pinky-finger-phalanx-intermediate',\n      'pinky-finger-phalanx-distal',\n      'pinky-finger-tip',\n    ]\n  }\n\n  updateMesh() {\n    const defaultRadius = 0.008\n    const joints = this.controller.joints\n\n    let count = 0\n\n    for (let i = 0; i < this.joints.length; i++) {\n      const joint = joints[this.joints[i]]\n\n      if (joint.visible) {\n        _vector.setScalar(joint.jointRadius || defaultRadius)\n        _matrix.compose(joint.position, joint.quaternion, _vector)\n        this.handMesh.setMatrixAt(i, _matrix)\n\n        count++\n      }\n    }\n\n    this.handMesh.count = count\n    this.handMesh.instanceMatrix.needsUpdate = true\n  }\n}\n\nexport { XRHandPrimitiveModel }\n", "import { BoxGeometry, Vector3 } from 'three'\n\nconst tempNormal = new Vector3()\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = (2 * Math.PI * radius) / 4\n\n  // length of the planes between the arcs on each axis\n  const centerLength = Math.max(sideLength - 2 * radius, 0)\n  const halfArc = Math.PI / 4\n\n  // Get the vector projected onto the Y plane\n  tempNormal.copy(normal)\n  tempNormal[projectionAxis] = 0\n  tempNormal.normalize()\n\n  // total amount of UV space alloted to a single arc\n  const arcUvRatio = (0.5 * totArcLength) / (totArcLength + centerLength)\n\n  // the distance along one arc the point is at\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    const lenUv = centerLength / (totArcLength + centerLength)\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio)\n  }\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1\n\n    // ensure radius isn't bigger than shortest side\n    radius = Math.min(width / 2, height / 2, depth / 2, radius)\n\n    super(1, 1, 1, segments, segments, segments)\n\n    // if we just have one segment we're the same as a regular box\n    if (segments === 1) return\n\n    const geometry2 = this.toNonIndexed()\n\n    this.index = null\n    this.attributes.position = geometry2.attributes.position\n    this.attributes.normal = geometry2.attributes.normal\n    this.attributes.uv = geometry2.attributes.uv\n\n    //\n\n    const position = new Vector3()\n    const normal = new Vector3()\n\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius)\n\n    const positions = this.attributes.position.array\n    const normals = this.attributes.normal.array\n    const uvs = this.attributes.uv.array\n\n    const faceTris = positions.length / 6\n    const faceDirVector = new Vector3()\n    const halfSegmentSize = 0.5 / segments\n\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i)\n      normal.copy(position)\n      normal.x -= Math.sign(normal.x) * halfSegmentSize\n      normal.y -= Math.sign(normal.y) * halfSegmentSize\n      normal.z -= Math.sign(normal.z) * halfSegmentSize\n      normal.normalize()\n\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius\n\n      normals[i + 0] = normal.x\n      normals[i + 1] = normal.y\n      normals[i + 2] = normal.z\n\n      const side = Math.floor(i / faceTris)\n\n      switch (side) {\n        case 0: // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0)\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height)\n          break\n\n        case 1: // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height)\n          break\n\n        case 2: // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width)\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth)\n          break\n\n        case 3: // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth)\n          break\n\n        case 4: // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height)\n          break\n\n        case 5: // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1)\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height)\n          break\n      }\n    }\n  }\n}\n\nexport { RoundedBoxGeometry }\n", "import { Vector3, Matrix4 } from 'three'\n\nconst inverseProjectionMatrix = new Matrix4()\n\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {}\n\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n    }\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000)\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0\n\n    inverseProjectionMatrix.copy(projectionMatrix).invert()\n\n    // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1)\n    this.vertices.near[1].set(1, -1, -1)\n    this.vertices.near[2].set(-1, -1, -1)\n    this.vertices.near[3].set(-1, 1, -1)\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix)\n    })\n\n    this.vertices.far[0].set(1, 1, 1)\n    this.vertices.far[1].set(1, -1, 1)\n    this.vertices.far[2].set(-1, -1, 1)\n    this.vertices.far[3].set(-1, 1, 1)\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix)\n\n      const absZ = Math.abs(v.z)\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0)\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0))\n      }\n    })\n\n    return this.vertices\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum())\n    }\n\n    target.length = breaks.length\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i]\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j])\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1])\n        }\n      }\n\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j])\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i])\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix)\n\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix)\n    }\n  }\n}\n\nexport { CSMFrustum }\n", "import { Vector2, Vector3, DirectionalLight, MathUtils, ShaderChunk, Matrix4, Box3 } from 'three'\nimport { CSMFrustum } from './CSMFrustum'\nimport { CSMShader } from './CSMShader'\n\nconst _cameraToLightMatrix = new Matrix4()\nconst _lightSpaceFrustum = new CSMFrustum()\nconst _center = new Vector3()\nconst _bbox = new Box3()\nconst _uniformArray = []\nconst _logArray = []\n\nexport class CSM {\n  constructor(data) {\n    data = data || {}\n\n    this.camera = data.camera\n    this.parent = data.parent\n    this.cascades = data.cascades || 3\n    this.maxFar = data.maxFar || 100000\n    this.mode = data.mode || 'practical'\n    this.shadowMapSize = data.shadowMapSize || 2048\n    this.shadowBias = data.shadowBias || 0.000001\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize()\n    this.lightIntensity = data.lightIntensity || 1\n    this.lightNear = data.lightNear || 1\n    this.lightFar = data.lightFar || 2000\n    this.lightMargin = data.lightMargin || 200\n    this.customSplitsCallback = data.customSplitsCallback\n    this.fade = false\n    this.mainFrustum = new CSMFrustum()\n    this.frustums = []\n    this.breaks = []\n\n    this.lights = []\n    this.shaders = new Map()\n\n    this.createLights()\n    this.updateFrustums()\n    this.injectInclude()\n  }\n\n  createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(0xffffff, this.lightIntensity)\n      light.castShadow = true\n      light.shadow.mapSize.width = this.shadowMapSize\n      light.shadow.mapSize.height = this.shadowMapSize\n\n      light.shadow.camera.near = this.lightNear\n      light.shadow.camera.far = this.lightFar\n      light.shadow.bias = this.shadowBias\n\n      this.parent.add(light)\n      this.parent.add(light.target)\n      this.lights.push(light)\n    }\n  }\n\n  initCascades() {\n    const camera = this.camera\n    camera.updateProjectionMatrix()\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar)\n    this.mainFrustum.split(this.breaks, this.frustums)\n  }\n\n  updateShadowBounds() {\n    const frustums = this.frustums\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i]\n      const shadowCam = light.shadow.camera\n      const frustum = this.frustums[i]\n\n      // Get the two points that represent that furthest points on the frustum assuming\n      // that's either the diagonal across the far plane or the diagonal across the whole\n      // frustum itself.\n      const nearVerts = frustum.vertices.near\n      const farVerts = frustum.vertices.far\n      const point1 = farVerts[0]\n      let point2\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2]\n      } else {\n        point2 = nearVerts[2]\n      }\n\n      let squaredBBWidth = point1.distanceTo(point2)\n      if (this.fade) {\n        // expand the shadow extents by the fade margin if fade is enabled.\n        const camera = this.camera\n        const far = Math.max(camera.far, this.maxFar)\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near)\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near)\n\n        squaredBBWidth += margin\n      }\n\n      shadowCam.left = -squaredBBWidth / 2\n      shadowCam.right = squaredBBWidth / 2\n      shadowCam.top = squaredBBWidth / 2\n      shadowCam.bottom = -squaredBBWidth / 2\n      shadowCam.updateProjectionMatrix()\n    }\n  }\n\n  getBreaks() {\n    const camera = this.camera\n    const far = Math.min(camera.far, this.maxFar)\n    this.breaks.length = 0\n\n    switch (this.mode) {\n      case 'uniform':\n        uniformSplit(this.cascades, camera.near, far, this.breaks)\n        break\n      case 'logarithmic':\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks)\n        break\n      case 'practical':\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks)\n        break\n      case 'custom':\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.')\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks)\n        break\n    }\n\n    function uniformSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + ((far - near) * i) / amount) / far)\n      }\n\n      target.push(1)\n    }\n\n    function logarithmicSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near * (far / near) ** (i / amount)) / far)\n      }\n\n      target.push(1)\n    }\n\n    function practicalSplit(amount, near, far, lambda, target) {\n      _uniformArray.length = 0\n      _logArray.length = 0\n      logarithmicSplit(amount, near, far, _logArray)\n      uniformSplit(amount, near, far, _uniformArray)\n\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda))\n      }\n\n      target.push(1)\n    }\n  }\n\n  update() {\n    const camera = this.camera\n    const frustums = this.frustums\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i]\n      const shadowCam = light.shadow.camera\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize\n      light.shadow.camera.updateMatrixWorld(true)\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld)\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum)\n\n      const nearVerts = _lightSpaceFrustum.vertices.near\n      const farVerts = _lightSpaceFrustum.vertices.far\n      _bbox.makeEmpty()\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j])\n        _bbox.expandByPoint(farVerts[j])\n      }\n\n      _bbox.getCenter(_center)\n      _center.z = _bbox.max.z + this.lightMargin\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight\n      _center.applyMatrix4(light.shadow.camera.matrixWorld)\n\n      light.position.copy(_center)\n      light.target.position.copy(_center)\n\n      light.target.position.x += this.lightDirection.x\n      light.target.position.y += this.lightDirection.y\n      light.target.position.z += this.lightDirection.z\n    }\n  }\n\n  injectInclude() {\n    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin\n    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin\n  }\n\n  setupMaterial(material) {\n    material.defines = material.defines || {}\n    material.defines.USE_CSM = 1\n    material.defines.CSM_CASCADES = this.cascades\n\n    if (this.fade) {\n      material.defines.CSM_FADE = ''\n    }\n\n    const breaksVec2 = []\n    const scope = this\n    const shaders = this.shaders\n\n    material.onBeforeCompile = function (shader) {\n      const far = Math.min(scope.camera.far, scope.maxFar)\n      scope.getExtendedBreaks(breaksVec2)\n\n      shader.uniforms.CSM_cascades = { value: breaksVec2 }\n      shader.uniforms.cameraNear = { value: scope.camera.near }\n      shader.uniforms.shadowFar = { value: far }\n\n      shaders.set(material, shader)\n    }\n\n    shaders.set(material, null)\n  }\n\n  updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar)\n    const shaders = this.shaders\n\n    shaders.forEach(function (shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms\n        this.getExtendedBreaks(uniforms.CSM_cascades.value)\n        uniforms.cameraNear.value = this.camera.near\n        uniforms.shadowFar.value = far\n      }\n\n      if (!this.fade && 'CSM_FADE' in material.defines) {\n        delete material.defines.CSM_FADE\n        material.needsUpdate = true\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\n        material.defines.CSM_FADE = ''\n        material.needsUpdate = true\n      }\n    }, this)\n  }\n\n  getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2())\n    }\n\n    target.length = this.breaks.length\n\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i]\n      const prev = this.breaks[i - 1] || 0\n      target[i].x = prev\n      target[i].y = amount\n    }\n  }\n\n  updateFrustums() {\n    this.getBreaks()\n    this.initCascades()\n    this.updateShadowBounds()\n    this.updateUniforms()\n  }\n\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i])\n    }\n  }\n\n  dispose() {\n    const shaders = this.shaders\n    shaders.forEach(function (shader, material) {\n      delete material.onBeforeCompile\n      delete material.defines.USE_CSM\n      delete material.defines.CSM_CASCADES\n      delete material.defines.CSM_FADE\n\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades\n        delete shader.uniforms.cameraNear\n        delete shader.uniforms.shadowFar\n      }\n\n      material.needsUpdate = true\n    })\n    shaders.clear()\n  }\n}\n", "/**\n * ACES Filmic Tone Mapping Shader by Stephen Hill\n * source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n *\n * this implementation of ACES is modified to accommodate a brighter viewing environment.\n * the scale factor of 1/0.6 is subjective. see discussion in #19621.\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type ACESFilmicToneMappingShaderUniforms = {\n  exposure: IUniform<number>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IACESFilmicToneMappingShader extends IShader<ACESFilmicToneMappingShaderUniforms> {}\n\nexport const ACESFilmicToneMappingShader: IACESFilmicToneMappingShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    exposure: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#define saturate(a) clamp( a, 0.0, 1.0 )',\n\n    'uniform sampler2D tDiffuse;',\n\n    'uniform float exposure;',\n\n    'varying vec2 vUv;',\n\n    'vec3 RRTAndODTFit( vec3 v ) {',\n\n    '\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;',\n    '\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;',\n    '\treturn a / b;',\n\n    '}',\n\n    'vec3 ACESFilmicToneMapping( vec3 color ) {',\n\n    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n    '\tconst mat3 ACESInputMat = mat3(',\n    '\t\tvec3( 0.59719, 0.07600, 0.02840 ),', // transposed from source\n    '\t\tvec3( 0.35458, 0.90834, 0.13383 ),',\n    '\t\tvec3( 0.04823, 0.01566, 0.83777 )',\n    '\t);',\n\n    // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    '\tconst mat3 ACESOutputMat = mat3(',\n    '\t\tvec3(  1.60475, -0.10208, -0.00327 ),', // transposed from source\n    '\t\tvec3( -0.53108,  1.10813, -0.07276 ),',\n    '\t\tvec3( -0.07367, -0.00605,  1.07602 )',\n    '\t);',\n\n    '\tcolor = ACESInputMat * color;',\n\n    // Apply RRT and ODT\n    '\tcolor = RRTAndODTFit( color );',\n\n    '\tcolor = ACESOutputMat * color;',\n\n    // Clamp to [0, 1]\n    '\treturn saturate( color );',\n\n    '}',\n\n    'void main() {',\n\n    '\tvec4 tex = texture2D( tDiffuse, vUv );',\n\n    '\ttex.rgb *= exposure / 0.6;', // pre-exposed, outside of the tone mapping function\n\n    '\tgl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Simple test shader\n */\n\nimport type { IShader } from './types'\n\nexport type BasicShaderUniforms = {}\n\nexport interface IBasicShader extends IShader<BasicShaderUniforms> {}\n\nexport const BasicShader: IBasicShader = {\n  uniforms: {},\n\n  vertexShader: [\n    'void main() {',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: ['void main() {', '\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );', '}'].join('\\n'),\n}\n", "/**\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type BleachBypassShaderUniforms = {\n  opacity: IUniform<number>\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IBleachBypassShader extends IShader<BleachBypassShaderUniforms> {}\n\nexport const BleachBypassShader: IBleachBypassShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float opacity;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 base = texture2D( tDiffuse, vUv );',\n\n    '\tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );',\n    '\tfloat lum = dot( lumCoeff, base.rgb );',\n    '\tvec3 blend = vec3( lum );',\n\n    '\tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );',\n\n    '\tvec3 result1 = 2.0 * base.rgb * blend;',\n    '\tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );',\n\n    '\tvec3 newColor = mix( result1, result2, L );',\n\n    '\tfloat A2 = opacity * base.a;',\n    '\tvec3 mixRGB = A2 * newColor.rgb;',\n    '\tmixRGB += ( ( 1.0 - A2 ) * base.rgb );',\n\n    '\tgl_FragColor = vec4( mixRGB, base.a );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Blend two textures\n */\n\nexport const BlendShader = {\n  uniforms: {\n    tDiffuse1: { value: null },\n    tDiffuse2: { value: null },\n    mixRatio: { value: 0.5 },\n    opacity: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float opacity;',\n    'uniform float mixRatio;',\n\n    'uniform sampler2D tDiffuse1;',\n    'uniform sampler2D tDiffuse2;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 texel1 = texture2D( tDiffuse1, vUv );',\n    '\tvec4 texel2 = texture2D( tDiffuse2, vUv );',\n    '\tgl_FragColor = opacity * mix( texel1, texel2, mixRatio );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nexport const BrightnessContrastShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    brightness: { value: 0 },\n    contrast: { value: 0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float brightness;',\n    'uniform float contrast;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tgl_FragColor = texture2D( tDiffuse, vUv );',\n\n    '\tgl_FragColor.rgb += brightness;',\n\n    '\tif (contrast > 0.0) {',\n    '\t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;',\n    '\t} else {',\n    '\t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;',\n    '\t}',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector3 } from 'three'\n\n/**\n * Color correction\n */\n\nexport const ColorCorrectionShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    powRGB: { value: new Vector3(2, 2, 2) },\n    mulRGB: { value: new Vector3(1, 1, 1) },\n    addRGB: { value: new Vector3(0, 0, 0) },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform vec3 powRGB;',\n    'uniform vec3 mulRGB;',\n    'uniform vec3 addRGB;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tgl_FragColor = texture2D( tDiffuse, vUv );',\n    '\tgl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Color } from 'three'\n\n/**\n * Colorify shader\n */\n\nexport const ColorifyShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    color: { value: new Color(0xffffff) },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec3 color;',\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 texel = texture2D( tDiffuse, vUv );',\n\n    '\tvec3 luma = vec3( 0.299, 0.587, 0.114 );',\n    '\tfloat v = dot( texel.xyz, luma );',\n\n    '\tgl_FragColor = vec4( v * color, texel.w );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\n\nexport const DOFMipMapShader = {\n  uniforms: {\n    tColor: { value: null },\n    tDepth: { value: null },\n    focus: { value: 1.0 },\n    maxblur: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float focus;',\n    'uniform float maxblur;',\n\n    'uniform sampler2D tColor;',\n    'uniform sampler2D tDepth;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 depth = texture2D( tDepth, vUv );',\n\n    '\tfloat factor = depth.x - focus;',\n\n    '\tvec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );',\n\n    '\tgl_FragColor = col;',\n    '\tgl_FragColor.a = 1.0;',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nexport const FXAAShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: new Vector2(1 / 1024, 1 / 512) },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'precision highp float;',\n    '',\n    'uniform sampler2D tDiffuse;',\n    '',\n    'uniform vec2 resolution;',\n    '',\n    'varying vec2 vUv;',\n    '',\n    '// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)',\n    '',\n    '//----------------------------------------------------------------------------------',\n    '// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag',\n    '// SDK Version: v3.00',\n    '// Email:       gameworks@nvidia.com',\n    '// Site:        http://developer.nvidia.com/',\n    '//',\n    '// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.',\n    '//',\n    '// Redistribution and use in source and binary forms, with or without',\n    '// modification, are permitted provided that the following conditions',\n    '// are met:',\n    '//  * Redistributions of source code must retain the above copyright',\n    '//    notice, this list of conditions and the following disclaimer.',\n    '//  * Redistributions in binary form must reproduce the above copyright',\n    '//    notice, this list of conditions and the following disclaimer in the',\n    '//    documentation and/or other materials provided with the distribution.',\n    '//  * Neither the name of NVIDIA CORPORATION nor the names of its',\n    '//    contributors may be used to endorse or promote products derived',\n    '//    from this software without specific prior written permission.',\n    '//',\n    \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\",\n    '// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE',\n    '// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR',\n    '// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR',\n    '// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,',\n    '// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,',\n    '// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR',\n    '// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY',\n    '// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT',\n    '// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE',\n    '// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.',\n    '//',\n    '//----------------------------------------------------------------------------------',\n    '',\n    '#define FXAA_PC 1',\n    '#define FXAA_GLSL_100 1',\n    '#define FXAA_QUALITY_PRESET 12',\n    '',\n    '#define FXAA_GREEN_AS_LUMA 1',\n    '',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_PC_CONSOLE',\n    '    //',\n    '    // The console algorithm for PC is included',\n    '    // for developers targeting really low spec machines.',\n    '    // Likely better to just run FXAA_PC, and use a really low preset.',\n    '    //',\n    '    #define FXAA_PC_CONSOLE 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_GLSL_120',\n    '    #define FXAA_GLSL_120 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_GLSL_130',\n    '    #define FXAA_GLSL_130 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_HLSL_3',\n    '    #define FXAA_HLSL_3 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_HLSL_4',\n    '    #define FXAA_HLSL_4 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_HLSL_5',\n    '    #define FXAA_HLSL_5 0',\n    '#endif',\n    '/*==========================================================================*/',\n    '#ifndef FXAA_GREEN_AS_LUMA',\n    '    //',\n    '    // For those using non-linear color,',\n    '    // and either not able to get luma in alpha, or not wanting to,',\n    '    // this enables FXAA to run using green as a proxy for luma.',\n    '    // So with this enabled, no need to pack luma in alpha.',\n    '    //',\n    '    // This will turn off AA on anything which lacks some amount of green.',\n    '    // Pure red and blue or combination of only R and B, will get no AA.',\n    '    //',\n    '    // Might want to lower the settings for both,',\n    '    //    fxaaConsoleEdgeThresholdMin',\n    '    //    fxaaQualityEdgeThresholdMin',\n    '    // In order to insure AA does not get turned off on colors',\n    '    // which contain a minor amount of green.',\n    '    //',\n    '    // 1 = On.',\n    '    // 0 = Off.',\n    '    //',\n    '    #define FXAA_GREEN_AS_LUMA 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_EARLY_EXIT',\n    '    //',\n    \"    // Controls algorithm's early exit path.\",\n    '    // On PS3 turning this ON adds 2 cycles to the shader.',\n    '    // On 360 turning this OFF adds 10ths of a millisecond to the shader.',\n    '    // Turning this off on console will result in a more blurry image.',\n    '    // So this defaults to on.',\n    '    //',\n    '    // 1 = On.',\n    '    // 0 = Off.',\n    '    //',\n    '    #define FXAA_EARLY_EXIT 1',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_DISCARD',\n    '    //',\n    '    // Only valid for PC OpenGL currently.',\n    '    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.',\n    '    //',\n    \"    // 1 = Use discard on pixels which don't need AA.\",\n    '    //     For APIs which enable concurrent TEX+ROP from same surface.',\n    \"    // 0 = Return unchanged color on pixels which don't need AA.\",\n    '    //',\n    '    #define FXAA_DISCARD 0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_FAST_PIXEL_OFFSET',\n    '    //',\n    '    // Used for GLSL 120 only.',\n    '    //',\n    '    // 1 = GL API supports fast pixel offsets',\n    '    // 0 = do not use fast pixel offsets',\n    '    //',\n    '    #ifdef GL_EXT_gpu_shader4',\n    '        #define FXAA_FAST_PIXEL_OFFSET 1',\n    '    #endif',\n    '    #ifdef GL_NV_gpu_shader5',\n    '        #define FXAA_FAST_PIXEL_OFFSET 1',\n    '    #endif',\n    '    #ifdef GL_ARB_gpu_shader5',\n    '        #define FXAA_FAST_PIXEL_OFFSET 1',\n    '    #endif',\n    '    #ifndef FXAA_FAST_PIXEL_OFFSET',\n    '        #define FXAA_FAST_PIXEL_OFFSET 0',\n    '    #endif',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#ifndef FXAA_GATHER4_ALPHA',\n    '    //',\n    '    // 1 = API supports gather4 on alpha channel.',\n    '    // 0 = API does not support gather4 on alpha channel.',\n    '    //',\n    '    #if (FXAA_HLSL_5 == 1)',\n    '        #define FXAA_GATHER4_ALPHA 1',\n    '    #endif',\n    '    #ifdef GL_ARB_gpu_shader5',\n    '        #define FXAA_GATHER4_ALPHA 1',\n    '    #endif',\n    '    #ifdef GL_NV_gpu_shader5',\n    '        #define FXAA_GATHER4_ALPHA 1',\n    '    #endif',\n    '    #ifndef FXAA_GATHER4_ALPHA',\n    '        #define FXAA_GATHER4_ALPHA 0',\n    '    #endif',\n    '#endif',\n    '',\n    '',\n    '/*============================================================================',\n    '                        FXAA QUALITY - TUNING KNOBS',\n    '------------------------------------------------------------------------------',\n    'NOTE the other tuning knobs are now in the shader function inputs!',\n    '============================================================================*/',\n    '#ifndef FXAA_QUALITY_PRESET',\n    '    //',\n    '    // Choose the quality preset.',\n    '    // This needs to be compiled into the shader as it effects code.',\n    '    // Best option to include multiple presets is to',\n    '    // in each shader define the preset, then include this file.',\n    '    //',\n    '    // OPTIONS',\n    '    // -----------------------------------------------------------------------',\n    '    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)',\n    '    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)',\n    '    // 39       - no dither, very expensive',\n    '    //',\n    '    // NOTES',\n    '    // -----------------------------------------------------------------------',\n    '    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)',\n    '    // 13 = about same speed as FXAA 3.9 and better than 12',\n    '    // 23 = closest to FXAA 3.9 visually and performance wise',\n    '    //  _ = the lowest digit is directly related to performance',\n    '    // _  = the highest digit is directly related to style',\n    '    //',\n    '    #define FXAA_QUALITY_PRESET 12',\n    '#endif',\n    '',\n    '',\n    '/*============================================================================',\n    '',\n    '                           FXAA QUALITY - PRESETS',\n    '',\n    '============================================================================*/',\n    '',\n    '/*============================================================================',\n    '                     FXAA QUALITY - MEDIUM DITHER PRESETS',\n    '============================================================================*/',\n    '#if (FXAA_QUALITY_PRESET == 10)',\n    '    #define FXAA_QUALITY_PS 3',\n    '    #define FXAA_QUALITY_P0 1.5',\n    '    #define FXAA_QUALITY_P1 3.0',\n    '    #define FXAA_QUALITY_P2 12.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 11)',\n    '    #define FXAA_QUALITY_PS 4',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 3.0',\n    '    #define FXAA_QUALITY_P3 12.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 12)',\n    '    #define FXAA_QUALITY_PS 5',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 4.0',\n    '    #define FXAA_QUALITY_P4 12.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 13)',\n    '    #define FXAA_QUALITY_PS 6',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 4.0',\n    '    #define FXAA_QUALITY_P5 12.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 14)',\n    '    #define FXAA_QUALITY_PS 7',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 4.0',\n    '    #define FXAA_QUALITY_P6 12.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 15)',\n    '    #define FXAA_QUALITY_PS 8',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 2.0',\n    '    #define FXAA_QUALITY_P6 4.0',\n    '    #define FXAA_QUALITY_P7 12.0',\n    '#endif',\n    '',\n    '/*============================================================================',\n    '                     FXAA QUALITY - LOW DITHER PRESETS',\n    '============================================================================*/',\n    '#if (FXAA_QUALITY_PRESET == 20)',\n    '    #define FXAA_QUALITY_PS 3',\n    '    #define FXAA_QUALITY_P0 1.5',\n    '    #define FXAA_QUALITY_P1 2.0',\n    '    #define FXAA_QUALITY_P2 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 21)',\n    '    #define FXAA_QUALITY_PS 4',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 22)',\n    '    #define FXAA_QUALITY_PS 5',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 23)',\n    '    #define FXAA_QUALITY_PS 6',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 24)',\n    '    #define FXAA_QUALITY_PS 7',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 3.0',\n    '    #define FXAA_QUALITY_P6 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 25)',\n    '    #define FXAA_QUALITY_PS 8',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 2.0',\n    '    #define FXAA_QUALITY_P6 4.0',\n    '    #define FXAA_QUALITY_P7 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 26)',\n    '    #define FXAA_QUALITY_PS 9',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 2.0',\n    '    #define FXAA_QUALITY_P6 2.0',\n    '    #define FXAA_QUALITY_P7 4.0',\n    '    #define FXAA_QUALITY_P8 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 27)',\n    '    #define FXAA_QUALITY_PS 10',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 2.0',\n    '    #define FXAA_QUALITY_P6 2.0',\n    '    #define FXAA_QUALITY_P7 2.0',\n    '    #define FXAA_QUALITY_P8 4.0',\n    '    #define FXAA_QUALITY_P9 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 28)',\n    '    #define FXAA_QUALITY_PS 11',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 2.0',\n    '    #define FXAA_QUALITY_P6 2.0',\n    '    #define FXAA_QUALITY_P7 2.0',\n    '    #define FXAA_QUALITY_P8 2.0',\n    '    #define FXAA_QUALITY_P9 4.0',\n    '    #define FXAA_QUALITY_P10 8.0',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_QUALITY_PRESET == 29)',\n    '    #define FXAA_QUALITY_PS 12',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.5',\n    '    #define FXAA_QUALITY_P2 2.0',\n    '    #define FXAA_QUALITY_P3 2.0',\n    '    #define FXAA_QUALITY_P4 2.0',\n    '    #define FXAA_QUALITY_P5 2.0',\n    '    #define FXAA_QUALITY_P6 2.0',\n    '    #define FXAA_QUALITY_P7 2.0',\n    '    #define FXAA_QUALITY_P8 2.0',\n    '    #define FXAA_QUALITY_P9 2.0',\n    '    #define FXAA_QUALITY_P10 4.0',\n    '    #define FXAA_QUALITY_P11 8.0',\n    '#endif',\n    '',\n    '/*============================================================================',\n    '                     FXAA QUALITY - EXTREME QUALITY',\n    '============================================================================*/',\n    '#if (FXAA_QUALITY_PRESET == 39)',\n    '    #define FXAA_QUALITY_PS 12',\n    '    #define FXAA_QUALITY_P0 1.0',\n    '    #define FXAA_QUALITY_P1 1.0',\n    '    #define FXAA_QUALITY_P2 1.0',\n    '    #define FXAA_QUALITY_P3 1.0',\n    '    #define FXAA_QUALITY_P4 1.0',\n    '    #define FXAA_QUALITY_P5 1.5',\n    '    #define FXAA_QUALITY_P6 2.0',\n    '    #define FXAA_QUALITY_P7 2.0',\n    '    #define FXAA_QUALITY_P8 2.0',\n    '    #define FXAA_QUALITY_P9 2.0',\n    '    #define FXAA_QUALITY_P10 4.0',\n    '    #define FXAA_QUALITY_P11 8.0',\n    '#endif',\n    '',\n    '',\n    '',\n    '/*============================================================================',\n    '',\n    '                                API PORTING',\n    '',\n    '============================================================================*/',\n    '#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)',\n    '    #define FxaaBool bool',\n    '    #define FxaaDiscard discard',\n    '    #define FxaaFloat float',\n    '    #define FxaaFloat2 vec2',\n    '    #define FxaaFloat3 vec3',\n    '    #define FxaaFloat4 vec4',\n    '    #define FxaaHalf float',\n    '    #define FxaaHalf2 vec2',\n    '    #define FxaaHalf3 vec3',\n    '    #define FxaaHalf4 vec4',\n    '    #define FxaaInt2 ivec2',\n    '    #define FxaaSat(x) clamp(x, 0.0, 1.0)',\n    '    #define FxaaTex sampler2D',\n    '#else',\n    '    #define FxaaBool bool',\n    '    #define FxaaDiscard clip(-1)',\n    '    #define FxaaFloat float',\n    '    #define FxaaFloat2 float2',\n    '    #define FxaaFloat3 float3',\n    '    #define FxaaFloat4 float4',\n    '    #define FxaaHalf half',\n    '    #define FxaaHalf2 half2',\n    '    #define FxaaHalf3 half3',\n    '    #define FxaaHalf4 half4',\n    '    #define FxaaSat(x) saturate(x)',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_GLSL_100 == 1)',\n    '  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)',\n    '  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_GLSL_120 == 1)',\n    '    // Requires,',\n    '    //  #version 120',\n    '    // And at least,',\n    '    //  #extension GL_EXT_gpu_shader4 : enable',\n    '    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)',\n    '    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)',\n    '    #if (FXAA_FAST_PIXEL_OFFSET == 1)',\n    '        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)',\n    '    #else',\n    '        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)',\n    '    #endif',\n    '    #if (FXAA_GATHER4_ALPHA == 1)',\n    '        // use #extension GL_ARB_gpu_shader5 : enable',\n    '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)',\n    '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)',\n    '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)',\n    '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)',\n    '    #endif',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_GLSL_130 == 1)',\n    '    // Requires \"#version 130\" or better',\n    '    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)',\n    '    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)',\n    '    #if (FXAA_GATHER4_ALPHA == 1)',\n    '        // use #extension GL_ARB_gpu_shader5 : enable',\n    '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)',\n    '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)',\n    '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)',\n    '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)',\n    '    #endif',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_HLSL_3 == 1)',\n    '    #define FxaaInt2 float2',\n    '    #define FxaaTex sampler2D',\n    '    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))',\n    '    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_HLSL_4 == 1)',\n    '    #define FxaaInt2 int2',\n    '    struct FxaaTex { SamplerState smpl; Texture2D tex; };',\n    '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)',\n    '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)',\n    '#endif',\n    '/*--------------------------------------------------------------------------*/',\n    '#if (FXAA_HLSL_5 == 1)',\n    '    #define FxaaInt2 int2',\n    '    struct FxaaTex { SamplerState smpl; Texture2D tex; };',\n    '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)',\n    '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)',\n    '    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)',\n    '    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)',\n    '    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)',\n    '    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)',\n    '#endif',\n    '',\n    '',\n    '/*============================================================================',\n    '                   GREEN AS LUMA OPTION SUPPORT FUNCTION',\n    '============================================================================*/',\n    '#if (FXAA_GREEN_AS_LUMA == 0)',\n    '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }',\n    '#else',\n    '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }',\n    '#endif',\n    '',\n    '',\n    '',\n    '',\n    '/*============================================================================',\n    '',\n    '                             FXAA3 QUALITY - PC',\n    '',\n    '============================================================================*/',\n    '#if (FXAA_PC == 1)',\n    '/*--------------------------------------------------------------------------*/',\n    'FxaaFloat4 FxaaPixelShader(',\n    '    //',\n    '    // Use noperspective interpolation here (turn off perspective interpolation).',\n    '    // {xy} = center of pixel',\n    '    FxaaFloat2 pos,',\n    '    //',\n    '    // Used only for FXAA Console, and not used on the 360 version.',\n    '    // Use noperspective interpolation here (turn off perspective interpolation).',\n    '    // {xy_} = upper left of pixel',\n    '    // {_zw} = lower right of pixel',\n    '    FxaaFloat4 fxaaConsolePosPos,',\n    '    //',\n    '    // Input color texture.',\n    '    // {rgb_} = color in linear or perceptual color space',\n    '    // if (FXAA_GREEN_AS_LUMA == 0)',\n    '    //     {__a} = luma in perceptual color space (not linear)',\n    '    FxaaTex tex,',\n    '    //',\n    '    // Only used on the optimized 360 version of FXAA Console.',\n    '    // For everything but 360, just use the same input here as for \"tex\".',\n    '    // For 360, same texture, just alias with a 2nd sampler.',\n    '    // This sampler needs to have an exponent bias of -1.',\n    '    FxaaTex fxaaConsole360TexExpBiasNegOne,',\n    '    //',\n    '    // Only used on the optimized 360 version of FXAA Console.',\n    '    // For everything but 360, just use the same input here as for \"tex\".',\n    '    // For 360, same texture, just alias with a 3nd sampler.',\n    '    // This sampler needs to have an exponent bias of -2.',\n    '    FxaaTex fxaaConsole360TexExpBiasNegTwo,',\n    '    //',\n    '    // Only used on FXAA Quality.',\n    '    // This must be from a constant/uniform.',\n    '    // {x_} = 1.0/screenWidthInPixels',\n    '    // {_y} = 1.0/screenHeightInPixels',\n    '    FxaaFloat2 fxaaQualityRcpFrame,',\n    '    //',\n    '    // Only used on FXAA Console.',\n    '    // This must be from a constant/uniform.',\n    '    // This effects sub-pixel AA quality and inversely sharpness.',\n    '    //   Where N ranges between,',\n    '    //     N = 0.50 (default)',\n    '    //     N = 0.33 (sharper)',\n    '    // {x__} = -N/screenWidthInPixels',\n    '    // {_y_} = -N/screenHeightInPixels',\n    '    // {_z_} =  N/screenWidthInPixels',\n    '    // {__w} =  N/screenHeightInPixels',\n    '    FxaaFloat4 fxaaConsoleRcpFrameOpt,',\n    '    //',\n    '    // Only used on FXAA Console.',\n    '    // Not used on 360, but used on PS3 and PC.',\n    '    // This must be from a constant/uniform.',\n    '    // {x__} = -2.0/screenWidthInPixels',\n    '    // {_y_} = -2.0/screenHeightInPixels',\n    '    // {_z_} =  2.0/screenWidthInPixels',\n    '    // {__w} =  2.0/screenHeightInPixels',\n    '    FxaaFloat4 fxaaConsoleRcpFrameOpt2,',\n    '    //',\n    '    // Only used on FXAA Console.',\n    '    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.',\n    '    // This must be from a constant/uniform.',\n    '    // {x__} =  8.0/screenWidthInPixels',\n    '    // {_y_} =  8.0/screenHeightInPixels',\n    '    // {_z_} = -4.0/screenWidthInPixels',\n    '    // {__w} = -4.0/screenHeightInPixels',\n    '    FxaaFloat4 fxaaConsole360RcpFrameOpt2,',\n    '    //',\n    '    // Only used on FXAA Quality.',\n    '    // This used to be the FXAA_QUALITY_SUBPIX define.',\n    '    // It is here now to allow easier tuning.',\n    '    // Choose the amount of sub-pixel aliasing removal.',\n    '    // This can effect sharpness.',\n    '    //   1.00 - upper limit (softer)',\n    '    //   0.75 - default amount of filtering',\n    '    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)',\n    '    //   0.25 - almost off',\n    '    //   0.00 - completely off',\n    '    FxaaFloat fxaaQualitySubpix,',\n    '    //',\n    '    // Only used on FXAA Quality.',\n    '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.',\n    '    // It is here now to allow easier tuning.',\n    '    // The minimum amount of local contrast required to apply algorithm.',\n    '    //   0.333 - too little (faster)',\n    '    //   0.250 - low quality',\n    '    //   0.166 - default',\n    '    //   0.125 - high quality',\n    '    //   0.063 - overkill (slower)',\n    '    FxaaFloat fxaaQualityEdgeThreshold,',\n    '    //',\n    '    // Only used on FXAA Quality.',\n    '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.',\n    '    // It is here now to allow easier tuning.',\n    '    // Trims the algorithm from processing darks.',\n    '    //   0.0833 - upper limit (default, the start of visible unfiltered edges)',\n    '    //   0.0625 - high quality (faster)',\n    '    //   0.0312 - visible limit (slower)',\n    '    // Special notes when using FXAA_GREEN_AS_LUMA,',\n    '    //   Likely want to set this to zero.',\n    '    //   As colors that are mostly not-green',\n    '    //   will appear very dark in the green channel!',\n    '    //   Tune by looking at mostly non-green content,',\n    '    //   then start at zero and increase until aliasing is a problem.',\n    '    FxaaFloat fxaaQualityEdgeThresholdMin,',\n    '    //',\n    '    // Only used on FXAA Console.',\n    '    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.',\n    '    // It is here now to allow easier tuning.',\n    '    // This does not effect PS3, as this needs to be compiled in.',\n    '    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.',\n    '    //   Due to the PS3 being ALU bound,',\n    '    //   there are only three safe values here: 2 and 4 and 8.',\n    '    //   These options use the shaders ability to a free *|/ by 2|4|8.',\n    '    // For all other platforms can be a non-power of two.',\n    '    //   8.0 is sharper (default!!!)',\n    '    //   4.0 is softer',\n    '    //   2.0 is really soft (good only for vector graphics inputs)',\n    '    FxaaFloat fxaaConsoleEdgeSharpness,',\n    '    //',\n    '    // Only used on FXAA Console.',\n    '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.',\n    '    // It is here now to allow easier tuning.',\n    '    // This does not effect PS3, as this needs to be compiled in.',\n    '    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.',\n    '    //   Due to the PS3 being ALU bound,',\n    '    //   there are only two safe values here: 1/4 and 1/8.',\n    '    //   These options use the shaders ability to a free *|/ by 2|4|8.',\n    '    // The console setting has a different mapping than the quality setting.',\n    '    // Other platforms can use other values.',\n    '    //   0.125 leaves less aliasing, but is softer (default!!!)',\n    '    //   0.25 leaves more aliasing, and is sharper',\n    '    FxaaFloat fxaaConsoleEdgeThreshold,',\n    '    //',\n    '    // Only used on FXAA Console.',\n    '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.',\n    '    // It is here now to allow easier tuning.',\n    '    // Trims the algorithm from processing darks.',\n    '    // The console setting has a different mapping than the quality setting.',\n    '    // This only applies when FXAA_EARLY_EXIT is 1.',\n    '    // This does not apply to PS3,',\n    '    // PS3 was simplified to avoid more shader instructions.',\n    '    //   0.06 - faster but more aliasing in darks',\n    '    //   0.05 - default',\n    '    //   0.04 - slower and less aliasing in darks',\n    '    // Special notes when using FXAA_GREEN_AS_LUMA,',\n    '    //   Likely want to set this to zero.',\n    '    //   As colors that are mostly not-green',\n    '    //   will appear very dark in the green channel!',\n    '    //   Tune by looking at mostly non-green content,',\n    '    //   then start at zero and increase until aliasing is a problem.',\n    '    FxaaFloat fxaaConsoleEdgeThresholdMin,',\n    '    //',\n    '    // Extra constants for 360 FXAA Console only.',\n    '    // Use zeros or anything else for other platforms.',\n    '    // These must be in physical constant registers and NOT immediates.',\n    '    // Immediates will result in compiler un-optimizing.',\n    '    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)',\n    '    FxaaFloat4 fxaaConsole360ConstDir',\n    ') {',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat2 posM;',\n    '    posM.x = pos.x;',\n    '    posM.y = pos.y;',\n    '    #if (FXAA_GATHER4_ALPHA == 1)',\n    '        #if (FXAA_DISCARD == 0)',\n    '            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);',\n    '            #if (FXAA_GREEN_AS_LUMA == 0)',\n    '                #define lumaM rgbyM.w',\n    '            #else',\n    '                #define lumaM rgbyM.y',\n    '            #endif',\n    '        #endif',\n    '        #if (FXAA_GREEN_AS_LUMA == 0)',\n    '            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);',\n    '            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));',\n    '        #else',\n    '            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);',\n    '            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));',\n    '        #endif',\n    '        #if (FXAA_DISCARD == 1)',\n    '            #define lumaM luma4A.w',\n    '        #endif',\n    '        #define lumaE luma4A.z',\n    '        #define lumaS luma4A.x',\n    '        #define lumaSE luma4A.y',\n    '        #define lumaNW luma4B.w',\n    '        #define lumaN luma4B.z',\n    '        #define lumaW luma4B.x',\n    '    #else',\n    '        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);',\n    '        #if (FXAA_GREEN_AS_LUMA == 0)',\n    '            #define lumaM rgbyM.w',\n    '        #else',\n    '            #define lumaM rgbyM.y',\n    '        #endif',\n    '        #if (FXAA_GLSL_100 == 1)',\n    '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));',\n    '        #else',\n    '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));',\n    '        #endif',\n    '    #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat maxSM = max(lumaS, lumaM);',\n    '    FxaaFloat minSM = min(lumaS, lumaM);',\n    '    FxaaFloat maxESM = max(lumaE, maxSM);',\n    '    FxaaFloat minESM = min(lumaE, minSM);',\n    '    FxaaFloat maxWN = max(lumaN, lumaW);',\n    '    FxaaFloat minWN = min(lumaN, lumaW);',\n    '    FxaaFloat rangeMax = max(maxWN, maxESM);',\n    '    FxaaFloat rangeMin = min(minWN, minESM);',\n    '    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;',\n    '    FxaaFloat range = rangeMax - rangeMin;',\n    '    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);',\n    '    FxaaBool earlyExit = range < rangeMaxClamped;',\n    '/*--------------------------------------------------------------------------*/',\n    '    if(earlyExit)',\n    '        #if (FXAA_DISCARD == 1)',\n    '            FxaaDiscard;',\n    '        #else',\n    '            return rgbyM;',\n    '        #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '    #if (FXAA_GATHER4_ALPHA == 0)',\n    '        #if (FXAA_GLSL_100 == 1)',\n    '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));',\n    '        #else',\n    '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));',\n    '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));',\n    '        #endif',\n    '    #else',\n    '        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));',\n    '        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));',\n    '    #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat lumaNS = lumaN + lumaS;',\n    '    FxaaFloat lumaWE = lumaW + lumaE;',\n    '    FxaaFloat subpixRcpRange = 1.0/range;',\n    '    FxaaFloat subpixNSWE = lumaNS + lumaWE;',\n    '    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;',\n    '    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat lumaNESE = lumaNE + lumaSE;',\n    '    FxaaFloat lumaNWNE = lumaNW + lumaNE;',\n    '    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;',\n    '    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat lumaNWSW = lumaNW + lumaSW;',\n    '    FxaaFloat lumaSWSE = lumaSW + lumaSE;',\n    '    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);',\n    '    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);',\n    '    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;',\n    '    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;',\n    '    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;',\n    '    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;',\n    '    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;',\n    '    FxaaBool horzSpan = edgeHorz >= edgeVert;',\n    '    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;',\n    '/*--------------------------------------------------------------------------*/',\n    '    if(!horzSpan) lumaN = lumaW;',\n    '    if(!horzSpan) lumaS = lumaE;',\n    '    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;',\n    '    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat gradientN = lumaN - lumaM;',\n    '    FxaaFloat gradientS = lumaS - lumaM;',\n    '    FxaaFloat lumaNN = lumaN + lumaM;',\n    '    FxaaFloat lumaSS = lumaS + lumaM;',\n    '    FxaaBool pairN = abs(gradientN) >= abs(gradientS);',\n    '    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));',\n    '    if(pairN) lengthSign = -lengthSign;',\n    '    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat2 posB;',\n    '    posB.x = posM.x;',\n    '    posB.y = posM.y;',\n    '    FxaaFloat2 offNP;',\n    '    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;',\n    '    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;',\n    '    if(!horzSpan) posB.x += lengthSign * 0.5;',\n    '    if( horzSpan) posB.y += lengthSign * 0.5;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat2 posN;',\n    '    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;',\n    '    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;',\n    '    FxaaFloat2 posP;',\n    '    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;',\n    '    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;',\n    '    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;',\n    '    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));',\n    '    FxaaFloat subpixE = subpixC * subpixC;',\n    '    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));',\n    '/*--------------------------------------------------------------------------*/',\n    '    if(!pairN) lumaNN = lumaSS;',\n    '    FxaaFloat gradientScaled = gradient * 1.0/4.0;',\n    '    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;',\n    '    FxaaFloat subpixF = subpixD * subpixE;',\n    '    FxaaBool lumaMLTZero = lumaMM < 0.0;',\n    '/*--------------------------------------------------------------------------*/',\n    '    lumaEndN -= lumaNN * 0.5;',\n    '    lumaEndP -= lumaNN * 0.5;',\n    '    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;',\n    '    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;',\n    '    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;',\n    '    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;',\n    '    FxaaBool doneNP = (!doneN) || (!doneP);',\n    '    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;',\n    '    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;',\n    '/*--------------------------------------------------------------------------*/',\n    '    if(doneNP) {',\n    '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '        doneN = abs(lumaEndN) >= gradientScaled;',\n    '        doneP = abs(lumaEndP) >= gradientScaled;',\n    '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;',\n    '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;',\n    '        doneNP = (!doneN) || (!doneP);',\n    '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;',\n    '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;',\n    '/*--------------------------------------------------------------------------*/',\n    '        #if (FXAA_QUALITY_PS > 3)',\n    '        if(doneNP) {',\n    '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '            doneN = abs(lumaEndN) >= gradientScaled;',\n    '            doneP = abs(lumaEndP) >= gradientScaled;',\n    '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;',\n    '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;',\n    '            doneNP = (!doneN) || (!doneP);',\n    '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;',\n    '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;',\n    '/*--------------------------------------------------------------------------*/',\n    '            #if (FXAA_QUALITY_PS > 4)',\n    '            if(doneNP) {',\n    '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                doneN = abs(lumaEndN) >= gradientScaled;',\n    '                doneP = abs(lumaEndP) >= gradientScaled;',\n    '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;',\n    '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;',\n    '                doneNP = (!doneN) || (!doneP);',\n    '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;',\n    '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;',\n    '/*--------------------------------------------------------------------------*/',\n    '                #if (FXAA_QUALITY_PS > 5)',\n    '                if(doneNP) {',\n    '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                    doneN = abs(lumaEndN) >= gradientScaled;',\n    '                    doneP = abs(lumaEndP) >= gradientScaled;',\n    '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;',\n    '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;',\n    '                    doneNP = (!doneN) || (!doneP);',\n    '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;',\n    '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;',\n    '/*--------------------------------------------------------------------------*/',\n    '                    #if (FXAA_QUALITY_PS > 6)',\n    '                    if(doneNP) {',\n    '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                        doneN = abs(lumaEndN) >= gradientScaled;',\n    '                        doneP = abs(lumaEndP) >= gradientScaled;',\n    '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;',\n    '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;',\n    '                        doneNP = (!doneN) || (!doneP);',\n    '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;',\n    '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;',\n    '/*--------------------------------------------------------------------------*/',\n    '                        #if (FXAA_QUALITY_PS > 7)',\n    '                        if(doneNP) {',\n    '                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                            doneN = abs(lumaEndN) >= gradientScaled;',\n    '                            doneP = abs(lumaEndP) >= gradientScaled;',\n    '                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;',\n    '                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;',\n    '                            doneNP = (!doneN) || (!doneP);',\n    '                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;',\n    '                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;',\n    '/*--------------------------------------------------------------------------*/',\n    '    #if (FXAA_QUALITY_PS > 8)',\n    '    if(doneNP) {',\n    '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '        doneN = abs(lumaEndN) >= gradientScaled;',\n    '        doneP = abs(lumaEndP) >= gradientScaled;',\n    '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;',\n    '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;',\n    '        doneNP = (!doneN) || (!doneP);',\n    '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;',\n    '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;',\n    '/*--------------------------------------------------------------------------*/',\n    '        #if (FXAA_QUALITY_PS > 9)',\n    '        if(doneNP) {',\n    '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '            doneN = abs(lumaEndN) >= gradientScaled;',\n    '            doneP = abs(lumaEndP) >= gradientScaled;',\n    '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;',\n    '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;',\n    '            doneNP = (!doneN) || (!doneP);',\n    '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;',\n    '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;',\n    '/*--------------------------------------------------------------------------*/',\n    '            #if (FXAA_QUALITY_PS > 10)',\n    '            if(doneNP) {',\n    '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                doneN = abs(lumaEndN) >= gradientScaled;',\n    '                doneP = abs(lumaEndP) >= gradientScaled;',\n    '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;',\n    '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;',\n    '                doneNP = (!doneN) || (!doneP);',\n    '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;',\n    '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;',\n    '/*--------------------------------------------------------------------------*/',\n    '                #if (FXAA_QUALITY_PS > 11)',\n    '                if(doneNP) {',\n    '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                    doneN = abs(lumaEndN) >= gradientScaled;',\n    '                    doneP = abs(lumaEndP) >= gradientScaled;',\n    '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;',\n    '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;',\n    '                    doneNP = (!doneN) || (!doneP);',\n    '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;',\n    '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;',\n    '/*--------------------------------------------------------------------------*/',\n    '                    #if (FXAA_QUALITY_PS > 12)',\n    '                    if(doneNP) {',\n    '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));',\n    '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));',\n    '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;',\n    '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;',\n    '                        doneN = abs(lumaEndN) >= gradientScaled;',\n    '                        doneP = abs(lumaEndP) >= gradientScaled;',\n    '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;',\n    '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;',\n    '                        doneNP = (!doneN) || (!doneP);',\n    '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;',\n    '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;',\n    '/*--------------------------------------------------------------------------*/',\n    '                    }',\n    '                    #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '                }',\n    '                #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '            }',\n    '            #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '        }',\n    '        #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '    }',\n    '    #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '                        }',\n    '                        #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '                    }',\n    '                    #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '                }',\n    '                #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '            }',\n    '            #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '        }',\n    '        #endif',\n    '/*--------------------------------------------------------------------------*/',\n    '    }',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat dstN = posM.x - posN.x;',\n    '    FxaaFloat dstP = posP.x - posM.x;',\n    '    if(!horzSpan) dstN = posM.y - posN.y;',\n    '    if(!horzSpan) dstP = posP.y - posM.y;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;',\n    '    FxaaFloat spanLength = (dstP + dstN);',\n    '    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;',\n    '    FxaaFloat spanLengthRcp = 1.0/spanLength;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaBool directionN = dstN < dstP;',\n    '    FxaaFloat dst = min(dstN, dstP);',\n    '    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;',\n    '    FxaaFloat subpixG = subpixF * subpixF;',\n    '    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;',\n    '    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;',\n    '/*--------------------------------------------------------------------------*/',\n    '    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;',\n    '    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);',\n    '    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;',\n    '    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;',\n    '    #if (FXAA_DISCARD == 1)',\n    '        return FxaaTexTop(tex, posM);',\n    '    #else',\n    '        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);',\n    '    #endif',\n    '}',\n    '/*==========================================================================*/',\n    '#endif',\n    '',\n    'void main() {',\n    '  gl_FragColor = FxaaPixelShader(',\n    '    vUv,',\n    '    vec4(0.0),',\n    '    tDiffuse,',\n    '    tDiffuse,',\n    '    tDiffuse,',\n    '    resolution,',\n    '    vec4(0.0),',\n    '    vec4(0.0),',\n    '    vec4(0.0),',\n    '    0.75,',\n    '    0.166,',\n    '    0.0833,',\n    '    0.0,',\n    '    0.0,',\n    '    0.0,',\n    '    vec4(0.0)',\n    '  );',\n    '',\n    '  // TODO avoid querying texture twice for same texel',\n    '  gl_FragColor.a = texture2D(tDiffuse, vUv).a;',\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nexport const FocusShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    screenWidth: { value: 1024 },\n    screenHeight: { value: 1024 },\n    sampleDistance: { value: 0.94 },\n    waveFactor: { value: 0.00125 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float screenWidth;',\n    'uniform float screenHeight;',\n    'uniform float sampleDistance;',\n    'uniform float waveFactor;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 color, org, tmp, add;',\n    '\tfloat sample_dist, f;',\n    '\tvec2 vin;',\n    '\tvec2 uv = vUv;',\n\n    '\tadd = color = org = texture2D( tDiffuse, uv );',\n\n    '\tvin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );',\n    '\tsample_dist = dot( vin, vin ) * 2.0;',\n\n    '\tf = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;',\n\n    '\tvec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );',\n    '\tif( tmp.b < color.b ) color = tmp;',\n\n    '\tcolor = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );',\n    '\tcolor = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );',\n\n    '\tgl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nexport const FreiChenShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    aspect: { value: new Vector2(512, 512) },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'varying vec2 vUv;',\n\n    'uniform vec2 aspect;',\n\n    'vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);',\n\n    'mat3 G[9];',\n\n    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n    'const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );',\n    'const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );',\n    'const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );',\n    'const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );',\n    'const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );',\n    'const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );',\n    'const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );',\n    'const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );',\n    'const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );',\n\n    'void main(void)',\n    '{',\n\n    '\tG[0] = g0,',\n    '\tG[1] = g1,',\n    '\tG[2] = g2,',\n    '\tG[3] = g3,',\n    '\tG[4] = g4,',\n    '\tG[5] = g5,',\n    '\tG[6] = g6,',\n    '\tG[7] = g7,',\n    '\tG[8] = g8;',\n\n    '\tmat3 I;',\n    '\tfloat cnv[9];',\n    '\tvec3 sample;',\n\n    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n    '\tfor (float i=0.0; i<3.0; i++) {',\n    '\t\tfor (float j=0.0; j<3.0; j++) {',\n    '\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;',\n    '\t\t\tI[int(i)][int(j)] = length(sample);',\n    '\t\t}',\n    '\t}',\n\n    /* calculate the convolution values for all the masks */\n    '\tfor (int i=0; i<9; i++) {',\n    '\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);',\n    '\t\tcnv[i] = dp3 * dp3;',\n    '\t}',\n\n    '\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);',\n    '\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);',\n\n    '\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);',\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Based on Nvidia Cg tutorial\n */\n\nexport const FresnelShader = {\n  uniforms: {\n    mRefractionRatio: { value: 1.02 },\n    mFresnelBias: { value: 0.1 },\n    mFresnelPower: { value: 2.0 },\n    mFresnelScale: { value: 1.0 },\n    tCube: { value: null },\n  },\n\n  vertexShader: [\n    'uniform float mRefractionRatio;',\n    'uniform float mFresnelBias;',\n    'uniform float mFresnelScale;',\n    'uniform float mFresnelPower;',\n\n    'varying vec3 vReflect;',\n    'varying vec3 vRefract[3];',\n    'varying float vReflectionFactor;',\n\n    'void main() {',\n\n    '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n    '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n\n    '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );',\n\n    '\tvec3 I = worldPosition.xyz - cameraPosition;',\n\n    '\tvReflect = reflect( I, worldNormal );',\n    '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );',\n    '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );',\n    '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );',\n    '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );',\n\n    '\tgl_Position = projectionMatrix * mvPosition;',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform samplerCube tCube;',\n\n    'varying vec3 vReflect;',\n    'varying vec3 vRefract[3];',\n    'varying float vReflectionFactor;',\n\n    'void main() {',\n\n    '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );',\n    '\tvec4 refractedColor = vec4( 1.0 );',\n\n    '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;',\n    '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;',\n    '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;',\n\n    '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Gamma Correction Shader\n * http://en.wikipedia.org/wiki/gamma_correction\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type GammaCorrectionShaderUniforms = {\n  tDiffuse: IUniform<Texture | null>\n}\n\nexport interface IGammaCorrectionShader extends IShader<GammaCorrectionShaderUniforms> {}\n\nexport const GammaCorrectionShader: IGammaCorrectionShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 tex = texture2D( tDiffuse, vUv );',\n\n    '\t#ifdef LinearTosRGB',\n    '\t\tgl_FragColor = LinearTosRGB( tex );',\n    '\t#else',\n    '\t\tgl_FragColor = sRGBTransferOETF( tex );',\n    '\t#endif',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Color, Vector3 } from 'three'\n\n/**\n * God-rays (crepuscular rays)\n *\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\n * Blurs a mask generated from the depth map along radial lines emanating from the light\n * source. The blur repeatedly applies a blur filter of increasing support but constant\n * sample count to produce a blur filter with large support.\n *\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\n * with decreasing filter support. The result is equivalent to a single pass with\n * 6*6*6 = 216 samples.\n *\n * References:\n *\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\n */\n\nexport const GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null,\n    },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    ' vUv = uv;',\n    ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'varying vec2 vUv;',\n\n    'uniform sampler2D tInput;',\n\n    'void main() {',\n\n    '\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );',\n\n    '}',\n  ].join('\\n'),\n}\n\n/**\n * The god-ray generation shader.\n *\n * First pass:\n *\n * The depth map is blurred along radial lines towards the \"sun\". The\n * output is written to a temporary render target (I used a 1/4 sized\n * target).\n *\n * Pass two & three:\n *\n * The results of the previous pass are re-blurred, each time with a\n * decreased distance between samples.\n */\n\nexport const GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null,\n    },\n    fStepSize: {\n      value: 1.0,\n    },\n    vSunPositionScreenSpace: {\n      value: new Vector3(),\n    },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    ' vUv = uv;',\n    ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#define TAPS_PER_PASS 6.0',\n\n    'varying vec2 vUv;',\n\n    'uniform sampler2D tInput;',\n\n    'uniform vec3 vSunPositionScreenSpace;',\n    'uniform float fStepSize;', // filter step size\n\n    'void main() {',\n\n    // delta from current pixel to \"sun\" position\n\n    '\tvec2 delta = vSunPositionScreenSpace.xy - vUv;',\n    '\tfloat dist = length( delta );',\n\n    // Step vector (uv space)\n\n    '\tvec2 stepv = fStepSize * delta / dist;',\n\n    // Number of iterations between pixel and sun\n\n    '\tfloat iters = dist/fStepSize;',\n\n    '\tvec2 uv = vUv.xy;',\n    '\tfloat col = 0.0;',\n\n    // This breaks ANGLE in Chrome 22\n    //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n    /*\n\t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t\t// so i've just left the loop\n\n\t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n\n\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t// mode, with a black border color. I don't think this is currently\n\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t// not specifically handled.\n\n\t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n\t\t\"\tuv += stepv;\",\n\n\t\t\"}\",\n\t\t*/\n\n    // Unrolling loop manually makes it work in ANGLE\n\n    '\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\n\n    '\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;',\n    '\tuv += stepv;',\n\n    '\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;',\n    '\tuv += stepv;',\n\n    '\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;',\n    '\tuv += stepv;',\n\n    '\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;',\n    '\tuv += stepv;',\n\n    '\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;',\n    '\tuv += stepv;',\n\n    '\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;',\n    '\tuv += stepv;',\n\n    // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n    // objectionable artifacts, in particular near the sun position. The side\n    // effect is that the result is darker than it should be around the sun, as\n    // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n    // When the result is inverted (in the shader 'godrays_combine', this produces\n    // a slight bright spot at the position of the sun, even when it is occluded.\n\n    '\tgl_FragColor = vec4( col/TAPS_PER_PASS );',\n    '\tgl_FragColor.a = 1.0;',\n\n    '}',\n  ].join('\\n'),\n}\n\n/**\n * Additively applies god rays from texture tGodRays to a background (tColors).\n * fGodRayIntensity attenuates the god rays.\n */\n\nexport const GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null,\n    },\n\n    tGodRays: {\n      value: null,\n    },\n\n    fGodRayIntensity: {\n      value: 0.69,\n    },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'varying vec2 vUv;',\n\n    'uniform sampler2D tColors;',\n    'uniform sampler2D tGodRays;',\n\n    'uniform float fGodRayIntensity;',\n\n    'void main() {',\n\n    // Since THREE.MeshDepthMaterial renders foreground objects white and background\n    // objects black, the god-rays will be white streaks. Therefore value is inverted\n    // before being combined with tColors\n\n    '\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );',\n    '\tgl_FragColor.a = 1.0;',\n\n    '}',\n  ].join('\\n'),\n}\n\n/**\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\n * cheaper/faster/simpler to implement this as a simple sun sprite.\n */\n\nexport const GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: new Vector3(),\n    },\n\n    fAspect: {\n      value: 1.0,\n    },\n\n    sunColor: {\n      value: new Color(0xffee00),\n    },\n\n    bgColor: {\n      value: new Color(0x000000),\n    },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'varying vec2 vUv;',\n\n    'uniform vec3 vSunPositionScreenSpace;',\n    'uniform float fAspect;',\n\n    'uniform vec3 sunColor;',\n    'uniform vec3 bgColor;',\n\n    'void main() {',\n\n    '\tvec2 diff = vUv - vSunPositionScreenSpace.xy;',\n\n    // Correct for aspect ratio\n\n    '\tdiff.x *= fAspect;',\n\n    '\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );',\n    '\tprop = 0.35 * pow( 1.0 - prop, 3.0 );',\n\n    '\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;',\n    '\tgl_FragColor.w = 1.0;',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type HorizontalBlurShaderUniforms = {\n  tDiffuse: IUniform<Texture | null>\n  h: IUniform<number>\n}\n\nexport interface IHorizontalBlurShader extends IShader<HorizontalBlurShaderUniforms> {}\n\nexport const HorizontalBlurShader: IHorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1.0 / 512.0 },\n  },\n  vertexShader: /* glsl */ `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n  fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `,\n}\n", "/**\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nexport const HorizontalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1.0 / 512.0 },\n    r: { value: 0.35 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float h;',\n    'uniform float r;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 sum = vec4( 0.0 );',\n\n    '\tfloat hh = h * abs( r - vUv.y );',\n\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;',\n\n    '\tgl_FragColor = sum;',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nexport const HueSaturationShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    hue: { value: 0 },\n    saturation: { value: 0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float hue;',\n    'uniform float saturation;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tgl_FragColor = texture2D( tDiffuse, vUv );',\n\n    // hue\n    '\tfloat angle = hue * 3.14159265;',\n    '\tfloat s = sin(angle), c = cos(angle);',\n    '\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;',\n    '\tfloat len = length(gl_FragColor.rgb);',\n    '\tgl_FragColor.rgb = vec3(',\n    '\t\tdot(gl_FragColor.rgb, weights.xyz),',\n    '\t\tdot(gl_FragColor.rgb, weights.zxy),',\n    '\t\tdot(gl_FragColor.rgb, weights.yzx)',\n    '\t);',\n\n    // saturation\n    '\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;',\n    '\tif (saturation > 0.0) {',\n    '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));',\n    '\t} else {',\n    '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);',\n    '\t}',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\n\nexport const KaleidoShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    sides: { value: 6.0 },\n    angle: { value: 0.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float sides;',\n    'uniform float angle;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 p = vUv - 0.5;',\n    '\tfloat r = length(p);',\n    '\tfloat a = atan(p.y, p.x) + angle;',\n    '\tfloat tau = 2. * 3.1416 ;',\n    '\ta = mod(a, tau/sides);',\n    '\ta = abs(a - tau/sides/2.) ;',\n    '\tp = r * vec2(cos(a), sin(a));',\n    '\tvec4 color = texture2D(tDiffuse, p + 0.5);',\n    '\tgl_FragColor = color;',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\n\nexport const MirrorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    side: { value: 1 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform int side;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 p = vUv;',\n    '\tif (side == 0){',\n    '\t\tif (p.x > 0.5) p.x = 1.0 - p.x;',\n    '\t}else if (side == 1){',\n    '\t\tif (p.x < 0.5) p.x = 1.0 - p.x;',\n    '\t}else if (side == 2){',\n    '\t\tif (p.y < 0.5) p.y = 1.0 - p.y;',\n    '\t}else if (side == 3){',\n    '\t\tif (p.y > 0.5) p.y = 1.0 - p.y;',\n    '\t} ',\n    '\tvec4 color = texture2D(tDiffuse, p);',\n    '\tgl_FragColor = color;',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * Normal map shader\n * - compute normals from heightmap\n */\n\nexport const NormalMapShader = {\n  uniforms: {\n    heightMap: { value: null },\n    resolution: { value: new Vector2(512, 512) },\n    scale: { value: new Vector2(1, 1) },\n    height: { value: 0.05 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float height;',\n    'uniform vec2 resolution;',\n    'uniform sampler2D heightMap;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tfloat val = texture2D( heightMap, vUv ).x;',\n\n    '\tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;',\n    '\tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;',\n\n    '\tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n", "// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\nexport const ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX',\n  },\n\n  uniforms: {\n    bumpMap: { value: null },\n    map: { value: null },\n    parallaxScale: { value: null },\n    parallaxMinLayers: { value: null },\n    parallaxMaxLayers: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n    'varying vec3 vViewPosition;',\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n    '\tvViewPosition = -mvPosition.xyz;',\n    '\tvNormal = normalize( normalMatrix * normal );',\n    '\tgl_Position = projectionMatrix * mvPosition;',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D bumpMap;',\n    'uniform sampler2D map;',\n\n    'uniform float parallaxScale;',\n    'uniform float parallaxMinLayers;',\n    'uniform float parallaxMaxLayers;',\n\n    'varying vec2 vUv;',\n    'varying vec3 vViewPosition;',\n    'varying vec3 vNormal;',\n\n    '#ifdef USE_BASIC_PARALLAX',\n\n    '\tvec2 parallaxMap( in vec3 V ) {',\n\n    '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;',\n\n    // No Offset Limitting: messy, floating output at grazing angles.\n    //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n\n    // Offset Limiting\n    '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;',\n    '\t\treturn vUv - texCoordOffset;',\n\n    '\t}',\n\n    '#else',\n\n    '\tvec2 parallaxMap( in vec3 V ) {',\n\n    // Determine number of layers from angle between V and N\n    '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );',\n\n    '\t\tfloat layerHeight = 1.0 / numLayers;',\n    '\t\tfloat currentLayerHeight = 0.0;',\n    // Shift of texture coordinates for each iteration\n    '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;',\n\n    '\t\tvec2 currentTextureCoords = vUv;',\n\n    '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n\n    // while ( heightFromTexture > currentLayerHeight )\n    // Infinite loops are not well supported. Do a \"large\" finite\n    // loop, but not too large, as it slows down some compilers.\n    '\t\tfor ( int i = 0; i < 30; i += 1 ) {',\n    '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {',\n    '\t\t\t\tbreak;',\n    '\t\t\t}',\n    '\t\t\tcurrentLayerHeight += layerHeight;',\n    // Shift texture coordinates along vector V\n    '\t\t\tcurrentTextureCoords -= dtex;',\n    '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n    '\t\t}',\n\n    '\t\t#ifdef USE_STEEP_PARALLAX',\n\n    '\t\t\treturn currentTextureCoords;',\n\n    '\t\t#elif defined( USE_RELIEF_PARALLAX )',\n\n    '\t\t\tvec2 deltaTexCoord = dtex / 2.0;',\n    '\t\t\tfloat deltaHeight = layerHeight / 2.0;',\n\n    // Return to the mid point of previous layer\n    '\t\t\tcurrentTextureCoords += deltaTexCoord;',\n    '\t\t\tcurrentLayerHeight -= deltaHeight;',\n\n    // Binary search to increase precision of Steep Parallax Mapping\n    '\t\t\tconst int numSearches = 5;',\n    '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {',\n\n    '\t\t\t\tdeltaTexCoord /= 2.0;',\n    '\t\t\t\tdeltaHeight /= 2.0;',\n    '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n    // Shift along or against vector V\n    '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\n\n    '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;',\n    '\t\t\t\t\tcurrentLayerHeight += deltaHeight;',\n\n    '\t\t\t\t} else {', // above the surface\n\n    '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;',\n    '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;',\n\n    '\t\t\t\t}',\n\n    '\t\t\t}',\n    '\t\t\treturn currentTextureCoords;',\n\n    '\t\t#elif defined( USE_OCLUSION_PARALLAX )',\n\n    '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;',\n\n    // Heights for linear interpolation\n    '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;',\n    '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;',\n\n    // Proportions for linear interpolation\n    '\t\t\tfloat weight = nextH / ( nextH - prevH );',\n\n    // Interpolation of texture coordinates\n    '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );',\n\n    '\t\t#else', // NO_PARALLAX\n\n    '\t\t\treturn vUv;',\n\n    '\t\t#endif',\n\n    '\t}',\n    '#endif',\n\n    'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {',\n\n    '\tvec2 texDx = dFdx( vUv );',\n    '\tvec2 texDy = dFdy( vUv );',\n\n    '\tvec3 vSigmaX = dFdx( surfPosition );',\n    '\tvec3 vSigmaY = dFdy( surfPosition );',\n    '\tvec3 vR1 = cross( vSigmaY, surfNormal );',\n    '\tvec3 vR2 = cross( surfNormal, vSigmaX );',\n    '\tfloat fDet = dot( vSigmaX, vR1 );',\n\n    '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );',\n    '\tvec3 vProjVtex;',\n    '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;',\n    '\tvProjVtex.z = dot( surfNormal, viewPosition );',\n\n    '\treturn parallaxMap( vProjVtex );',\n    '}',\n\n    'void main() {',\n\n    '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );',\n    '\tgl_FragColor = texture2D( map, mapUv );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Pixelation shader\n */\n\nexport const PixelShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: null },\n    pixelSize: { value: 1 },\n  },\n\n  vertexShader: [\n    'varying highp vec2 vUv;',\n\n    'void main() {',\n\n    'vUv = uv;',\n    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float pixelSize;',\n    'uniform vec2 resolution;',\n\n    'varying highp vec2 vUv;',\n\n    'void main(){',\n\n    'vec2 dxy = pixelSize / resolution;',\n    'vec2 coord = dxy * floor( vUv / dxy );',\n    'gl_FragColor = texture2D(tDiffuse, coord);',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nexport const RGBShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    amount: { value: 0.005 },\n    angle: { value: 0.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float amount;',\n    'uniform float angle;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 offset = amount * vec2( cos(angle), sin(angle));',\n    '\tvec4 cr = texture2D(tDiffuse, vUv + offset);',\n    '\tvec4 cga = texture2D(tDiffuse, vUv);',\n    '\tvec4 cb = texture2D(tDiffuse, vUv - offset);',\n    '\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nexport const SepiaShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    amount: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float amount;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 color = texture2D( tDiffuse, vUv );',\n    '\tvec3 c = color.rgb;',\n\n    '\tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );',\n    '\tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );',\n    '\tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );',\n\n    '\tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nexport const SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    resolution: { value: new Vector2() },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform vec2 resolution;',\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );',\n\n    // kernel definition (in glsl matrices are filled in column-major order)\n\n    '\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\n    '\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\n\n    // fetch the 3x3 neighbourhood of a fragment\n\n    // first column\n\n    '\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;',\n    '\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;',\n    '\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;',\n\n    // second column\n\n    '\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;',\n    '\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;',\n    '\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;',\n\n    // third column\n\n    '\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;',\n    '\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;',\n    '\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;',\n\n    // gradient value in x direction\n\n    '\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ',\n    '\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ',\n    '\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ',\n\n    // gradient value in y direction\n\n    '\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ',\n    '\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ',\n    '\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ',\n\n    // magnitute of the total gradient\n\n    '\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );',\n\n    '\tgl_FragColor = vec4( vec3( G ), 1 );',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Technicolor Shader\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n */\n\nexport const TechnicolorShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );',\n    '\tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);',\n\n    '\tgl_FragColor = newTex;',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Color, Vector3 } from 'three'\n\n/**\n * Currently contains:\n *\n *\ttoon1\n *\ttoon2\n *\thatching\n *\tdotted\n */\n\nexport const ToonShader1 = {\n  uniforms: {\n    uDirLightPos: { value: new Vector3() },\n    uDirLightColor: { value: new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: new Color(0x050505) },\n\n    uBaseColor: { value: new Color(0xffffff) },\n  },\n\n  vertexShader: [\n    'varying vec3 vNormal;',\n    'varying vec3 vRefract;',\n\n    'void main() {',\n\n    '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n    '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n    '\tvec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );',\n\n    '\tvNormal = normalize( normalMatrix * normal );',\n\n    '\tvec3 I = worldPosition.xyz - cameraPosition;',\n    '\tvRefract = refract( normalize( I ), worldNormal, 1.02 );',\n\n    '\tgl_Position = projectionMatrix * mvPosition;',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec3 uBaseColor;',\n\n    'uniform vec3 uDirLightPos;',\n    'uniform vec3 uDirLightColor;',\n\n    'uniform vec3 uAmbientLightColor;',\n\n    'varying vec3 vNormal;',\n\n    'varying vec3 vRefract;',\n\n    'void main() {',\n\n    '\tfloat directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);',\n    '\tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;',\n\n    '\tfloat intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );',\n    '\tintensity += length(lightWeighting) * 0.2;',\n\n    '\tfloat cameraWeighting = dot( normalize( vNormal ), vRefract );',\n    '\tintensity += pow( 1.0 - length( cameraWeighting ), 6.0 );',\n    '\tintensity = intensity * 0.2 + 0.3;',\n\n    '\tif ( intensity < 0.50 ) {',\n\n    '\t\tgl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );',\n\n    '\t} else {',\n\n    '\t\tgl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );',\n\n    '}',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const ToonShader2 = {\n  uniforms: {\n    uDirLightPos: { value: new Vector3() },\n    uDirLightColor: { value: new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: new Color(0x050505) },\n\n    uBaseColor: { value: new Color(0xeeeeee) },\n    uLineColor1: { value: new Color(0x808080) },\n    uLineColor2: { value: new Color(0x000000) },\n    uLineColor3: { value: new Color(0x000000) },\n    uLineColor4: { value: new Color(0x000000) },\n  },\n\n  vertexShader: [\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '\tvNormal = normalize( normalMatrix * normal );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec3 uBaseColor;',\n    'uniform vec3 uLineColor1;',\n    'uniform vec3 uLineColor2;',\n    'uniform vec3 uLineColor3;',\n    'uniform vec3 uLineColor4;',\n\n    'uniform vec3 uDirLightPos;',\n    'uniform vec3 uDirLightColor;',\n\n    'uniform vec3 uAmbientLightColor;',\n\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    '\tfloat camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);',\n    '\tfloat light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);',\n\n    '\tgl_FragColor = vec4( uBaseColor, 1.0 );',\n\n    '\tif ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {',\n\n    '\t\tgl_FragColor *= vec4( uLineColor1, 1.0 );',\n\n    '\t}',\n\n    '\tif ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {',\n\n    '\t\tgl_FragColor *= vec4( uLineColor2, 1.0 );',\n\n    '\t}',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const ToonShaderHatching = {\n  uniforms: {\n    uDirLightPos: { value: new Vector3() },\n    uDirLightColor: { value: new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: new Color(0x050505) },\n\n    uBaseColor: { value: new Color(0xffffff) },\n    uLineColor1: { value: new Color(0x000000) },\n    uLineColor2: { value: new Color(0x000000) },\n    uLineColor3: { value: new Color(0x000000) },\n    uLineColor4: { value: new Color(0x000000) },\n  },\n\n  vertexShader: [\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '\tvNormal = normalize( normalMatrix * normal );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec3 uBaseColor;',\n    'uniform vec3 uLineColor1;',\n    'uniform vec3 uLineColor2;',\n    'uniform vec3 uLineColor3;',\n    'uniform vec3 uLineColor4;',\n\n    'uniform vec3 uDirLightPos;',\n    'uniform vec3 uDirLightColor;',\n\n    'uniform vec3 uAmbientLightColor;',\n\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    '\tfloat directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);',\n    '\tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;',\n\n    '\tgl_FragColor = vec4( uBaseColor, 1.0 );',\n\n    '\tif ( length(lightWeighting) < 1.00 ) {',\n\n    '\t\tif ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {',\n\n    '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tif ( length(lightWeighting) < 0.75 ) {',\n\n    '\t\tif (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {',\n\n    '\t\t\tgl_FragColor = vec4( uLineColor2, 1.0 );',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tif ( length(lightWeighting) < 0.50 ) {',\n\n    '\t\tif (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {',\n\n    '\t\t\tgl_FragColor = vec4( uLineColor3, 1.0 );',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tif ( length(lightWeighting) < 0.3465 ) {',\n\n    '\t\tif (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {',\n\n    '\t\t\tgl_FragColor = vec4( uLineColor4, 1.0 );',\n\n    '\t}',\n\n    '\t}',\n\n    '}',\n  ].join('\\n'),\n}\n\nexport const ToonShaderDotted = {\n  uniforms: {\n    uDirLightPos: { value: new Vector3() },\n    uDirLightColor: { value: new Color(0xeeeeee) },\n\n    uAmbientLightColor: { value: new Color(0x050505) },\n\n    uBaseColor: { value: new Color(0xffffff) },\n    uLineColor1: { value: new Color(0x000000) },\n  },\n\n  vertexShader: [\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n    '\tvNormal = normalize( normalMatrix * normal );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec3 uBaseColor;',\n    'uniform vec3 uLineColor1;',\n    'uniform vec3 uLineColor2;',\n    'uniform vec3 uLineColor3;',\n    'uniform vec3 uLineColor4;',\n\n    'uniform vec3 uDirLightPos;',\n    'uniform vec3 uDirLightColor;',\n\n    'uniform vec3 uAmbientLightColor;',\n\n    'varying vec3 vNormal;',\n\n    'void main() {',\n\n    'float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);',\n    'vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;',\n\n    'gl_FragColor = vec4( uBaseColor, 1.0 );',\n\n    'if ( length(lightWeighting) < 1.00 ) {',\n\n    '\t\tif ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {',\n\n    '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );',\n\n    '\t\t}',\n\n    '\t}',\n\n    '\tif ( length(lightWeighting) < 0.50 ) {',\n\n    '\t\tif ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {',\n\n    '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );',\n\n    '\t\t}',\n\n    '\t}',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2 } from 'three'\n\n/**\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nexport const TriangleBlurShader = {\n  uniforms: {\n    texture: { value: null },\n    delta: { value: new Vector2(1, 1) },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#include <common>',\n\n    '#define ITERATIONS 10.0',\n\n    'uniform sampler2D texture;',\n    'uniform vec2 delta;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 color = vec4( 0.0 );',\n\n    '\tfloat total = 0.0;',\n\n    // randomize the lookup values to hide the fixed number of samples\n\n    '\tfloat offset = rand( vUv );',\n\n    '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {',\n\n    '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;',\n    '\t\tfloat weight = 1.0 - abs( percent );',\n\n    '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;',\n    '\t\ttotal += weight;',\n\n    '\t}',\n\n    '\tgl_FragColor = color / total;',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nimport type { IUniform, Texture } from 'three'\nimport type { IShader } from './types'\n\nexport type VerticalBlurShaderUniforms = {\n  tDiffuse: IUniform<Texture | null>\n  v: IUniform<number>\n}\n\nexport interface IVerticalBlurShader extends IShader<VerticalBlurShaderUniforms> {}\n\nexport const VerticalBlurShader: IVerticalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1.0 / 512.0 },\n  },\n  vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n  fragmentShader: /* glsl */ `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `,\n}\n", "/**\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nexport const VerticalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1.0 / 512.0 },\n    r: { value: 0.35 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform sampler2D tDiffuse;',\n    'uniform float v;',\n    'uniform float r;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvec4 sum = vec4( 0.0 );',\n\n    '\tfloat vv = v * abs( r - vUv.y );',\n\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;',\n    '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;',\n\n    '\tgl_FragColor = sum;',\n\n    '}',\n  ].join('\\n'),\n}\n", "/**\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nexport const VignetteShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    offset: { value: 1.0 },\n    darkness: { value: 1.0 },\n  },\n\n  vertexShader: [\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform float offset;',\n    'uniform float darkness;',\n\n    'uniform sampler2D tDiffuse;',\n\n    'varying vec2 vUv;',\n\n    'void main() {',\n\n    // Eskil's vignette\n\n    '\tvec4 texel = texture2D( tDiffuse, vUv );',\n    '\tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );',\n    '\tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );',\n\n    /*\n\t\t// alternative version from glfx.js\n\t\t// this one makes more \"dusty\" look (as opposed to \"burned\")\n\n\t\t\"\tvec4 color = texture2D( tDiffuse, vUv );\",\n\t\t\"\tfloat dist = distance( vUv, vec2( 0.5 ) );\",\n\t\t\"\tcolor.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\n\t\t\"\tgl_FragColor = color;\",\n\t\t*/\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Vector2, Vector3 } from 'three'\n\n/**\n * Shaders to render 3D volumes using raycasting.\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n * This is not the only approach, therefore it's marked 1.\n */\n\nexport const VolumeRenderShader1 = {\n  uniforms: {\n    u_size: { value: new Vector3(1, 1, 1) },\n    u_renderstyle: { value: 0 },\n    u_renderthreshold: { value: 0.5 },\n    u_clim: { value: new Vector2(1, 1) },\n    u_data: { value: null },\n    u_cmdata: { value: null },\n  },\n  vertexShader: [\n    '\t\tvarying vec4 v_nearpos;',\n    '\t\tvarying vec4 v_farpos;',\n    '\t\tvarying vec3 v_position;',\n\n    '\t\tvoid main() {',\n    // Prepare transforms to map to \"camera view\". See also:\n    // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n    '\t\t\t\tmat4 viewtransformf = modelViewMatrix;',\n    '\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);',\n\n    // Project local vertex coordinate to camera position. Then do a step\n    // backward (in cam coords) to the near clipping plane, and project back. Do\n    // the same for the far clipping plane. This gives us all the information we\n    // need to calculate the ray and truncate it to the viewing cone.\n    '\t\t\t\tvec4 position4 = vec4(position, 1.0);',\n    '\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;',\n\n    // Intersection of ray and near clipping plane (z = -1 in clip coords)\n    '\t\t\t\tpos_in_cam.z = -pos_in_cam.w;',\n    '\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;',\n\n    // Intersection of ray and far clipping plane (z = +1 in clip coords)\n    '\t\t\t\tpos_in_cam.z = pos_in_cam.w;',\n    '\t\t\t\tv_farpos = viewtransformi * pos_in_cam;',\n\n    // Set varyings and output pos\n    '\t\t\t\tv_position = position;',\n    '\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;',\n    '\t\t}',\n  ].join('\\n'),\n  fragmentShader: [\n    '\t\tprecision highp float;',\n    '\t\tprecision mediump sampler3D;',\n\n    '\t\tuniform vec3 u_size;',\n    '\t\tuniform int u_renderstyle;',\n    '\t\tuniform float u_renderthreshold;',\n    '\t\tuniform vec2 u_clim;',\n\n    '\t\tuniform sampler3D u_data;',\n    '\t\tuniform sampler2D u_cmdata;',\n\n    '\t\tvarying vec3 v_position;',\n    '\t\tvarying vec4 v_nearpos;',\n    '\t\tvarying vec4 v_farpos;',\n\n    // The maximum distance through our rendering volume is sqrt(3).\n    '\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3',\n    '\t\tconst int REFINEMENT_STEPS = 4;',\n    '\t\tconst float relative_step_size = 1.0;',\n    '\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);',\n    '\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);',\n    '\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);',\n    '\t\tconst float shininess = 40.0;',\n\n    '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);',\n    '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);',\n\n    '\t\tfloat sample1(vec3 texcoords);',\n    '\t\tvec4 apply_colormap(float val);',\n    '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);',\n\n    '\t\tvoid main() {',\n    // Normalize clipping plane info\n    '\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;',\n    '\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;',\n\n    // Calculate unit vector pointing in the view direction through this fragment.\n    '\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);',\n\n    // Compute the (negative) distance to the front surface or near clipping plane.\n    // v_position is the back face of the cuboid, so the initial distance calculated in the dot\n    // product below is the distance from near clip plane to the back of the cuboid\n    '\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);',\n    '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,',\n    '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));',\n    '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,',\n    '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));',\n    '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,',\n    '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));',\n\n    // Now we have the starting position on the front surface\n    '\t\t\t\tvec3 front = v_position + view_ray * distance;',\n\n    // Decide how many steps to take\n    '\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);',\n    '\t\t\t\tif ( nsteps < 1 )',\n    '\t\t\t\t\t\tdiscard;',\n\n    // Get starting location and step vector in texture coordinates\n    '\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);',\n    '\t\t\t\tvec3 start_loc = front / u_size;',\n\n    // For testing: show the number of steps. This helps to establish\n    // whether the rays are correctly oriented\n    //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',\n    //'return;',\n\n    '\t\t\t\tif (u_renderstyle == 0)',\n    '\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);',\n    '\t\t\t\telse if (u_renderstyle == 1)',\n    '\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);',\n\n    '\t\t\t\tif (gl_FragColor.a < 0.05)',\n    '\t\t\t\t\t\tdiscard;',\n    '\t\t}',\n\n    '\t\tfloat sample1(vec3 texcoords) {',\n    '\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */',\n    '\t\t\t\treturn texture(u_data, texcoords.xyz).r;',\n    '\t\t}',\n\n    '\t\tvec4 apply_colormap(float val) {',\n    '\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);',\n    '\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));',\n    '\t\t}',\n\n    '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {',\n\n    '\t\t\t\tfloat max_val = -1e6;',\n    '\t\t\t\tint max_i = 100;',\n    '\t\t\t\tvec3 loc = start_loc;',\n\n    // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n    // non-constant expression. So we use a hard-coded max, and an additional condition\n    // inside the loop.\n    '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {',\n    '\t\t\t\t\t\tif (iter >= nsteps)',\n    '\t\t\t\t\t\t\t\tbreak;',\n    // Sample from the 3D texture\n    '\t\t\t\t\t\tfloat val = sample1(loc);',\n    // Apply MIP operation\n    '\t\t\t\t\t\tif (val > max_val) {',\n    '\t\t\t\t\t\t\t\tmax_val = val;',\n    '\t\t\t\t\t\t\t\tmax_i = iter;',\n    '\t\t\t\t\t\t}',\n    // Advance location deeper into the volume\n    '\t\t\t\t\t\tloc += step;',\n    '\t\t\t\t}',\n\n    // Refine location, gives crispier images\n    '\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);',\n    '\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);',\n    '\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {',\n    '\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));',\n    '\t\t\t\t\t\tiloc += istep;',\n    '\t\t\t\t}',\n\n    // Resolve final color\n    '\t\t\t\tgl_FragColor = apply_colormap(max_val);',\n    '\t\t}',\n\n    '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {',\n\n    '\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent',\n    '\t\t\t\tvec4 color3 = vec4(0.0);\t// final color',\n    '\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative',\n    '\t\t\t\tvec3 loc = start_loc;',\n\n    '\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);',\n\n    // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n    // non-constant expression. So we use a hard-coded max, and an additional condition\n    // inside the loop.\n    '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {',\n    '\t\t\t\t\t\tif (iter >= nsteps)',\n    '\t\t\t\t\t\t\t\tbreak;',\n\n    // Sample from the 3D texture\n    '\t\t\t\t\t\tfloat val = sample1(loc);',\n\n    '\t\t\t\t\t\tif (val > low_threshold) {',\n    // Take the last interval in smaller steps\n    '\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;',\n    '\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);',\n    '\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {',\n    '\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);',\n    '\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {',\n    '\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);',\n    '\t\t\t\t\t\t\t\t\t\t\t\treturn;',\n    '\t\t\t\t\t\t\t\t\t\t}',\n    '\t\t\t\t\t\t\t\t\t\tiloc += istep;',\n    '\t\t\t\t\t\t\t\t}',\n    '\t\t\t\t\t\t}',\n\n    // Advance location deeper into the volume\n    '\t\t\t\t\t\tloc += step;',\n    '\t\t\t\t}',\n    '\t\t}',\n\n    '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)',\n    '\t\t{',\n    // Calculate color by incorporating lighting\n\n    // View direction\n    '\t\t\t\tvec3 V = normalize(view_ray);',\n\n    // calculate normal vector from gradient\n    '\t\t\t\tvec3 N;',\n    '\t\t\t\tfloat val1, val2;',\n    '\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));',\n    '\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));',\n    '\t\t\t\tN[0] = val1 - val2;',\n    '\t\t\t\tval = max(max(val1, val2), val);',\n    '\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));',\n    '\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));',\n    '\t\t\t\tN[1] = val1 - val2;',\n    '\t\t\t\tval = max(max(val1, val2), val);',\n    '\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));',\n    '\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));',\n    '\t\t\t\tN[2] = val1 - val2;',\n    '\t\t\t\tval = max(max(val1, val2), val);',\n\n    '\t\t\t\tfloat gm = length(N); // gradient magnitude',\n    '\t\t\t\tN = normalize(N);',\n\n    // Flip normal so it points towards viewer\n    '\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);',\n    '\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;',\n\n    // Init colors\n    '\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);',\n    '\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);',\n    '\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);',\n\n    // note: could allow multiple lights\n    '\t\t\t\tfor (int i=0; i<1; i++)',\n    '\t\t\t\t{',\n    // Get light direction (make sure to prevent zero devision)\n    '\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];',\n    '\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );',\n    '\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));',\n\n    // Calculate lighting properties\n    '\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);',\n    '\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector',\n    '\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);',\n\n    // Calculate mask\n    '\t\t\t\t\t\tfloat mask1 = lightEnabled;',\n\n    // Calculate colors\n    '\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;',\n    '\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;',\n    '\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;',\n    '\t\t\t\t}',\n\n    // Calculate final color by componing different components\n    '\t\t\t\tvec4 final_color;',\n    '\t\t\t\tvec4 color = apply_colormap(val);',\n    '\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;',\n    '\t\t\t\tfinal_color.a = color.a;',\n    '\t\t\t\treturn final_color;',\n    '\t\t}',\n  ].join('\\n'),\n}\n", "export const WaterRefractionShader = {\n  uniforms: {\n    color: {\n      value: null,\n    },\n\n    time: {\n      value: 0,\n    },\n\n    tDiffuse: {\n      value: null,\n    },\n\n    tDudv: {\n      value: null,\n    },\n\n    textureMatrix: {\n      value: null,\n    },\n  },\n\n  vertexShader: [\n    'uniform mat4 textureMatrix;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vUvRefraction;',\n\n    'void main() {',\n\n    '\tvUv = uv;',\n\n    '\tvUvRefraction = textureMatrix * vec4( position, 1.0 );',\n\n    '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n    '}',\n  ].join('\\n'),\n\n  fragmentShader: [\n    'uniform vec3 color;',\n    'uniform float time;',\n    'uniform sampler2D tDiffuse;',\n    'uniform sampler2D tDudv;',\n\n    'varying vec2 vUv;',\n    'varying vec4 vUvRefraction;',\n\n    'float blendOverlay( float base, float blend ) {',\n\n    '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n    '}',\n\n    'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n    '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );',\n\n    '}',\n\n    'void main() {',\n\n    ' float waveStrength = 0.1;',\n    ' float waveSpeed = 0.03;',\n\n    // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\n\n    '\tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;',\n    '\tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );',\n    '\tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;',\n\n    // new uv coords\n\n    ' vec4 uv = vec4( vUvRefraction );',\n    ' uv.xy += distortion;',\n\n    '\tvec4 base = texture2DProj( tDiffuse, uv );',\n\n    '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n    '}',\n  ].join('\\n'),\n}\n", "import { Group, Matrix4, Raycaster, Vector2 } from 'three'\n\nconst _pointer = new Vector2()\nconst _event = { type: '', data: _pointer }\n\nclass InteractiveGroup extends Group {\n  constructor(renderer, camera) {\n    super()\n\n    const scope = this\n\n    const raycaster = new Raycaster()\n    const tempMatrix = new Matrix4()\n\n    // Pointer Events\n\n    const element = renderer.domElement\n\n    function onPointerEvent(event) {\n      event.stopPropagation()\n\n      _pointer.x = (event.clientX / element.clientWidth) * 2 - 1\n      _pointer.y = -(event.clientY / element.clientHeight) * 2 + 1\n\n      raycaster.setFromCamera(_pointer, camera)\n\n      const intersects = raycaster.intersectObjects(scope.children, false)\n\n      if (intersects.length > 0) {\n        const intersection = intersects[0]\n\n        const object = intersection.object\n        const uv = intersection.uv\n\n        _event.type = event.type\n        _event.data.set(uv.x, 1 - uv.y)\n\n        object.dispatchEvent(_event)\n      }\n    }\n\n    element.addEventListener('pointerdown', onPointerEvent)\n    element.addEventListener('pointerup', onPointerEvent)\n    element.addEventListener('pointermove', onPointerEvent)\n    element.addEventListener('mousedown', onPointerEvent)\n    element.addEventListener('mouseup', onPointerEvent)\n    element.addEventListener('mousemove', onPointerEvent)\n    element.addEventListener('click', onPointerEvent)\n\n    // WebXR Controller Events\n    // TODO: Dispatch pointerevents too\n\n    const events = {\n      move: 'mousemove',\n      select: 'click',\n      selectstart: 'mousedown',\n      selectend: 'mouseup',\n    }\n\n    function onXRControllerEvent(event) {\n      const controller = event.target\n\n      tempMatrix.identity().extractRotation(controller.matrixWorld)\n\n      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld)\n      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix)\n\n      const intersections = raycaster.intersectObjects(scope.children, false)\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0]\n\n        const object = intersection.object\n        const uv = intersection.uv\n\n        _event.type = events[event.type]\n        _event.data.set(uv.x, 1 - uv.y)\n\n        object.dispatchEvent(_event)\n      }\n    }\n\n    const controller1 = renderer.xr.getController(0)\n    controller1.addEventListener('move', onXRControllerEvent)\n    controller1.addEventListener('select', onXRControllerEvent)\n    controller1.addEventListener('selectstart', onXRControllerEvent)\n    controller1.addEventListener('selectend', onXRControllerEvent)\n\n    const controller2 = renderer.xr.getController(1)\n    controller2.addEventListener('move', onXRControllerEvent)\n    controller2.addEventListener('select', onXRControllerEvent)\n    controller2.addEventListener('selectstart', onXRControllerEvent)\n    controller2.addEventListener('selectend', onXRControllerEvent)\n  }\n}\n\nexport { InteractiveGroup }\n", "import { Frustum, Vector3 } from 'three'\n\nconst frustum = new Frustum()\nconst center = new Vector3()\n\nconst tmpPoint = new Vector3()\n\nconst vecNear = new Vector3()\nconst vecTopLeft = new Vector3()\nconst vecTopRight = new Vector3()\nconst vecDownRight = new Vector3()\nconst vecDownLeft = new Vector3()\n\nconst vecFarTopLeft = new Vector3()\nconst vecFarTopRight = new Vector3()\nconst vecFarDownRight = new Vector3()\nconst vecFarDownLeft = new Vector3()\n\nconst vectemp1 = new Vector3()\nconst vectemp2 = new Vector3()\nconst vectemp3 = new Vector3()\n\nclass SelectionBox {\n  constructor(camera, scene, deep) {\n    this.camera = camera\n    this.scene = scene\n    this.startPoint = new Vector3()\n    this.endPoint = new Vector3()\n    this.collection = []\n    this.deep = deep || Number.MAX_VALUE\n  }\n\n  select(startPoint, endPoint) {\n    this.startPoint = startPoint || this.startPoint\n    this.endPoint = endPoint || this.endPoint\n    this.collection = []\n\n    this.updateFrustum(this.startPoint, this.endPoint)\n    this.searchChildInFrustum(frustum, this.scene)\n\n    return this.collection\n  }\n\n  updateFrustum(startPoint, endPoint) {\n    startPoint = startPoint || this.startPoint\n    endPoint = endPoint || this.endPoint\n\n    // Avoid invalid frustum\n\n    if (startPoint.x === endPoint.x) {\n      endPoint.x += Number.EPSILON\n    }\n\n    if (startPoint.y === endPoint.y) {\n      endPoint.y += Number.EPSILON\n    }\n\n    this.camera.updateProjectionMatrix()\n    this.camera.updateMatrixWorld()\n\n    if (this.camera.isPerspectiveCamera) {\n      tmpPoint.copy(startPoint)\n      tmpPoint.x = Math.min(startPoint.x, endPoint.x)\n      tmpPoint.y = Math.max(startPoint.y, endPoint.y)\n      endPoint.x = Math.max(startPoint.x, endPoint.x)\n      endPoint.y = Math.min(startPoint.y, endPoint.y)\n\n      vecNear.setFromMatrixPosition(this.camera.matrixWorld)\n      vecTopLeft.copy(tmpPoint)\n      vecTopRight.set(endPoint.x, tmpPoint.y, 0)\n      vecDownRight.copy(endPoint)\n      vecDownLeft.set(tmpPoint.x, endPoint.y, 0)\n\n      vecTopLeft.unproject(this.camera)\n      vecTopRight.unproject(this.camera)\n      vecDownRight.unproject(this.camera)\n      vecDownLeft.unproject(this.camera)\n\n      vectemp1.copy(vecTopLeft).sub(vecNear)\n      vectemp2.copy(vecTopRight).sub(vecNear)\n      vectemp3.copy(vecDownRight).sub(vecNear)\n      vectemp1.normalize()\n      vectemp2.normalize()\n      vectemp3.normalize()\n\n      vectemp1.multiplyScalar(this.deep)\n      vectemp2.multiplyScalar(this.deep)\n      vectemp3.multiplyScalar(this.deep)\n      vectemp1.add(vecNear)\n      vectemp2.add(vecNear)\n      vectemp3.add(vecNear)\n\n      var planes = frustum.planes\n\n      planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight)\n      planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight)\n      planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear)\n      planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear)\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft)\n      planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1)\n      planes[5].normal.multiplyScalar(-1)\n    } else if (this.camera.isOrthographicCamera) {\n      const left = Math.min(startPoint.x, endPoint.x)\n      const top = Math.max(startPoint.y, endPoint.y)\n      const right = Math.max(startPoint.x, endPoint.x)\n      const down = Math.min(startPoint.y, endPoint.y)\n\n      vecTopLeft.set(left, top, -1)\n      vecTopRight.set(right, top, -1)\n      vecDownRight.set(right, down, -1)\n      vecDownLeft.set(left, down, -1)\n\n      vecFarTopLeft.set(left, top, 1)\n      vecFarTopRight.set(right, top, 1)\n      vecFarDownRight.set(right, down, 1)\n      vecFarDownLeft.set(left, down, 1)\n\n      vecTopLeft.unproject(this.camera)\n      vecTopRight.unproject(this.camera)\n      vecDownRight.unproject(this.camera)\n      vecDownLeft.unproject(this.camera)\n\n      vecFarTopLeft.unproject(this.camera)\n      vecFarTopRight.unproject(this.camera)\n      vecFarDownRight.unproject(this.camera)\n      vecFarDownLeft.unproject(this.camera)\n\n      var planes = frustum.planes\n\n      planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight)\n      planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight)\n      planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft)\n      planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft)\n      planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft)\n      planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft)\n      planes[5].normal.multiplyScalar(-1)\n    } else {\n      console.error('THREE.SelectionBox: Unsupported camera type.')\n    }\n  }\n\n  searchChildInFrustum(frustum, object) {\n    if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material !== undefined) {\n        if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere()\n\n        center.copy(object.geometry.boundingSphere.center)\n\n        center.applyMatrix4(object.matrixWorld)\n\n        if (frustum.containsPoint(center)) {\n          this.collection.push(object)\n        }\n      }\n    }\n\n    if (object.children.length > 0) {\n      for (let x = 0; x < object.children.length; x++) {\n        this.searchChildInFrustum(frustum, object.children[x])\n      }\n    }\n  }\n}\n\nexport { SelectionBox }\n", "import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  EquirectangularReflectionMapping,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Line,\n  LineBasicMaterial,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  Vector4,\n  VectorKeyframeTrack,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { NURBSCurve } from '../curves/NURBSCurve'\nimport { decodeText } from '../_polyfill/LoaderUtils'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nlet fbxTree\nlet connections\nlet sceneGraph\n\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer)\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer)\n\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error('THREE.FBXLoader: Unknown format.')\n      }\n\n      if (getFbxVersion(FBXText) < 7000) {\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText))\n      }\n\n      fbxTree = new TextParser().parse(FBXText)\n    }\n\n    // console.log( fbxTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree)\n  }\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader\n    this.manager = manager\n  }\n\n  parse() {\n    connections = this.parseConnections()\n\n    const images = this.parseImages()\n    const textures = this.parseTextures(images)\n    const materials = this.parseMaterials(textures)\n    const deformers = this.parseDeformers()\n    const geometryMap = new GeometryParser().parse(deformers)\n\n    this.parseScene(deformers, geometryMap, materials)\n\n    return sceneGraph\n  }\n\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const connectionMap = new Map()\n\n    if ('Connections' in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections\n\n      rawConnections.forEach(function (rawConnection) {\n        const fromID = rawConnection[0]\n        const toID = rawConnection[1]\n        const relationship = rawConnection[2]\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const parentRelationship = { ID: toID, relationship: relationship }\n        connectionMap.get(fromID).parents.push(parentRelationship)\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const childRelationship = { ID: fromID, relationship: relationship }\n        connectionMap.get(toID).children.push(childRelationship)\n      })\n    }\n\n    return connectionMap\n  }\n\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const images = {}\n    const blobs = {}\n\n    if ('Video' in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video\n\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID]\n\n        const id = parseInt(nodeID)\n\n        images[id] = videoNode.RelativeFilename || videoNode.Filename\n\n        // raw image data is in videoNode.Content\n        if ('Content' in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0\n          const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== ''\n\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID])\n\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image\n          }\n        }\n      }\n    }\n\n    for (const id in images) {\n      const filename = images[id]\n\n      if (blobs[filename] !== undefined) images[id] = blobs[filename]\n      else images[id] = images[id].split('\\\\').pop()\n    }\n\n    return images\n  }\n\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(videoNode) {\n    const content = videoNode.Content\n    const fileName = videoNode.RelativeFilename || videoNode.Filename\n    const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase()\n\n    let type\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp'\n        break\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg'\n        break\n\n      case 'png':\n        type = 'image/png'\n        break\n\n      case 'tif':\n        type = 'image/tiff'\n        break\n\n      case 'tga':\n        if (this.manager.getHandler('.tga') === null) {\n          console.warn('FBXLoader: TGA loader not found, skipping ', fileName)\n        }\n\n        type = 'image/tga'\n        break\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.')\n        return\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n\n      return 'data:' + type + ';base64,' + content\n    } else {\n      // Binary Format\n\n      const array = new Uint8Array(content)\n      return window.URL.createObjectURL(new Blob([array], { type: type }))\n    }\n  }\n\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(images) {\n    const textureMap = new Map()\n\n    if ('Texture' in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images)\n        textureMap.set(parseInt(nodeID), texture)\n      }\n    }\n\n    return textureMap\n  }\n\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images)\n\n    texture.ID = textureNode.id\n\n    texture.name = textureNode.attrName\n\n    const wrapModeU = textureNode.WrapModeU\n    const wrapModeV = textureNode.WrapModeV\n\n    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0\n    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0\n\n    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping\n\n    if ('Scaling' in textureNode) {\n      const values = textureNode.Scaling.value\n\n      texture.repeat.x = values[0]\n      texture.repeat.y = values[1]\n    }\n\n    return texture\n  }\n\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(textureNode, images) {\n    let fileName\n\n    const currentPath = this.textureLoader.path\n\n    const children = connections.get(textureNode.id).children\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID]\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        this.textureLoader.setPath(undefined)\n      }\n    }\n\n    let texture\n\n    const extension = textureNode.FileName.slice(-3).toLowerCase()\n\n    if (extension === 'tga') {\n      const loader = this.manager.getHandler('.tga')\n\n      if (loader === null) {\n        console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename)\n        texture = new Texture()\n      } else {\n        loader.setPath(this.textureLoader.path)\n        texture = loader.load(fileName)\n      }\n    } else if (extension === 'psd') {\n      console.warn(\n        'FBXLoader: PSD textures are not supported, creating placeholder texture for',\n        textureNode.RelativeFilename,\n      )\n      texture = new Texture()\n    } else {\n      texture = this.textureLoader.load(fileName)\n    }\n\n    this.textureLoader.setPath(currentPath)\n\n    return texture\n  }\n\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(textureMap) {\n    const materialMap = new Map()\n\n    if ('Material' in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material\n\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap)\n\n        if (material !== null) materialMap.set(parseInt(nodeID), material)\n      }\n    }\n\n    return materialMap\n  }\n\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id\n    const name = materialNode.attrName\n    let type = materialNode.ShadingModel\n\n    // Case where FBX wraps shading model in property object.\n    if (typeof type === 'object') {\n      type = type.value\n    }\n\n    // Ignore unused materials which don't have any connections.\n    if (!connections.has(ID)) return null\n\n    const parameters = this.parseParameters(materialNode, textureMap, ID)\n\n    let material\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new MeshPhongMaterial()\n        break\n      case 'lambert':\n        material = new MeshLambertMaterial()\n        break\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type)\n        material = new MeshPhongMaterial()\n        break\n    }\n\n    material.setValues(parameters)\n    material.name = name\n\n    return material\n  }\n\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {}\n\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value\n    }\n\n    if (materialNode.Diffuse) {\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value)\n    } else if (\n      materialNode.DiffuseColor &&\n      (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value)\n    }\n\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value\n    }\n\n    if (materialNode.Emissive) {\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value)\n    } else if (\n      materialNode.EmissiveColor &&\n      (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports emissive color here instead of in materialNode.Emissive\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value)\n    }\n\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value)\n    }\n\n    if (materialNode.Opacity) {\n      parameters.opacity = parseFloat(materialNode.Opacity.value)\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true\n    }\n\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value\n    }\n\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value\n    }\n\n    if (materialNode.Specular) {\n      parameters.specular = new Color().fromArray(materialNode.Specular.value)\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in materialNode.Specular\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value)\n    }\n\n    const scope = this\n    connections.get(ID).children.forEach(function (child) {\n      const type = child.relationship\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'Maya|TEX_ao_map':\n          parameters.aoMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'DiffuseColor':\n        case 'Maya|TEX_color_map':\n          parameters.map = scope.getTexture(textureMap, child.ID)\n          if (parameters.map !== undefined) {\n            if ('colorSpace' in parameters.map) parameters.map.colorSpace = 'srgb'\n            else parameters.map.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'DisplacementColor':\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.emissiveMap !== undefined) {\n            if ('colorSpace' in parameters.emissiveMap) parameters.emissiveMap.colorSpace = 'srgb'\n            else parameters.emissiveMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'NormalMap':\n        case 'Maya|TEX_normal_map':\n          parameters.normalMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'ReflectionColor':\n          parameters.envMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.envMap !== undefined) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping\n\n            if ('colorSpace' in parameters.envMap) parameters.envMap.colorSpace = 'srgb'\n            else parameters.envMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'SpecularColor':\n          parameters.specularMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.specularMap !== undefined) {\n            if ('colorSpace' in parameters.specularMap) parameters.specularMap.colorSpace = 'srgb'\n            else parameters.specularMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'TransparentColor':\n        case 'TransparencyFactor':\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID)\n          parameters.transparent = true\n          break\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n        case 'SpecularFactor': // AKA specularLevel\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type)\n          break\n      }\n    })\n\n    return parameters\n  }\n\n  // get a texture from the textureMap for use by a material.\n  getTexture(textureMap, id) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.')\n      id = connections.get(id).children[0].ID\n    }\n\n    return textureMap.get(id)\n  }\n\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const skeletons = {}\n    const morphTargets = {}\n\n    if ('Deformer' in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer\n\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID]\n\n        const relationships = connections.get(parseInt(nodeID))\n\n        if (deformerNode.attrType === 'Skin') {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes)\n          skeleton.ID = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.')\n          }\n          skeleton.geometryID = relationships.parents[0].ID\n\n          skeletons[nodeID] = skeleton\n        } else if (deformerNode.attrType === 'BlendShape') {\n          const morphTarget = {\n            id: nodeID,\n          }\n\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes)\n          morphTarget.id = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.')\n          }\n\n          morphTargets[nodeID] = morphTarget\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets,\n    }\n  }\n\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = []\n\n    relationships.children.forEach(function (child) {\n      const boneNode = deformerNodes[child.ID]\n\n      if (boneNode.attrType !== 'Cluster') return\n\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a),\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      }\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a\n        rawBone.weights = boneNode.Weights.a\n      }\n\n      rawBones.push(rawBone)\n    })\n\n    return {\n      rawBones: rawBones,\n      bones: [],\n    }\n  }\n\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = []\n\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i]\n\n      const morphTargetNode = deformerNodes[child.ID]\n\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a,\n      }\n\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return\n\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n        return child.relationship === undefined\n      })[0].ID\n\n      rawMorphTargets.push(rawMorphTarget)\n    }\n\n    return rawMorphTargets\n  }\n\n  // create the main Group() to be returned by the loader\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group()\n\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap)\n\n    const modelNodes = fbxTree.Objects.Model\n\n    const scope = this\n    modelMap.forEach(function (model) {\n      const modelNode = modelNodes[model.ID]\n      scope.setLookAtProperties(model, modelNode)\n\n      const parentConnections = connections.get(model.ID).parents\n\n      parentConnections.forEach(function (connection) {\n        const parent = modelMap.get(connection.ID)\n        if (parent !== undefined) parent.add(model)\n      })\n\n      if (model.parent === null) {\n        sceneGraph.add(model)\n      }\n    })\n\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap)\n\n    this.createAmbientLight()\n\n    sceneGraph.traverse(function (node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld\n        }\n\n        const transform = generateTransform(node.userData.transformData)\n\n        node.applyMatrix4(transform)\n        node.updateWorldMatrix()\n      }\n    })\n\n    const animations = new AnimationParser().parse()\n\n    // if all the models where already combined in a single group, just return that\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations\n      sceneGraph = sceneGraph.children[0]\n    }\n\n    sceneGraph.animations = animations\n  }\n\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = new Map()\n    const modelNodes = fbxTree.Objects.Model\n\n    for (const nodeID in modelNodes) {\n      const id = parseInt(nodeID)\n      const node = modelNodes[nodeID]\n      const relationships = connections.get(id)\n\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName)\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = this.createCamera(relationships)\n            break\n          case 'Light':\n            model = this.createLight(relationships)\n            break\n          case 'Mesh':\n            model = this.createMesh(relationships, geometryMap, materialMap)\n            break\n          case 'NurbsCurve':\n            model = this.createCurve(relationships, geometryMap)\n            break\n          case 'LimbNode':\n          case 'Root':\n            model = new Bone()\n            break\n          case 'Null':\n          default:\n            model = new Group()\n            break\n        }\n\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : ''\n\n        model.ID = id\n      }\n\n      this.getTransformData(model, node)\n      modelMap.set(id, model)\n    }\n\n    return modelMap\n  }\n\n  buildSkeleton(relationships, skeletons, id, name) {\n    let bone = null\n\n    relationships.parents.forEach(function (parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID]\n\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone\n            bone = new Bone()\n\n            bone.matrixWorld.copy(rawBone.transformLink)\n\n            // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : ''\n            bone.ID = id\n\n            skeleton.bones[i] = bone\n\n            // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n            if (subBone !== null) {\n              bone.add(subBone)\n            }\n          }\n        })\n      }\n    })\n\n    return bone\n  }\n\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(relationships) {\n    let model\n    let cameraAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        cameraAttribute = attr\n      }\n    })\n\n    if (cameraAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type = 0\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1\n      }\n\n      let nearClippingPlane = 1\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000\n      }\n\n      let farClippingPlane = 1000\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000\n      }\n\n      let width = window.innerWidth\n      let height = window.innerHeight\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value\n        height = cameraAttribute.AspectHeight.value\n      }\n\n      const aspect = width / height\n\n      let fov = 45\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value\n      }\n\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null\n\n      switch (type) {\n        case 0: // Perspective\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane)\n          if (focalLength !== null) model.setFocalLength(focalLength)\n          break\n\n        case 1: // Orthographic\n          model = new OrthographicCamera(\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            nearClippingPlane,\n            farClippingPlane,\n          )\n          break\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.')\n          model = new Object3D()\n          break\n      }\n    }\n\n    return model\n  }\n\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(relationships) {\n    let model\n    let lightAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        lightAttribute = attr\n      }\n    })\n\n    if (lightAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type\n\n      // LightType can be undefined for Point lights\n      if (lightAttribute.LightType === undefined) {\n        type = 0\n      } else {\n        type = lightAttribute.LightType.value\n      }\n\n      let color = 0xffffff\n\n      if (lightAttribute.Color !== undefined) {\n        color = new Color().fromArray(lightAttribute.Color.value)\n      }\n\n      let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100\n\n      // light disabled\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0\n      }\n\n      let distance = 0\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value\n        }\n      }\n\n      // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n      const decay = 1\n\n      switch (type) {\n        case 0: // Point\n          model = new PointLight(color, intensity, distance, decay)\n          break\n\n        case 1: // Directional\n          model = new DirectionalLight(color, intensity)\n          break\n\n        case 2: // Spot\n          let angle = Math.PI / 3\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value)\n          }\n\n          let penumbra = 0\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value)\n            penumbra = Math.max(penumbra, 1)\n          }\n\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay)\n          break\n\n        default:\n          console.warn(\n            'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.',\n          )\n          model = new PointLight(color, intensity)\n          break\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true\n      }\n    }\n\n    return model\n  }\n\n  createMesh(relationships, geometryMap, materialMap) {\n    let model\n    let geometry = null\n    let material = null\n    const materials = []\n\n    // get geometry and materials(s) from connections\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID)\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID))\n      }\n    })\n\n    if (materials.length > 1) {\n      material = materials\n    } else if (materials.length > 0) {\n      material = materials[0]\n    } else {\n      material = new MeshPhongMaterial({ color: 0xcccccc })\n      materials.push(material)\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = true\n      })\n    }\n\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material)\n      model.normalizeSkinWeights()\n    } else {\n      model = new Mesh(geometry, material)\n    }\n\n    return model\n  }\n\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID)\n\n      return geo\n    }, null)\n\n    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n    const material = new LineBasicMaterial({ color: 0x3300ff, linewidth: 1 })\n    return new Line(geometry, material)\n  }\n\n  // parse the model node for transform data\n  getTransformData(model, modelNode) {\n    const transformData = {}\n\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    else transformData.eulerOrder = 'ZYX'\n\n    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value\n\n    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value\n    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value\n    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value\n\n    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value\n\n    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value\n    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value\n\n    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value\n    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value\n\n    model.userData.transformData = transformData\n  }\n\n  setLookAtProperties(model, modelNode) {\n    if ('LookAtProperty' in modelNode) {\n      const children = connections.get(model.ID).children\n\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID]\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value\n\n            // DirectionalLight, SpotLight\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos)\n              sceneGraph.add(model.target)\n            } else {\n              // Cameras and other Object3Ds\n\n              model.lookAt(new Vector3().fromArray(pos))\n            }\n          }\n        }\n      })\n    }\n  }\n\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes()\n\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID]\n\n      const parents = connections.get(parseInt(skeleton.ID)).parents\n\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID\n          const geoRelationships = connections.get(geoID)\n\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID)\n\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID])\n            }\n          })\n        }\n      })\n    }\n  }\n\n  parsePoseNodes() {\n    const bindMatrices = {}\n\n    if ('Pose' in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose\n\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a)\n            })\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a)\n          }\n        }\n      }\n    }\n\n    return bindMatrices\n  }\n\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  createAmbientLight() {\n    if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value\n      const r = ambientColor[0]\n      const g = ambientColor[1]\n      const b = ambientColor[2]\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        const color = new Color(r, g, b)\n        sceneGraph.add(new AmbientLight(color, 1))\n      }\n    }\n  }\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = new Map()\n\n    if ('Geometry' in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry\n\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID))\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers)\n\n        geometryMap.set(parseInt(nodeID), geo)\n      }\n    }\n\n    return geometryMap\n  }\n\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return this.parseMeshGeometry(relationships, geoNode, deformers)\n        break\n\n      case 'NurbsCurve':\n        return this.parseNurbsGeometry(geoNode)\n        break\n    }\n  }\n\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons\n    const morphTargets = []\n\n    const modelNodes = relationships.parents.map(function (parent) {\n      return fbxTree.Objects.Model[parent.ID]\n    })\n\n    // don't create geometry if it is not associated with any models\n    if (modelNodes.length === 0) return\n\n    const skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID]\n\n      return skeleton\n    }, null)\n\n    relationships.children.forEach(function (child) {\n      if (deformers.morphTargets[child.ID] !== undefined) {\n        morphTargets.push(deformers.morphTargets[child.ID])\n      }\n    })\n\n    // Assume one model and get the preRotation from that\n    // if there is more than one model associated with the geometry this may cause problems\n    const modelNode = modelNodes[0]\n\n    const transformData = {}\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value\n    if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value\n    if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value\n\n    const transform = generateTransform(transformData)\n\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform)\n  }\n\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry()\n    if (geoNode.attrName) geo.name = geoNode.attrName\n\n    const geoInfo = this.parseGeoNode(geoNode, skeleton)\n    const buffers = this.genBuffers(geoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3)\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    geo.setAttribute('position', positionAttribute)\n\n    if (buffers.colors.length > 0) {\n      geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3))\n    }\n\n    if (skeleton) {\n      geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4))\n\n      geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4))\n\n      // used later to bind the skeleton to the model\n      geo.FBX_Deformer = skeleton\n    }\n\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform)\n\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3)\n      normalAttribute.applyNormalMatrix(normalMatrix)\n\n      geo.setAttribute('normal', normalAttribute)\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      if (UV1 === 'uv2') i++;\n      const name = i === 0 ? 'uv' : `uv${i}`;\n\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2))\n    })\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      let prevMaterialIndex = buffers.materialIndex[0]\n      let startIndex = 0\n\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex)\n\n          prevMaterialIndex = currentIndex\n          startIndex = i\n        }\n      })\n\n      // the loop above doesn't add the last group, do that here.\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1]\n        const lastIndex = lastGroup.start + lastGroup.count\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex)\n        }\n      }\n\n      // case where there are multiple materials but the whole geometry is only\n      // using one of them\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0])\n      }\n    }\n\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform)\n\n    return geo\n  }\n\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {}\n\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : []\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : []\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0])\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0])\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0])\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = []\n\n      let i = 0\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]))\n        }\n\n        i++\n      }\n    }\n\n    geoInfo.weightTable = {}\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton\n\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = []\n\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j],\n          })\n        })\n      })\n    }\n\n    return geoInfo\n  }\n\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: [],\n    }\n\n    let polygonIndex = 0\n    let faceLength = 0\n    let displayedWeightsWarning = false\n\n    // these will hold data for a single face\n    let facePositionIndexes = []\n    let faceNormals = []\n    let faceColors = []\n    let faceUVs = []\n    let faceWeights = []\n    let faceWeightIndices = []\n\n    const scope = this\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      let materialIndex\n      let endOfFace = false\n\n      // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1 // equivalent to ( x * -1 ) - 1\n        endOfFace = true\n      }\n\n      let weightIndices = []\n      let weights = []\n\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2)\n\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color)\n\n        faceColors.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight)\n            weightIndices.push(wt.id)\n          })\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn(\n              'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.',\n            )\n            displayedWeightsWarning = true\n          }\n\n          const wIndex = [0, 0, 0, 0]\n          const Weight = [0, 0, 0, 0]\n\n          weights.forEach(function (weight, weightIndex) {\n            let currentWeight = weight\n            let currentIndex = weightIndices[weightIndex]\n\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight\n                currentWeight = comparedWeight\n\n                const tmp = wIndex[comparedWeightIndex]\n                wIndex[comparedWeightIndex] = currentIndex\n                currentIndex = tmp\n              }\n            })\n          })\n\n          weightIndices = wIndex\n          weights = Weight\n        }\n\n        // if the weight array is shorter than 4 pad with 0s\n        while (weights.length < 4) {\n          weights.push(0)\n          weightIndices.push(0)\n        }\n\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i])\n          faceWeightIndices.push(weightIndices[i])\n        }\n      }\n\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal)\n\n        faceNormals.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0]\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv)\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = []\n          }\n\n          faceUVs[i].push(data[0])\n          faceUVs[i].push(data[1])\n        })\n      }\n\n      faceLength++\n\n      if (endOfFace) {\n        scope.genFace(\n          buffers,\n          geoInfo,\n          facePositionIndexes,\n          materialIndex,\n          faceNormals,\n          faceColors,\n          faceUVs,\n          faceWeights,\n          faceWeightIndices,\n          faceLength,\n        )\n\n        polygonIndex++\n        faceLength = 0\n\n        // reset arrays for the next face\n        facePositionIndexes = []\n        faceNormals = []\n        faceColors = []\n        faceUVs = []\n        faceWeights = []\n        faceWeightIndices = []\n      }\n    })\n\n    return buffers\n  }\n\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(\n    buffers,\n    geoInfo,\n    facePositionIndexes,\n    materialIndex,\n    faceNormals,\n    faceColors,\n    faceUVs,\n    faceWeights,\n    faceWeightIndices,\n    faceLength,\n  ) {\n    for (let i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]])\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0])\n        buffers.vertexWeights.push(faceWeights[1])\n        buffers.vertexWeights.push(faceWeights[2])\n        buffers.vertexWeights.push(faceWeights[3])\n\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3])\n\n        buffers.vertexWeights.push(faceWeights[i * 4])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[0])\n        buffers.weightsIndices.push(faceWeightIndices[1])\n        buffers.weightsIndices.push(faceWeightIndices[2])\n        buffers.weightsIndices.push(faceWeightIndices[3])\n\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[i * 4])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3])\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0])\n        buffers.colors.push(faceColors[1])\n        buffers.colors.push(faceColors[2])\n\n        buffers.colors.push(faceColors[(i - 1) * 3])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2])\n\n        buffers.colors.push(faceColors[i * 3])\n        buffers.colors.push(faceColors[i * 3 + 1])\n        buffers.colors.push(faceColors[i * 3 + 2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0])\n        buffers.normal.push(faceNormals[1])\n        buffers.normal.push(faceNormals[2])\n\n        buffers.normal.push(faceNormals[(i - 1) * 3])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2])\n\n        buffers.normal.push(faceNormals[i * 3])\n        buffers.normal.push(faceNormals[i * 3 + 1])\n        buffers.normal.push(faceNormals[i * 3 + 2])\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = []\n\n          buffers.uvs[j].push(faceUVs[j][0])\n          buffers.uvs[j].push(faceUVs[j][1])\n\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2])\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1])\n\n          buffers.uvs[j].push(faceUVs[j][i * 2])\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1])\n        })\n      }\n    }\n  }\n\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0) return\n\n    parentGeo.morphTargetsRelative = true\n\n    parentGeo.morphAttributes.position = []\n    // parentGeo.morphAttributes.normal = []; // not implemented\n\n    const scope = this\n    morphTargets.forEach(function (morphTarget) {\n      morphTarget.rawTargets.forEach(function (rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID]\n\n        if (morphGeoNode !== undefined) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name)\n        }\n      })\n    })\n  }\n\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []\n\n    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : []\n    const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : []\n\n    const length = parentGeo.attributes.position.count * 3\n    const morphPositions = new Float32Array(length)\n\n    for (let i = 0; i < indices.length; i++) {\n      const morphIndex = indices[i] * 3\n\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3]\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1]\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2]\n    }\n\n    // TODO: add morph normal support\n    const morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: morphPositions,\n    }\n\n    const morphBuffers = this.genBuffers(morphGeoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3)\n    positionAttribute.name = name || morphGeoNode.attrName\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    parentGeo.morphAttributes.position.push(positionAttribute)\n  }\n\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType\n    const referenceType = NormalNode.ReferenceInformationType\n    const buffer = NormalNode.Normals.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType\n    const referenceType = UVNode.ReferenceInformationType\n    const buffer = UVNode.UV.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType\n    const referenceType = ColorNode.ReferenceInformationType\n    const buffer = ColorNode.Colors.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType\n    const referenceType = MaterialNode.ReferenceInformationType\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType,\n      }\n    }\n\n    const materialIndexBuffer = MaterialNode.Materials.a\n\n    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n    const materialIndices = []\n\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i)\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(geoNode) {\n    if (NURBSCurve === undefined) {\n      console.error(\n        'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.',\n      )\n      return new BufferGeometry()\n    }\n\n    const order = parseInt(geoNode.Order)\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id)\n      return new BufferGeometry()\n    }\n\n    const degree = order - 1\n\n    const knots = geoNode.KnotVector.a\n    const controlPoints = []\n    const pointsValues = geoNode.Points.a\n\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i))\n    }\n\n    let startKnot, endKnot\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0])\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree\n      endKnot = knots.length - 1 - startKnot\n\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i])\n      }\n    }\n\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot)\n    const points = curve.getPoints(controlPoints.length * 12)\n\n    return new BufferGeometry().setFromPoints(points)\n  }\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = []\n\n    const rawClips = this.parseClips()\n\n    if (rawClips !== undefined) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key]\n\n        const clip = this.addClip(rawClip)\n\n        animationClips.push(clip)\n      }\n    }\n\n    return animationClips\n  }\n\n  parseClips() {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (fbxTree.Objects.AnimationCurve === undefined) return undefined\n\n    const curveNodesMap = this.parseAnimationCurveNodes()\n\n    this.parseAnimationCurves(curveNodesMap)\n\n    const layersMap = this.parseAnimationLayers(curveNodesMap)\n    const rawClips = this.parseAnimStacks(layersMap)\n\n    return rawClips\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode\n\n    const curveNodesMap = new Map()\n\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID]\n\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {},\n        }\n\n        curveNodesMap.set(curveNode.id, curveNode)\n      }\n    }\n\n    return curveNodesMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve\n\n    // TODO: Many values are identical up to roundoff error, but won't be optimised\n    // e.g. position times: [0, 0.4, 0. 8]\n    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n    // clearly, this should be optimised to\n    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n    // this shows up in nearly every FBX file, and generally time array is length > 100\n\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a,\n      }\n\n      const relationships = connections.get(animationCurve.id)\n\n      if (relationships !== undefined) {\n        const animationCurveID = relationships.parents[0].ID\n        const animationCurveRelationship = relationships.parents[0].relationship\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve\n        }\n      }\n    }\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer\n\n    const layersMap = new Map()\n\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = []\n\n      const connection = connections.get(parseInt(nodeID))\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        const children = connection.children\n\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID)\n\n            // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n            if (\n              curveNode.curves.x !== undefined ||\n              curveNode.curves.y !== undefined ||\n              curveNode.curves.z !== undefined\n            ) {\n              if (layerCurveNodes[i] === undefined) {\n                const modelID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                if (modelID !== undefined) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()]\n\n                  if (rawModel === undefined) {\n                    console.warn('THREE.FBXLoader: Encountered a unused curve.', child)\n                    return\n                  }\n\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1],\n                  }\n\n                  sceneGraph.traverse(function (child) {\n                    if (child.ID === rawModel.id) {\n                      node.transform = child.matrix\n\n                      if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder\n                    }\n                  })\n\n                  if (!node.transform) node.transform = new Matrix4()\n\n                  // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                  // animation value as well\n                  if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value\n                  if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value\n\n                  layerCurveNodes[i] = node\n                }\n              }\n\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode\n            } else if (curveNode.curves.morph !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                const deformerID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                const morpherID = connections.get(deformerID).parents[0].ID\n                const geoID = connections.get(morpherID).parents[0].ID\n\n                // assuming geometry is not used in more than one model\n                const modelID = connections.get(geoID).parents[0].ID\n\n                const rawModel = fbxTree.Objects.Model[modelID]\n\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName,\n                }\n\n                layerCurveNodes[i] = node\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode\n            }\n          }\n        })\n\n        layersMap.set(parseInt(nodeID), layerCurveNodes)\n      }\n    }\n\n    return layersMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack\n\n    // connect the stacks (clips) up to the layers\n    const rawClips = {}\n\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn(\n          'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.',\n        )\n      }\n\n      const layer = layersMap.get(children[0].ID)\n\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer,\n      }\n    }\n\n    return rawClips\n  }\n\n  addClip(rawClip) {\n    let tracks = []\n\n    const scope = this\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks))\n    })\n\n    return new AnimationClip(rawClip.name, -1, tracks)\n  }\n\n  generateTracks(rawTracks) {\n    const tracks = []\n\n    let initialPosition = new Vector3()\n    let initialRotation = new Quaternion()\n    let initialScale = new Vector3()\n\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale)\n\n    initialPosition = initialPosition.toArray()\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray()\n    initialScale = initialScale.toArray()\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(\n        rawTracks.modelName,\n        rawTracks.T.curves,\n        initialPosition,\n        'position',\n      )\n      if (positionTrack !== undefined) tracks.push(positionTrack)\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(\n        rawTracks.modelName,\n        rawTracks.R.curves,\n        initialRotation,\n        rawTracks.preRotation,\n        rawTracks.postRotation,\n        rawTracks.eulerOrder,\n      )\n      if (rotationTrack !== undefined) tracks.push(rotationTrack)\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale')\n      if (scaleTrack !== undefined) tracks.push(scaleTrack)\n    }\n\n    if (rawTracks.DeformPercent !== undefined) {\n      const morphTrack = this.generateMorphTrack(rawTracks)\n      if (morphTrack !== undefined) tracks.push(morphTrack)\n    }\n\n    return tracks\n  }\n\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    return new VectorKeyframeTrack(modelName + '.' + type, times, values)\n  }\n\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n    if (curves.x !== undefined) {\n      this.interpolateRotations(curves.x)\n      curves.x.values = curves.x.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.y !== undefined) {\n      this.interpolateRotations(curves.y)\n      curves.y.values = curves.y.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.z !== undefined) {\n      this.interpolateRotations(curves.z)\n      curves.z.values = curves.z.values.map(MathUtils.degToRad)\n    }\n\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    if (preRotation !== undefined) {\n      preRotation = preRotation.map(MathUtils.degToRad)\n      preRotation.push(eulerOrder)\n\n      preRotation = new Euler().fromArray(preRotation)\n      preRotation = new Quaternion().setFromEuler(preRotation)\n    }\n\n    if (postRotation !== undefined) {\n      postRotation = postRotation.map(MathUtils.degToRad)\n      postRotation.push(eulerOrder)\n\n      postRotation = new Euler().fromArray(postRotation)\n      postRotation = new Quaternion().setFromEuler(postRotation).invert()\n    }\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n\n    const quaternionValues = []\n\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder)\n\n      quaternion.setFromEuler(euler)\n\n      if (preRotation !== undefined) quaternion.premultiply(preRotation)\n      if (postRotation !== undefined) quaternion.multiply(postRotation)\n\n      quaternion.toArray(quaternionValues, (i / 3) * 4)\n    }\n\n    return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues)\n  }\n\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph\n    const values = curves.values.map(function (val) {\n      return val / 100\n    })\n\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName]\n\n    return new NumberKeyframeTrack(\n      rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']',\n      curves.times,\n      values,\n    )\n  }\n\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(curves) {\n    let times = []\n\n    // first join together the times for each axis, if defined\n    if (curves.x !== undefined) times = times.concat(curves.x.times)\n    if (curves.y !== undefined) times = times.concat(curves.y.times)\n    if (curves.z !== undefined) times = times.concat(curves.z.times)\n\n    // then sort them\n    times = times.sort(function (a, b) {\n      return a - b\n    })\n\n    // and remove duplicates\n    if (times.length > 1) {\n      let targetIndex = 1\n      let lastValue = times[0]\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i]\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue\n          lastValue = currentValue\n          targetIndex++\n        }\n      }\n\n      times = times.slice(0, targetIndex)\n    }\n\n    return times\n  }\n\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue\n\n    const values = []\n\n    let xIndex = -1\n    let yIndex = -1\n    let zIndex = -1\n\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time)\n      if (curves.y) yIndex = curves.y.times.indexOf(time)\n      if (curves.z) zIndex = curves.z.times.indexOf(time)\n\n      // if there is an x value defined for this frame, use that\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex]\n        values.push(xValue)\n        prevValue[0] = xValue\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0])\n      }\n\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex]\n        values.push(yValue)\n        prevValue[1] = yValue\n      } else {\n        values.push(prevValue[1])\n      }\n\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex]\n        values.push(zValue)\n        prevValue[2] = zValue\n      } else {\n        values.push(prevValue[2])\n      }\n    })\n\n    return values\n  }\n\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(curve) {\n    for (let i = 1; i < curve.values.length; i++) {\n      const initialValue = curve.values[i - 1]\n      const valuesSpan = curve.values[i] - initialValue\n\n      const absoluteSpan = Math.abs(valuesSpan)\n\n      if (absoluteSpan >= 180) {\n        const numSubIntervals = absoluteSpan / 180\n\n        const step = valuesSpan / numSubIntervals\n        let nextValue = initialValue + step\n\n        const initialTime = curve.times[i - 1]\n        const timeSpan = curve.times[i] - initialTime\n        const interval = timeSpan / numSubIntervals\n        let nextTime = initialTime + interval\n\n        const interpolatedTimes = []\n        const interpolatedValues = []\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime)\n          nextTime += interval\n\n          interpolatedValues.push(nextValue)\n          nextValue += step\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes)\n        curve.values = inject(curve.values, i, interpolatedValues)\n      }\n    }\n  }\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2]\n  }\n\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1]\n  }\n\n  getCurrentProp() {\n    return this.currentProp\n  }\n\n  pushStack(node) {\n    this.nodeStack.push(node)\n    this.currentIndent += 1\n  }\n\n  popStack() {\n    this.nodeStack.pop()\n    this.currentIndent -= 1\n  }\n\n  setCurrentProp(val, name) {\n    this.currentProp = val\n    this.currentPropName = name\n  }\n\n  parse(text) {\n    this.currentIndent = 0\n\n    this.allNodes = new FBXTree()\n    this.nodeStack = []\n    this.currentProp = []\n    this.currentPropName = ''\n\n    const scope = this\n\n    const split = text.split(/[\\r\\n]+/)\n\n    split.forEach(function (line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/)\n      const matchEmpty = line.match(/^[\\s\\t]*$/)\n\n      if (matchComment || matchEmpty) return\n\n      const matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '')\n      const matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)')\n      const matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}')\n\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning)\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i])\n      } else if (matchEnd) {\n        scope.popStack()\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        // large arrays are split over multiple lines terminated with a ',' character\n        // if this is encountered the line needs to be joined to the previous line\n        scope.parseNodePropertyContinued(line)\n      }\n    })\n\n    return this.allNodes\n  }\n\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '')\n\n    const nodeAttrs = property[2].split(',').map(function (attr) {\n      return attr.trim().replace(/^\"/, '').replace(/\"$/, '')\n    })\n\n    const node = { name: nodeName }\n    const attrs = this.parseNodeAttr(nodeAttrs)\n\n    const currentNode = this.getCurrentNode()\n\n    // a top node\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node)\n    } else {\n      // a subnode\n\n      // if the subnode already exists, append it\n      if (nodeName in currentNode) {\n        // special case Pose needs PoseNodes as an array\n        if (nodeName === 'PoseNode') {\n          currentNode.PoseNode.push(node)\n        } else if (currentNode[nodeName].id !== undefined) {\n          currentNode[nodeName] = {}\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName]\n        }\n\n        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node\n      } else if (typeof attrs.id === 'number') {\n        currentNode[nodeName] = {}\n        currentNode[nodeName][attrs.id] = node\n      } else if (nodeName !== 'Properties70') {\n        if (nodeName === 'PoseNode') currentNode[nodeName] = [node]\n        else currentNode[nodeName] = node\n      }\n    }\n\n    if (typeof attrs.id === 'number') node.id = attrs.id\n    if (attrs.name !== '') node.attrName = attrs.name\n    if (attrs.type !== '') node.attrType = attrs.type\n\n    this.pushStack(node)\n  }\n\n  parseNodeAttr(attrs) {\n    let id = attrs[0]\n\n    if (attrs[0] !== '') {\n      id = parseInt(attrs[0])\n\n      if (isNaN(id)) {\n        id = attrs[0]\n      }\n    }\n\n    let name = '',\n      type = ''\n\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, '')\n      type = attrs[2]\n    }\n\n    return { id: id, name: name, type: type }\n  }\n\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim()\n    let propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim()\n\n    // for special case: base64 image data follows \"Content: ,\" line\n    //\tContent: ,\n    //\t \"/9j/4RDaRXhpZgAATU0A...\"\n    if (propName === 'Content' && propValue === ',') {\n      propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim()\n    }\n\n    const currentNode = this.getCurrentNode()\n    const parentName = currentNode.name\n\n    if (parentName === 'Properties70') {\n      this.parseNodeSpecialProperty(line, propName, propValue)\n      return\n    }\n\n    // Connections\n    if (propName === 'C') {\n      const connProps = propValue.split(',').slice(1)\n      const from = parseInt(connProps[0])\n      const to = parseInt(connProps[1])\n\n      let rest = propValue.split(',').slice(3)\n\n      rest = rest.map(function (elem) {\n        return elem.trim().replace(/^\"/, '')\n      })\n\n      propName = 'connections'\n      propValue = [from, to]\n      append(propValue, rest)\n\n      if (currentNode[propName] === undefined) {\n        currentNode[propName] = []\n      }\n    }\n\n    // Node\n    if (propName === 'Node') currentNode.id = propValue\n\n    // connections\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue)\n    } else {\n      if (propName !== 'a') currentNode[propName] = propValue\n      else currentNode.a = propValue\n    }\n\n    this.setCurrentProp(currentNode, propName)\n\n    // convert string to array, unless it ends in ',' in which case more will be added to it\n    if (propName === 'a' && propValue.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(propValue)\n    }\n  }\n\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode()\n\n    currentNode.a += line\n\n    // if the line doesn't end in ',' we have reached the end of the property value\n    // so convert the string to an array\n    if (line.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(currentNode.a)\n    }\n  }\n\n  // parse \"Property70\"\n  parseNodeSpecialProperty(line, propName, propValue) {\n    // split this\n    // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n    // into array like below\n    // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n    const props = propValue.split('\",').map(function (prop) {\n      return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_')\n    })\n\n    const innerPropName = props[0]\n    const innerPropType1 = props[1]\n    const innerPropType2 = props[2]\n    const innerPropFlag = props[3]\n    let innerPropValue = props[4]\n\n    // cast values where needed, otherwise leave as strings\n    switch (innerPropType1) {\n      case 'int':\n      case 'enum':\n      case 'bool':\n      case 'ULongLong':\n      case 'double':\n      case 'Number':\n      case 'FieldOfView':\n        innerPropValue = parseFloat(innerPropValue)\n        break\n\n      case 'Color':\n      case 'ColorRGB':\n      case 'Vector3D':\n      case 'Lcl_Translation':\n      case 'Lcl_Rotation':\n      case 'Lcl_Scaling':\n        innerPropValue = parseNumberArray(innerPropValue)\n        break\n    }\n\n    // CAUTION: these props must append to parent's parent\n    this.getPrevNode()[innerPropName] = {\n      type: innerPropType1,\n      type2: innerPropType2,\n      flag: innerPropFlag,\n      value: innerPropValue,\n    }\n\n    this.setCurrentProp(this.getPrevNode(), innerPropName)\n  }\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer)\n    reader.skip(23) // skip magic 23 bytes\n\n    const version = reader.getUint32()\n\n    if (version < 6400) {\n      throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version)\n    }\n\n    const allNodes = new FBXTree()\n\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version)\n      if (node !== null) allNodes.add(node.name, node)\n    }\n\n    return allNodes\n  }\n\n  // Check if reader has reached the end of content.\n  endOfContent(reader) {\n    // footer size: 160bytes + 16-byte alignment padding\n    // - 16bytes: magic\n    // - padding til 16-byte alignment (at least 1byte?)\n    //\t(seems like some exporters embed fixed 15 or 16bytes?)\n    // - 4bytes: magic\n    // - 4bytes: version\n    // - 120bytes: zero\n    // - 16bytes: magic\n    if (reader.size() % 16 === 0) {\n      return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size()\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size()\n    }\n  }\n\n  // recursively parse nodes until the end of the file is reached\n  parseNode(reader, version) {\n    const node = {}\n\n    // The first three data sizes depends on version.\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32()\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32()\n\n    version >= 7500 ? reader.getUint64() : reader.getUint32() // the returned propertyListLen is not used\n\n    const nameLen = reader.getUint8()\n    const name = reader.getString(nameLen)\n\n    // Regards this node as NULL-record if endOffset is zero\n    if (endOffset === 0) return null\n\n    const propertyList = []\n\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader))\n    }\n\n    // Regards the first three elements in propertyList as id, attrName, and attrType\n    const id = propertyList.length > 0 ? propertyList[0] : ''\n    const attrName = propertyList.length > 1 ? propertyList[1] : ''\n    const attrType = propertyList.length > 2 ? propertyList[2] : ''\n\n    // check if this node represents just a single property\n    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false\n\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version)\n\n      if (subNode !== null) this.parseSubNode(name, node, subNode)\n    }\n\n    node.propertyList = propertyList // raw property list used by parent\n\n    if (typeof id === 'number') node.id = id\n    if (attrName !== '') node.attrName = attrName\n    if (attrType !== '') node.attrType = attrType\n    if (name !== '') node.name = name\n\n    return node\n  }\n\n  parseSubNode(name, node, subNode) {\n    // special case: child node is single property\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0]\n\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode\n\n        subNode.a = value\n      } else {\n        node[subNode.name] = value\n      }\n    } else if (name === 'Connections' && subNode.name === 'C') {\n      const array = []\n\n      subNode.propertyList.forEach(function (property, i) {\n        // first Connection is FBX type (OO, OP, etc.). We'll discard these\n        if (i !== 0) array.push(property)\n      })\n\n      if (node.connections === undefined) {\n        node.connections = []\n      }\n\n      node.connections.push(array)\n    } else if (subNode.name === 'Properties70') {\n      const keys = Object.keys(subNode)\n\n      keys.forEach(function (key) {\n        node[key] = subNode[key]\n      })\n    } else if (name === 'Properties70' && subNode.name === 'P') {\n      let innerPropName = subNode.propertyList[0]\n      let innerPropType1 = subNode.propertyList[1]\n      const innerPropType2 = subNode.propertyList[2]\n      const innerPropFlag = subNode.propertyList[3]\n      let innerPropValue\n\n      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_')\n      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_')\n\n      if (\n        innerPropType1 === 'Color' ||\n        innerPropType1 === 'ColorRGB' ||\n        innerPropType1 === 'Vector' ||\n        innerPropType1 === 'Vector3D' ||\n        innerPropType1.indexOf('Lcl_') === 0\n      ) {\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]]\n      } else {\n        innerPropValue = subNode.propertyList[4]\n      }\n\n      // this will be copied to parent, see above\n      node[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue,\n      }\n    } else if (node[subNode.name] === undefined) {\n      if (typeof subNode.id === 'number') {\n        node[subNode.name] = {}\n        node[subNode.name][subNode.id] = subNode\n      } else {\n        node[subNode.name] = subNode\n      }\n    } else {\n      if (subNode.name === 'PoseNode') {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]]\n        }\n\n        node[subNode.name].push(subNode)\n      } else if (node[subNode.name][subNode.id] === undefined) {\n        node[subNode.name][subNode.id] = subNode\n      }\n    }\n  }\n\n  parseProperty(reader) {\n    const type = reader.getString(1)\n    let length\n\n    switch (type) {\n      case 'C':\n        return reader.getBoolean()\n\n      case 'D':\n        return reader.getFloat64()\n\n      case 'F':\n        return reader.getFloat32()\n\n      case 'I':\n        return reader.getInt32()\n\n      case 'L':\n        return reader.getInt64()\n\n      case 'R':\n        length = reader.getUint32()\n        return reader.getArrayBuffer(length)\n\n      case 'S':\n        length = reader.getUint32()\n        return reader.getString(length)\n\n      case 'Y':\n        return reader.getInt16()\n\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'f':\n      case 'i':\n      case 'l':\n        const arrayLength = reader.getUint32()\n        const encoding = reader.getUint32() // 0: non-compressed, 1: compressed\n        const compressedLength = reader.getUint32()\n\n        if (encoding === 0) {\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader.getBooleanArray(arrayLength)\n\n            case 'd':\n              return reader.getFloat64Array(arrayLength)\n\n            case 'f':\n              return reader.getFloat32Array(arrayLength)\n\n            case 'i':\n              return reader.getInt32Array(arrayLength)\n\n            case 'l':\n              return reader.getInt64Array(arrayLength)\n          }\n        }\n\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)))\n        const reader2 = new BinaryReader(data.buffer)\n\n        switch (type) {\n          case 'b':\n          case 'c':\n            return reader2.getBooleanArray(arrayLength)\n\n          case 'd':\n            return reader2.getFloat64Array(arrayLength)\n\n          case 'f':\n            return reader2.getFloat32Array(arrayLength)\n\n          case 'i':\n            return reader2.getInt32Array(arrayLength)\n\n          case 'l':\n            return reader2.getInt64Array(arrayLength)\n        }\n\n      default:\n        throw new Error('THREE.FBXLoader: Unknown property type ' + type)\n    }\n  }\n}\n\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer)\n    this.offset = 0\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true\n  }\n\n  getOffset() {\n    return this.offset\n  }\n\n  size() {\n    return this.dv.buffer.byteLength\n  }\n\n  skip(length) {\n    this.offset += length\n  }\n\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1\n  }\n\n  getBooleanArray(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean())\n    }\n\n    return a\n  }\n\n  getUint8() {\n    const value = this.dv.getUint8(this.offset)\n    this.offset += 1\n    return value\n  }\n\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian)\n    this.offset += 2\n    return value\n  }\n\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getInt32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32())\n    }\n\n    return a\n  }\n\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    // calculate negative value\n    if (high & 0x80000000) {\n      high = ~high & 0xffffffff\n      low = ~low & 0xffffffff\n\n      if (low === 0xffffffff) high = (high + 1) & 0xffffffff\n\n      low = (low + 1) & 0xffffffff\n\n      return -(high * 0x100000000 + low)\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getInt64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64())\n    }\n\n    return a\n  }\n\n  // Note: see getInt64() comment\n  getUint64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getFloat32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32())\n    }\n\n    return a\n  }\n\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian)\n    this.offset += 8\n    return value\n  }\n\n  getFloat64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64())\n    }\n\n    return a\n  }\n\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size)\n    this.offset += size\n    return value\n  }\n\n  getString(size) {\n    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n    let a = []\n\n    for (let i = 0; i < size; i++) {\n      a[i] = this.getUint8()\n    }\n\n    const nullByte = a.indexOf(0)\n    if (nullByte >= 0) a = a.slice(0, nullByte)\n\n    return decodeText(new Uint8Array(a))\n  }\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n  add(key, val) {\n    this[key] = val\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0'\n\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length)\n}\n\nfunction isFbxFormatASCII(text) {\n  const CORRECT = [\n    'K',\n    'a',\n    'y',\n    'd',\n    'a',\n    'r',\n    'a',\n    '\\\\',\n    'F',\n    'B',\n    'X',\n    '\\\\',\n    'B',\n    'i',\n    'n',\n    'a',\n    'r',\n    'y',\n    '\\\\',\n    '\\\\',\n  ]\n\n  let cursor = 0\n\n  function read(offset) {\n    const result = text[offset - 1]\n    text = text.slice(cursor + offset)\n    cursor++\n    return result\n  }\n\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1)\n    if (num === CORRECT[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/\n  const match = text.match(versionRegExp)\n\n  if (match) {\n    const version = parseInt(match[1])\n    return version\n  }\n\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.')\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158000\n}\n\nconst dataArray = []\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index\n\n  switch (infoObject.mappingType) {\n    case 'ByPolygonVertex':\n      index = polygonVertexIndex\n      break\n    case 'ByPolygon':\n      index = polygonIndex\n      break\n    case 'ByVertice':\n      index = vertexIndex\n      break\n    case 'AllSame':\n      index = infoObject.indices[0]\n      break\n    default:\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType)\n  }\n\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index]\n\n  const from = index * infoObject.dataSize\n  const to = from + infoObject.dataSize\n\n  return slice(dataArray, infoObject.buffer, from, to)\n}\n\nconst tempEuler = new Euler()\nconst tempVec = new Vector3()\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4()\n  const lPreRotationM = new Matrix4()\n  const lRotationM = new Matrix4()\n  const lPostRotationM = new Matrix4()\n\n  const lScalingM = new Matrix4()\n  const lScalingPivotM = new Matrix4()\n  const lScalingOffsetM = new Matrix4()\n  const lRotationOffsetM = new Matrix4()\n  const lRotationPivotM = new Matrix4()\n\n  const lParentGX = new Matrix4()\n  const lParentLX = new Matrix4()\n  const lGlobalT = new Matrix4()\n\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0\n\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation))\n\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n    lPostRotationM.invert()\n  }\n\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale))\n\n  // Pivots and offsets\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset))\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot))\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset))\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot))\n\n  // parent transform\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix)\n    lParentGX.copy(transformData.parentMatrixWorld)\n  }\n\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM)\n  // Global Rotation\n  const lParentGRM = new Matrix4()\n  lParentGRM.extractRotation(lParentGX)\n\n  // Global Shear*Scaling\n  const lParentTM = new Matrix4()\n  lParentTM.copyPosition(lParentGX)\n\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX)\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM)\n  const lLSM = lScalingM\n\n  const lGlobalRS = new Matrix4()\n\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM)\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM)\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX))\n    const lParentLSM_inv = lParentLSM.clone().invert()\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv)\n\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM)\n  }\n\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert()\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert()\n  // Calculate the local transform matrix\n  let lTransform = lTranslationM\n    .clone()\n    .multiply(lRotationOffsetM)\n    .multiply(lRotationPivotM)\n    .multiply(lPreRotationM)\n    .multiply(lRotationM)\n    .multiply(lPostRotationM)\n    .multiply(lRotationPivotM_inv)\n    .multiply(lScalingOffsetM)\n    .multiply(lScalingPivotM)\n    .multiply(lScalingM)\n    .multiply(lScalingPivotM_inv)\n\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform)\n\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo)\n  lGlobalT.copyPosition(lGlobalTranslation)\n\n  lTransform = lGlobalT.clone().multiply(lGlobalRS)\n\n  // from global to local\n  lTransform.premultiply(lParentGX.invert())\n\n  return lTransform\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder(order) {\n  order = order || 0\n\n  const enums = [\n    'ZYX', // -> XYZ extrinsic\n    'YZX', // -> XZY extrinsic\n    'XZY', // -> YZX extrinsic\n    'ZXY', // -> YXZ extrinsic\n    'YXZ', // -> ZXY extrinsic\n    'XYZ', // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ]\n\n  if (order === 6) {\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.')\n    return enums[0]\n  }\n\n  return enums[order]\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray(value) {\n  const array = value.split(',').map(function (val) {\n    return parseFloat(val)\n  })\n\n  return array\n}\n\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === undefined) from = 0\n  if (to === undefined) to = buffer.byteLength\n\n  return decodeText(new Uint8Array(buffer, from, to))\n}\n\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i]\n  }\n}\n\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i]\n  }\n\n  return a\n}\n\n// inject array a2 into array a1 at index\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index))\n}\n\nexport { FBXLoader }\n", "import { Loader, FileLoader, ShapePath } from 'three'\n\nimport type { LoadingManager, Shape } from 'three'\n\ntype Options = {\n  lineHeight: number\n  letterSpacing: number\n}\n\nexport class FontLoader extends Loader {\n  constructor(manager?: LoadingManager) {\n    super(manager)\n  }\n\n  public load(\n    url: string,\n    onLoad?: (responseFont: Font) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): void {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== 'string') throw new Error('unsupported data type')\n\n        const json = JSON.parse(response)\n\n        const font = this.parse(json)\n\n        if (onLoad) onLoad(font)\n      },\n      onProgress,\n      onError as (event: unknown) => void,\n    )\n  }\n\n  loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Font> {\n    // @ts-ignore\n    return super.loadAsync(url, onProgress)\n  }\n\n  public parse(json: FontData): Font {\n    return new Font(json)\n  }\n}\n\ntype Glyph = {\n  _cachedOutline: string[]\n  ha: number\n  o: string\n}\n\ntype FontData = {\n  boundingBox: { yMax: number; yMin: number }\n  familyName: string\n  glyphs: { [k: string]: Glyph }\n  resolution: number\n  underlineThickness: number\n}\n\nexport class Font {\n  public data: FontData\n  public static isFont: true\n  public static type: 'Font'\n\n  constructor(data: FontData) {\n    this.data = data\n  }\n\n  public generateShapes(text: string, size = 100, _options?: Partial<Options>): Shape[] {\n    const shapes: Shape[] = []\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options }\n    const paths = createPaths(text, size, this.data, options)\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false))\n    }\n    return shapes\n  }\n}\n\nfunction createPaths(text: string, size: number, data: FontData, options: Options): ShapePath[] {\n  const chars = Array.from(text)\n  const scale = size / data.resolution\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale\n\n  const paths: ShapePath[] = []\n\n  let offsetX = 0,\n    offsetY = 0\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n\n    if (char === '\\n') {\n      offsetX = 0\n      offsetY -= line_height * options.lineHeight\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data)\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing\n        paths.push(ret.path)\n      }\n    }\n  }\n\n  return paths\n}\n\nfunction createPath(\n  char: string,\n  scale: number,\n  offsetX: number,\n  offsetY: number,\n  data: FontData,\n): { offsetX: number; path: ShapePath } | undefined {\n  const glyph = data.glyphs[char] || data.glyphs['?']\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.')\n    return\n  }\n\n  const path = new ShapePath()\n\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))\n\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++]\n\n      switch (action) {\n        case 'm': // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.moveTo(x, y)\n\n          break\n\n        case 'l': // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.lineTo(x, y)\n\n          break\n\n        case 'q': // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)\n\n          break\n\n        case 'b': // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n          cpx2 = parseInt(outline[i++]) * scale + offsetX\n          cpy2 = parseInt(outline[i++]) * scale + offsetY\n\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)\n\n          break\n      }\n    }\n  }\n\n  return { offsetX: glyph.ha * scale, path }\n}\n", "import { Texture, ClampToEdgeWrapping, NearestFilter } from 'three'\n\nclass Data3DTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null)\n\n    this.isData3DTexture = true\n\n    this.image = { data, width, height, depth }\n\n    this.magFilter = NearestFilter\n    this.minFilter = NearestFilter\n\n    this.wrapR = ClampToEdgeWrapping\n\n    this.generateMipmaps = false\n    this.flipY = false\n    this.unpackAlignment = 1\n  }\n}\n\nexport { Data3DTexture }\n", "import {\n  AnimationClip,\n  AnimationMixer,\n  Bone,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  Quaternion,\n  Skeleton,\n  SkinnedMesh,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector2,\n  Vector3,\n} from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nvar XLoader = (function () {\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function')\n    }\n  }\n\n  var createClass = (function () {\n    function defineProperties(target, props) {\n      for (let i = 0; i < props.length; i++) {\n        var descriptor = props[i]\n        descriptor.enumerable = descriptor.enumerable || false\n        descriptor.configurable = true\n        if ('value' in descriptor) descriptor.writable = true\n        Object.defineProperty(target, descriptor.key, descriptor)\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps)\n      if (staticProps) defineProperties(Constructor, staticProps)\n      return Constructor\n    }\n  })()\n\n  var XboneInf = function XboneInf() {\n    classCallCheck(this, XboneInf)\n\n    this.boneName = ''\n    this.BoneIndex = 0\n    this.Indeces = []\n    this.Weights = []\n    this.initMatrix = null\n    this.OffsetMatrix = null\n  }\n\n  var XAnimationInfo = function XAnimationInfo() {\n    classCallCheck(this, XAnimationInfo)\n\n    this.animeName = ''\n    this.boneName = ''\n    this.targetBone = null\n    this.keyType = 4\n    this.frameStartLv = 0\n    this.keyFrames = []\n    this.InverseMx = null\n  }\n\n  var XAnimationObj = (function () {\n    function XAnimationObj(_flags) {\n      classCallCheck(this, XAnimationObj)\n\n      this.fps = 30\n      this.name = 'xanimation'\n      this.length = 0\n      this.hierarchy = []\n      this.putFlags = _flags\n      if (this.putFlags.putPos === undefined) {\n        this.putFlags.putPos = true\n      }\n\n      if (this.putFlags.putRot === undefined) {\n        this.putFlags.putRot = true\n      }\n\n      if (this.putFlags.putScl === undefined) {\n        this.putFlags.putScl = true\n      }\n    }\n\n    createClass(XAnimationObj, [\n      {\n        key: 'make',\n        value: function make(XAnimationInfoArray) {\n          for (let i = 0; i < XAnimationInfoArray.length; i++) {\n            this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]))\n          }\n\n          this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time\n        },\n      },\n      {\n        key: 'clone',\n        value: function clone() {\n          return Object.assign({}, this)\n        },\n      },\n      {\n        key: 'makeBonekeys',\n        value: function makeBonekeys(XAnimationInfo) {\n          var refObj = {}\n          refObj.name = XAnimationInfo.boneName\n          refObj.parent = ''\n          refObj.keys = this.keyFrameRefactor(XAnimationInfo)\n          refObj.copy = function () {\n            return Object.assign({}, this)\n          }\n\n          return refObj\n        },\n      },\n      {\n        key: 'keyFrameRefactor',\n        value: function keyFrameRefactor(XAnimationInfo) {\n          var keys = []\n          for (let i = 0; i < XAnimationInfo.keyFrames.length; i++) {\n            var keyframe = {}\n            keyframe.time = XAnimationInfo.keyFrames[i].time * this.fps\n            if (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {\n              keyframe.pos = XAnimationInfo.keyFrames[i].pos\n            }\n\n            if (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {\n              keyframe.rot = XAnimationInfo.keyFrames[i].rot\n            }\n\n            if (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {\n              keyframe.scl = XAnimationInfo.keyFrames[i].scl\n            }\n\n            if (XAnimationInfo.keyFrames[i].matrix) {\n              keyframe.matrix = XAnimationInfo.keyFrames[i].matrix\n              if (this.putFlags.putPos) {\n                keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix)\n              }\n\n              if (this.putFlags.putRot) {\n                keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix)\n              }\n\n              if (this.putFlags.putScl) {\n                keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix)\n              }\n            }\n\n            keys.push(keyframe)\n          }\n\n          return keys\n        },\n      },\n    ])\n    return XAnimationObj\n  })()\n\n  var XKeyFrameInfo = function XKeyFrameInfo() {\n    classCallCheck(this, XKeyFrameInfo)\n\n    this.index = 0\n    this.Frame = 0\n    this.time = 0.0\n    this.matrix = null\n  }\n\n  var XLoader = (function () {\n    function XLoader(manager) {\n      Loader.call(this, manager)\n\n      classCallCheck(this, XLoader)\n\n      this.debug = false\n      this.texloader = new TextureLoader(this.manager)\n      this.url = ''\n      this._putMatLength = 0\n      this._nowMat = null\n      this._nowFrameName = ''\n      this.frameHierarchie = []\n      this.Hierarchies = {}\n      this.HieStack = []\n      this._currentObject = {}\n      this._currentFrame = {}\n      this._data = null\n      this.onLoad = null\n      this.IsUvYReverse = true\n      this.Meshes = []\n      this.animations = []\n      this.animTicksPerSecond = 30\n      this._currentGeo = null\n      this._currentAnime = null\n      this._currentAnimeFrames = null\n    }\n\n    createClass(XLoader, [\n      {\n        key: '_setArgOption',\n        value: function _setArgOption(_arg) {\n          var _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0\n\n          if (!_arg) {\n            return\n          }\n\n          for (let i = _start; i < _arg.length; i++) {\n            switch (i) {\n              case 0:\n                this.url = _arg[i]\n                break\n              case 1:\n                this.options = _arg[i]\n                break\n            }\n          }\n\n          if (this.options === undefined) {\n            this.options = {}\n          }\n        },\n      },\n      {\n        key: 'load',\n        value: function load(_arg, onLoad, onProgress, onError) {\n          var _this = this\n\n          this._setArgOption(_arg)\n          var loader = new FileLoader(this.manager)\n          loader.setPath(this.path)\n          loader.setResponseType('arraybuffer')\n          loader.setRequestHeader(this.requestHeader)\n          loader.setWithCredentials(this.withCredentials)\n          loader.load(\n            this.url,\n            function (response) {\n              try {\n                _this.parse(response, onLoad)\n              } catch (e) {\n                if (onError) {\n                  onError(e)\n                } else {\n                  console.error(e)\n                }\n\n                _this.manager.itemError(_this.url)\n              }\n            },\n            onProgress,\n            onError,\n          )\n        },\n      },\n      {\n        key: '_readLine',\n        value: function _readLine(line) {\n          var readed = 0\n          while (true) {\n            var find = -1\n            find = line.indexOf('//', readed)\n            if (find === -1) {\n              find = line.indexOf('#', readed)\n            }\n\n            if (find > -1 && find < 2) {\n              var foundNewLine = -1\n              foundNewLine = line.indexOf('\\r\\n', readed)\n              if (foundNewLine > 0) {\n                readed = foundNewLine + 2\n              } else {\n                foundNewLine = line.indexOf('\\r', readed)\n                if (foundNewLine > 0) {\n                  readed = foundNewLine + 1\n                } else {\n                  readed = line.indexOf('\\n', readed) + 1\n                }\n              }\n            } else {\n              break\n            }\n          }\n\n          return line.substr(readed)\n        },\n      },\n      {\n        key: '_readLine',\n        value: function _readLine(line) {\n          var readed = 0\n          while (true) {\n            var find = -1\n            find = line.indexOf('//', readed)\n            if (find === -1) {\n              find = line.indexOf('#', readed)\n            }\n\n            if (find > -1 && find < 2) {\n              var foundNewLine = -1\n              foundNewLine = line.indexOf('\\r\\n', readed)\n              if (foundNewLine > 0) {\n                readed = foundNewLine + 2\n              } else {\n                foundNewLine = line.indexOf('\\r', readed)\n                if (foundNewLine > 0) {\n                  readed = foundNewLine + 1\n                } else {\n                  readed = line.indexOf('\\n', readed) + 1\n                }\n              }\n            } else {\n              break\n            }\n          }\n\n          return line.substr(readed)\n        },\n      },\n      {\n        key: '_isBinary',\n        value: function _isBinary(binData) {\n          var reader = new DataView(binData)\n          var face_size = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8\n          var n_faces = reader.getUint32(80, true)\n          var expect = 80 + 32 / 8 + n_faces * face_size\n          if (expect === reader.byteLength) {\n            return true\n          }\n\n          var fileLength = reader.byteLength\n          for (let index = 0; index < fileLength; index++) {\n            if (reader.getUint8(index, false) > 127) {\n              return true\n            }\n          }\n\n          return false\n        },\n      },\n      {\n        key: '_ensureBinary',\n        value: function _ensureBinary(buf) {\n          if (typeof buf === 'string') {\n            var array_buffer = new Uint8Array(buf.length)\n            for (let i = 0; i < buf.length; i++) {\n              array_buffer[i] = buf.charCodeAt(i) & 0xff\n            }\n\n            return array_buffer.buffer || array_buffer\n          } else {\n            return buf\n          }\n        },\n      },\n      {\n        key: '_ensureString',\n        value: function _ensureString(buf) {\n          if (typeof buf !== 'string') {\n            return decodeText(new Uint8Array(buf))\n          } else {\n            return buf\n          }\n        },\n      },\n      {\n        key: 'parse',\n        value: function _parse(data, onLoad) {\n          var binData = this._ensureBinary(data)\n          this._data = this._ensureString(data)\n          this.onLoad = onLoad\n          return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII()\n        },\n      },\n      {\n        key: '_parseBinary',\n        value: function _parseBinary(data) {\n          return this._parseASCII(decodeText(new Uint8Array(data)))\n        },\n      },\n      {\n        key: '_parseASCII',\n        value: function _parseASCII() {\n          var path\n\n          if (this.resourcePath !== '') {\n            path = this.resourcePath\n          } else if (this.path !== '') {\n            path = this.path\n          } else {\n            path = LoaderUtils.extractUrlBase(this.url)\n          }\n\n          this.texloader.setPath(path).setCrossOrigin(this.crossOrigin)\n\n          var endRead = 16\n          this.Hierarchies.children = []\n          this._hierarchieParse(this.Hierarchies, endRead)\n          this._changeRoot()\n          this._currentObject = this.Hierarchies.children.shift()\n          this._mainloop()\n        },\n      },\n      {\n        key: '_hierarchieParse',\n        value: function _hierarchieParse(_parent, _end) {\n          var endRead = _end\n          while (true) {\n            var find1 = this._data.indexOf('{', endRead) + 1\n            var findEnd = this._data.indexOf('}', endRead)\n            var findNext = this._data.indexOf('{', find1) + 1\n            if (find1 > 0 && findEnd > find1) {\n              var _currentObject = {}\n              _currentObject.children = []\n              var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim()\n              var word = nameData.split(/ /g)\n              if (word.length > 0) {\n                _currentObject.type = word[0]\n                if (word.length >= 2) {\n                  _currentObject.name = word[1]\n                } else {\n                  _currentObject.name = word[0] + this.Hierarchies.children.length\n                }\n              } else {\n                _currentObject.name = nameData\n                _currentObject.type = ''\n              }\n\n              if (_currentObject.type === 'Animation') {\n                _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim()\n                var refs = this._hierarchieParse(_currentObject, findEnd + 1)\n                endRead = refs.end\n                _currentObject.children = refs.parent.children\n              } else {\n                var DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd)\n                _currentObject.data = this._data.substr(find1, DataEnder - find1).trim()\n                if (findNext <= 0 || findEnd < findNext) {\n                  endRead = findEnd + 1\n                } else {\n                  var nextStart = Math.max(DataEnder + 1, find1)\n                  var _refs = this._hierarchieParse(_currentObject, nextStart)\n                  endRead = _refs.end\n                  _currentObject.children = _refs.parent.children\n                }\n              }\n\n              _currentObject.parent = _parent\n              if (_currentObject.type != 'template') {\n                _parent.children.push(_currentObject)\n              }\n            } else {\n              endRead = find1 === -1 ? this._data.length : findEnd + 1\n              break\n            }\n          }\n\n          return {\n            parent: _parent,\n            end: endRead,\n          }\n        },\n      },\n      {\n        key: '_mainloop',\n        value: function _mainloop() {\n          var _this2 = this\n\n          this._mainProc()\n          if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {\n            setTimeout(function () {\n              _this2._mainloop()\n            }, 1)\n          } else {\n            setTimeout(function () {\n              _this2.onLoad({\n                models: _this2.Meshes,\n                animations: _this2.animations,\n              })\n            }, 1)\n          }\n        },\n      },\n      {\n        key: '_mainProc',\n        value: function _mainProc() {\n          var breakFlag = false\n          while (true) {\n            if (!this._currentObject.worked) {\n              switch (this._currentObject.type) {\n                case 'template':\n                  break\n                case 'AnimTicksPerSecond':\n                  this.animTicksPerSecond = parseInt(this._currentObject.data)\n                  break\n                case 'Frame':\n                  this._setFrame()\n                  break\n                case 'FrameTransformMatrix':\n                  this._setFrameTransformMatrix()\n                  break\n                case 'Mesh':\n                  this._changeRoot()\n                  this._currentGeo = {}\n                  this._currentGeo.name = this._currentObject.name.trim()\n                  this._currentGeo.parentName = this._getParentName(this._currentObject).trim()\n                  this._currentGeo.VertexSetedBoneCount = []\n                  this._currentGeo.GeometryData = {\n                    vertices: [],\n                    normals: [],\n                    uvs: [],\n                    skinIndices: [],\n                    skinWeights: [],\n                    indices: [],\n                    materialIndices: [],\n                  }\n                  this._currentGeo.Materials = []\n                  this._currentGeo.normalVectors = []\n                  this._currentGeo.BoneInfs = []\n                  this._currentGeo.baseFrame = this._currentFrame\n                  this._makeBoneFrom_CurrentFrame()\n                  this._readVertexDatas()\n                  breakFlag = true\n                  break\n                case 'MeshNormals':\n                  this._readVertexDatas()\n                  break\n                case 'MeshTextureCoords':\n                  this._setMeshTextureCoords()\n                  break\n                case 'VertexDuplicationIndices':\n                  break\n                case 'MeshMaterialList':\n                  this._setMeshMaterialList()\n                  break\n                case 'Material':\n                  this._setMaterial()\n                  break\n                case 'SkinWeights':\n                  this._setSkinWeights()\n                  break\n                case 'AnimationSet':\n                  this._changeRoot()\n                  this._currentAnime = {}\n                  this._currentAnime.name = this._currentObject.name.trim()\n                  this._currentAnime.AnimeFrames = []\n                  break\n                case 'Animation':\n                  if (this._currentAnimeFrames) {\n                    this._currentAnime.AnimeFrames.push(this._currentAnimeFrames)\n                  }\n\n                  this._currentAnimeFrames = new XAnimationInfo()\n                  this._currentAnimeFrames.boneName = this._currentObject.data.trim()\n                  break\n                case 'AnimationKey':\n                  this._readAnimationKey()\n                  breakFlag = true\n                  break\n              }\n\n              this._currentObject.worked = true\n            }\n\n            if (this._currentObject.children.length > 0) {\n              this._currentObject = this._currentObject.children.shift()\n              if (this.debug) {\n                console.log('processing ' + this._currentObject.name)\n              }\n\n              if (breakFlag) break\n            } else {\n              if (this._currentObject.worked) {\n                if (this._currentObject.parent && !this._currentObject.parent.parent) {\n                  this._changeRoot()\n                }\n              }\n\n              if (this._currentObject.parent) {\n                this._currentObject = this._currentObject.parent\n              } else {\n                breakFlag = true\n              }\n\n              if (breakFlag) break\n            }\n          }\n\n          return\n        },\n      },\n      {\n        key: '_changeRoot',\n        value: function _changeRoot() {\n          if (this._currentGeo != null && this._currentGeo.name) {\n            this._makeOutputGeometry()\n          }\n\n          this._currentGeo = {}\n          if (this._currentAnime != null && this._currentAnime.name) {\n            if (this._currentAnimeFrames) {\n              this._currentAnime.AnimeFrames.push(this._currentAnimeFrames)\n              this._currentAnimeFrames = null\n            }\n\n            this._makeOutputAnimation()\n          }\n\n          this._currentAnime = {}\n        },\n      },\n      {\n        key: '_getParentName',\n        value: function _getParentName(_obj) {\n          if (_obj.parent) {\n            if (_obj.parent.name) {\n              return _obj.parent.name\n            } else {\n              return this._getParentName(_obj.parent)\n            }\n          } else {\n            return ''\n          }\n        },\n      },\n      {\n        key: '_setFrame',\n        value: function _setFrame() {\n          this._nowFrameName = this._currentObject.name.trim()\n          this._currentFrame = {}\n          this._currentFrame.name = this._nowFrameName\n          this._currentFrame.children = []\n          if (this._currentObject.parent && this._currentObject.parent.name) {\n            this._currentFrame.parentName = this._currentObject.parent.name\n          }\n\n          this.frameHierarchie.push(this._nowFrameName)\n          this.HieStack[this._nowFrameName] = this._currentFrame\n        },\n      },\n      {\n        key: '_setFrameTransformMatrix',\n        value: function _setFrameTransformMatrix() {\n          this._currentFrame.FrameTransformMatrix = new Matrix4()\n          var data = this._currentObject.data.split(',')\n          this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data)\n          this._makeBoneFrom_CurrentFrame()\n        },\n      },\n      {\n        key: '_makeBoneFrom_CurrentFrame',\n        value: function _makeBoneFrom_CurrentFrame() {\n          if (!this._currentFrame.FrameTransformMatrix) {\n            return\n          }\n\n          var b = new Bone()\n          b.name = this._currentFrame.name\n          b.applyMatrix4(this._currentFrame.FrameTransformMatrix)\n          b.matrixWorld = b.matrix\n          b.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix\n          this._currentFrame.putBone = b\n          if (this._currentFrame.parentName) {\n            for (let frame in this.HieStack) {\n              if (this.HieStack[frame].name === this._currentFrame.parentName) {\n                this.HieStack[frame].putBone.add(this._currentFrame.putBone)\n              }\n            }\n          }\n        },\n      },\n      {\n        key: '_readVertexDatas',\n        value: function _readVertexDatas() {\n          var endRead = 0\n          var mode = 0\n          var mode_local = 0\n          var maxLength = 0\n          while (true) {\n            var changeMode = false\n            if (mode_local === 0) {\n              var refO = this._readInt1(endRead)\n              endRead = refO.endRead\n              mode_local = 1\n              maxLength = this._currentObject.data.indexOf(';;', endRead) + 1\n              if (maxLength <= 0) {\n                maxLength = this._currentObject.data.length\n              }\n            } else {\n              var find = 0\n              switch (mode) {\n                case 0:\n                  find = this._currentObject.data.indexOf(',', endRead) + 1\n                  break\n                case 1:\n                  find = this._currentObject.data.indexOf(';,', endRead) + 1\n                  break\n              }\n\n              if (find === 0 || find > maxLength) {\n                find = maxLength\n                mode_local = 0\n                changeMode = true\n              }\n\n              switch (this._currentObject.type) {\n                case 'Mesh':\n                  switch (mode) {\n                    case 0:\n                      this._readVertex1(this._currentObject.data.substr(endRead, find - endRead))\n                      break\n                    case 1:\n                      this._readFace1(this._currentObject.data.substr(endRead, find - endRead))\n                      break\n                  }\n\n                  break\n                case 'MeshNormals':\n                  switch (mode) {\n                    case 0:\n                      this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead))\n                      break\n                  }\n\n                  break\n              }\n\n              endRead = find + 1\n              if (changeMode) {\n                mode++\n              }\n            }\n\n            if (endRead >= this._currentObject.data.length) {\n              break\n            }\n          }\n        },\n      },\n      {\n        key: '_readInt1',\n        value: function _readInt1(start) {\n          var find = this._currentObject.data.indexOf(';', start)\n          return {\n            refI: parseInt(this._currentObject.data.substr(start, find - start)),\n            endRead: find + 1,\n          }\n        },\n      },\n      {\n        key: '_readVertex1',\n        value: function _readVertex1(line) {\n          var data = this._readLine(line.trim())\n            .substr(0, line.length - 2)\n            .split(';')\n          this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]))\n          this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0)\n          this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0)\n          this._currentGeo.VertexSetedBoneCount.push(0)\n        },\n      },\n      {\n        key: '_readFace1',\n        value: function _readFace1(line) {\n          var data = this._readLine(line.trim())\n            .substr(2, line.length - 4)\n            .split(',')\n          this._currentGeo.GeometryData.indices.push(\n            parseInt(data[0], 10),\n            parseInt(data[1], 10),\n            parseInt(data[2], 10),\n          )\n        },\n      },\n      {\n        key: '_readNormalVector1',\n        value: function _readNormalVector1(line) {\n          var data = this._readLine(line.trim())\n            .substr(0, line.length - 2)\n            .split(';')\n          this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]))\n        },\n      },\n      {\n        key: '_buildGeometry',\n        value: function _buildGeometry() {\n          var bufferGeometry = new BufferGeometry()\n          var position = []\n          var normals = []\n          var uvs = []\n          var skinIndices = []\n          var skinWeights = []\n\n          //\n\n          var data = this._currentGeo.GeometryData\n\n          for (let i = 0, l = data.indices.length; i < l; i++) {\n            var stride2 = data.indices[i] * 2\n            var stride3 = data.indices[i] * 3\n            var stride4 = data.indices[i] * 4\n\n            position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2])\n            normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2])\n            skinIndices.push(\n              data.skinIndices[stride4],\n              data.skinIndices[stride4 + 1],\n              data.skinIndices[stride4 + 2],\n              data.skinIndices[stride4 + 3],\n            )\n            skinWeights.push(\n              data.skinWeights[stride4],\n              data.skinWeights[stride4 + 1],\n              data.skinWeights[stride4 + 2],\n              data.skinWeights[stride4 + 3],\n            )\n            uvs.push(data.uvs[stride2], data.uvs[stride2 + 1])\n          }\n\n          //\n\n          bufferGeometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n          bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n          bufferGeometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n          bufferGeometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4))\n          bufferGeometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4))\n\n          this._computeGroups(bufferGeometry, data.materialIndices)\n\n          return bufferGeometry\n        },\n      },\n      {\n        key: '_computeGroups',\n        value: function _computeGroups(bufferGeometry, materialIndices) {\n          var group\n          var groups = []\n          var materialIndex = undefined\n\n          for (let i = 0; i < materialIndices.length; i++) {\n            var currentMaterialIndex = materialIndices[i]\n\n            if (currentMaterialIndex !== materialIndex) {\n              materialIndex = currentMaterialIndex\n\n              if (group !== undefined) {\n                group.count = i * 3 - group.start\n                groups.push(group)\n              }\n\n              group = {\n                start: i * 3,\n                materialIndex: materialIndex,\n              }\n            }\n          }\n\n          if (group !== undefined) {\n            group.count = i * 3 - group.start\n            groups.push(group)\n          }\n\n          bufferGeometry.groups = groups\n        },\n      },\n      {\n        key: '_setMeshTextureCoords',\n        value: function _setMeshTextureCoords() {\n          var endRead = 0\n          var mode = 0\n          var mode_local = 0\n          while (true) {\n            switch (mode) {\n              case 0:\n                if (mode_local === 0) {\n                  var refO = this._readInt1(0)\n                  endRead = refO.endRead\n                  mode_local = 1\n                } else {\n                  var find = this._currentObject.data.indexOf(',', endRead) + 1\n                  if (find === 0) {\n                    find = this._currentObject.data.length\n                    mode = 2\n                    mode_local = 0\n                  }\n\n                  var line = this._currentObject.data.substr(endRead, find - endRead)\n                  var data = this._readLine(line.trim()).split(';')\n                  if (this.IsUvYReverse) {\n                    this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]))\n                  } else {\n                    this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]))\n                  }\n\n                  endRead = find + 1\n                }\n\n                break\n            }\n\n            if (endRead >= this._currentObject.data.length) {\n              break\n            }\n          }\n        },\n      },\n      {\n        key: '_setMeshMaterialList',\n        value: function _setMeshMaterialList() {\n          var endRead = 0\n          var mode = 0\n          var mode_local = 0\n          while (true) {\n            if (mode_local < 2) {\n              var refO = this._readInt1(endRead)\n              endRead = refO.endRead\n              mode_local++\n            } else {\n              var find = this._currentObject.data.indexOf(';', endRead)\n              if (find === -1) {\n                find = this._currentObject.data.length\n                mode = 3\n                mode_local = 0\n              }\n\n              var line = this._currentObject.data.substr(endRead, find - endRead)\n              var data = this._readLine(line.trim()).split(',')\n              for (let i = 0; i < data.length; i++) {\n                this._currentGeo.GeometryData.materialIndices[i] = parseInt(data[i])\n              }\n\n              endRead = this._currentObject.data.length\n            }\n\n            if (endRead >= this._currentObject.data.length || mode >= 3) {\n              break\n            }\n          }\n        },\n      },\n      {\n        key: '_setMaterial',\n        value: function _setMaterial() {\n          var _nowMat = new MeshPhongMaterial({\n            color: Math.random() * 0xffffff,\n          })\n          _nowMat.side = FrontSide\n          _nowMat.name = this._currentObject.name\n          var endRead = 0\n          var find = this._currentObject.data.indexOf(';;', endRead)\n          var line = this._currentObject.data.substr(endRead, find - endRead)\n          var data = this._readLine(line.trim()).split(';')\n          _nowMat.color.r = parseFloat(data[0])\n          _nowMat.color.g = parseFloat(data[1])\n          _nowMat.color.b = parseFloat(data[2])\n          endRead = find + 2\n          find = this._currentObject.data.indexOf(';', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          _nowMat.shininess = parseFloat(this._readLine(line))\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';;', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data2 = this._readLine(line.trim()).split(';')\n          _nowMat.specular.r = parseFloat(data2[0])\n          _nowMat.specular.g = parseFloat(data2[1])\n          _nowMat.specular.b = parseFloat(data2[2])\n          endRead = find + 2\n          find = this._currentObject.data.indexOf(';;', endRead)\n          if (find === -1) {\n            find = this._currentObject.data.length\n          }\n\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data3 = this._readLine(line.trim()).split(';')\n          _nowMat.emissive.r = parseFloat(data3[0])\n          _nowMat.emissive.g = parseFloat(data3[1])\n          _nowMat.emissive.b = parseFloat(data3[2])\n          var localObject = null\n          while (true) {\n            if (this._currentObject.children.length > 0) {\n              localObject = this._currentObject.children.shift()\n              if (this.debug) {\n                console.log('processing ' + localObject.name)\n              }\n\n              var fileName = localObject.data.substr(1, localObject.data.length - 2)\n              switch (localObject.type) {\n                case 'TextureFilename':\n                  _nowMat.map = this.texloader.load(fileName)\n                  break\n                case 'BumpMapFilename':\n                  _nowMat.bumpMap = this.texloader.load(fileName)\n                  _nowMat.bumpScale = 0.05\n                  break\n                case 'NormalMapFilename':\n                  _nowMat.normalMap = this.texloader.load(fileName)\n                  _nowMat.normalScale = new Vector2(2, 2)\n                  break\n                case 'EmissiveMapFilename':\n                  _nowMat.emissiveMap = this.texloader.load(fileName)\n                  break\n                case 'LightMapFilename':\n                  _nowMat.lightMap = this.texloader.load(fileName)\n                  break\n              }\n            } else {\n              break\n            }\n          }\n\n          this._currentGeo.Materials.push(_nowMat)\n        },\n      },\n      {\n        key: '_setSkinWeights',\n        value: function _setSkinWeights() {\n          var boneInf = new XboneInf()\n          var endRead = 0\n          var find = this._currentObject.data.indexOf(';', endRead)\n          var line = this._currentObject.data.substr(endRead, find - endRead)\n          endRead = find + 1\n          boneInf.boneName = line.substr(1, line.length - 2)\n          boneInf.BoneIndex = this._currentGeo.BoneInfs.length\n          find = this._currentObject.data.indexOf(';', endRead)\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data = this._readLine(line.trim()).split(',')\n          for (let i = 0; i < data.length; i++) {\n            boneInf.Indeces.push(parseInt(data[i]))\n          }\n\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';', endRead)\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data2 = this._readLine(line.trim()).split(',')\n          for (let _i = 0; _i < data2.length; _i++) {\n            boneInf.Weights.push(parseFloat(data2[_i]))\n          }\n\n          endRead = find + 1\n          find = this._currentObject.data.indexOf(';', endRead)\n          if (find <= 0) {\n            find = this._currentObject.data.length\n          }\n\n          line = this._currentObject.data.substr(endRead, find - endRead)\n          var data3 = this._readLine(line.trim()).split(',')\n          boneInf.OffsetMatrix = new Matrix4()\n          this._ParseMatrixData(boneInf.OffsetMatrix, data3)\n          this._currentGeo.BoneInfs.push(boneInf)\n        },\n      },\n      {\n        key: '_makePutBoneList',\n        value: function _makePutBoneList(_RootName, _bones) {\n          var putting = false\n          for (let frame in this.HieStack) {\n            if (this.HieStack[frame].name === _RootName || putting) {\n              putting = true\n              var b = new Bone()\n              b.name = this.HieStack[frame].name\n              b.applyMatrix4(this.HieStack[frame].FrameTransformMatrix)\n              b.matrixWorld = b.matrix\n              b.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix\n              b.pos = new Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray()\n              b.rotq = new Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray()\n              b.scl = new Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray()\n              if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {\n                for (let i = 0; i < _bones.length; i++) {\n                  if (this.HieStack[frame].parentName === _bones[i].name) {\n                    _bones[i].add(b)\n                    b.parent = i\n                    break\n                  }\n                }\n              }\n\n              _bones.push(b)\n            }\n          }\n        },\n      },\n      {\n        key: '_makeOutputGeometry',\n        value: function _makeOutputGeometry() {\n          var mesh = null\n          if (this._currentGeo.BoneInfs.length > 0) {\n            var putBones = []\n            this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones)\n            for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {\n              var boneIndex = 0\n              for (let bb = 0; bb < putBones.length; bb++) {\n                if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {\n                  boneIndex = bb\n                  putBones[bb].OffsetMatrix = new Matrix4()\n                  putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix)\n                  break\n                }\n              }\n\n              for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {\n                var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi]\n                var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi]\n\n                var stride = nowVertexID * 4\n\n                switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {\n                  case 0:\n                    this._currentGeo.GeometryData.skinIndices[stride] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride] = nowVal\n                    break\n                  case 1:\n                    this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal\n                    break\n                  case 2:\n                    this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal\n                    break\n                  case 3:\n                    this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex\n                    this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal\n                    break\n                }\n\n                this._currentGeo.VertexSetedBoneCount[nowVertexID]++\n                if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {\n                  console.log('warn! over 4 bone weight! :' + nowVertexID)\n                }\n              }\n            }\n\n            for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {\n              this._currentGeo.Materials[sk].skinning = true\n            }\n\n            var offsetList = []\n            for (let _bi = 0; _bi < putBones.length; _bi++) {\n              if (putBones[_bi].OffsetMatrix) {\n                offsetList.push(putBones[_bi].OffsetMatrix)\n              } else {\n                offsetList.push(new Matrix4())\n              }\n            }\n\n            var bufferGeometry = this._buildGeometry()\n            mesh = new SkinnedMesh(\n              bufferGeometry,\n              this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials,\n            )\n\n            this._initSkeleton(mesh, putBones, offsetList)\n          } else {\n            var _bufferGeometry = this._buildGeometry()\n            mesh = new Mesh(\n              _bufferGeometry,\n              this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials,\n            )\n          }\n\n          mesh.name = this._currentGeo.name\n          var worldBaseMx = new Matrix4()\n          var currentMxFrame = this._currentGeo.baseFrame.putBone\n          if (currentMxFrame && currentMxFrame.parent) {\n            while (true) {\n              currentMxFrame = currentMxFrame.parent\n              if (currentMxFrame) {\n                worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix)\n              } else {\n                break\n              }\n            }\n\n            mesh.applyMatrix4(worldBaseMx)\n          }\n\n          this.Meshes.push(mesh)\n        },\n      },\n      {\n        key: '_initSkeleton',\n        value: function _initSkeleton(mesh, boneList, boneInverses) {\n          var bones = [],\n            bone,\n            gbone\n          var i, il\n\n          for (i = 0, il = boneList.length; i < il; i++) {\n            gbone = boneList[i]\n\n            bone = new Bone()\n            bones.push(bone)\n\n            bone.name = gbone.name\n            bone.position.fromArray(gbone.pos)\n            bone.quaternion.fromArray(gbone.rotq)\n            if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl)\n          }\n\n          for (i = 0, il = boneList.length; i < il; i++) {\n            gbone = boneList[i]\n\n            if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n              bones[gbone.parent].add(bones[i])\n            } else {\n              mesh.add(bones[i])\n            }\n          }\n\n          mesh.updateMatrixWorld(true)\n\n          var skeleton = new Skeleton(bones, boneInverses)\n          mesh.bind(skeleton, mesh.matrixWorld)\n        },\n      },\n      {\n        key: '_readAnimationKey',\n        value: function _readAnimationKey() {\n          var endRead = 0\n          var find = this._currentObject.data.indexOf(';', endRead)\n          var line = this._currentObject.data.substr(endRead, find - endRead)\n          endRead = find + 1\n          var nowKeyType = parseInt(this._readLine(line))\n          find = this._currentObject.data.indexOf(';', endRead)\n          endRead = find + 1\n          line = this._currentObject.data.substr(endRead)\n          var data = this._readLine(line.trim()).split(';;,')\n          for (let i = 0; i < data.length; i++) {\n            var data2 = data[i].split(';')\n            var keyInfo = new XKeyFrameInfo()\n            keyInfo.type = nowKeyType\n            keyInfo.Frame = parseInt(data2[0])\n            keyInfo.index = this._currentAnimeFrames.keyFrames.length\n            keyInfo.time = keyInfo.Frame\n            if (nowKeyType != 4) {\n              var frameFound = false\n              for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {\n                if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {\n                  keyInfo = this._currentAnimeFrames.keyFrames[mm]\n                  frameFound = true\n                  break\n                }\n              }\n\n              var frameValue = data2[2].split(',')\n              switch (nowKeyType) {\n                case 0:\n                  keyInfo.rot = new Quaternion(\n                    parseFloat(frameValue[1]),\n                    parseFloat(frameValue[2]),\n                    parseFloat(frameValue[3]),\n                    parseFloat(frameValue[0]) * -1,\n                  )\n                  break\n                case 1:\n                  keyInfo.scl = new Vector3(\n                    parseFloat(frameValue[0]),\n                    parseFloat(frameValue[1]),\n                    parseFloat(frameValue[2]),\n                  )\n                  break\n                case 2:\n                  keyInfo.pos = new Vector3(\n                    parseFloat(frameValue[0]),\n                    parseFloat(frameValue[1]),\n                    parseFloat(frameValue[2]),\n                  )\n                  break\n              }\n\n              if (!frameFound) {\n                this._currentAnimeFrames.keyFrames.push(keyInfo)\n              }\n            } else {\n              keyInfo.matrix = new Matrix4()\n              this._ParseMatrixData(keyInfo.matrix, data2[2].split(','))\n              this._currentAnimeFrames.keyFrames.push(keyInfo)\n            }\n          }\n        },\n      },\n      {\n        key: '_makeOutputAnimation',\n        value: function _makeOutputAnimation() {\n          var animationObj = new XAnimationObj(this.options)\n          animationObj.fps = this.animTicksPerSecond\n          animationObj.name = this._currentAnime.name\n          animationObj.make(this._currentAnime.AnimeFrames)\n          this.animations.push(animationObj)\n        },\n      },\n      {\n        key: 'assignAnimation',\n        value: function assignAnimation(_model, _animation) {\n          var model = _model\n          var animation = _animation\n          if (!model) {\n            model = this.Meshes[0]\n          }\n\n          if (!animation) {\n            animation = this.animations[0]\n          }\n\n          if (!model || !animation) {\n            return null\n          }\n\n          var put = {}\n          put.fps = animation.fps\n          put.name = animation.name\n          put.length = animation.length\n          put.hierarchy = []\n          for (let b = 0; b < model.skeleton.bones.length; b++) {\n            var findAnimation = false\n            for (let i = 0; i < animation.hierarchy.length; i++) {\n              if (model.skeleton.bones[b].name === animation.hierarchy[i].name) {\n                findAnimation = true\n                var c_key = animation.hierarchy[i].copy()\n                c_key.parent = -1\n                if (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === 'Bone') {\n                  for (let bb = 0; bb < put.hierarchy.length; bb++) {\n                    if (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {\n                      c_key.parent = bb\n                      c_key.parentName = model.skeleton.bones[b].parent.name\n                    }\n                  }\n                }\n\n                put.hierarchy.push(c_key)\n                break\n              }\n            }\n\n            if (!findAnimation) {\n              var _c_key = animation.hierarchy[0].copy()\n              _c_key.name = model.skeleton.bones[b].name\n              _c_key.parent = -1\n              for (let k = 0; k < _c_key.keys.length; k++) {\n                if (_c_key.keys[k].pos) {\n                  _c_key.keys[k].pos.set(0, 0, 0)\n                }\n\n                if (_c_key.keys[k].scl) {\n                  _c_key.keys[k].scl.set(1, 1, 1)\n                }\n\n                if (_c_key.keys[k].rot) {\n                  _c_key.keys[k].rot.set(0, 0, 0, 1)\n                }\n              }\n\n              put.hierarchy.push(_c_key)\n            }\n          }\n\n          if (!model.geometry.animations) {\n            model.geometry.animations = []\n          }\n\n          model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones))\n          if (!model.animationMixer) {\n            model.animationMixer = new AnimationMixer(model)\n          }\n\n          return put\n        },\n      },\n      {\n        key: '_ParseMatrixData',\n        value: function _ParseMatrixData(targetMatrix, data) {\n          targetMatrix.set(\n            parseFloat(data[0]),\n            parseFloat(data[4]),\n            parseFloat(data[8]),\n            parseFloat(data[12]),\n            parseFloat(data[1]),\n            parseFloat(data[5]),\n            parseFloat(data[9]),\n            parseFloat(data[13]),\n            parseFloat(data[2]),\n            parseFloat(data[6]),\n            parseFloat(data[10]),\n            parseFloat(data[14]),\n            parseFloat(data[3]),\n            parseFloat(data[7]),\n            parseFloat(data[11]),\n            parseFloat(data[15]),\n          )\n        },\n      },\n    ])\n    return XLoader\n  })()\n\n  return XLoader\n})()\n\nexport { XLoader }\n", "const { CstParser, Lexer, createToken } = (() => {\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global\n\n  const freeGlobal$1 = freeGlobal\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal$1 || freeSelf || Function('return this')()\n\n  const root$1 = root\n\n  /** Built-in value references. */\n  var Symbol$1 = root$1.Symbol\n\n  const Symbol$2 = Symbol$1\n\n  /** Used for built-in method references. */\n  var objectProto$j = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$g = objectProto$j.hasOwnProperty\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$j.toString\n\n  /** Built-in value references. */\n  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty$g.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1]\n\n    try {\n      value[symToStringTag$1] = undefined\n      var unmasked = true\n    } catch (e) {}\n\n    var result = nativeObjectToString$1.call(value)\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag\n      } else {\n        delete value[symToStringTag$1]\n      }\n    }\n    return result\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$i = Object.prototype\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto$i.toString\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value)\n  }\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]'\n\n  /** Built-in value references. */\n  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object'\n  }\n\n  /** `Object#toString` result references. */\n  var symbolTag$3 = '[object Symbol]'\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag$3)\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length)\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array)\n    }\n    return result\n  }\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray\n\n  const isArray$1 = isArray\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$3 = 1 / 0\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value\n    }\n    if (isArray$1(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + ''\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : ''\n    }\n    var result = value + ''\n    return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result\n  }\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index\n  }\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value\n    return value != null && (type == 'object' || type == 'function')\n  }\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value\n    }\n    if (isSymbol(value)) {\n      return NAN\n    }\n    if (isObject(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value\n      value = isObject(other) ? other + '' : other\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value\n    }\n    value = baseTrim(value)\n    var isBinary = reIsBinary.test(value)\n    return isBinary || reIsOctal.test(value)\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : reIsBadHex.test(value)\n      ? NAN\n      : +value\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$2 = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e308\n\n  /**\n   * Converts `value` to a finite number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.12.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted number.\n   * @example\n   *\n   * _.toFinite(3.2);\n   * // => 3.2\n   *\n   * _.toFinite(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toFinite(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toFinite('3.2');\n   * // => 3.2\n   */\n  function toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0\n    }\n    value = toNumber(value)\n    if (value === INFINITY$2 || value === -INFINITY$2) {\n      var sign = value < 0 ? -1 : 1\n      return sign * MAX_INTEGER\n    }\n    return value === value ? value : 0\n  }\n\n  /**\n   * Converts `value` to an integer.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted integer.\n   * @example\n   *\n   * _.toInteger(3.2);\n   * // => 3\n   *\n   * _.toInteger(Number.MIN_VALUE);\n   * // => 0\n   *\n   * _.toInteger(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toInteger('3.2');\n   * // => 3\n   */\n  function toInteger(value) {\n    var result = toFinite(value),\n      remainder = result % 1\n\n    return result === result ? (remainder ? result - remainder : result) : 0\n  }\n\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value\n  }\n\n  /** `Object#toString` result references. */\n  var asyncTag = '[object AsyncFunction]',\n    funcTag$2 = '[object Function]',\n    genTag$1 = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]'\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag(value)\n    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag\n  }\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root$1['__core-js_shared__']\n\n  const coreJsData$1 = coreJsData\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function () {\n    var uid = /[^.]+$/.exec((coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO) || '')\n    return uid ? 'Symbol(src)_1.' + uid : ''\n  })()\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func\n  }\n\n  /** Used for built-in method references. */\n  var funcProto$1 = Function.prototype\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString$1 = funcProto$1.toString\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString$1.call(func)\n      } catch (e) {}\n      try {\n        return func + ''\n      } catch (e) {}\n    }\n    return ''\n  }\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype,\n    objectProto$h = Object.prototype\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$f = objectProto$h.hasOwnProperty\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp(\n    '^' +\n      funcToString\n        .call(hasOwnProperty$f)\n        .replace(reRegExpChar, '\\\\$&')\n        .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') +\n      '$',\n  )\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor\n    return pattern.test(toSource(value))\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key]\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key)\n    return baseIsNative(value) ? value : undefined\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var WeakMap = getNative(root$1, 'WeakMap')\n\n  const WeakMap$1 = WeakMap\n\n  /** Built-in value references. */\n  var objectCreate = Object.create\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} proto The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  var baseCreate = (function () {\n    function object() {}\n    return function (proto) {\n      if (!isObject(proto)) {\n        return {}\n      }\n      if (objectCreate) {\n        return objectCreate(proto)\n      }\n      object.prototype = proto\n      var result = new object()\n      object.prototype = undefined\n      return result\n    }\n  })()\n\n  const baseCreate$1 = baseCreate\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg)\n      case 1:\n        return func.call(thisArg, args[0])\n      case 2:\n        return func.call(thisArg, args[0], args[1])\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2])\n    }\n    return func.apply(thisArg, args)\n  }\n\n  /**\n   * This method returns `undefined`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.3.0\n   * @category Util\n   * @example\n   *\n   * _.times(2, _.noop);\n   * // => [undefined, undefined]\n   */\n  function noop() {\n    // No operation performed.\n  }\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n      length = source.length\n\n    array || (array = Array(length))\n    while (++index < length) {\n      array[index] = source[index]\n    }\n    return array\n  }\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n    HOT_SPAN = 16\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeNow = Date.now\n\n  /**\n   * Creates a function that'll short out and invoke `identity` instead\n   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n   * milliseconds.\n   *\n   * @private\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new shortable function.\n   */\n  function shortOut(func) {\n    var count = 0,\n      lastCalled = 0\n\n    return function () {\n      var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled)\n\n      lastCalled = stamp\n      if (remaining > 0) {\n        if (++count >= HOT_COUNT) {\n          return arguments[0]\n        }\n      } else {\n        count = 0\n      }\n      return func.apply(undefined, arguments)\n    }\n  }\n\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n  function constant(value) {\n    return function () {\n      return value\n    }\n  }\n\n  var defineProperty = (function () {\n    try {\n      var func = getNative(Object, 'defineProperty')\n      func({}, '', {})\n      return func\n    } catch (e) {}\n  })()\n\n  const defineProperty$1 = defineProperty\n\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var baseSetToString = !defineProperty$1\n    ? identity\n    : function (func, string) {\n        return defineProperty$1(func, 'toString', {\n          configurable: true,\n          enumerable: false,\n          value: constant(string),\n          writable: true,\n        })\n      }\n\n  const baseSetToString$1 = baseSetToString\n\n  /**\n   * Sets the `toString` method of `func` to return `string`.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var setToString = shortOut(baseSetToString$1)\n\n  const setToString$1 = setToString\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break\n      }\n    }\n    return array\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1)\n\n    while (fromRight ? index-- : ++index < length) {\n      if (predicate(array[index], index, array)) {\n        return index\n      }\n    }\n    return -1\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n      length = array.length\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index\n      }\n    }\n    return -1\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length\n    return !!length && baseIndexOf(array, value, 0) > -1\n  }\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER$1 = 9007199254740991\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    var type = typeof value\n    length = length == null ? MAX_SAFE_INTEGER$1 : length\n\n    return (\n      !!length &&\n      (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&\n      value > -1 &&\n      value % 1 == 0 &&\n      value < length\n    )\n  }\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && defineProperty$1) {\n      defineProperty$1(object, key, {\n        configurable: true,\n        enumerable: true,\n        value: value,\n        writable: true,\n      })\n    } else {\n      object[key] = value\n    }\n  }\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$g = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$e = objectProto$g.hasOwnProperty\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key]\n    if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {\n      baseAssignValue(object, key, value)\n    }\n  }\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object\n    object || (object = {})\n\n    var index = -1,\n      length = props.length\n\n    while (++index < length) {\n      var key = props[index]\n\n      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined\n\n      if (newValue === undefined) {\n        newValue = source[key]\n      }\n      if (isNew) {\n        baseAssignValue(object, key, newValue)\n      } else {\n        assignValue(object, key, newValue)\n      }\n    }\n    return object\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$3 = Math.max\n\n  /**\n   * A specialized version of `baseRest` which transforms the rest array.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @param {Function} transform The rest array transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overRest(func, start, transform) {\n    start = nativeMax$3(start === undefined ? func.length - 1 : start, 0)\n    return function () {\n      var args = arguments,\n        index = -1,\n        length = nativeMax$3(args.length - start, 0),\n        array = Array(length)\n\n      while (++index < length) {\n        array[index] = args[start + index]\n      }\n      index = -1\n      var otherArgs = Array(start + 1)\n      while (++index < start) {\n        otherArgs[index] = args[index]\n      }\n      otherArgs[start] = transform(array)\n      return apply(func, this, otherArgs)\n    }\n  }\n\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n  function baseRest(func, start) {\n    return setToString$1(overRest(func, start, identity), func + '')\n  }\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER\n  }\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value)\n  }\n\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n  function isIterateeCall(value, index, object) {\n    if (!isObject(object)) {\n      return false\n    }\n    var type = typeof index\n    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n      return eq(object[index], value)\n    }\n    return false\n  }\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return baseRest(function (object, sources) {\n      var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined\n\n      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer\n        length = 1\n      }\n      object = Object(object)\n      while (++index < length) {\n        var source = sources[index]\n        if (source) {\n          assigner(object, source, index, customizer)\n        }\n      }\n      return object\n    })\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$f = Object.prototype\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$f\n\n    return value === proto\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n      result = Array(n)\n\n    while (++index < n) {\n      result[index] = iteratee(index)\n    }\n    return result\n  }\n\n  /** `Object#toString` result references. */\n  var argsTag$3 = '[object Arguments]'\n\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag$3\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$e = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$d = objectProto$e.hasOwnProperty\n\n  /** Built-in value references. */\n  var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  var isArguments = baseIsArguments(\n    (function () {\n      return arguments\n    })(),\n  )\n    ? baseIsArguments\n    : function (value) {\n        return (\n          isObjectLike(value) && hasOwnProperty$d.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee')\n        )\n      }\n\n  const isArguments$1 = isArguments\n\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2\n\n  /** Built-in value references. */\n  var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined\n\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n  var isBuffer = nativeIsBuffer || stubFalse\n\n  const isBuffer$1 = isBuffer\n\n  /** `Object#toString` result references. */\n  var argsTag$2 = '[object Arguments]',\n    arrayTag$2 = '[object Array]',\n    boolTag$3 = '[object Boolean]',\n    dateTag$3 = '[object Date]',\n    errorTag$2 = '[object Error]',\n    funcTag$1 = '[object Function]',\n    mapTag$6 = '[object Map]',\n    numberTag$3 = '[object Number]',\n    objectTag$3 = '[object Object]',\n    regexpTag$4 = '[object RegExp]',\n    setTag$6 = '[object Set]',\n    stringTag$4 = '[object String]',\n    weakMapTag$2 = '[object WeakMap]'\n\n  var arrayBufferTag$3 = '[object ArrayBuffer]',\n    dataViewTag$4 = '[object DataView]',\n    float32Tag$2 = '[object Float32Array]',\n    float64Tag$2 = '[object Float64Array]',\n    int8Tag$2 = '[object Int8Array]',\n    int16Tag$2 = '[object Int16Array]',\n    int32Tag$2 = '[object Int32Array]',\n    uint8Tag$2 = '[object Uint8Array]',\n    uint8ClampedTag$2 = '[object Uint8ClampedArray]',\n    uint16Tag$2 = '[object Uint16Array]',\n    uint32Tag$2 = '[object Uint32Array]'\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {}\n  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[\n    int16Tag$2\n  ] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[\n    uint16Tag$2\n  ] = typedArrayTags[uint32Tag$2] = true\n  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[\n    boolTag$3\n  ] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[\n    funcTag$1\n  ] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[\n    regexpTag$4\n  ] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false\n\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function (value) {\n      return func(value)\n    }\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports$1 && freeGlobal$1.process\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function () {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types\n\n      if (types) {\n        return types\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util')\n    } catch (e) {}\n  })()\n\n  const nodeUtil$1 = nodeUtil\n\n  /* Node.js helper references. */\n  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray\n\n  const isTypedArray$1 = isTypedArray\n\n  /** Used for built-in method references. */\n  var objectProto$d = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$c = objectProto$d.hasOwnProperty\n\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray$1(value),\n      isArg = !isArr && isArguments$1(value),\n      isBuff = !isArr && !isArg && isBuffer$1(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length\n\n    for (var key in value) {\n      if (\n        (inherited || hasOwnProperty$c.call(value, key)) &&\n        !(\n          skipIndexes &&\n          // Safari 9 has enumerable `arguments.length` in strict mode.\n          (key == 'length' ||\n            // Node.js 0.10 has enumerable non-index properties on buffers.\n            (isBuff && (key == 'offset' || key == 'parent')) ||\n            // PhantomJS 2 has enumerable non-index properties on typed arrays.\n            (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n            // Skip index properties.\n            isIndex(key, length))\n        )\n      ) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg))\n    }\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeKeys = overArg(Object.keys, Object)\n\n  const nativeKeys$1 = nativeKeys\n\n  /** Used for built-in method references. */\n  var objectProto$c = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$b = objectProto$c.hasOwnProperty\n\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys$1(object)\n    }\n    var result = []\n    for (var key in Object(object)) {\n      if (hasOwnProperty$b.call(object, key) && key != 'constructor') {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$b = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$a = objectProto$b.hasOwnProperty\n\n  /**\n   * Assigns own enumerable string keyed properties of source objects to the\n   * destination object. Source objects are applied from left to right.\n   * Subsequent sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object` and is loosely based on\n   * [`Object.assign`](https://mdn.io/Object/assign).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.10.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.assignIn\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * function Bar() {\n   *   this.c = 3;\n   * }\n   *\n   * Foo.prototype.b = 2;\n   * Bar.prototype.d = 4;\n   *\n   * _.assign({ 'a': 0 }, new Foo, new Bar);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  var assign = createAssigner(function (object, source) {\n    if (isPrototype(source) || isArrayLike(source)) {\n      copyObject(source, keys(source), object)\n      return\n    }\n    for (var key in source) {\n      if (hasOwnProperty$a.call(source, key)) {\n        assignValue(object, key, source[key])\n      }\n    }\n  })\n\n  const assign$1 = assign\n\n  /**\n   * This function is like\n   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * except that it includes inherited enumerable properties.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function nativeKeysIn(object) {\n    var result = []\n    if (object != null) {\n      for (var key in Object(object)) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$a = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$9 = objectProto$a.hasOwnProperty\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    if (!isObject(object)) {\n      return nativeKeysIn(object)\n    }\n    var isProto = isPrototype(object),\n      result = []\n\n    for (var key in object) {\n      if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n  function keysIn(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object)\n  }\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray$1(value)) {\n      return false\n    }\n    var type = typeof value\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object))\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var nativeCreate = getNative(Object, 'create')\n\n  const nativeCreate$1 = nativeCreate\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}\n    this.size = 0\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key]\n    this.size -= result ? 1 : 0\n    return result\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__'\n\n  /** Used for built-in method references. */\n  var objectProto$9 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$8 = objectProto$9.hasOwnProperty\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__\n    if (nativeCreate$1) {\n      var result = data[key]\n      return result === HASH_UNDEFINED$2 ? undefined : result\n    }\n    return hasOwnProperty$8.call(data, key) ? data[key] : undefined\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$8 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$7 = objectProto$8.hasOwnProperty\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__\n    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$7.call(data, key)\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__'\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__\n    this.size += this.has(key) ? 0 : 1\n    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$1 : value\n    return this\n  }\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear\n  Hash.prototype['delete'] = hashDelete\n  Hash.prototype.get = hashGet\n  Hash.prototype.has = hashHas\n  Hash.prototype.set = hashSet\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = []\n    this.size = 0\n  }\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length\n      }\n    }\n    return -1\n  }\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    if (index < 0) {\n      return false\n    }\n    var lastIndex = data.length - 1\n    if (index == lastIndex) {\n      data.pop()\n    } else {\n      splice.call(data, index, 1)\n    }\n    --this.size\n    return true\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    return index < 0 ? undefined : data[index][1]\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    if (index < 0) {\n      ++this.size\n      data.push([key, value])\n    } else {\n      data[index][1] = value\n    }\n    return this\n  }\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear\n  ListCache.prototype['delete'] = listCacheDelete\n  ListCache.prototype.get = listCacheGet\n  ListCache.prototype.has = listCacheHas\n  ListCache.prototype.set = listCacheSet\n\n  /* Built-in method references that are verified to be native. */\n  var Map$1 = getNative(root$1, 'Map')\n\n  const Map$2 = Map$1\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.size = 0\n    this.__data__ = {\n      hash: new Hash(),\n      map: new (Map$2 || ListCache)(),\n      string: new Hash(),\n    }\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'\n      ? value !== '__proto__'\n      : value === null\n  }\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key)\n    this.size -= result ? 1 : 0\n    return result\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key)\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key)\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n      size = data.size\n\n    data.set(key, value)\n    this.size += data.size == size ? 0 : 1\n    return this\n  }\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear\n  MapCache.prototype['delete'] = mapCacheDelete\n  MapCache.prototype.get = mapCacheGet\n  MapCache.prototype.has = mapCacheHas\n  MapCache.prototype.set = mapCacheSet\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT$1 = 'Expected a function'\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT$1)\n    }\n    var memoized = function () {\n      var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache\n\n      if (cache.has(key)) {\n        return cache.get(key)\n      }\n      var result = func.apply(this, args)\n      memoized.cache = cache.set(key, result) || cache\n      return result\n    }\n    memoized.cache = new (memoize.Cache || MapCache)()\n    return memoized\n  }\n\n  // Expose `MapCache`.\n  memoize.Cache = MapCache\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500\n\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear()\n      }\n      return key\n    })\n\n    var cache = result.cache\n    return result\n  }\n\n  /** Used to match property names within property paths. */\n  var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = memoizeCapped(function (string) {\n    var result = []\n    if (string.charCodeAt(0) === 46 /* . */) {\n      result.push('')\n    }\n    string.replace(rePropName, function (match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match)\n    })\n    return result\n  })\n\n  const stringToPath$1 = stringToPath\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value)\n  }\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value, object) {\n    if (isArray$1(value)) {\n      return value\n    }\n    return isKey(value, object) ? [value] : stringToPath$1(toString(value))\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$1 = 1 / 0\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value\n    }\n    var result = value + ''\n    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result\n  }\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = castPath(path, object)\n\n    var index = 0,\n      length = path.length\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])]\n    }\n    return index && index == length ? object : undefined\n  }\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path)\n    return result === undefined ? defaultValue : result\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n      length = values.length,\n      offset = array.length\n\n    while (++index < length) {\n      array[offset + index] = values[index]\n    }\n    return array\n  }\n\n  /** Built-in value references. */\n  var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined\n\n  /**\n   * Checks if `value` is a flattenable `arguments` object or array.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n   */\n  function isFlattenable(value) {\n    return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol])\n  }\n\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n      length = array.length\n\n    predicate || (predicate = isFlattenable)\n    result || (result = [])\n\n    while (++index < length) {\n      var value = array[index]\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result)\n        } else {\n          arrayPush(result, value)\n        }\n      } else if (!isStrict) {\n        result[result.length] = value\n      }\n    }\n    return result\n  }\n\n  /**\n   * Flattens `array` a single level deep.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to flatten.\n   * @returns {Array} Returns the new flattened array.\n   * @example\n   *\n   * _.flatten([1, [2, [3, [4]], 5]]);\n   * // => [1, 2, [3, [4]], 5]\n   */\n  function flatten(array) {\n    var length = array == null ? 0 : array.length\n    return length ? baseFlatten(array, 1) : []\n  }\n\n  /** Built-in value references. */\n  var getPrototype = overArg(Object.getPrototypeOf, Object)\n\n  const getPrototype$1 = getPrototype\n\n  /**\n   * The base implementation of `_.slice` without an iteratee call guard.\n   *\n   * @private\n   * @param {Array} array The array to slice.\n   * @param {number} [start=0] The start position.\n   * @param {number} [end=array.length] The end position.\n   * @returns {Array} Returns the slice of `array`.\n   */\n  function baseSlice(array, start, end) {\n    var index = -1,\n      length = array.length\n\n    if (start < 0) {\n      start = -start > length ? 0 : length + start\n    }\n    end = end > length ? length : end\n    if (end < 0) {\n      end += length\n    }\n    length = start > end ? 0 : (end - start) >>> 0\n    start >>>= 0\n\n    var result = Array(length)\n    while (++index < length) {\n      result[index] = array[index + start]\n    }\n    return result\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    if (initAccum && length) {\n      accumulator = array[++index]\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array)\n    }\n    return accumulator\n  }\n\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n  function stackClear() {\n    this.__data__ = new ListCache()\n    this.size = 0\n  }\n\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function stackDelete(key) {\n    var data = this.__data__,\n      result = data['delete'](key)\n\n    this.size = data.size\n    return result\n  }\n\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function stackGet(key) {\n    return this.__data__.get(key)\n  }\n\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function stackHas(key) {\n    return this.__data__.has(key)\n  }\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE$2 = 200\n\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n  function stackSet(key, value) {\n    var data = this.__data__\n    if (data instanceof ListCache) {\n      var pairs = data.__data__\n      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {\n        pairs.push([key, value])\n        this.size = ++data.size\n        return this\n      }\n      data = this.__data__ = new MapCache(pairs)\n    }\n    data.set(key, value)\n    this.size = data.size\n    return this\n  }\n\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Stack(entries) {\n    var data = (this.__data__ = new ListCache(entries))\n    this.size = data.size\n  }\n\n  // Add methods to `Stack`.\n  Stack.prototype.clear = stackClear\n  Stack.prototype['delete'] = stackDelete\n  Stack.prototype.get = stackGet\n  Stack.prototype.has = stackHas\n  Stack.prototype.set = stackSet\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object)\n  }\n\n  /**\n   * The base implementation of `_.assignIn` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssignIn(object, source) {\n    return object && copyObject(source, keysIn(source), object)\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root$1.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice()\n    }\n    var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length)\n\n    buffer.copy(result)\n    return result\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = []\n\n    while (++index < length) {\n      var value = array[index]\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value\n      }\n    }\n    return result\n  }\n\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n  function stubArray() {\n    return []\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$7 = Object.prototype\n\n  /** Built-in value references. */\n  var propertyIsEnumerable = objectProto$7.propertyIsEnumerable\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols$1 = Object.getOwnPropertySymbols\n\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbols = !nativeGetSymbols$1\n    ? stubArray\n    : function (object) {\n        if (object == null) {\n          return []\n        }\n        object = Object(object)\n        return arrayFilter(nativeGetSymbols$1(object), function (symbol) {\n          return propertyIsEnumerable.call(object, symbol)\n        })\n      }\n\n  const getSymbols$1 = getSymbols\n\n  /**\n   * Copies own symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols$1(source), object)\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols = Object.getOwnPropertySymbols\n\n  /**\n   * Creates an array of the own and inherited enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbolsIn = !nativeGetSymbols\n    ? stubArray\n    : function (object) {\n        var result = []\n        while (object) {\n          arrayPush(result, getSymbols$1(object))\n          object = getPrototype$1(object)\n        }\n        return result\n      }\n\n  const getSymbolsIn$1 = getSymbolsIn\n\n  /**\n   * Copies own and inherited symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbolsIn(source, object) {\n    return copyObject(source, getSymbolsIn$1(source), object)\n  }\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object)\n    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object))\n  }\n\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols$1)\n  }\n\n  /**\n   * Creates an array of own and inherited enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeysIn(object) {\n    return baseGetAllKeys(object, keysIn, getSymbolsIn$1)\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var DataView = getNative(root$1, 'DataView')\n\n  const DataView$1 = DataView\n\n  /* Built-in method references that are verified to be native. */\n  var Promise$1 = getNative(root$1, 'Promise')\n\n  const Promise$2 = Promise$1\n\n  /* Built-in method references that are verified to be native. */\n  var Set = getNative(root$1, 'Set')\n\n  const Set$1 = Set\n\n  /** `Object#toString` result references. */\n  var mapTag$5 = '[object Map]',\n    objectTag$2 = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag$5 = '[object Set]',\n    weakMapTag$1 = '[object WeakMap]'\n\n  var dataViewTag$3 = '[object DataView]'\n\n  /** Used to detect maps, sets, and weakmaps. */\n  var dataViewCtorString = toSource(DataView$1),\n    mapCtorString = toSource(Map$2),\n    promiseCtorString = toSource(Promise$2),\n    setCtorString = toSource(Set$1),\n    weakMapCtorString = toSource(WeakMap$1)\n\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  var getTag = baseGetTag\n\n  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n  if (\n    (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3) ||\n    (Map$2 && getTag(new Map$2()) != mapTag$5) ||\n    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||\n    (Set$1 && getTag(new Set$1()) != setTag$5) ||\n    (WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1)\n  ) {\n    getTag = function (value) {\n      var result = baseGetTag(value),\n        Ctor = result == objectTag$2 ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : ''\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag$3\n          case mapCtorString:\n            return mapTag$5\n          case promiseCtorString:\n            return promiseTag\n          case setCtorString:\n            return setTag$5\n          case weakMapCtorString:\n            return weakMapTag$1\n        }\n      }\n      return result\n    }\n  }\n\n  const getTag$1 = getTag\n\n  /** Used for built-in method references. */\n  var objectProto$6 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$6 = objectProto$6.hasOwnProperty\n\n  /**\n   * Initializes an array clone.\n   *\n   * @private\n   * @param {Array} array The array to clone.\n   * @returns {Array} Returns the initialized clone.\n   */\n  function initCloneArray(array) {\n    var length = array.length,\n      result = new array.constructor(length)\n\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty$6.call(array, 'index')) {\n      result.index = array.index\n      result.input = array.input\n    }\n    return result\n  }\n\n  /** Built-in value references. */\n  var Uint8Array = root$1.Uint8Array\n\n  const Uint8Array$1 = Uint8Array\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength)\n    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer))\n    return result\n  }\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)\n  }\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp))\n    result.lastIndex = regexp.lastIndex\n    return result\n  }\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {}\n  }\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)\n  }\n\n  /** `Object#toString` result references. */\n  var boolTag$2 = '[object Boolean]',\n    dateTag$2 = '[object Date]',\n    mapTag$4 = '[object Map]',\n    numberTag$2 = '[object Number]',\n    regexpTag$3 = '[object RegExp]',\n    setTag$4 = '[object Set]',\n    stringTag$3 = '[object String]',\n    symbolTag$2 = '[object Symbol]'\n\n  var arrayBufferTag$2 = '[object ArrayBuffer]',\n    dataViewTag$2 = '[object DataView]',\n    float32Tag$1 = '[object Float32Array]',\n    float64Tag$1 = '[object Float64Array]',\n    int8Tag$1 = '[object Int8Array]',\n    int16Tag$1 = '[object Int16Array]',\n    int32Tag$1 = '[object Int32Array]',\n    uint8Tag$1 = '[object Uint8Array]',\n    uint8ClampedTag$1 = '[object Uint8ClampedArray]',\n    uint16Tag$1 = '[object Uint16Array]',\n    uint32Tag$1 = '[object Uint32Array]'\n\n  /**\n   * Initializes an object clone based on its `toStringTag`.\n   *\n   * **Note:** This function only supports cloning values with tags of\n   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {string} tag The `toStringTag` of the object to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneByTag(object, tag, isDeep) {\n    var Ctor = object.constructor\n    switch (tag) {\n      case arrayBufferTag$2:\n        return cloneArrayBuffer(object)\n\n      case boolTag$2:\n      case dateTag$2:\n        return new Ctor(+object)\n\n      case dataViewTag$2:\n        return cloneDataView(object, isDeep)\n\n      case float32Tag$1:\n      case float64Tag$1:\n      case int8Tag$1:\n      case int16Tag$1:\n      case int32Tag$1:\n      case uint8Tag$1:\n      case uint8ClampedTag$1:\n      case uint16Tag$1:\n      case uint32Tag$1:\n        return cloneTypedArray(object, isDeep)\n\n      case mapTag$4:\n        return new Ctor()\n\n      case numberTag$2:\n      case stringTag$3:\n        return new Ctor(object)\n\n      case regexpTag$3:\n        return cloneRegExp(object)\n\n      case setTag$4:\n        return new Ctor()\n\n      case symbolTag$2:\n        return cloneSymbol(object)\n    }\n  }\n\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneObject(object) {\n    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {}\n  }\n\n  /** `Object#toString` result references. */\n  var mapTag$3 = '[object Map]'\n\n  /**\n   * The base implementation of `_.isMap` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   */\n  function baseIsMap(value) {\n    return isObjectLike(value) && getTag$1(value) == mapTag$3\n  }\n\n  /* Node.js helper references. */\n  var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap\n\n  /**\n   * Checks if `value` is classified as a `Map` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   * @example\n   *\n   * _.isMap(new Map);\n   * // => true\n   *\n   * _.isMap(new WeakMap);\n   * // => false\n   */\n  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap\n\n  const isMap$1 = isMap\n\n  /** `Object#toString` result references. */\n  var setTag$3 = '[object Set]'\n\n  /**\n   * The base implementation of `_.isSet` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   */\n  function baseIsSet(value) {\n    return isObjectLike(value) && getTag$1(value) == setTag$3\n  }\n\n  /* Node.js helper references. */\n  var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet\n\n  /**\n   * Checks if `value` is classified as a `Set` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   * @example\n   *\n   * _.isSet(new Set);\n   * // => true\n   *\n   * _.isSet(new WeakSet);\n   * // => false\n   */\n  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet\n\n  const isSet$1 = isSet\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG$1 = 4\n\n  /** `Object#toString` result references. */\n  var argsTag$1 = '[object Arguments]',\n    arrayTag$1 = '[object Array]',\n    boolTag$1 = '[object Boolean]',\n    dateTag$1 = '[object Date]',\n    errorTag$1 = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag$2 = '[object Map]',\n    numberTag$1 = '[object Number]',\n    objectTag$1 = '[object Object]',\n    regexpTag$2 = '[object RegExp]',\n    setTag$2 = '[object Set]',\n    stringTag$2 = '[object String]',\n    symbolTag$1 = '[object Symbol]',\n    weakMapTag = '[object WeakMap]'\n\n  var arrayBufferTag$1 = '[object ArrayBuffer]',\n    dataViewTag$1 = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]'\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {}\n  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[\n    dataViewTag$1\n  ] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[\n    float64Tag\n  ] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[\n    mapTag$2\n  ] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[\n    setTag$2\n  ] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[\n    uint8ClampedTag\n  ] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true\n  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Deep clone\n   *  2 - Flatten inherited properties\n   *  4 - Clone symbols\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, bitmask, customizer, key, object, stack) {\n    var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG$1\n\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value)\n    }\n    if (result !== undefined) {\n      return result\n    }\n    if (!isObject(value)) {\n      return value\n    }\n    var isArr = isArray$1(value)\n    if (isArr) {\n      result = initCloneArray(value)\n      if (!isDeep) {\n        return copyArray(value, result)\n      }\n    } else {\n      var tag = getTag$1(value),\n        isFunc = tag == funcTag || tag == genTag\n\n      if (isBuffer$1(value)) {\n        return cloneBuffer(value, isDeep)\n      }\n      if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {\n        result = isFlat || isFunc ? {} : initCloneObject(value)\n        if (!isDeep) {\n          return isFlat\n            ? copySymbolsIn(value, baseAssignIn(result, value))\n            : copySymbols(value, baseAssign(result, value))\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {}\n        }\n        result = initCloneByTag(value, tag, isDeep)\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack())\n    var stacked = stack.get(value)\n    if (stacked) {\n      return stacked\n    }\n    stack.set(value, result)\n\n    if (isSet$1(value)) {\n      value.forEach(function (subValue) {\n        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))\n      })\n    } else if (isMap$1(value)) {\n      value.forEach(function (subValue, key) {\n        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))\n      })\n    }\n\n    var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys\n\n    var props = isArr ? undefined : keysFunc(value)\n    arrayEach(props || value, function (subValue, key) {\n      if (props) {\n        key = subValue\n        subValue = value[key]\n      }\n      // Recursively populate clone (susceptible to call stack limits).\n      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))\n    })\n    return result\n  }\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_SYMBOLS_FLAG = 4\n\n  /**\n   * Creates a shallow clone of `value`.\n   *\n   * **Note:** This method is loosely based on the\n   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n   * and supports cloning arrays, array buffers, booleans, date objects, maps,\n   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n   * arrays. The own enumerable properties of `arguments` objects are cloned\n   * as plain objects. An empty object is returned for uncloneable values such\n   * as error objects, functions, DOM nodes, and WeakMaps.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to clone.\n   * @returns {*} Returns the cloned value.\n   * @see _.cloneDeep\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var shallow = _.clone(objects);\n   * console.log(shallow[0] === objects[0]);\n   * // => true\n   */\n  function clone(value) {\n    return baseClone(value, CLONE_SYMBOLS_FLAG)\n  }\n\n  /**\n   * Creates an array with all falsey values removed. The values `false`, `null`,\n   * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to compact.\n   * @returns {Array} Returns the new array of filtered values.\n   * @example\n   *\n   * _.compact([0, 1, false, 2, '', 3]);\n   * // => [1, 2, 3]\n   */\n  function compact(array) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = []\n\n    while (++index < length) {\n      var value = array[index]\n      if (value) {\n        result[resIndex++] = value\n      }\n    }\n    return result\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__'\n\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED)\n    return this\n  }\n\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n  function setCacheHas(value) {\n    return this.__data__.has(value)\n  }\n\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n  function SetCache(values) {\n    var index = -1,\n      length = values == null ? 0 : values.length\n\n    this.__data__ = new MapCache()\n    while (++index < length) {\n      this.add(values[index])\n    }\n  }\n\n  // Add methods to `SetCache`.\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd\n  SetCache.prototype.has = setCacheHas\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$5 = 1,\n    COMPARE_UNORDERED_FLAG$3 = 2\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,\n      arrLength = array.length,\n      othLength = other.length\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false\n    }\n    // Check that cyclic values are equal.\n    var arrStacked = stack.get(array)\n    var othStacked = stack.get(other)\n    if (arrStacked && othStacked) {\n      return arrStacked == other && othStacked == array\n    }\n    var index = -1,\n      result = true,\n      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined\n\n    stack.set(array, other)\n    stack.set(other, array)\n\n    // Ignore non-index properties.\n    while (++index < arrLength) {\n      var arrValue = array[index],\n        othValue = other[index]\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, arrValue, index, other, array, stack)\n          : customizer(arrValue, othValue, index, array, other, stack)\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue\n        }\n        result = false\n        break\n      }\n      // Recursively compare arrays (susceptible to call stack limits).\n      if (seen) {\n        if (\n          !arraySome(other, function (othValue, othIndex) {\n            if (\n              !cacheHas(seen, othIndex) &&\n              (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))\n            ) {\n              return seen.push(othIndex)\n            }\n          })\n        ) {\n          result = false\n          break\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false\n        break\n      }\n    }\n    stack['delete'](array)\n    stack['delete'](other)\n    return result\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n      result = Array(map.size)\n\n    map.forEach(function (value, key) {\n      result[++index] = [key, value]\n    })\n    return result\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n      result = Array(set.size)\n\n    set.forEach(function (value) {\n      result[++index] = value\n    })\n    return result\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$4 = 1,\n    COMPARE_UNORDERED_FLAG$2 = 2\n\n  /** `Object#toString` result references. */\n  var boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag$1 = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag$1 = '[object RegExp]',\n    setTag$1 = '[object Set]',\n    stringTag$1 = '[object String]',\n    symbolTag = '[object Symbol]'\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]'\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false\n        }\n        object = object.buffer\n        other = other.buffer\n\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n          return false\n        }\n        return true\n\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        // Coerce booleans to `1` or `0` and dates to milliseconds.\n        // Invalid dates are coerced to `NaN`.\n        return eq(+object, +other)\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message\n\n      case regexpTag$1:\n      case stringTag$1:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == other + ''\n\n      case mapTag$1:\n        var convert = mapToArray\n\n      case setTag$1:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4\n        convert || (convert = setToArray)\n\n        if (object.size != other.size && !isPartial) {\n          return false\n        }\n        // Assume cyclic values are equal.\n        var stacked = stack.get(object)\n        if (stacked) {\n          return stacked == other\n        }\n        bitmask |= COMPARE_UNORDERED_FLAG$2\n\n        // Recursively compare objects (susceptible to call stack limits).\n        stack.set(object, other)\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack)\n        stack['delete'](object)\n        return result\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other)\n        }\n    }\n    return false\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$3 = 1\n\n  /** Used for built-in method references. */\n  var objectProto$5 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$5 = objectProto$5.hasOwnProperty\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length\n\n    if (objLength != othLength && !isPartial) {\n      return false\n    }\n    var index = objLength\n    while (index--) {\n      var key = objProps[index]\n      if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n        return false\n      }\n    }\n    // Check that cyclic values are equal.\n    var objStacked = stack.get(object)\n    var othStacked = stack.get(other)\n    if (objStacked && othStacked) {\n      return objStacked == other && othStacked == object\n    }\n    var result = true\n    stack.set(object, other)\n    stack.set(other, object)\n\n    var skipCtor = isPartial\n    while (++index < objLength) {\n      key = objProps[index]\n      var objValue = object[key],\n        othValue = other[key]\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, objValue, key, other, object, stack)\n          : customizer(objValue, othValue, key, object, other, stack)\n      }\n      // Recursively compare objects (susceptible to call stack limits).\n      if (\n        !(compared === undefined\n          ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)\n          : compared)\n      ) {\n        result = false\n        break\n      }\n      skipCtor || (skipCtor = key == 'constructor')\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n        othCtor = other.constructor\n\n      // Non `Object` object instances with different constructors are not equal.\n      if (\n        objCtor != othCtor &&\n        'constructor' in object &&\n        'constructor' in other &&\n        !(\n          typeof objCtor == 'function' &&\n          objCtor instanceof objCtor &&\n          typeof othCtor == 'function' &&\n          othCtor instanceof othCtor\n        )\n      ) {\n        result = false\n      }\n    }\n    stack['delete'](object)\n    stack['delete'](other)\n    return result\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$2 = 1\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]'\n\n  /** Used for built-in method references. */\n  var objectProto$4 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$4 = objectProto$4.hasOwnProperty\n\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray$1(object),\n      othIsArr = isArray$1(other),\n      objTag = objIsArr ? arrayTag : getTag$1(object),\n      othTag = othIsArr ? arrayTag : getTag$1(other)\n\n    objTag = objTag == argsTag ? objectTag : objTag\n    othTag = othTag == argsTag ? objectTag : othTag\n\n    var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag\n\n    if (isSameTag && isBuffer$1(object)) {\n      if (!isBuffer$1(other)) {\n        return false\n      }\n      objIsArr = true\n      objIsObj = false\n    }\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack())\n      return objIsArr || isTypedArray$1(object)\n        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n      var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__')\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other\n\n        stack || (stack = new Stack())\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)\n      }\n    }\n    if (!isSameTag) {\n      return false\n    }\n    stack || (stack = new Stack())\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack)\n  }\n\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Unordered comparison\n   *  2 - Partial comparison\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true\n    }\n    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n      return value !== value && other !== other\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$1 = 1,\n    COMPARE_UNORDERED_FLAG$1 = 2\n\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer\n\n    if (object == null) {\n      return !length\n    }\n    object = Object(object)\n    while (index--) {\n      var data = matchData[index]\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false\n      }\n    }\n    while (++index < length) {\n      data = matchData[index]\n      var key = data[0],\n        objValue = object[key],\n        srcValue = data[1]\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false\n        }\n      } else {\n        var stack = new Stack()\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack)\n        }\n        if (\n          !(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)\n            : result)\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n  function isStrictComparable(value) {\n    return value === value && !isObject(value)\n  }\n\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n  function getMatchData(object) {\n    var result = keys(object),\n      length = result.length\n\n    while (length--) {\n      var key = result[length],\n        value = object[key]\n\n      result[length] = [key, value, isStrictComparable(value)]\n    }\n    return result\n  }\n\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false\n      }\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object))\n    }\n  }\n\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatches(source) {\n    var matchData = getMatchData(source)\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1])\n    }\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData)\n    }\n  }\n\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object)\n  }\n\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object)\n\n    var index = -1,\n      length = path.length,\n      result = false\n\n    while (++index < length) {\n      var key = toKey(path[index])\n      if (!(result = object != null && hasFunc(object, key))) {\n        break\n      }\n      object = object[key]\n    }\n    if (result || ++index != length) {\n      return result\n    }\n    length = object == null ? 0 : object.length\n    return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object))\n  }\n\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2\n\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue)\n    }\n    return function (object) {\n      var objValue = get(object, path)\n      return objValue === undefined && objValue === srcValue\n        ? hasIn(object, path)\n        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)\n    }\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key]\n    }\n  }\n\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path)\n    }\n  }\n\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)\n  }\n\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value\n    }\n    if (value == null) {\n      return identity\n    }\n    if (typeof value == 'object') {\n      return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value)\n    }\n    return property(value)\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      var value = array[index]\n      setter(accumulator, value, iteratee(value), array)\n    }\n    return accumulator\n  }\n\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index]\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break\n        }\n      }\n      return object\n    }\n  }\n\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseFor = createBaseFor()\n\n  const baseFor$1 = baseFor\n\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwn(object, iteratee) {\n    return object && baseFor$1(object, iteratee, keys)\n  }\n\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee)\n      }\n      var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection)\n\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break\n        }\n      }\n      return collection\n    }\n  }\n\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEach = createBaseEach(baseForOwn)\n\n  const baseEach$1 = baseEach\n\n  /**\n   * Aggregates elements of `collection` on `accumulator` with keys transformed\n   * by `iteratee` and values set by `setter`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function baseAggregator(collection, setter, iteratee, accumulator) {\n    baseEach$1(collection, function (value, key, collection) {\n      setter(accumulator, value, iteratee(value), collection)\n    })\n    return accumulator\n  }\n\n  /**\n   * Creates a function like `_.groupBy`.\n   *\n   * @private\n   * @param {Function} setter The function to set accumulator values.\n   * @param {Function} [initializer] The accumulator object initializer.\n   * @returns {Function} Returns the new aggregator function.\n   */\n  function createAggregator(setter, initializer) {\n    return function (collection, iteratee) {\n      var func = isArray$1(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {}\n\n      return func(collection, setter, baseIteratee(iteratee), accumulator)\n    }\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$3 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$3 = objectProto$3.hasOwnProperty\n\n  /**\n   * Assigns own and inherited enumerable string keyed properties of source\n   * objects to the destination object for all destination properties that\n   * resolve to `undefined`. Source objects are applied from left to right.\n   * Once a property is set, additional values of the same property are ignored.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.defaultsDeep\n   * @example\n   *\n   * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n   * // => { 'a': 1, 'b': 2 }\n   */\n  var defaults = baseRest(function (object, sources) {\n    object = Object(object)\n\n    var index = -1\n    var length = sources.length\n    var guard = length > 2 ? sources[2] : undefined\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      length = 1\n    }\n\n    while (++index < length) {\n      var source = sources[index]\n      var props = keysIn(source)\n      var propsIndex = -1\n      var propsLength = props.length\n\n      while (++propsIndex < propsLength) {\n        var key = props[propsIndex]\n        var value = object[key]\n\n        if (value === undefined || (eq(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key))) {\n          object[key] = source[key]\n        }\n      }\n    }\n\n    return object\n  })\n\n  const defaults$1 = defaults\n\n  /**\n   * This method is like `_.isArrayLike` except that it also checks if `value`\n   * is an object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array-like object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArrayLikeObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLikeObject(document.body.children);\n   * // => true\n   *\n   * _.isArrayLikeObject('abc');\n   * // => false\n   *\n   * _.isArrayLikeObject(_.noop);\n   * // => false\n   */\n  function isArrayLikeObject(value) {\n    return isObjectLike(value) && isArrayLike(value)\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE$1 = 200\n\n  /**\n   * The base implementation of methods like `_.difference` without support\n   * for excluding multiple arrays or iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Array} values The values to exclude.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new array of filtered values.\n   */\n  function baseDifference(array, values, iteratee, comparator) {\n    var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length\n\n    if (!length) {\n      return result\n    }\n    if (iteratee) {\n      values = arrayMap(values, baseUnary(iteratee))\n    }\n    if (comparator) {\n      includes = arrayIncludesWith\n      isCommon = false\n    } else if (values.length >= LARGE_ARRAY_SIZE$1) {\n      includes = cacheHas\n      isCommon = false\n      values = new SetCache(values)\n    }\n    outer: while (++index < length) {\n      var value = array[index],\n        computed = iteratee == null ? value : iteratee(value)\n\n      value = comparator || value !== 0 ? value : 0\n      if (isCommon && computed === computed) {\n        var valuesIndex = valuesLength\n        while (valuesIndex--) {\n          if (values[valuesIndex] === computed) {\n            continue outer\n          }\n        }\n        result.push(value)\n      } else if (!includes(values, computed, comparator)) {\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of `array` values not included in the other given arrays\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons. The order and references of result values are\n   * determined by the first array.\n   *\n   * **Note:** Unlike `_.pullAll`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {...Array} [values] The values to exclude.\n   * @returns {Array} Returns the new array of filtered values.\n   * @see _.without, _.xor\n   * @example\n   *\n   * _.difference([2, 1], [2, 3]);\n   * // => [1]\n   */\n  var difference = baseRest(function (array, values) {\n    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []\n  })\n\n  const difference$1 = difference\n\n  /**\n   * Gets the last element of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @returns {*} Returns the last element of `array`.\n   * @example\n   *\n   * _.last([1, 2, 3]);\n   * // => 3\n   */\n  function last(array) {\n    var length = array == null ? 0 : array.length\n    return length ? array[length - 1] : undefined\n  }\n\n  /**\n   * Creates a slice of `array` with `n` elements dropped from the beginning.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @param {number} [n=1] The number of elements to drop.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the slice of `array`.\n   * @example\n   *\n   * _.drop([1, 2, 3]);\n   * // => [2, 3]\n   *\n   * _.drop([1, 2, 3], 2);\n   * // => [3]\n   *\n   * _.drop([1, 2, 3], 5);\n   * // => []\n   *\n   * _.drop([1, 2, 3], 0);\n   * // => [1, 2, 3]\n   */\n  function drop(array, n, guard) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return []\n    }\n    n = guard || n === undefined ? 1 : toInteger(n)\n    return baseSlice(array, n < 0 ? 0 : n, length)\n  }\n\n  /**\n   * Creates a slice of `array` with `n` elements dropped from the end.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @param {number} [n=1] The number of elements to drop.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the slice of `array`.\n   * @example\n   *\n   * _.dropRight([1, 2, 3]);\n   * // => [1, 2]\n   *\n   * _.dropRight([1, 2, 3], 2);\n   * // => [1]\n   *\n   * _.dropRight([1, 2, 3], 5);\n   * // => []\n   *\n   * _.dropRight([1, 2, 3], 0);\n   * // => [1, 2, 3]\n   */\n  function dropRight(array, n, guard) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return []\n    }\n    n = guard || n === undefined ? 1 : toInteger(n)\n    n = length - n\n    return baseSlice(array, 0, n < 0 ? 0 : n)\n  }\n\n  /**\n   * Casts `value` to `identity` if it's not a function.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Function} Returns cast function.\n   */\n  function castFunction(value) {\n    return typeof value == 'function' ? value : identity\n  }\n\n  /**\n   * Iterates over elements of `collection` and invokes `iteratee` for each element.\n   * The iteratee is invoked with three arguments: (value, index|key, collection).\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n   * property are iterated like arrays. To avoid this behavior use `_.forIn`\n   * or `_.forOwn` for object iteration.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias each\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   * @see _.forEachRight\n   * @example\n   *\n   * _.forEach([1, 2], function(value) {\n   *   console.log(value);\n   * });\n   * // => Logs `1` then `2`.\n   *\n   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n   *   console.log(key);\n   * });\n   * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n   */\n  function forEach(collection, iteratee) {\n    var func = isArray$1(collection) ? arrayEach : baseEach$1\n    return func(collection, castFunction(iteratee))\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * The base implementation of `_.every` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`\n   */\n  function baseEvery(collection, predicate) {\n    var result = true\n    baseEach$1(collection, function (value, index, collection) {\n      result = !!predicate(value, index, collection)\n      return result\n    })\n    return result\n  }\n\n  /**\n   * Checks if `predicate` returns truthy for **all** elements of `collection`.\n   * Iteration is stopped once `predicate` returns falsey. The predicate is\n   * invoked with three arguments: (value, index|key, collection).\n   *\n   * **Note:** This method returns `true` for\n   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n   * elements of empty collections.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   * @example\n   *\n   * _.every([true, 1, null, 'yes'], Boolean);\n   * // => false\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': false },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.every(users, { 'user': 'barney', 'active': false });\n   * // => false\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.every(users, ['active', false]);\n   * // => true\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.every(users, 'active');\n   * // => false\n   */\n  function every(collection, predicate, guard) {\n    var func = isArray$1(collection) ? arrayEvery : baseEvery\n    if (guard && isIterateeCall(collection, predicate, guard)) {\n      predicate = undefined\n    }\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /**\n   * The base implementation of `_.filter` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function baseFilter(collection, predicate) {\n    var result = []\n    baseEach$1(collection, function (value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value)\n      }\n    })\n    return result\n  }\n\n  /**\n   * Iterates over elements of `collection`, returning an array of all elements\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * **Note:** Unlike `_.remove`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.reject\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': true },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * _.filter(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.filter(users, { 'age': 36, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.filter(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.filter(users, 'active');\n   * // => objects for ['barney']\n   *\n   * // Combining several predicates using `_.overEvery` or `_.overSome`.\n   * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n   * // => objects for ['fred', 'barney']\n   */\n  function filter(collection, predicate) {\n    var func = isArray$1(collection) ? arrayFilter : baseFilter\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /**\n   * Creates a `_.find` or `_.findLast` function.\n   *\n   * @private\n   * @param {Function} findIndexFunc The function to find the collection index.\n   * @returns {Function} Returns the new find function.\n   */\n  function createFind(findIndexFunc) {\n    return function (collection, predicate, fromIndex) {\n      var iterable = Object(collection)\n      if (!isArrayLike(collection)) {\n        var iteratee = baseIteratee(predicate)\n        collection = keys(collection)\n        predicate = function (key) {\n          return iteratee(iterable[key], key, iterable)\n        }\n      }\n      var index = findIndexFunc(collection, predicate, fromIndex)\n      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined\n    }\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$2 = Math.max\n\n  /**\n   * This method is like `_.find` except that it returns the index of the first\n   * element `predicate` returns truthy for instead of the element itself.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the found element, else `-1`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'active': false },\n   *   { 'user': 'fred',    'active': false },\n   *   { 'user': 'pebbles', 'active': true }\n   * ];\n   *\n   * _.findIndex(users, function(o) { return o.user == 'barney'; });\n   * // => 0\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.findIndex(users, { 'user': 'fred', 'active': false });\n   * // => 1\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.findIndex(users, ['active', false]);\n   * // => 0\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.findIndex(users, 'active');\n   * // => 2\n   */\n  function findIndex(array, predicate, fromIndex) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return -1\n    }\n    var index = fromIndex == null ? 0 : toInteger(fromIndex)\n    if (index < 0) {\n      index = nativeMax$2(length + index, 0)\n    }\n    return baseFindIndex(array, baseIteratee(predicate), index)\n  }\n\n  /**\n   * Iterates over elements of `collection`, returning the first element\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {*} Returns the matched element, else `undefined`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'age': 36, 'active': true },\n   *   { 'user': 'fred',    'age': 40, 'active': false },\n   *   { 'user': 'pebbles', 'age': 1,  'active': true }\n   * ];\n   *\n   * _.find(users, function(o) { return o.age < 40; });\n   * // => object for 'barney'\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.find(users, { 'age': 1, 'active': true });\n   * // => object for 'pebbles'\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.find(users, ['active', false]);\n   * // => object for 'fred'\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.find(users, 'active');\n   * // => object for 'barney'\n   */\n  var find = createFind(findIndex)\n\n  const find$1 = find\n\n  /**\n   * Gets the first element of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias first\n   * @category Array\n   * @param {Array} array The array to query.\n   * @returns {*} Returns the first element of `array`.\n   * @example\n   *\n   * _.head([1, 2, 3]);\n   * // => 1\n   *\n   * _.head([]);\n   * // => undefined\n   */\n  function head(array) {\n    return array && array.length ? array[0] : undefined\n  }\n\n  /**\n   * The base implementation of `_.map` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function baseMap(collection, iteratee) {\n    var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : []\n\n    baseEach$1(collection, function (value, key, collection) {\n      result[++index] = iteratee(value, key, collection)\n    })\n    return result\n  }\n\n  /**\n   * Creates an array of values by running each element in `collection` thru\n   * `iteratee`. The iteratee is invoked with three arguments:\n   * (value, index|key, collection).\n   *\n   * Many lodash methods are guarded to work as iteratees for methods like\n   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n   *\n   * The guarded methods are:\n   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   * @example\n   *\n   * function square(n) {\n   *   return n * n;\n   * }\n   *\n   * _.map([4, 8], square);\n   * // => [16, 64]\n   *\n   * _.map({ 'a': 4, 'b': 8 }, square);\n   * // => [16, 64] (iteration order is not guaranteed)\n   *\n   * var users = [\n   *   { 'user': 'barney' },\n   *   { 'user': 'fred' }\n   * ];\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.map(users, 'user');\n   * // => ['barney', 'fred']\n   */\n  function map(collection, iteratee) {\n    var func = isArray$1(collection) ? arrayMap : baseMap\n    return func(collection, baseIteratee(iteratee))\n  }\n\n  /**\n   * Creates a flattened array of values by running each element in `collection`\n   * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n   * with three arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new flattened array.\n   * @example\n   *\n   * function duplicate(n) {\n   *   return [n, n];\n   * }\n   *\n   * _.flatMap([1, 2], duplicate);\n   * // => [1, 1, 2, 2]\n   */\n  function flatMap(collection, iteratee) {\n    return baseFlatten(map(collection, iteratee), 1)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$2 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$2 = objectProto$2.hasOwnProperty\n\n  /**\n   * Creates an object composed of keys generated from the results of running\n   * each element of `collection` thru `iteratee`. The order of grouped values\n   * is determined by the order they occur in `collection`. The corresponding\n   * value of each key is an array of elements responsible for generating the\n   * key. The iteratee is invoked with one argument: (value).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n   * @returns {Object} Returns the composed aggregate object.\n   * @example\n   *\n   * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n   * // => { '4': [4.2], '6': [6.1, 6.3] }\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.groupBy(['one', 'two', 'three'], 'length');\n   * // => { '3': ['one', 'two'], '5': ['three'] }\n   */\n  var groupBy = createAggregator(function (result, value, key) {\n    if (hasOwnProperty$2.call(result, key)) {\n      result[key].push(value)\n    } else {\n      baseAssignValue(result, key, [value])\n    }\n  })\n\n  const groupBy$1 = groupBy\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$1 = objectProto$1.hasOwnProperty\n\n  /**\n   * The base implementation of `_.has` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHas(object, key) {\n    return object != null && hasOwnProperty$1.call(object, key)\n  }\n\n  /**\n   * Checks if `path` is a direct property of `object`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = { 'a': { 'b': 2 } };\n   * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.has(object, 'a');\n   * // => true\n   *\n   * _.has(object, 'a.b');\n   * // => true\n   *\n   * _.has(object, ['a', 'b']);\n   * // => true\n   *\n   * _.has(other, 'a');\n   * // => false\n   */\n  function has(object, path) {\n    return object != null && hasPath(object, path, baseHas)\n  }\n\n  /** `Object#toString` result references. */\n  var stringTag = '[object String]'\n\n  /**\n   * Checks if `value` is classified as a `String` primitive or object.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n   * @example\n   *\n   * _.isString('abc');\n   * // => true\n   *\n   * _.isString(1);\n   * // => false\n   */\n  function isString(value) {\n    return typeof value == 'string' || (!isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag)\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function (key) {\n      return object[key]\n    })\n  }\n\n  /**\n   * Creates an array of the own enumerable string keyed property values of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property values.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.values(new Foo);\n   * // => [1, 2] (iteration order is not guaranteed)\n   *\n   * _.values('hi');\n   * // => ['h', 'i']\n   */\n  function values(object) {\n    return object == null ? [] : baseValues(object, keys(object))\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$1 = Math.max\n\n  /**\n   * Checks if `value` is in `collection`. If `collection` is a string, it's\n   * checked for a substring of `value`, otherwise\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * is used for equality comparisons. If `fromIndex` is negative, it's used as\n   * the offset from the end of `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object|string} collection The collection to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n   * @returns {boolean} Returns `true` if `value` is found, else `false`.\n   * @example\n   *\n   * _.includes([1, 2, 3], 1);\n   * // => true\n   *\n   * _.includes([1, 2, 3], 1, 2);\n   * // => false\n   *\n   * _.includes({ 'a': 1, 'b': 2 }, 1);\n   * // => true\n   *\n   * _.includes('abcd', 'bc');\n   * // => true\n   */\n  function includes(collection, value, fromIndex, guard) {\n    collection = isArrayLike(collection) ? collection : values(collection)\n    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0\n\n    var length = collection.length\n    if (fromIndex < 0) {\n      fromIndex = nativeMax$1(length + fromIndex, 0)\n    }\n    return isString(collection)\n      ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1\n      : !!length && baseIndexOf(collection, value, fromIndex) > -1\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max\n\n  /**\n   * Gets the index at which the first occurrence of `value` is found in `array`\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons. If `fromIndex` is negative, it's used as the\n   * offset from the end of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   * @example\n   *\n   * _.indexOf([1, 2, 1, 2], 2);\n   * // => 1\n   *\n   * // Search from the `fromIndex`.\n   * _.indexOf([1, 2, 1, 2], 2, 2);\n   * // => 3\n   */\n  function indexOf(array, value, fromIndex) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return -1\n    }\n    var index = fromIndex == null ? 0 : toInteger(fromIndex)\n    if (index < 0) {\n      index = nativeMax(length + index, 0)\n    }\n    return baseIndexOf(array, value, index)\n  }\n\n  /** `Object#toString` result references. */\n  var mapTag = '[object Map]',\n    setTag = '[object Set]'\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty\n\n  /**\n   * Checks if `value` is an empty object, collection, map, or set.\n   *\n   * Objects are considered empty if they have no own enumerable string keyed\n   * properties.\n   *\n   * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n   * jQuery-like collections are considered empty if they have a `length` of `0`.\n   * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n   * @example\n   *\n   * _.isEmpty(null);\n   * // => true\n   *\n   * _.isEmpty(true);\n   * // => true\n   *\n   * _.isEmpty(1);\n   * // => true\n   *\n   * _.isEmpty([1, 2, 3]);\n   * // => false\n   *\n   * _.isEmpty({ 'a': 1 });\n   * // => false\n   */\n  function isEmpty(value) {\n    if (value == null) {\n      return true\n    }\n    if (\n      isArrayLike(value) &&\n      (isArray$1(value) ||\n        typeof value == 'string' ||\n        typeof value.splice == 'function' ||\n        isBuffer$1(value) ||\n        isTypedArray$1(value) ||\n        isArguments$1(value))\n    ) {\n      return !value.length\n    }\n    var tag = getTag$1(value)\n    if (tag == mapTag || tag == setTag) {\n      return !value.size\n    }\n    if (isPrototype(value)) {\n      return !baseKeys(value).length\n    }\n    for (var key in value) {\n      if (hasOwnProperty.call(value, key)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /** `Object#toString` result references. */\n  var regexpTag = '[object RegExp]'\n\n  /**\n   * The base implementation of `_.isRegExp` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   */\n  function baseIsRegExp(value) {\n    return isObjectLike(value) && baseGetTag(value) == regexpTag\n  }\n\n  /* Node.js helper references. */\n  var nodeIsRegExp = nodeUtil$1 && nodeUtil$1.isRegExp\n\n  /**\n   * Checks if `value` is classified as a `RegExp` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   * @example\n   *\n   * _.isRegExp(/abc/);\n   * // => true\n   *\n   * _.isRegExp('/abc/');\n   * // => false\n   */\n  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp\n\n  const isRegExp$1 = isRegExp\n\n  /**\n   * Checks if `value` is `undefined`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n   * @example\n   *\n   * _.isUndefined(void 0);\n   * // => true\n   *\n   * _.isUndefined(null);\n   * // => false\n   */\n  function isUndefined(value) {\n    return value === undefined\n  }\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function'\n\n  /**\n   * Creates a function that negates the result of the predicate `func`. The\n   * `func` predicate is invoked with the `this` binding and arguments of the\n   * created function.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Function\n   * @param {Function} predicate The predicate to negate.\n   * @returns {Function} Returns the new negated function.\n   * @example\n   *\n   * function isEven(n) {\n   *   return n % 2 == 0;\n   * }\n   *\n   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n   * // => [1, 3, 5]\n   */\n  function negate(predicate) {\n    if (typeof predicate != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT)\n    }\n    return function () {\n      var args = arguments\n      switch (args.length) {\n        case 0:\n          return !predicate.call(this)\n        case 1:\n          return !predicate.call(this, args[0])\n        case 2:\n          return !predicate.call(this, args[0], args[1])\n        case 3:\n          return !predicate.call(this, args[0], args[1], args[2])\n      }\n      return !predicate.apply(this, args)\n    }\n  }\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    if (!isObject(object)) {\n      return object\n    }\n    path = castPath(path, object)\n\n    var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object\n\n    while (nested != null && ++index < length) {\n      var key = toKey(path[index]),\n        newValue = value\n\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        return object\n      }\n\n      if (index != lastIndex) {\n        var objValue = nested[key]\n        newValue = customizer ? customizer(objValue, key, nested) : undefined\n        if (newValue === undefined) {\n          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {}\n        }\n      }\n      assignValue(nested, key, newValue)\n      nested = nested[key]\n    }\n    return object\n  }\n\n  /**\n   * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The source object.\n   * @param {string[]} paths The property paths to pick.\n   * @param {Function} predicate The function invoked per property.\n   * @returns {Object} Returns the new object.\n   */\n  function basePickBy(object, paths, predicate) {\n    var index = -1,\n      length = paths.length,\n      result = {}\n\n    while (++index < length) {\n      var path = paths[index],\n        value = baseGet(object, path)\n\n      if (predicate(value, path)) {\n        baseSet(result, castPath(path, object), value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an object composed of the `object` properties `predicate` returns\n   * truthy for. The predicate is invoked with two arguments: (value, key).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The source object.\n   * @param {Function} [predicate=_.identity] The function invoked per property.\n   * @returns {Object} Returns the new object.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': '2', 'c': 3 };\n   *\n   * _.pickBy(object, _.isNumber);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  function pickBy(object, predicate) {\n    if (object == null) {\n      return {}\n    }\n    var props = arrayMap(getAllKeysIn(object), function (prop) {\n      return [prop]\n    })\n    predicate = baseIteratee(predicate)\n    return basePickBy(object, props, function (value, path) {\n      return predicate(value, path[0])\n    })\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function (value, index, collection) {\n      accumulator = initAccum ? ((initAccum = false), value) : iteratee(accumulator, value, index, collection)\n    })\n    return accumulator\n  }\n\n  /**\n   * Reduces `collection` to a value which is the accumulated result of running\n   * each element in `collection` thru `iteratee`, where each successive\n   * invocation is supplied the return value of the previous. If `accumulator`\n   * is not given, the first element of `collection` is used as the initial\n   * value. The iteratee is invoked with four arguments:\n   * (accumulator, value, index|key, collection).\n   *\n   * Many lodash methods are guarded to work as iteratees for methods like\n   * `_.reduce`, `_.reduceRight`, and `_.transform`.\n   *\n   * The guarded methods are:\n   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n   * and `sortBy`\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @returns {*} Returns the accumulated value.\n   * @see _.reduceRight\n   * @example\n   *\n   * _.reduce([1, 2], function(sum, n) {\n   *   return sum + n;\n   * }, 0);\n   * // => 3\n   *\n   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n   *   (result[value] || (result[value] = [])).push(key);\n   *   return result;\n   * }, {});\n   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n   */\n  function reduce(collection, iteratee, accumulator) {\n    var func = isArray$1(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3\n\n    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach$1)\n  }\n\n  /**\n   * The opposite of `_.filter`; this method returns the elements of `collection`\n   * that `predicate` does **not** return truthy for.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.filter\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': false },\n   *   { 'user': 'fred',   'age': 40, 'active': true }\n   * ];\n   *\n   * _.reject(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.reject(users, { 'age': 40, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.reject(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.reject(users, 'active');\n   * // => objects for ['barney']\n   */\n  function reject(collection, predicate) {\n    var func = isArray$1(collection) ? arrayFilter : baseFilter\n    return func(collection, negate(baseIteratee(predicate)))\n  }\n\n  /**\n   * The base implementation of `_.some` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function baseSome(collection, predicate) {\n    var result\n\n    baseEach$1(collection, function (value, index, collection) {\n      result = predicate(value, index, collection)\n      return !result\n    })\n    return !!result\n  }\n\n  /**\n   * Checks if `predicate` returns truthy for **any** element of `collection`.\n   * Iteration is stopped once `predicate` returns truthy. The predicate is\n   * invoked with three arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   * @example\n   *\n   * _.some([null, 0, 'yes', false], Boolean);\n   * // => true\n   *\n   * var users = [\n   *   { 'user': 'barney', 'active': true },\n   *   { 'user': 'fred',   'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.some(users, { 'user': 'barney', 'active': false });\n   * // => false\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.some(users, ['active', false]);\n   * // => true\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.some(users, 'active');\n   * // => true\n   */\n  function some(collection, predicate, guard) {\n    var func = isArray$1(collection) ? arraySome : baseSome\n    if (guard && isIterateeCall(collection, predicate, guard)) {\n      predicate = undefined\n    }\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0\n\n  /**\n   * Creates a set object of `values`.\n   *\n   * @private\n   * @param {Array} values The values to add to the set.\n   * @returns {Object} Returns the new set.\n   */\n  var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY)\n    ? noop\n    : function (values) {\n        return new Set$1(values)\n      }\n\n  const createSet$1 = createSet\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200\n\n  /**\n   * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseUniq(array, iteratee, comparator) {\n    var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result\n\n    if (comparator) {\n      isCommon = false\n      includes = arrayIncludesWith\n    } else if (length >= LARGE_ARRAY_SIZE) {\n      var set = iteratee ? null : createSet$1(array)\n      if (set) {\n        return setToArray(set)\n      }\n      isCommon = false\n      includes = cacheHas\n      seen = new SetCache()\n    } else {\n      seen = iteratee ? [] : result\n    }\n    outer: while (++index < length) {\n      var value = array[index],\n        computed = iteratee ? iteratee(value) : value\n\n      value = comparator || value !== 0 ? value : 0\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer\n          }\n        }\n        if (iteratee) {\n          seen.push(computed)\n        }\n        result.push(value)\n      } else if (!includes(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed)\n        }\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates a duplicate-free version of an array, using\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons, in which only the first occurrence of each element\n   * is kept. The order of result values is determined by the order they occur\n   * in the array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @returns {Array} Returns the new duplicate free array.\n   * @example\n   *\n   * _.uniq([2, 1, 2]);\n   * // => [2, 1]\n   */\n  function uniq(array) {\n    return array && array.length ? baseUniq(array) : []\n  }\n\n  function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n      console.error(`Error: ${msg}`)\n    }\n  }\n  function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n      // TODO: modify docs accordingly\n      console.warn(`Warning: ${msg}`)\n    }\n  }\n\n  function timer(func) {\n    const start = new Date().getTime()\n    const val = func()\n    const end = new Date().getTime()\n    const total = end - start\n    return { time: total, value: val }\n  }\n\n  // based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\n  function toFastProperties(toBecomeFast) {\n    function FakeConstructor() {}\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast\n    const fakeInstance = new FakeConstructor()\n    function fakeAccess() {\n      return typeof fakeInstance.bar\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess()\n    fakeAccess()\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    return toBecomeFast\n  }\n\n  // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n  function tokenLabel$1(tokType) {\n    if (hasTokenLabel$1(tokType)) {\n      return tokType.LABEL\n    } else {\n      return tokType.name\n    }\n  }\n  // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n  function hasTokenLabel$1(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== ''\n  }\n  class AbstractProduction {\n    get definition() {\n      return this._definition\n    }\n    set definition(value) {\n      this._definition = value\n    }\n    constructor(_definition) {\n      this._definition = _definition\n    }\n    accept(visitor) {\n      visitor.visit(this)\n      forEach(this.definition, (prod) => {\n        prod.accept(visitor)\n      })\n    }\n  }\n  class NonTerminal extends AbstractProduction {\n    constructor(options) {\n      super([])\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n    set definition(definition) {\n      // immutable\n    }\n    get definition() {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition\n      }\n      return []\n    }\n    accept(visitor) {\n      visitor.visit(this)\n      // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n  }\n  class Rule extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.orgText = ''\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Alternative extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.ignoreAmbiguities = false\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Option extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Repetition extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Alternation extends AbstractProduction {\n    get definition() {\n      return this._definition\n    }\n    set definition(value) {\n      this._definition = value\n    }\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      this.ignoreAmbiguities = false\n      this.hasPredicates = false\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Terminal {\n    constructor(options) {\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n    accept(visitor) {\n      visitor.visit(this)\n    }\n  }\n  function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction)\n  }\n  function serializeProduction(node) {\n    function convertDefinition(definition) {\n      return map(definition, serializeProduction)\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n      const serializedNonTerminal = {\n        type: 'NonTerminal',\n        name: node.nonTerminalName,\n        idx: node.idx,\n      }\n      if (isString(node.label)) {\n        serializedNonTerminal.label = node.label\n      }\n      return serializedNonTerminal\n    } else if (node instanceof Alternative) {\n      return {\n        type: 'Alternative',\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Option) {\n      return {\n        type: 'Option',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionMandatory) {\n      return {\n        type: 'RepetitionMandatory',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionMandatoryWithSeparator) {\n      return {\n        type: 'RepetitionMandatoryWithSeparator',\n        idx: node.idx,\n        separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionWithSeparator) {\n      return {\n        type: 'RepetitionWithSeparator',\n        idx: node.idx,\n        separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Repetition) {\n      return {\n        type: 'Repetition',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Alternation) {\n      return {\n        type: 'Alternation',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Terminal) {\n      const serializedTerminal = {\n        type: 'Terminal',\n        name: node.terminalType.name,\n        label: tokenLabel$1(node.terminalType),\n        idx: node.idx,\n      }\n      if (isString(node.label)) {\n        serializedTerminal.terminalLabel = node.label\n      }\n      const pattern = node.terminalType.PATTERN\n      if (node.terminalType.PATTERN) {\n        serializedTerminal.pattern = isRegExp$1(pattern) ? pattern.source : pattern\n      }\n      return serializedTerminal\n    } else if (node instanceof Rule) {\n      return {\n        type: 'Rule',\n        name: node.name,\n        orgText: node.orgText,\n        definition: convertDefinition(node.definition),\n      }\n      /* c8 ignore next 3 */\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n\n  class GAstVisitor {\n    visit(node) {\n      const nodeAny = node\n      switch (nodeAny.constructor) {\n        case NonTerminal:\n          return this.visitNonTerminal(nodeAny)\n        case Alternative:\n          return this.visitAlternative(nodeAny)\n        case Option:\n          return this.visitOption(nodeAny)\n        case RepetitionMandatory:\n          return this.visitRepetitionMandatory(nodeAny)\n        case RepetitionMandatoryWithSeparator:\n          return this.visitRepetitionMandatoryWithSeparator(nodeAny)\n        case RepetitionWithSeparator:\n          return this.visitRepetitionWithSeparator(nodeAny)\n        case Repetition:\n          return this.visitRepetition(nodeAny)\n        case Alternation:\n          return this.visitAlternation(nodeAny)\n        case Terminal:\n          return this.visitTerminal(nodeAny)\n        case Rule:\n          return this.visitRule(nodeAny)\n        /* c8 ignore next 2 */\n        default:\n          throw Error('non exhaustive match')\n      }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) {}\n    /* c8 ignore next */\n    visitAlternative(node) {}\n    /* c8 ignore next */\n    visitOption(node) {}\n    /* c8 ignore next */\n    visitRepetition(node) {}\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) {}\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) {}\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) {}\n    /* c8 ignore next */\n    visitAlternation(node) {}\n    /* c8 ignore next */\n    visitTerminal(node) {}\n    /* c8 ignore next */\n    visitRule(node) {}\n  }\n\n  function isSequenceProd(prod) {\n    return (\n      prod instanceof Alternative ||\n      prod instanceof Option ||\n      prod instanceof Repetition ||\n      prod instanceof RepetitionMandatory ||\n      prod instanceof RepetitionMandatoryWithSeparator ||\n      prod instanceof RepetitionWithSeparator ||\n      prod instanceof Terminal ||\n      prod instanceof Rule\n    )\n  }\n  function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional =\n      prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator\n    if (isDirectlyOptional) {\n      return true\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n      // for OR its enough for just one of the alternatives to be optional\n      return some(prod.definition, (subProd) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      })\n    } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n      // avoiding stack overflow due to infinite recursion\n      return false\n    } else if (prod instanceof AbstractProduction) {\n      if (prod instanceof NonTerminal) {\n        alreadyVisited.push(prod)\n      }\n      return every(prod.definition, (subProd) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      })\n    } else {\n      return false\n    }\n  }\n  function isBranchingProd(prod) {\n    return prod instanceof Alternation\n  }\n  function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n      return 'SUBRULE'\n    } else if (prod instanceof Option) {\n      return 'OPTION'\n    } else if (prod instanceof Alternation) {\n      return 'OR'\n    } else if (prod instanceof RepetitionMandatory) {\n      return 'AT_LEAST_ONE'\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      return 'AT_LEAST_ONE_SEP'\n    } else if (prod instanceof RepetitionWithSeparator) {\n      return 'MANY_SEP'\n    } else if (prod instanceof Repetition) {\n      return 'MANY'\n    } else if (prod instanceof Terminal) {\n      return 'CONSUME'\n      /* c8 ignore next 3 */\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n\n  /**\n   *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n   */\n  class RestWalker {\n    walk(prod, prevRest = []) {\n      forEach(prod.definition, (subProd, index) => {\n        const currRest = drop(prod.definition, index + 1)\n        /* istanbul ignore else */\n        if (subProd instanceof NonTerminal) {\n          this.walkProdRef(subProd, currRest, prevRest)\n        } else if (subProd instanceof Terminal) {\n          this.walkTerminal(subProd, currRest, prevRest)\n        } else if (subProd instanceof Alternative) {\n          this.walkFlat(subProd, currRest, prevRest)\n        } else if (subProd instanceof Option) {\n          this.walkOption(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionMandatory) {\n          this.walkAtLeastOne(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n          this.walkAtLeastOneSep(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionWithSeparator) {\n          this.walkManySep(subProd, currRest, prevRest)\n        } else if (subProd instanceof Repetition) {\n          this.walkMany(subProd, currRest, prevRest)\n        } else if (subProd instanceof Alternation) {\n          this.walkOr(subProd, currRest, prevRest)\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n    }\n    walkTerminal(terminal, currRest, prevRest) {}\n    walkProdRef(refProd, currRest, prevRest) {}\n    walkFlat(flatProd, currRest, prevRest) {\n      // ABCDEF => after the D the rest is EF\n      const fullOrRest = currRest.concat(prevRest)\n      this.walk(flatProd, fullOrRest)\n    }\n    walkOption(optionProd, currRest, prevRest) {\n      // ABC(DE)?F => after the (DE)? the rest is F\n      const fullOrRest = currRest.concat(prevRest)\n      this.walk(optionProd, fullOrRest)\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n      const fullAtLeastOneRest = [new Option({ definition: atLeastOneProd.definition })].concat(currRest, prevRest)\n      this.walk(atLeastOneProd, fullAtLeastOneRest)\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n      // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n      const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest)\n      this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n    }\n    walkMany(manyProd, currRest, prevRest) {\n      // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n      const fullManyRest = [new Option({ definition: manyProd.definition })].concat(currRest, prevRest)\n      this.walk(manyProd, fullManyRest)\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n      // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n      const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest)\n      this.walk(manySepProd, fullManySepRest)\n    }\n    walkOr(orProd, currRest, prevRest) {\n      // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n      const fullOrRest = currRest.concat(prevRest)\n      // walk all different alternatives\n      forEach(orProd.definition, (alt) => {\n        // wrapping each alternative in a single definition wrapper\n        // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n        // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n        const prodWrapper = new Alternative({ definition: [alt] })\n        this.walk(prodWrapper, fullOrRest)\n      })\n    }\n  }\n  function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n      new Option({\n        definition: [new Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition),\n      }),\n    ]\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest)\n    return fullRepSepRest\n  }\n\n  function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n      // this could in theory cause infinite loops if\n      // (1) prod A refs prod B.\n      // (2) prod B refs prod A\n      // (3) AB can match the empty set\n      // in other words a cycle where everything is optional so the first will keep\n      // looking ahead for the next optional part and will never exit\n      // currently there is no safeguard for this unique edge case because\n      // (1) not sure a grammar in which this can happen is useful for anything (productive)\n      return first(prod.referencedRule)\n    } else if (prod instanceof Terminal) {\n      return firstForTerminal(prod)\n    } else if (isSequenceProd(prod)) {\n      return firstForSequence(prod)\n    } else if (isBranchingProd(prod)) {\n      return firstForBranching(prod)\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function firstForSequence(prod) {\n    let firstSet = []\n    const seq = prod.definition\n    let nextSubProdIdx = 0\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n    let currSubProd\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n      currSubProd = seq[nextSubProdIdx]\n      isLastInnerProdOptional = isOptionalProd(currSubProd)\n      firstSet = firstSet.concat(first(currSubProd))\n      nextSubProdIdx = nextSubProdIdx + 1\n      hasInnerProdsRemaining = seq.length > nextSubProdIdx\n    }\n    return uniq(firstSet)\n  }\n  function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n      return first(innerProd)\n    })\n    return uniq(flatten(allAlternativesFirsts))\n  }\n  function firstForTerminal(terminal) {\n    return [terminal.terminalType]\n  }\n\n  // TODO: can this be removed? where is it used?\n  const IN = '_~IN~_'\n\n  // This ResyncFollowsWalker computes all of the follows required for RESYNC\n  // (skipping reference production).\n  class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n      super()\n      this.topProd = topProd\n      this.follows = {}\n    }\n    startWalking() {\n      this.walk(this.topProd)\n      return this.follows\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n      // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n      const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name\n      const fullRest = currRest.concat(prevRest)\n      const restProd = new Alternative({ definition: fullRest })\n      const t_in_topProd_follows = first(restProd)\n      this.follows[followName] = t_in_topProd_follows\n    }\n  }\n  function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {}\n    forEach(topProductions, (topProd) => {\n      const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking()\n      assign$1(reSyncFollows, currRefsFollow)\n    })\n    return reSyncFollows\n  }\n  function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN\n  }\n\n  function cc(char) {\n    return char.charCodeAt(0)\n  }\n  function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n      item.forEach(function (subItem) {\n        set.push(subItem)\n      })\n    } else {\n      set.push(item)\n    }\n  }\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw 'duplicate flag ' + flagKey\n    }\n    flagObj[flagKey]\n    flagObj[flagKey] = true\n  }\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error('Internal Error - Should never get here!')\n    }\n    return true\n  }\n  // istanbul ignore next\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error('Internal Error - Should never get here!')\n  }\n  function isCharacter(obj) {\n    return obj['type'] === 'Character'\n  }\n\n  const digitsCharCodes = []\n  for (let i = cc('0'); i <= cc('9'); i++) {\n    digitsCharCodes.push(i)\n  }\n  const wordCharCodes = [cc('_')].concat(digitsCharCodes)\n  for (let i = cc('a'); i <= cc('z'); i++) {\n    wordCharCodes.push(i)\n  }\n  for (let i = cc('A'); i <= cc('Z'); i++) {\n    wordCharCodes.push(i)\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n  const whitespaceCodes = [\n    cc(' '),\n    cc('\\f'),\n    cc('\\n'),\n    cc('\\r'),\n    cc('\\t'),\n    cc('\\v'),\n    cc('\\t'),\n    cc('\\u00a0'),\n    cc('\\u1680'),\n    cc('\\u2000'),\n    cc('\\u2001'),\n    cc('\\u2002'),\n    cc('\\u2003'),\n    cc('\\u2004'),\n    cc('\\u2005'),\n    cc('\\u2006'),\n    cc('\\u2007'),\n    cc('\\u2008'),\n    cc('\\u2009'),\n    cc('\\u200a'),\n    cc('\\u2028'),\n    cc('\\u2029'),\n    cc('\\u202f'),\n    cc('\\u205f'),\n    cc('\\u3000'),\n    cc('\\ufeff'),\n  ]\n\n  // consts and utilities\n  const hexDigitPattern = /[0-9a-fA-F]/\n  const decimalPattern = /[0-9]/\n  const decimalPatternNoZero = /[1-9]/\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  class RegExpParser {\n    constructor() {\n      this.idx = 0\n      this.input = ''\n      this.groupIdx = 0\n    }\n    saveState() {\n      return {\n        idx: this.idx,\n        input: this.input,\n        groupIdx: this.groupIdx,\n      }\n    }\n    restoreState(newState) {\n      this.idx = newState.idx\n      this.input = newState.input\n      this.groupIdx = newState.groupIdx\n    }\n    pattern(input) {\n      // parser state\n      this.idx = 0\n      this.input = input\n      this.groupIdx = 0\n      this.consumeChar('/')\n      const value = this.disjunction()\n      this.consumeChar('/')\n      const flags = {\n        type: 'Flags',\n        loc: { begin: this.idx, end: input.length },\n        global: false,\n        ignoreCase: false,\n        multiLine: false,\n        unicode: false,\n        sticky: false,\n      }\n      while (this.isRegExpFlag()) {\n        switch (this.popChar()) {\n          case 'g':\n            addFlag(flags, 'global')\n            break\n          case 'i':\n            addFlag(flags, 'ignoreCase')\n            break\n          case 'm':\n            addFlag(flags, 'multiLine')\n            break\n          case 'u':\n            addFlag(flags, 'unicode')\n            break\n          case 'y':\n            addFlag(flags, 'sticky')\n            break\n        }\n      }\n      if (this.idx !== this.input.length) {\n        throw Error('Redundant input: ' + this.input.substring(this.idx))\n      }\n      return {\n        type: 'Pattern',\n        flags: flags,\n        value: value,\n        loc: this.loc(0),\n      }\n    }\n    disjunction() {\n      const alts = []\n      const begin = this.idx\n      alts.push(this.alternative())\n      while (this.peekChar() === '|') {\n        this.consumeChar('|')\n        alts.push(this.alternative())\n      }\n      return { type: 'Disjunction', value: alts, loc: this.loc(begin) }\n    }\n    alternative() {\n      const terms = []\n      const begin = this.idx\n      while (this.isTerm()) {\n        terms.push(this.term())\n      }\n      return { type: 'Alternative', value: terms, loc: this.loc(begin) }\n    }\n    term() {\n      if (this.isAssertion()) {\n        return this.assertion()\n      } else {\n        return this.atom()\n      }\n    }\n    assertion() {\n      const begin = this.idx\n      switch (this.popChar()) {\n        case '^':\n          return {\n            type: 'StartAnchor',\n            loc: this.loc(begin),\n          }\n        case '$':\n          return { type: 'EndAnchor', loc: this.loc(begin) }\n        // '\\b' or '\\B'\n        case '\\\\':\n          switch (this.popChar()) {\n            case 'b':\n              return {\n                type: 'WordBoundary',\n                loc: this.loc(begin),\n              }\n            case 'B':\n              return {\n                type: 'NonWordBoundary',\n                loc: this.loc(begin),\n              }\n          }\n          // istanbul ignore next\n          throw Error('Invalid Assertion Escape')\n        // '(?=' or '(?!'\n        case '(':\n          this.consumeChar('?')\n          let type\n          switch (this.popChar()) {\n            case '=':\n              type = 'Lookahead'\n              break\n            case '!':\n              type = 'NegativeLookahead'\n              break\n          }\n          ASSERT_EXISTS(type)\n          const disjunction = this.disjunction()\n          this.consumeChar(')')\n          return {\n            type: type,\n            value: disjunction,\n            loc: this.loc(begin),\n          }\n      }\n      // istanbul ignore next\n      return ASSERT_NEVER_REACH_HERE()\n    }\n    quantifier(isBacktracking = false) {\n      let range = undefined\n      const begin = this.idx\n      switch (this.popChar()) {\n        case '*':\n          range = {\n            atLeast: 0,\n            atMost: Infinity,\n          }\n          break\n        case '+':\n          range = {\n            atLeast: 1,\n            atMost: Infinity,\n          }\n          break\n        case '?':\n          range = {\n            atLeast: 0,\n            atMost: 1,\n          }\n          break\n        case '{':\n          const atLeast = this.integerIncludingZero()\n          switch (this.popChar()) {\n            case '}':\n              range = {\n                atLeast: atLeast,\n                atMost: atLeast,\n              }\n              break\n            case ',':\n              let atMost\n              if (this.isDigit()) {\n                atMost = this.integerIncludingZero()\n                range = {\n                  atLeast: atLeast,\n                  atMost: atMost,\n                }\n              } else {\n                range = {\n                  atLeast: atLeast,\n                  atMost: Infinity,\n                }\n              }\n              this.consumeChar('}')\n              break\n          }\n          // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n          // causes severe performance degradations\n          if (isBacktracking === true && range === undefined) {\n            return undefined\n          }\n          ASSERT_EXISTS(range)\n          break\n      }\n      // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n      // causes severe performance degradations\n      if (isBacktracking === true && range === undefined) {\n        return undefined\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(range)) {\n        if (this.peekChar(0) === '?') {\n          this.consumeChar('?')\n          range.greedy = false\n        } else {\n          range.greedy = true\n        }\n        range.type = 'Quantifier'\n        range.loc = this.loc(begin)\n        return range\n      }\n    }\n    atom() {\n      let atom\n      const begin = this.idx\n      switch (this.peekChar()) {\n        case '.':\n          atom = this.dotAll()\n          break\n        case '\\\\':\n          atom = this.atomEscape()\n          break\n        case '[':\n          atom = this.characterClass()\n          break\n        case '(':\n          atom = this.group()\n          break\n      }\n      if (atom === undefined && this.isPatternCharacter()) {\n        atom = this.patternCharacter()\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(atom)) {\n        atom.loc = this.loc(begin)\n        if (this.isQuantifier()) {\n          atom.quantifier = this.quantifier()\n        }\n        return atom\n      }\n    }\n    dotAll() {\n      this.consumeChar('.')\n      return {\n        type: 'Set',\n        complement: true,\n        value: [cc('\\n'), cc('\\r'), cc('\\u2028'), cc('\\u2029')],\n      }\n    }\n    atomEscape() {\n      this.consumeChar('\\\\')\n      switch (this.peekChar()) {\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          return this.decimalEscapeAtom()\n        case 'd':\n        case 'D':\n        case 's':\n        case 'S':\n        case 'w':\n        case 'W':\n          return this.characterClassEscape()\n        case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n        case 'v':\n          return this.controlEscapeAtom()\n        case 'c':\n          return this.controlLetterEscapeAtom()\n        case '0':\n          return this.nulCharacterAtom()\n        case 'x':\n          return this.hexEscapeSequenceAtom()\n        case 'u':\n          return this.regExpUnicodeEscapeSequenceAtom()\n        default:\n          return this.identityEscapeAtom()\n      }\n    }\n    decimalEscapeAtom() {\n      const value = this.positiveInteger()\n      return { type: 'GroupBackReference', value: value }\n    }\n    characterClassEscape() {\n      let set\n      let complement = false\n      switch (this.popChar()) {\n        case 'd':\n          set = digitsCharCodes\n          break\n        case 'D':\n          set = digitsCharCodes\n          complement = true\n          break\n        case 's':\n          set = whitespaceCodes\n          break\n        case 'S':\n          set = whitespaceCodes\n          complement = true\n          break\n        case 'w':\n          set = wordCharCodes\n          break\n        case 'W':\n          set = wordCharCodes\n          complement = true\n          break\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(set)) {\n        return { type: 'Set', value: set, complement: complement }\n      }\n    }\n    controlEscapeAtom() {\n      let escapeCode\n      switch (this.popChar()) {\n        case 'f':\n          escapeCode = cc('\\f')\n          break\n        case 'n':\n          escapeCode = cc('\\n')\n          break\n        case 'r':\n          escapeCode = cc('\\r')\n          break\n        case 't':\n          escapeCode = cc('\\t')\n          break\n        case 'v':\n          escapeCode = cc('\\v')\n          break\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(escapeCode)) {\n        return { type: 'Character', value: escapeCode }\n      }\n    }\n    controlLetterEscapeAtom() {\n      this.consumeChar('c')\n      const letter = this.popChar()\n      if (/[a-zA-Z]/.test(letter) === false) {\n        throw Error('Invalid ')\n      }\n      const letterCode = letter.toUpperCase().charCodeAt(0) - 64\n      return { type: 'Character', value: letterCode }\n    }\n    nulCharacterAtom() {\n      // TODO implement '[lookahead  DecimalDigit]'\n      // TODO: for the deprecated octal escape sequence\n      this.consumeChar('0')\n      return { type: 'Character', value: cc('\\0') }\n    }\n    hexEscapeSequenceAtom() {\n      this.consumeChar('x')\n      return this.parseHexDigits(2)\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n      this.consumeChar('u')\n      return this.parseHexDigits(4)\n    }\n    identityEscapeAtom() {\n      // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n      // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n      const escapedChar = this.popChar()\n      return { type: 'Character', value: cc(escapedChar) }\n    }\n    classPatternCharacterAtom() {\n      switch (this.peekChar()) {\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n        // istanbul ignore next\n        case '\\\\':\n        // istanbul ignore next\n        case ']':\n          throw Error('TBD')\n        default:\n          const nextChar = this.popChar()\n          return { type: 'Character', value: cc(nextChar) }\n      }\n    }\n    characterClass() {\n      const set = []\n      let complement = false\n      this.consumeChar('[')\n      if (this.peekChar(0) === '^') {\n        this.consumeChar('^')\n        complement = true\n      }\n      while (this.isClassAtom()) {\n        const from = this.classAtom()\n        from.type === 'Character'\n        if (isCharacter(from) && this.isRangeDash()) {\n          this.consumeChar('-')\n          const to = this.classAtom()\n          to.type === 'Character'\n          // a range can only be used when both sides are single characters\n          if (isCharacter(to)) {\n            if (to.value < from.value) {\n              throw Error('Range out of order in character class')\n            }\n            set.push({ from: from.value, to: to.value })\n          } else {\n            // literal dash\n            insertToSet(from.value, set)\n            set.push(cc('-'))\n            insertToSet(to.value, set)\n          }\n        } else {\n          insertToSet(from.value, set)\n        }\n      }\n      this.consumeChar(']')\n      return { type: 'Set', complement: complement, value: set }\n    }\n    classAtom() {\n      switch (this.peekChar()) {\n        // istanbul ignore next\n        case ']':\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n          throw Error('TBD')\n        case '\\\\':\n          return this.classEscape()\n        default:\n          return this.classPatternCharacterAtom()\n      }\n    }\n    classEscape() {\n      this.consumeChar('\\\\')\n      switch (this.peekChar()) {\n        // Matches a backspace.\n        // (Not to be confused with \\b word boundary outside characterClass)\n        case 'b':\n          this.consumeChar('b')\n          return { type: 'Character', value: cc('\\u0008') }\n        case 'd':\n        case 'D':\n        case 's':\n        case 'S':\n        case 'w':\n        case 'W':\n          return this.characterClassEscape()\n        case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n        case 'v':\n          return this.controlEscapeAtom()\n        case 'c':\n          return this.controlLetterEscapeAtom()\n        case '0':\n          return this.nulCharacterAtom()\n        case 'x':\n          return this.hexEscapeSequenceAtom()\n        case 'u':\n          return this.regExpUnicodeEscapeSequenceAtom()\n        default:\n          return this.identityEscapeAtom()\n      }\n    }\n    group() {\n      let capturing = true\n      this.consumeChar('(')\n      switch (this.peekChar(0)) {\n        case '?':\n          this.consumeChar('?')\n          this.consumeChar(':')\n          capturing = false\n          break\n        default:\n          this.groupIdx++\n          break\n      }\n      const value = this.disjunction()\n      this.consumeChar(')')\n      const groupAst = {\n        type: 'Group',\n        capturing: capturing,\n        value: value,\n      }\n      if (capturing) {\n        groupAst['idx'] = this.groupIdx\n      }\n      return groupAst\n    }\n    positiveInteger() {\n      let number = this.popChar()\n      // istanbul ignore next - can't ever get here due to previous lookahead checks\n      // still implementing this error checking in case this ever changes.\n      if (decimalPatternNoZero.test(number) === false) {\n        throw Error('Expecting a positive integer')\n      }\n      while (decimalPattern.test(this.peekChar(0))) {\n        number += this.popChar()\n      }\n      return parseInt(number, 10)\n    }\n    integerIncludingZero() {\n      let number = this.popChar()\n      if (decimalPattern.test(number) === false) {\n        throw Error('Expecting an integer')\n      }\n      while (decimalPattern.test(this.peekChar(0))) {\n        number += this.popChar()\n      }\n      return parseInt(number, 10)\n    }\n    patternCharacter() {\n      const nextChar = this.popChar()\n      switch (nextChar) {\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n        // istanbul ignore next\n        case '^':\n        // istanbul ignore next\n        case '$':\n        // istanbul ignore next\n        case '\\\\':\n        // istanbul ignore next\n        case '.':\n        // istanbul ignore next\n        case '*':\n        // istanbul ignore next\n        case '+':\n        // istanbul ignore next\n        case '?':\n        // istanbul ignore next\n        case '(':\n        // istanbul ignore next\n        case ')':\n        // istanbul ignore next\n        case '[':\n        // istanbul ignore next\n        case '|':\n          // istanbul ignore next\n          throw Error('TBD')\n        default:\n          return { type: 'Character', value: cc(nextChar) }\n      }\n    }\n    isRegExpFlag() {\n      switch (this.peekChar(0)) {\n        case 'g':\n        case 'i':\n        case 'm':\n        case 'u':\n        case 'y':\n          return true\n        default:\n          return false\n      }\n    }\n    isRangeDash() {\n      return this.peekChar() === '-' && this.isClassAtom(1)\n    }\n    isDigit() {\n      return decimalPattern.test(this.peekChar(0))\n    }\n    isClassAtom(howMuch = 0) {\n      switch (this.peekChar(howMuch)) {\n        case ']':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n          return false\n        default:\n          return true\n      }\n    }\n    isTerm() {\n      return this.isAtom() || this.isAssertion()\n    }\n    isAtom() {\n      if (this.isPatternCharacter()) {\n        return true\n      }\n      switch (this.peekChar(0)) {\n        case '.':\n        case '\\\\': // atomEscape\n        case '[': // characterClass\n        // TODO: isAtom must be called before isAssertion - disambiguate\n        case '(': // group\n          return true\n        default:\n          return false\n      }\n    }\n    isAssertion() {\n      switch (this.peekChar(0)) {\n        case '^':\n        case '$':\n          return true\n        // '\\b' or '\\B'\n        case '\\\\':\n          switch (this.peekChar(1)) {\n            case 'b':\n            case 'B':\n              return true\n            default:\n              return false\n          }\n        // '(?=' or '(?!'\n        case '(':\n          return this.peekChar(1) === '?' && (this.peekChar(2) === '=' || this.peekChar(2) === '!')\n        default:\n          return false\n      }\n    }\n    isQuantifier() {\n      const prevState = this.saveState()\n      try {\n        return this.quantifier(true) !== undefined\n      } catch (e) {\n        return false\n      } finally {\n        this.restoreState(prevState)\n      }\n    }\n    isPatternCharacter() {\n      switch (this.peekChar()) {\n        case '^':\n        case '$':\n        case '\\\\':\n        case '.':\n        case '*':\n        case '+':\n        case '?':\n        case '(':\n        case ')':\n        case '[':\n        case '|':\n        case '/':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n          return false\n        default:\n          return true\n      }\n    }\n    parseHexDigits(howMany) {\n      let hexString = ''\n      for (let i = 0; i < howMany; i++) {\n        const hexChar = this.popChar()\n        if (hexDigitPattern.test(hexChar) === false) {\n          throw Error('Expecting a HexDecimal digits')\n        }\n        hexString += hexChar\n      }\n      const charCode = parseInt(hexString, 16)\n      return { type: 'Character', value: charCode }\n    }\n    peekChar(howMuch = 0) {\n      return this.input[this.idx + howMuch]\n    }\n    popChar() {\n      const nextChar = this.peekChar(0)\n      this.consumeChar(undefined)\n      return nextChar\n    }\n    consumeChar(char) {\n      if (char !== undefined && this.input[this.idx] !== char) {\n        throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx)\n      }\n      if (this.idx >= this.input.length) {\n        throw Error('Unexpected end of input')\n      }\n      this.idx++\n    }\n    loc(begin) {\n      return { begin: begin, end: this.idx }\n    }\n  }\n\n  class BaseRegExpVisitor {\n    visitChildren(node) {\n      for (const key in node) {\n        const child = node[key]\n        /* istanbul ignore else */\n        if (node.hasOwnProperty(key)) {\n          if (child.type !== undefined) {\n            this.visit(child)\n          } else if (Array.isArray(child)) {\n            child.forEach((subChild) => {\n              this.visit(subChild)\n            }, this)\n          }\n        }\n      }\n    }\n    visit(node) {\n      switch (node.type) {\n        case 'Pattern':\n          this.visitPattern(node)\n          break\n        case 'Flags':\n          this.visitFlags(node)\n          break\n        case 'Disjunction':\n          this.visitDisjunction(node)\n          break\n        case 'Alternative':\n          this.visitAlternative(node)\n          break\n        case 'StartAnchor':\n          this.visitStartAnchor(node)\n          break\n        case 'EndAnchor':\n          this.visitEndAnchor(node)\n          break\n        case 'WordBoundary':\n          this.visitWordBoundary(node)\n          break\n        case 'NonWordBoundary':\n          this.visitNonWordBoundary(node)\n          break\n        case 'Lookahead':\n          this.visitLookahead(node)\n          break\n        case 'NegativeLookahead':\n          this.visitNegativeLookahead(node)\n          break\n        case 'Character':\n          this.visitCharacter(node)\n          break\n        case 'Set':\n          this.visitSet(node)\n          break\n        case 'Group':\n          this.visitGroup(node)\n          break\n        case 'GroupBackReference':\n          this.visitGroupBackReference(node)\n          break\n        case 'Quantifier':\n          this.visitQuantifier(node)\n          break\n      }\n      this.visitChildren(node)\n    }\n    visitPattern(node) {}\n    visitFlags(node) {}\n    visitDisjunction(node) {}\n    visitAlternative(node) {}\n    // Assertion\n    visitStartAnchor(node) {}\n    visitEndAnchor(node) {}\n    visitWordBoundary(node) {}\n    visitNonWordBoundary(node) {}\n    visitLookahead(node) {}\n    visitNegativeLookahead(node) {}\n    // atoms\n    visitCharacter(node) {}\n    visitSet(node) {}\n    visitGroup(node) {}\n    visitGroupBackReference(node) {}\n    visitQuantifier(node) {}\n  }\n\n  let regExpAstCache = {}\n  const regExpParser = new RegExpParser()\n  function getRegExpAst(regExp) {\n    const regExpStr = regExp.toString()\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n      return regExpAstCache[regExpStr]\n    } else {\n      const regExpAst = regExpParser.pattern(regExpStr)\n      regExpAstCache[regExpStr] = regExpAst\n      return regExpAst\n    }\n  }\n  function clearRegExpParserCache() {\n    regExpAstCache = {}\n  }\n\n  const complementErrorMessage = 'Complement Sets are not supported for first char optimization'\n  const failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n'\n  function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n      const ast = getRegExpAst(regExp)\n      const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase)\n      return firstChars\n    } catch (e) {\n      /* istanbul ignore next */\n      // Testing this relies on the regexp-to-ast library having a bug... */\n      // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n      if (e.message === complementErrorMessage) {\n        if (ensureOptimizations) {\n          PRINT_WARNING(\n            `${failedOptimizationPrefixMsg}` +\n              `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n              '\\tComplement Sets cannot be automatically optimized.\\n' +\n              \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n              '\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.',\n          )\n        }\n      } else {\n        let msgSuffix = ''\n        if (ensureOptimizations) {\n          msgSuffix =\n            \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n            '\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.'\n        }\n        PRINT_ERROR(\n          `${failedOptimizationPrefixMsg}\\n` +\n            `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n            `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n            '\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues' +\n            msgSuffix,\n        )\n      }\n    }\n    return []\n  }\n  function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n      case 'Disjunction':\n        for (let i = 0; i < ast.value.length; i++) {\n          firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n        }\n        break\n      case 'Alternative':\n        const terms = ast.value\n        for (let i = 0; i < terms.length; i++) {\n          const term = terms[i]\n          // skip terms that cannot effect the first char results\n          switch (term.type) {\n            case 'EndAnchor':\n            // A group back reference cannot affect potential starting char.\n            // because if a back reference is the first production than automatically\n            // the group being referenced has had to come BEFORE so its codes have already been added\n            case 'GroupBackReference':\n            // assertions do not affect potential starting codes\n            case 'Lookahead':\n            case 'NegativeLookahead':\n            case 'StartAnchor':\n            case 'WordBoundary':\n            case 'NonWordBoundary':\n              continue\n          }\n          const atom = term\n          switch (atom.type) {\n            case 'Character':\n              addOptimizedIdxToResult(atom.value, result, ignoreCase)\n              break\n            case 'Set':\n              if (atom.complement === true) {\n                throw Error(complementErrorMessage)\n              }\n              forEach(atom.value, (code) => {\n                if (typeof code === 'number') {\n                  addOptimizedIdxToResult(code, result, ignoreCase)\n                } else {\n                  // range\n                  const range = code\n                  // cannot optimize when ignoreCase is\n                  if (ignoreCase === true) {\n                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                    }\n                  }\n                  // Optimization (2 orders of magnitude less work for very large ranges)\n                  else {\n                    // handle unoptimized values\n                    for (\n                      let rangeCode = range.from;\n                      rangeCode <= range.to && rangeCode < minOptimizationVal;\n                      rangeCode++\n                    ) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                    }\n                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                    if (range.to >= minOptimizationVal) {\n                      const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal\n                      const maxUnOptVal = range.to\n                      const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                      const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n                      for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                        result[currOptIdx] = currOptIdx\n                      }\n                    }\n                  }\n                }\n              })\n              break\n            case 'Group':\n              firstCharOptimizedIndices(atom.value, result, ignoreCase)\n              break\n            /* istanbul ignore next */\n            default:\n              throw Error('Non Exhaustive Match')\n          }\n          // reached a mandatory production, no more **start** codes can be found on this alternative\n          const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n          if (\n            // A group may be optional due to empty contents /(?:)/\n            // or if everything inside it is optional /((a)?)/\n            (atom.type === 'Group' && isWholeOptional(atom) === false) ||\n            // If this term is not a group it may only be optional if it has an optional quantifier\n            (atom.type !== 'Group' && isOptionalQuantifier === false)\n          ) {\n            break\n          }\n        }\n        break\n      /* istanbul ignore next */\n      default:\n        throw Error('non exhaustive match!')\n    }\n    // console.log(Object.keys(result).length)\n    return values(result)\n  }\n  function addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code)\n    result[optimizedCharIdx] = optimizedCharIdx\n    if (ignoreCase === true) {\n      handleIgnoreCase(code, result)\n    }\n  }\n  function handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code)\n    const upperChar = char.toUpperCase()\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    } else {\n      const lowerChar = char.toLowerCase()\n      if (lowerChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n        result[optimizedCharIdx] = optimizedCharIdx\n      }\n    }\n  }\n  function findCode(setNode, targetCharCodes) {\n    return find$1(setNode.value, (codeOrRange) => {\n      if (typeof codeOrRange === 'number') {\n        return includes(targetCharCodes, codeOrRange)\n      } else {\n        // range\n        const range = codeOrRange\n        return find$1(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined\n      }\n    })\n  }\n  function isWholeOptional(ast) {\n    const quantifier = ast.quantifier\n    if (quantifier && quantifier.atLeast === 0) {\n      return true\n    }\n    if (!ast.value) {\n      return false\n    }\n    return isArray$1(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value)\n  }\n  class CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n      super()\n      this.targetCharCodes = targetCharCodes\n      this.found = false\n    }\n    visitChildren(node) {\n      // No need to keep looking...\n      if (this.found === true) {\n        return\n      }\n      // switch lookaheads as they do not actually consume any characters thus\n      // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n      switch (node.type) {\n        case 'Lookahead':\n          this.visitLookahead(node)\n          return\n        case 'NegativeLookahead':\n          this.visitNegativeLookahead(node)\n          return\n      }\n      super.visitChildren(node)\n    }\n    visitCharacter(node) {\n      if (includes(this.targetCharCodes, node.value)) {\n        this.found = true\n      }\n    }\n    visitSet(node) {\n      if (node.complement) {\n        if (findCode(node, this.targetCharCodes) === undefined) {\n          this.found = true\n        }\n      } else {\n        if (findCode(node, this.targetCharCodes) !== undefined) {\n          this.found = true\n        }\n      }\n    }\n  }\n  function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n      const ast = getRegExpAst(pattern)\n      const charCodeFinder = new CharCodeFinder(charCodes)\n      charCodeFinder.visit(ast)\n      return charCodeFinder.found\n    } else {\n      return (\n        find$1(pattern, (char) => {\n          return includes(charCodes, char.charCodeAt(0))\n        }) !== undefined\n      )\n    }\n  }\n\n  const PATTERN = 'PATTERN'\n  const DEFAULT_MODE = 'defaultMode'\n  const MODES = 'modes'\n  let SUPPORT_STICKY = typeof new RegExp('(?:)').sticky === 'boolean'\n  function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults$1(options, {\n      useSticky: SUPPORT_STICKY,\n      debug: false,\n      safeMode: false,\n      positionTracking: 'full',\n      lineTerminatorCharacters: ['\\r', '\\n'],\n      tracer: (msg, action) => action(),\n    })\n    const tracer = options.tracer\n    tracer('initCharCodeToOptimizedIndexMap', () => {\n      initCharCodeToOptimizedIndexMap()\n    })\n    let onlyRelevantTypes\n    tracer('Reject Lexer.NA', () => {\n      onlyRelevantTypes = reject(tokenTypes, (currType) => {\n        return currType[PATTERN] === Lexer.NA\n      })\n    })\n    let hasCustom = false\n    let allTransformedPatterns\n    tracer('Transform Patterns', () => {\n      hasCustom = false\n      allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n        const currPattern = currType[PATTERN]\n        /* istanbul ignore else */\n        if (isRegExp$1(currPattern)) {\n          const regExpSource = currPattern.source\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== '^' &&\n            regExpSource !== '$' &&\n            regExpSource !== '.' &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === '\\\\' &&\n            // not a meta character\n            !includes(['d', 'D', 's', 'S', 't', 'r', 'n', 't', '0', 'c', 'b', 'B', 'f', 'v', 'w', 'W'], regExpSource[1])\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1]\n          } else {\n            return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern)\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern }\n        } else if (typeof currPattern === 'object') {\n          hasCustom = true\n          // ICustomPattern\n          return currPattern\n        } else if (typeof currPattern === 'string') {\n          if (currPattern.length === 1) {\n            return currPattern\n          } else {\n            const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n            const wrappedRegExp = new RegExp(escapedRegExpString)\n            return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp)\n          }\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n    })\n    let patternIdxToType\n    let patternIdxToGroup\n    let patternIdxToLongerAltIdxArr\n    let patternIdxToPushMode\n    let patternIdxToPopMode\n    tracer('misc mapping', () => {\n      patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx)\n      patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n        const groupName = clazz.GROUP\n        /* istanbul ignore next */\n        if (groupName === Lexer.SKIPPED) {\n          return undefined\n        } else if (isString(groupName)) {\n          return groupName\n        } else if (isUndefined(groupName)) {\n          return false\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n      patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n        const longerAltType = clazz.LONGER_ALT\n        if (longerAltType) {\n          const longerAltIdxArr = isArray$1(longerAltType)\n            ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type))\n            : [indexOf(onlyRelevantTypes, longerAltType)]\n          return longerAltIdxArr\n        }\n      })\n      patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE)\n      patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, 'POP_MODE'))\n    })\n    let patternIdxToCanLineTerminator\n    tracer('Line Terminator Handling', () => {\n      const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters)\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n      if (options.positionTracking !== 'onlyOffset') {\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n          if (has(tokType, 'LINE_BREAKS')) {\n            return !!tokType.LINE_BREAKS\n          } else {\n            return (\n              checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n              canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n            )\n          }\n        })\n      }\n    })\n    let patternIdxToIsCustom\n    let patternIdxToShort\n    let emptyGroups\n    let patternIdxToConfig\n    tracer('Misc Mapping #2', () => {\n      patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n      patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n      emptyGroups = reduce(\n        onlyRelevantTypes,\n        (acc, clazz) => {\n          const groupName = clazz.GROUP\n          if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n            acc[groupName] = []\n          }\n          return acc\n        },\n        {},\n      )\n      patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx],\n        }\n      })\n    })\n    let canBeOptimized = true\n    let charCodeToPatternIdxToConfig = []\n    if (!options.safeMode) {\n      tracer('First Char Optimization', () => {\n        charCodeToPatternIdxToConfig = reduce(\n          onlyRelevantTypes,\n          (result, currTokType, idx) => {\n            if (typeof currTokType.PATTERN === 'string') {\n              const charCode = currTokType.PATTERN.charCodeAt(0)\n              const optimizedIdx = charCodeToOptimizedIndex(charCode)\n              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n            } else if (isArray$1(currTokType.START_CHARS_HINT)) {\n              let lastOptimizedIdx\n              forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n                const charCode = typeof charOrInt === 'string' ? charOrInt.charCodeAt(0) : charOrInt\n                const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n                // Avoid adding the config multiple times\n                /* istanbul ignore else */\n                // - Difficult to check this scenario effects as it is only a performance\n                //   optimization that does not change correctness\n                if (lastOptimizedIdx !== currOptimizedIdx) {\n                  lastOptimizedIdx = currOptimizedIdx\n                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx])\n                }\n              })\n            } else if (isRegExp$1(currTokType.PATTERN)) {\n              if (currTokType.PATTERN.unicode) {\n                canBeOptimized = false\n                if (options.ensureOptimizations) {\n                  PRINT_ERROR(\n                    `${failedOptimizationPrefixMsg}` +\n                      `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                      '\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n' +\n                      \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                      '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE',\n                  )\n                }\n              } else {\n                const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations)\n                /* istanbul ignore if */\n                // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                // the first should be a different validation and the second cannot be tested.\n                if (isEmpty(optimizedCodes)) {\n                  // we cannot understand what codes may start possible matches\n                  // The optimization correctness requires knowing start codes for ALL patterns.\n                  // Not actually sure this is an error, no debug message\n                  canBeOptimized = false\n                }\n                forEach(optimizedCodes, (code) => {\n                  addToMapOfArrays(result, code, patternIdxToConfig[idx])\n                })\n              }\n            } else {\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE',\n                )\n              }\n              canBeOptimized = false\n            }\n            return result\n          },\n          [],\n        )\n      })\n    }\n    return {\n      emptyGroups: emptyGroups,\n      patternIdxToConfig: patternIdxToConfig,\n      charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n      hasCustom: hasCustom,\n      canBeOptimized: canBeOptimized,\n    }\n  }\n  function validatePatterns(tokenTypes, validModesNames) {\n    let errors = []\n    const missingResult = findMissingPatterns(tokenTypes)\n    errors = errors.concat(missingResult.errors)\n    const invalidResult = findInvalidPatterns(missingResult.valid)\n    const validTokenTypes = invalidResult.valid\n    errors = errors.concat(invalidResult.errors)\n    errors = errors.concat(validateRegExpPattern(validTokenTypes))\n    errors = errors.concat(findInvalidGroupType(validTokenTypes))\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames))\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n    return errors\n  }\n  function validateRegExpPattern(tokenTypes) {\n    let errors = []\n    const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp$1(currTokType[PATTERN]))\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n    return errors\n  }\n  function findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n      return !has(currType, PATTERN)\n    })\n    const errors = map(tokenTypesWithMissingPattern, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- missing static 'PATTERN' property\",\n        type: LexerDefinitionErrorType.MISSING_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    const valid = difference$1(tokenTypes, tokenTypesWithMissingPattern)\n    return { errors, valid }\n  }\n  function findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n      const pattern = currType[PATTERN]\n      return !isRegExp$1(pattern) && !isFunction(pattern) && !has(pattern, 'exec') && !isString(pattern)\n    })\n    const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n      return {\n        message:\n          'Token Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' can only be a RegExp, a\" +\n          ' Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.',\n        type: LexerDefinitionErrorType.INVALID_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    const valid = difference$1(tokenTypes, tokenTypesWithInvalidPattern)\n    return { errors, valid }\n  }\n  const end_of_input = /[^\\\\][$]/\n  function findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n      constructor() {\n        super(...arguments)\n        this.found = false\n      }\n      visitEndAnchor(node) {\n        this.found = true\n      }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      try {\n        const regexpAst = getRegExpAst(pattern)\n        const endAnchorVisitor = new EndAnchorFinder()\n        endAnchorVisitor.visit(regexpAst)\n        return endAnchorVisitor.found\n      } catch (e) {\n        // old behavior in case of runtime exceptions with regexp-to-ast.\n        /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n        return end_of_input.test(pattern.source)\n      }\n    })\n    const errors = map(invalidRegex, (currType) => {\n      return {\n        message:\n          'Unexpected RegExp Anchor Error:\\n' +\n          '\\tToken Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n          '\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      return pattern.test('')\n    })\n    const errors = map(matchesEmptyString, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n        type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  const start_of_input = /[^\\\\[][\\^]|^\\^/\n  function findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n      constructor() {\n        super(...arguments)\n        this.found = false\n      }\n      visitStartAnchor(node) {\n        this.found = true\n      }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      try {\n        const regexpAst = getRegExpAst(pattern)\n        const startAnchorVisitor = new StartAnchorFinder()\n        startAnchorVisitor.visit(regexpAst)\n        return startAnchorVisitor.found\n      } catch (e) {\n        // old behavior in case of runtime exceptions with regexp-to-ast.\n        /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n        return start_of_input.test(pattern.source)\n      }\n    })\n    const errors = map(invalidRegex, (currType) => {\n      return {\n        message:\n          'Unexpected RegExp Anchor Error:\\n' +\n          '\\tToken Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n          '\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = filter(tokenTypes, (currType) => {\n      const pattern = currType[PATTERN]\n      return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n    })\n    const errors = map(invalidFlags, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n        type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  // This can only test for identical duplicate RegExps, not semantically equivalent ones.\n  function findDuplicatePatterns(tokenTypes) {\n    const found = []\n    let identicalPatterns = map(tokenTypes, (outerType) => {\n      return reduce(\n        tokenTypes,\n        (result, innerType) => {\n          if (\n            outerType.PATTERN.source === innerType.PATTERN.source &&\n            !includes(found, innerType) &&\n            innerType.PATTERN !== Lexer.NA\n          ) {\n            // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n            // in essence we are creating Equivalence classes on equality relation.\n            found.push(innerType)\n            result.push(innerType)\n            return result\n          }\n          return result\n        },\n        [],\n      )\n    })\n    identicalPatterns = compact(identicalPatterns)\n    const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n      return currIdenticalSet.length > 1\n    })\n    const errors = map(duplicatePatterns, (setOfIdentical) => {\n      const tokenTypeNames = map(setOfIdentical, (currType) => {\n        return currType.name\n      })\n      const dupPatternSrc = head(setOfIdentical).PATTERN\n      return {\n        message:\n          `The same RegExp pattern ->${dupPatternSrc}<-` +\n          `has been used in all of the following Token Types: ${tokenTypeNames.join(', ')} <-`,\n        type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n        tokenTypes: setOfIdentical,\n      }\n    })\n    return errors\n  }\n  function findInvalidGroupType(tokenTypes) {\n    const invalidTypes = filter(tokenTypes, (clazz) => {\n      if (!has(clazz, 'GROUP')) {\n        return false\n      }\n      const group = clazz.GROUP\n      return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n    })\n    const errors = map(invalidTypes, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n        type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = filter(tokenTypes, (clazz) => {\n      return clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    })\n    const errors = map(invalidModes, (tokType) => {\n      const msg =\n        `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n        `which does not exist`\n      return {\n        message: msg,\n        type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n        tokenTypes: [tokType],\n      }\n    })\n    return errors\n  }\n  function findUnreachablePatterns(tokenTypes) {\n    const errors = []\n    const canBeTested = reduce(\n      tokenTypes,\n      (result, tokType, idx) => {\n        const pattern = tokType.PATTERN\n        if (pattern === Lexer.NA) {\n          return result\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n          result.push({ str: pattern, idx, tokenType: tokType })\n        } else if (isRegExp$1(pattern) && noMetaChar(pattern)) {\n          result.push({ str: pattern.source, idx, tokenType: tokType })\n        }\n        return result\n      },\n      [],\n    )\n    forEach(tokenTypes, (tokType, testIdx) => {\n      forEach(canBeTested, ({ str, idx, tokenType }) => {\n        if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n          const msg =\n            `Token: ->${tokenType.name}<- can never be matched.\\n` +\n            `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n            `in the lexer's definition.\\n` +\n            `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n          errors.push({\n            message: msg,\n            type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n            tokenTypes: [tokType, tokenType],\n          })\n        }\n      })\n    })\n    return errors\n  }\n  function testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp$1(pattern)) {\n      const regExpArray = pattern.exec(str)\n      return regExpArray !== null && regExpArray.index === 0\n    } else if (isFunction(pattern)) {\n      // maintain the API of custom patterns\n      return pattern(str, 0, [], {})\n    } else if (has(pattern, 'exec')) {\n      // maintain the API of custom patterns\n      return pattern.exec(str, 0, [], {})\n    } else if (typeof pattern === 'string') {\n      return pattern === str\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = ['.', '\\\\', '[', ']', '|', '^', '$', '(', ')', '?', '*', '+', '{']\n    return find$1(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  }\n  function addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? 'i' : ''\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags)\n  }\n  function addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? 'iy' : 'y'\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags)\n  }\n  function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = []\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n      errors.push({\n        message:\n          'A MultiMode Lexer cannot be initialized without a <' + DEFAULT_MODE + '> property in its definition\\n',\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n      })\n    }\n    if (!has(lexerDefinition, MODES)) {\n      errors.push({\n        message: 'A MultiMode Lexer cannot be initialized without a <' + MODES + '> property in its definition\\n',\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n      })\n    }\n    if (\n      has(lexerDefinition, MODES) &&\n      has(lexerDefinition, DEFAULT_MODE) &&\n      !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n    ) {\n      errors.push({\n        message:\n          `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n          `which does not exist\\n`,\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n      })\n    }\n    if (has(lexerDefinition, MODES)) {\n      forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n        forEach(currModeValue, (currTokType, currIdx) => {\n          if (isUndefined(currTokType)) {\n            errors.push({\n              message:\n                `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                `<${currModeName}> at index: <${currIdx}>\\n`,\n              type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n            })\n          } else if (has(currTokType, 'LONGER_ALT')) {\n            const longerAlt = isArray$1(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT]\n            forEach(longerAlt, (currLongerAlt) => {\n              if (!isUndefined(currLongerAlt) && !includes(currModeValue, currLongerAlt)) {\n                errors.push({\n                  message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                  type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                })\n              }\n            })\n          }\n        })\n      })\n    }\n    return errors\n  }\n  function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = []\n    let hasAnyLineBreak = false\n    const allTokenTypes = compact(flatten(values(lexerDefinition.modes)))\n    const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA)\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n    if (trackLines) {\n      forEach(concreteTokenTypes, (tokType) => {\n        const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n        if (currIssue !== false) {\n          const message = buildLineBreakIssueMessage(tokType, currIssue)\n          const warningDescriptor = {\n            message,\n            type: currIssue.issue,\n            tokenType: tokType,\n          }\n          warnings.push(warningDescriptor)\n        } else {\n          // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n          if (has(tokType, 'LINE_BREAKS')) {\n            if (tokType.LINE_BREAKS === true) {\n              hasAnyLineBreak = true\n            }\n          } else {\n            if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n              hasAnyLineBreak = true\n            }\n          }\n        }\n      })\n    }\n    if (trackLines && !hasAnyLineBreak) {\n      warnings.push({\n        message:\n          'Warning: No LINE_BREAKS Found.\\n' +\n          '\\tThis Lexer has been defined to track line and column information,\\n' +\n          '\\tBut none of the Token Types can be identified as matching a line terminator.\\n' +\n          '\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n      })\n    }\n    return warnings\n  }\n  function cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {}\n    const groupKeys = keys(emptyGroups)\n    forEach(groupKeys, (currKey) => {\n      const currGroupValue = emptyGroups[currKey]\n      /* istanbul ignore else */\n      if (isArray$1(currGroupValue)) {\n        clonedResult[currKey] = []\n      } else {\n        throw Error('non exhaustive match')\n      }\n    })\n    return clonedResult\n  }\n  // TODO: refactor to avoid duplication\n  function isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN\n    /* istanbul ignore else */\n    if (isRegExp$1(pattern)) {\n      return false\n    } else if (isFunction(pattern)) {\n      // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n      return true\n    } else if (has(pattern, 'exec')) {\n      // ICustomPattern\n      return true\n    } else if (isString(pattern)) {\n      return false\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n      return pattern.charCodeAt(0)\n    } else {\n      return false\n    }\n  }\n  /**\n   * Faster than using a RegExp for default newline detection during lexing.\n   */\n  const LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n      const len = text.length\n      for (let i = this.lastIndex; i < len; i++) {\n        const c = text.charCodeAt(i)\n        if (c === 10) {\n          this.lastIndex = i + 1\n          return true\n        } else if (c === 13) {\n          if (text.charCodeAt(i + 1) === 10) {\n            this.lastIndex = i + 2\n          } else {\n            this.lastIndex = i + 1\n          }\n          return true\n        }\n      }\n      return false\n    },\n    lastIndex: 0,\n  }\n  function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, 'LINE_BREAKS')) {\n      // if the user explicitly declared the line_breaks option we will respect their choice\n      // and assume it is correct.\n      return false\n    } else {\n      /* istanbul ignore else */\n      if (isRegExp$1(tokType.PATTERN)) {\n        try {\n          // TODO: why is the casting suddenly needed?\n          canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n        } catch (e) {\n          /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n          return {\n            issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n            errMsg: e.message,\n          }\n        }\n        return false\n      } else if (isString(tokType.PATTERN)) {\n        // string literal patterns can always be analyzed to detect line terminator usage\n        return false\n      } else if (isCustomPattern(tokType)) {\n        // custom token types\n        return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n      } else {\n        throw Error('non exhaustive match')\n      }\n    }\n  }\n  function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n      return (\n        'Warning: unable to identify line terminator usage in pattern.\\n' +\n        `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n        `\\t Root cause: ${details.errMsg}.\\n` +\n        '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR'\n      )\n    } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n      return (\n        'Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n' +\n        `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n        '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK'\n      )\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function getCharCodes(charsOrCodes) {\n    const charCodes = map(charsOrCodes, (numOrString) => {\n      if (isString(numOrString)) {\n        return numOrString.charCodeAt(0)\n      } else {\n        return numOrString\n      }\n    })\n    return charCodes\n  }\n  function addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n      map[key] = [value]\n    } else {\n      map[key].push(value)\n    }\n  }\n  const minOptimizationVal = 256\n  /**\n   * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n   * This is because ASCI are the most common start chars so each one of those will get its own\n   * possible token configs vector.\n   *\n   * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n   * to place these into buckets of possible token configs, What we gain from\n   * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n   * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n   * Our 'charCodeToPatternIdxToConfig' max size will now be:\n   * 256 + (2^16 / 2^8) - 1 === 511\n   *\n   * note the hack for fast division integer part extraction\n   * See: https://stackoverflow.com/a/4228528\n   */\n  let charCodeToOptimizedIdxMap = []\n  function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode]\n  }\n  /**\n   * This is a compromise between cold start / hot running performance\n   * Creating this array takes ~3ms on a modern machine,\n   * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n   * performance degrades by ~10%\n   *\n   * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n   */\n  function initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n      charCodeToOptimizedIdxMap = new Array(65536)\n      for (let i = 0; i < 65536; i++) {\n        charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n      }\n    }\n  }\n\n  function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n      return true\n    } else {\n      return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true\n    }\n  }\n  // Optimized tokenMatcher in case our grammar does not use token categories\n  // Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n  function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx\n  }\n  let tokenShortNameIdx = 1\n  const tokenIdxToClass = {}\n  function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes)\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents)\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents)\n    assignCategoriesTokensProp(tokenTypesAndParents)\n    forEach(tokenTypesAndParents, (tokType) => {\n      tokType.isParent = tokType.categoryMatches.length > 0\n    })\n  }\n  function expandCategories(tokenTypes) {\n    let result = clone(tokenTypes)\n    let categories = tokenTypes\n    let searching = true\n    while (searching) {\n      categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)))\n      const newCategories = difference$1(categories, result)\n      result = result.concat(newCategories)\n      if (isEmpty(newCategories)) {\n        searching = false\n      } else {\n        categories = newCategories\n      }\n    }\n    return result\n  }\n  function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      if (!hasShortKeyProperty(currTokType)) {\n        tokenIdxToClass[tokenShortNameIdx] = currTokType\n        currTokType.tokenTypeIdx = tokenShortNameIdx++\n      }\n      // CATEGORIES? : TokenType | TokenType[]\n      if (\n        hasCategoriesProperty(currTokType) &&\n        !isArray$1(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n      ) {\n        currTokType.CATEGORIES = [currTokType.CATEGORIES]\n      }\n      if (!hasCategoriesProperty(currTokType)) {\n        currTokType.CATEGORIES = []\n      }\n      if (!hasExtendingTokensTypesProperty(currTokType)) {\n        currTokType.categoryMatches = []\n      }\n      if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n        currTokType.categoryMatchesMap = {}\n      }\n    })\n  }\n  function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      // avoid duplications\n      currTokType.categoryMatches = []\n      forEach(currTokType.categoryMatchesMap, (val, key) => {\n        currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx)\n      })\n    })\n  }\n  function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      singleAssignCategoriesToksMap([], currTokType)\n    })\n  }\n  function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, (pathNode) => {\n      nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true\n    })\n    forEach(nextNode.CATEGORIES, (nextCategory) => {\n      const newPath = path.concat(nextNode)\n      // avoids infinite loops due to cyclic categories.\n      if (!includes(newPath, nextCategory)) {\n        singleAssignCategoriesToksMap(newPath, nextCategory)\n      }\n    })\n  }\n  function hasShortKeyProperty(tokType) {\n    return has(tokType, 'tokenTypeIdx')\n  }\n  function hasCategoriesProperty(tokType) {\n    return has(tokType, 'CATEGORIES')\n  }\n  function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, 'categoryMatches')\n  }\n  function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, 'categoryMatchesMap')\n  }\n  function isTokenType(tokType) {\n    return has(tokType, 'tokenTypeIdx')\n  }\n\n  const defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n      return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n      return (\n        `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` +\n        ` skipped ${length} characters.`\n      )\n    },\n  }\n\n  var LexerDefinitionErrorType\n  ;(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MISSING_PATTERN'] = 0)] = 'MISSING_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['INVALID_PATTERN'] = 1)] = 'INVALID_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['EOI_ANCHOR_FOUND'] = 2)] = 'EOI_ANCHOR_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['UNSUPPORTED_FLAGS_FOUND'] = 3)] = 'UNSUPPORTED_FLAGS_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['DUPLICATE_PATTERNS_FOUND'] = 4)] = 'DUPLICATE_PATTERNS_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['INVALID_GROUP_TYPE_FOUND'] = 5)] = 'INVALID_GROUP_TYPE_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['PUSH_MODE_DOES_NOT_EXIST'] = 6)] = 'PUSH_MODE_DOES_NOT_EXIST'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'] = 7)] =\n      'MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'] = 8)] =\n      'MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'] = 9)] =\n      'MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'] = 10)] =\n      'LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['SOI_ANCHOR_FOUND'] = 11)] = 'SOI_ANCHOR_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['EMPTY_MATCH_PATTERN'] = 12)] = 'EMPTY_MATCH_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['NO_LINE_BREAKS_FLAGS'] = 13)] = 'NO_LINE_BREAKS_FLAGS'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['UNREACHABLE_PATTERN'] = 14)] = 'UNREACHABLE_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['IDENTIFY_TERMINATOR'] = 15)] = 'IDENTIFY_TERMINATOR'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['CUSTOM_LINE_BREAK'] = 16)] = 'CUSTOM_LINE_BREAK'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE'] = 17)] =\n      'MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE'\n  })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}))\n  const DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: 'full',\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: ['\\n', '\\r'],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n  }\n  Object.freeze(DEFAULT_LEXER_CONFIG)\n  class Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n      this.lexerDefinition = lexerDefinition\n      this.lexerDefinitionErrors = []\n      this.lexerDefinitionWarning = []\n      this.patternIdxToConfig = {}\n      this.charCodeToPatternIdxToConfig = {}\n      this.modes = []\n      this.emptyGroups = {}\n      this.trackStartLines = true\n      this.trackEndLines = true\n      this.hasCustom = false\n      this.canModeBeOptimized = {}\n      // Duplicated from the parser's perf trace trait to allow future extraction\n      // of the lexer to a separate package.\n      this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n          this.traceInitIndent++\n          const indent = new Array(this.traceInitIndent + 1).join('\\t')\n          if (this.traceInitIndent < this.traceInitMaxIdent) {\n            console.log(`${indent}--> <${phaseDesc}>`)\n          }\n          const { time, value } = timer(phaseImpl)\n          /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n          const traceMethod = time > 10 ? console.warn : console.log\n          if (this.traceInitIndent < this.traceInitMaxIdent) {\n            traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n          }\n          this.traceInitIndent--\n          return value\n        } else {\n          return phaseImpl()\n        }\n      }\n      if (typeof config === 'boolean') {\n        throw Error(\n          'The second argument to the Lexer constructor is now an ILexerConfig Object.\\n' +\n            'a boolean 2nd argument is no longer supported',\n        )\n      }\n      // todo: defaults func?\n      this.config = assign$1({}, DEFAULT_LEXER_CONFIG, config)\n      const traceInitVal = this.config.traceInitPerf\n      if (traceInitVal === true) {\n        this.traceInitMaxIdent = Infinity\n        this.traceInitPerf = true\n      } else if (typeof traceInitVal === 'number') {\n        this.traceInitMaxIdent = traceInitVal\n        this.traceInitPerf = true\n      }\n      this.traceInitIndent = -1\n      this.TRACE_INIT('Lexer Constructor', () => {\n        let actualDefinition\n        let hasOnlySingleMode = true\n        this.TRACE_INIT('Lexer Config handling', () => {\n          if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n            // optimized built-in implementation for the defaults definition of lineTerminators\n            this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n          } else {\n            if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n              throw Error(\n                'Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n' +\n                  '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS',\n              )\n            }\n          }\n          if (config.safeMode && config.ensureOptimizations) {\n            throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.')\n          }\n          this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking)\n          this.trackEndLines = /full/i.test(this.config.positionTracking)\n          // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n          if (isArray$1(lexerDefinition)) {\n            actualDefinition = {\n              modes: { defaultMode: clone(lexerDefinition) },\n              defaultMode: DEFAULT_MODE,\n            }\n          } else {\n            // no conversion needed, input should already be a IMultiModeLexerDefinition\n            hasOnlySingleMode = false\n            actualDefinition = clone(lexerDefinition)\n          }\n        })\n        if (this.config.skipValidations === false) {\n          this.TRACE_INIT('performRuntimeChecks', () => {\n            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n              performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters),\n            )\n          })\n          this.TRACE_INIT('performWarningRuntimeChecks', () => {\n            this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n              performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters),\n            )\n          })\n        }\n        // for extra robustness to avoid throwing an none informative error message\n        actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}\n        // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n        // this transformation is to increase robustness in the case of partially invalid lexer definition.\n        forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n          actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType))\n        })\n        const allModeNames = keys(actualDefinition.modes)\n        forEach(actualDefinition.modes, (currModDef, currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames),\n                )\n              })\n            }\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n              let currAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT,\n                })\n              })\n              this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig\n              this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig\n              this.emptyGroups = assign$1({}, this.emptyGroups, currAnalyzeResult.emptyGroups)\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n              this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized\n            }\n          })\n        })\n        this.defaultMode = actualDefinition.defaultMode\n        if (!isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n          const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n            return error.message\n          })\n          const allErrMessagesString = allErrMessages.join('-----------------------\\n')\n          throw new Error('Errors detected in definition of Lexer:\\n' + allErrMessagesString)\n        }\n        // Only print warning if there are no errors, This will avoid pl\n        forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n          PRINT_WARNING(warningDescriptor.message)\n        })\n        this.TRACE_INIT('Choosing sub-methods implementations', () => {\n          // Choose the relevant internal implementations for this specific parser.\n          // These implementations should be in-lined by the JavaScript engine\n          // to provide optimal performance in each scenario.\n          if (SUPPORT_STICKY) {\n            this.chopInput = identity\n            this.match = this.matchWithTest\n          } else {\n            this.updateLastIndex = noop\n            this.match = this.matchWithExec\n          }\n          if (hasOnlySingleMode) {\n            this.handleModes = noop\n          }\n          if (this.trackStartLines === false) {\n            this.computeNewColumn = identity\n          }\n          if (this.trackEndLines === false) {\n            this.updateTokenEndLineColumnLocation = noop\n          }\n          if (/full/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createFullToken\n          } else if (/onlyStart/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createStartOnlyToken\n          } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createOffsetOnlyToken\n          } else {\n            throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`)\n          }\n          if (this.hasCustom) {\n            this.addToken = this.addTokenUsingPush\n            this.handlePayload = this.handlePayloadWithCustom\n          } else {\n            this.addToken = this.addTokenUsingMemberAccess\n            this.handlePayload = this.handlePayloadNoCustom\n          }\n        })\n        this.TRACE_INIT('Failed Optimization Warnings', () => {\n          const unOptimizedModes = reduce(\n            this.canModeBeOptimized,\n            (cannotBeOptimized, canBeOptimized, modeName) => {\n              if (canBeOptimized === false) {\n                cannotBeOptimized.push(modeName)\n              }\n              return cannotBeOptimized\n            },\n            [],\n          )\n          if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n            throw Error(\n              `Lexer Modes: < ${unOptimizedModes.join(', ')} > cannot be optimized.\\n` +\n                '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                '\\t Or inspect the console log for details on how to resolve these issues.',\n            )\n          }\n        })\n        this.TRACE_INIT('clearRegExpParserCache', () => {\n          clearRegExpParserCache()\n        })\n        this.TRACE_INIT('toFastProperties', () => {\n          toFastProperties(this)\n        })\n      })\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n      if (!isEmpty(this.lexerDefinitionErrors)) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join('-----------------------\\n')\n        throw new Error('Unable to Tokenize because Errors detected in definition of Lexer:\\n' + allErrMessagesString)\n      }\n      return this.tokenizeInternal(text, initialMode)\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n      let i,\n        j,\n        k,\n        matchAltImage,\n        longerAlt,\n        matchedImage,\n        payload,\n        altPayload,\n        imageLength,\n        group,\n        tokType,\n        newToken,\n        errLength,\n        msg,\n        match\n      const orgText = text\n      const orgLength = orgText.length\n      let offset = 0\n      let matchedTokensIndex = 0\n      // initializing the tokensArray to the \"guessed\" size.\n      // guessing too little will still reduce the number of array re-sizes on pushes.\n      // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n      // but would still have a faster runtime by avoiding (All but one) array resizing.\n      const guessedNumberOfTokens = this.hasCustom\n        ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n        : Math.floor(text.length / 10)\n      const matchedTokens = new Array(guessedNumberOfTokens)\n      const errors = []\n      let line = this.trackStartLines ? 1 : undefined\n      let column = this.trackStartLines ? 1 : undefined\n      const groups = cloneEmptyGroups(this.emptyGroups)\n      const trackLines = this.trackStartLines\n      const lineTerminatorPattern = this.config.lineTerminatorsPattern\n      let currModePatternsLength = 0\n      let patternIdxToConfig = []\n      let currCharCodeToPatternIdxToConfig = []\n      const modeStack = []\n      const emptyArray = []\n      Object.freeze(emptyArray)\n      let getPossiblePatterns\n      function getPossiblePatternsSlow() {\n        return patternIdxToConfig\n      }\n      function getPossiblePatternsOptimized(charCode) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n        const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n        if (possiblePatterns === undefined) {\n          return emptyArray\n        } else {\n          return possiblePatterns\n        }\n      }\n      const pop_mode = (popToken) => {\n        // TODO: perhaps avoid this error in the edge case there is no more input?\n        if (\n          modeStack.length === 1 &&\n          // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n          // So no error should occur.\n          popToken.tokenType.PUSH_MODE === undefined\n        ) {\n          // if we try to pop the last mode there lexer will no longer have ANY mode.\n          // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n          const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken)\n          errors.push({\n            offset: popToken.startOffset,\n            line: popToken.startLine,\n            column: popToken.startColumn,\n            length: popToken.image.length,\n            message: msg,\n          })\n        } else {\n          modeStack.pop()\n          const newMode = last(modeStack)\n          patternIdxToConfig = this.patternIdxToConfig[newMode]\n          currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode]\n          currModePatternsLength = patternIdxToConfig.length\n          const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false\n          if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n            getPossiblePatterns = getPossiblePatternsOptimized\n          } else {\n            getPossiblePatterns = getPossiblePatternsSlow\n          }\n        }\n      }\n      function push_mode(newMode) {\n        modeStack.push(newMode)\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode]\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currModePatternsLength = patternIdxToConfig.length\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n      // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n      // seem to matter performance wise.\n      push_mode.call(this, initialMode)\n      let currConfig\n      const recoveryEnabled = this.config.recoveryEnabled\n      while (offset < orgLength) {\n        matchedImage = null\n        const nextCharCode = orgText.charCodeAt(offset)\n        const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n        const chosenPatternsLength = chosenPatternIdxToConfig.length\n        for (i = 0; i < chosenPatternsLength; i++) {\n          currConfig = chosenPatternIdxToConfig[i]\n          const currPattern = currConfig.pattern\n          payload = null\n          // manually in-lined because > 600 chars won't be in-lined in V8\n          const singleCharCode = currConfig.short\n          if (singleCharCode !== false) {\n            if (nextCharCode === singleCharCode) {\n              // single character string\n              matchedImage = currPattern\n            }\n          } else if (currConfig.isCustom === true) {\n            match = currPattern.exec(orgText, offset, matchedTokens, groups)\n            if (match !== null) {\n              matchedImage = match[0]\n              if (match.payload !== undefined) {\n                payload = match.payload\n              }\n            } else {\n              matchedImage = null\n            }\n          } else {\n            this.updateLastIndex(currPattern, offset)\n            matchedImage = this.match(currPattern, text, offset)\n          }\n          if (matchedImage !== null) {\n            // even though this pattern matched we must try a another longer alternative.\n            // this can be used to prioritize keywords over identifiers\n            longerAlt = currConfig.longerAlt\n            if (longerAlt !== undefined) {\n              // TODO: micro optimize, avoid extra prop access\n              // by saving/linking longerAlt on the original config?\n              const longerAltLength = longerAlt.length\n              for (k = 0; k < longerAltLength; k++) {\n                const longerAltConfig = patternIdxToConfig[longerAlt[k]]\n                const longerAltPattern = longerAltConfig.pattern\n                altPayload = null\n                // single Char can never be a longer alt so no need to test it.\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                if (longerAltConfig.isCustom === true) {\n                  match = longerAltPattern.exec(orgText, offset, matchedTokens, groups)\n                  if (match !== null) {\n                    matchAltImage = match[0]\n                    if (match.payload !== undefined) {\n                      altPayload = match.payload\n                    }\n                  } else {\n                    matchAltImage = null\n                  }\n                } else {\n                  this.updateLastIndex(longerAltPattern, offset)\n                  matchAltImage = this.match(longerAltPattern, text, offset)\n                }\n                if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                  matchedImage = matchAltImage\n                  payload = altPayload\n                  currConfig = longerAltConfig\n                  // Exit the loop early after matching one of the longer alternatives\n                  // The first matched alternative takes precedence\n                  break\n                }\n              }\n            }\n            break\n          }\n        }\n        // successful match\n        if (matchedImage !== null) {\n          imageLength = matchedImage.length\n          group = currConfig.group\n          if (group !== undefined) {\n            tokType = currConfig.tokenTypeIdx\n            // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n            // createFullToken method\n            newToken = this.createTokenInstance(\n              matchedImage,\n              offset,\n              tokType,\n              currConfig.tokenType,\n              line,\n              column,\n              imageLength,\n            )\n            this.handlePayload(newToken, payload)\n            // TODO: optimize NOOP in case there are no special groups?\n            if (group === false) {\n              matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken)\n            } else {\n              groups[group].push(newToken)\n            }\n          }\n          text = this.chopInput(text, imageLength)\n          offset = offset + imageLength\n          // TODO: with newlines the column may be assigned twice\n          column = this.computeNewColumn(column, imageLength)\n          if (trackLines === true && currConfig.canLineTerminator === true) {\n            let numOfLTsInMatch = 0\n            let foundTerminator\n            let lastLTEndOffset\n            lineTerminatorPattern.lastIndex = 0\n            do {\n              foundTerminator = lineTerminatorPattern.test(matchedImage)\n              if (foundTerminator === true) {\n                lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n                numOfLTsInMatch++\n              }\n            } while (foundTerminator === true)\n            if (numOfLTsInMatch !== 0) {\n              line = line + numOfLTsInMatch\n              column = imageLength - lastLTEndOffset\n              this.updateTokenEndLineColumnLocation(\n                newToken,\n                group,\n                lastLTEndOffset,\n                numOfLTsInMatch,\n                line,\n                column,\n                imageLength,\n              )\n            }\n          }\n          // will be NOOP if no modes present\n          this.handleModes(currConfig, pop_mode, push_mode, newToken)\n        } else {\n          // error recovery, drop characters until we identify a valid token's start point\n          const errorStartOffset = offset\n          const errorLine = line\n          const errorColumn = column\n          let foundResyncPoint = recoveryEnabled === false\n          while (foundResyncPoint === false && offset < orgLength) {\n            // Identity Func (when sticky flag is enabled)\n            text = this.chopInput(text, 1)\n            offset++\n            for (j = 0; j < currModePatternsLength; j++) {\n              const currConfig = patternIdxToConfig[j]\n              const currPattern = currConfig.pattern\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              const singleCharCode = currConfig.short\n              if (singleCharCode !== false) {\n                if (orgText.charCodeAt(offset) === singleCharCode) {\n                  // single character string\n                  foundResyncPoint = true\n                }\n              } else if (currConfig.isCustom === true) {\n                foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null\n              } else {\n                this.updateLastIndex(currPattern, offset)\n                foundResyncPoint = currPattern.exec(text) !== null\n              }\n              if (foundResyncPoint === true) {\n                break\n              }\n            }\n          }\n          errLength = offset - errorStartOffset\n          column = this.computeNewColumn(column, errLength)\n          // at this point we either re-synced or reached the end of the input text\n          msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n            orgText,\n            errorStartOffset,\n            errLength,\n            errorLine,\n            errorColumn,\n          )\n          errors.push({\n            offset: errorStartOffset,\n            line: errorLine,\n            column: errorColumn,\n            length: errLength,\n            message: msg,\n          })\n          if (recoveryEnabled === false) {\n            break\n          }\n        }\n      }\n      // if we do have custom patterns which push directly into the\n      // TODO: custom tokens should not push directly??\n      if (!this.hasCustom) {\n        // if we guessed a too large size for the tokens array this will shrink it to the right size.\n        matchedTokens.length = matchedTokensIndex\n      }\n      return {\n        tokens: matchedTokens,\n        groups: groups,\n        errors: errors,\n      }\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n      if (config.pop === true) {\n        // need to save the PUSH_MODE property as if the mode is popped\n        // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n        const pushMode = config.push\n        pop_mode(newToken)\n        if (pushMode !== undefined) {\n          push_mode.call(this, pushMode)\n        }\n      } else if (config.push !== undefined) {\n        push_mode.call(this, config.push)\n      }\n    }\n    chopInput(text, length) {\n      return text.substring(length)\n    }\n    updateLastIndex(regExp, newLastIndex) {\n      regExp.lastIndex = newLastIndex\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n      let lastCharIsLT, fixForEndingInLT\n      if (group !== undefined) {\n        // a none skipped multi line Token, need to update endLine/endColumn\n        lastCharIsLT = lastLTIdx === imageLength - 1\n        fixForEndingInLT = lastCharIsLT ? -1 : 0\n        if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n          // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n          newToken.endLine = line + fixForEndingInLT\n          // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n          // inclusive to exclusive range.\n          newToken.endColumn = column - 1 + -fixForEndingInLT\n        }\n        // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n      }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n      return oldColumn + imageLength\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n      return {\n        image,\n        startOffset,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n      return {\n        image,\n        startOffset,\n        startLine,\n        startColumn,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n      return {\n        image,\n        startOffset,\n        endOffset: startOffset + imageLength - 1,\n        startLine,\n        endLine: startLine,\n        startColumn,\n        endColumn: startColumn + imageLength - 1,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n      tokenVector.push(tokenToAdd)\n      return index\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n      tokenVector[index] = tokenToAdd\n      index++\n      return index\n    }\n    handlePayloadNoCustom(token, payload) {}\n    handlePayloadWithCustom(token, payload) {\n      if (payload !== null) {\n        token.payload = payload\n      }\n    }\n    matchWithTest(pattern, text, offset) {\n      const found = pattern.test(text)\n      if (found === true) {\n        return text.substring(offset, pattern.lastIndex)\n      }\n      return null\n    }\n    matchWithExec(pattern, text) {\n      const regExpArray = pattern.exec(text)\n      return regExpArray !== null ? regExpArray[0] : null\n    }\n  }\n  Lexer.SKIPPED =\n    'This marks a skipped Token pattern, this means each token identified by it will' +\n    'be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.'\n  Lexer.NA = /NOT_APPLICABLE/\n\n  function tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n      return tokType.LABEL\n    } else {\n      return tokType.name\n    }\n  }\n  function hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== ''\n  }\n  const PARENT = 'parent'\n  const CATEGORIES = 'categories'\n  const LABEL = 'label'\n  const GROUP = 'group'\n  const PUSH_MODE = 'push_mode'\n  const POP_MODE = 'pop_mode'\n  const LONGER_ALT = 'longer_alt'\n  const LINE_BREAKS = 'line_breaks'\n  const START_CHARS_HINT = 'start_chars_hint'\n  function createToken(config) {\n    return createTokenInternal(config)\n  }\n  function createTokenInternal(config) {\n    const pattern = config.pattern\n    const tokenType = {}\n    tokenType.name = config.name\n    if (!isUndefined(pattern)) {\n      tokenType.PATTERN = pattern\n    }\n    if (has(config, PARENT)) {\n      throw (\n        'The parent property is no longer supported.\\n' +\n        'See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.'\n      )\n    }\n    if (has(config, CATEGORIES)) {\n      // casting to ANY as this will be fixed inside `augmentTokenTypes``\n      tokenType.CATEGORIES = config[CATEGORIES]\n    }\n    augmentTokenTypes([tokenType])\n    if (has(config, LABEL)) {\n      tokenType.LABEL = config[LABEL]\n    }\n    if (has(config, GROUP)) {\n      tokenType.GROUP = config[GROUP]\n    }\n    if (has(config, POP_MODE)) {\n      tokenType.POP_MODE = config[POP_MODE]\n    }\n    if (has(config, PUSH_MODE)) {\n      tokenType.PUSH_MODE = config[PUSH_MODE]\n    }\n    if (has(config, LONGER_ALT)) {\n      tokenType.LONGER_ALT = config[LONGER_ALT]\n    }\n    if (has(config, LINE_BREAKS)) {\n      tokenType.LINE_BREAKS = config[LINE_BREAKS]\n    }\n    if (has(config, START_CHARS_HINT)) {\n      tokenType.START_CHARS_HINT = config[START_CHARS_HINT]\n    }\n    return tokenType\n  }\n  const EOF = createToken({ name: 'EOF', pattern: Lexer.NA })\n  augmentTokenTypes([EOF])\n  function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n      image,\n      startOffset,\n      endOffset,\n      startLine,\n      endLine,\n      startColumn,\n      endColumn,\n      tokenTypeIdx: tokType.tokenTypeIdx,\n      tokenType: tokType,\n    }\n  }\n  function tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType)\n  }\n\n  const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n      const hasLabel = hasTokenLabel(expected)\n      const expectedMsg = hasLabel ? `--> ${tokenLabel(expected)} <--` : `token of type --> ${expected.name} <--`\n      const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n      return msg\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n      return 'Redundant input, expecting EOF but found: ' + firstRedundant.image\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n      const errPrefix = 'Expecting: '\n      // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n      const actualText = head(actual).image\n      const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n      if (customUserDescription) {\n        return errPrefix + customUserDescription + errSuffix\n      } else {\n        const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), [])\n        const nextValidTokenSequences = map(\n          allLookAheadPaths,\n          (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(', ')}]`,\n        )\n        const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`)\n        const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join('\\n')}`\n        return errPrefix + calculatedDescription + errSuffix\n      }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n      const errPrefix = 'Expecting: '\n      // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n      const actualText = head(actual).image\n      const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n      if (customUserDescription) {\n        return errPrefix + customUserDescription + errSuffix\n      } else {\n        const nextValidTokenSequences = map(\n          expectedIterationPaths,\n          (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(',')}]`,\n        )\n        const calculatedDescription =\n          `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n          `<${nextValidTokenSequences.join(' ,')}>`\n        return errPrefix + calculatedDescription + errSuffix\n      }\n    },\n  }\n  Object.freeze(defaultParserErrorProvider)\n  const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n      const msg =\n        'Invalid grammar, reference to a rule which is not defined: ->' +\n        undefinedRule.nonTerminalName +\n        '<-\\n' +\n        'inside top level rule: ->' +\n        topLevelRule.name +\n        '<-'\n      return msg\n    },\n  }\n  const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n      function getExtraProductionArgument(prod) {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return ''\n        }\n      }\n      const topLevelName = topLevelRule.name\n      const duplicateProd = head(duplicateProds)\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : ''}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : ''\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, ' ')\n      msg = msg.replace(/\\s\\s+/g, '\\n')\n      return msg\n    },\n    buildNamespaceConflictError(rule) {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n      return errMsg\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n      const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(', ')\n      const occurrence = options.alternation.idx === 0 ? '' : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(' ,')}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n      return errMsg\n    },\n    buildAlternationAmbiguityError(options) {\n      const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(', ')\n      const occurrence = options.alternation.idx === 0 ? '' : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(' ,')}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n    buildEmptyRepetitionError(options) {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n      return errMsg\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n      /* istanbul ignore next */\n      return 'deprecated'\n    },\n    buildEmptyAlternationError(options) {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n      return errMsg\n    },\n    buildTooManyAlternativesError(options) {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n      return errMsg\n    },\n    buildLeftRecursionError(options) {\n      const ruleName = options.topLevelRule.name\n      const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name)\n      const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(' --> ')}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\n      return errMsg\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n      /* istanbul ignore next */\n      return 'deprecated'\n    },\n    buildDuplicateRuleNameError(options) {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n      return errMsg\n    },\n  }\n\n  function resolveGrammar$1(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider)\n    refResolver.resolveRefs()\n    return refResolver.errors\n  }\n  class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n      super()\n      this.nameToTopRule = nameToTopRule\n      this.errMsgProvider = errMsgProvider\n      this.errors = []\n    }\n    resolveRefs() {\n      forEach(values(this.nameToTopRule), (prod) => {\n        this.currTopLevel = prod\n        prod.accept(this)\n      })\n    }\n    visitNonTerminal(node) {\n      const ref = this.nameToTopRule[node.nonTerminalName]\n      if (!ref) {\n        const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node)\n        this.errors.push({\n          message: msg,\n          type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n          ruleName: this.currTopLevel.name,\n          unresolvedRefName: node.nonTerminalName,\n        })\n      } else {\n        node.referencedRule = ref\n      }\n    }\n  }\n\n  class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n      super()\n      this.topProd = topProd\n      this.path = path\n      this.possibleTokTypes = []\n      this.nextProductionName = ''\n      this.nextProductionOccurrence = 0\n      this.found = false\n      this.isAtEndOfPath = false\n    }\n    startWalking() {\n      this.found = false\n      if (this.path.ruleStack[0] !== this.topProd.name) {\n        throw Error(\"The path does not start with the walker's top Rule!\")\n      }\n      // immutable for the win\n      this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\n      this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n      // already verified that the first production is valid, we now seek the 2nd production\n      this.ruleStack.pop()\n      this.occurrenceStack.pop()\n      this.updateExpectedNext()\n      this.walk(this.topProd)\n      return this.possibleTokTypes\n    }\n    walk(prod, prevRest = []) {\n      // stop scanning once we found the path\n      if (!this.found) {\n        super.walk(prod, prevRest)\n      }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n      // found the next production, need to keep walking in it\n      if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n        const fullRest = currRest.concat(prevRest)\n        this.updateExpectedNext()\n        this.walk(refProd.referencedRule, fullRest)\n      }\n    }\n    updateExpectedNext() {\n      // need to consume the Terminal\n      if (isEmpty(this.ruleStack)) {\n        // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n        // really seeking is the last Terminal...\n        this.nextProductionName = ''\n        this.nextProductionOccurrence = 0\n        this.isAtEndOfPath = true\n      } else {\n        this.nextProductionName = this.ruleStack.pop()\n        this.nextProductionOccurrence = this.occurrenceStack.pop()\n      }\n    }\n  }\n  class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n      super(topProd, path)\n      this.path = path\n      this.nextTerminalName = ''\n      this.nextTerminalOccurrence = 0\n      this.nextTerminalName = this.path.lastTok.name\n      this.nextTerminalOccurrence = this.path.lastTokOccurrence\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n      if (\n        this.isAtEndOfPath &&\n        terminal.terminalType.name === this.nextTerminalName &&\n        terminal.idx === this.nextTerminalOccurrence &&\n        !this.found\n      ) {\n        const fullRest = currRest.concat(prevRest)\n        const restProd = new Alternative({ definition: fullRest })\n        this.possibleTokTypes = first(restProd)\n        this.found = true\n      }\n    }\n  }\n  /**\n   * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n   * it never \"follows\" production refs\n   */\n  class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n      super()\n      this.topRule = topRule\n      this.occurrence = occurrence\n      this.result = {\n        token: undefined,\n        occurrence: undefined,\n        isEndOfRule: undefined,\n      }\n    }\n    startWalking() {\n      this.walk(this.topRule)\n      return this.result\n    }\n  }\n  class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n      if (manyProd.idx === this.occurrence) {\n        const firstAfterMany = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterMany === undefined\n        if (firstAfterMany instanceof Terminal) {\n          this.result.token = firstAfterMany.terminalType\n          this.result.occurrence = firstAfterMany.idx\n        }\n      } else {\n        super.walkMany(manyProd, currRest, prevRest)\n      }\n    }\n  }\n  class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n      if (manySepProd.idx === this.occurrence) {\n        const firstAfterManySep = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterManySep === undefined\n        if (firstAfterManySep instanceof Terminal) {\n          this.result.token = firstAfterManySep.terminalType\n          this.result.occurrence = firstAfterManySep.idx\n        }\n      } else {\n        super.walkManySep(manySepProd, currRest, prevRest)\n      }\n    }\n  }\n  class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      if (atLeastOneProd.idx === this.occurrence) {\n        const firstAfterAtLeastOne = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n        if (firstAfterAtLeastOne instanceof Terminal) {\n          this.result.token = firstAfterAtLeastOne.terminalType\n          this.result.occurrence = firstAfterAtLeastOne.idx\n        }\n      } else {\n        super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n      }\n    }\n  }\n  // TODO: reduce code duplication in the AfterWalkers\n  class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n      if (atleastOneSepProd.idx === this.occurrence) {\n        const firstAfterfirstAfterAtLeastOneSep = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n        if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n          this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n          this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n        }\n      } else {\n        super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n      }\n    }\n  }\n  function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath)\n    let result = []\n    let i = 0\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n      return nextDef.concat(drop(targetDef, i + 1))\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n      const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath)\n      return result.concat(alternatives)\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n      const prod = targetDef[i]\n      /* istanbul ignore else */\n      if (prod instanceof Alternative) {\n        return getAlternativesForProd(prod.definition)\n      } else if (prod instanceof NonTerminal) {\n        return getAlternativesForProd(prod.definition)\n      } else if (prod instanceof Option) {\n        result = getAlternativesForProd(prod.definition)\n      } else if (prod instanceof RepetitionMandatory) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: prod.definition,\n          }),\n        ])\n        return getAlternativesForProd(newDef)\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        const newDef = [\n          new Alternative({ definition: prod.definition }),\n          new Repetition({\n            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n          }),\n        ]\n        return getAlternativesForProd(newDef)\n      } else if (prod instanceof RepetitionWithSeparator) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n          }),\n        ])\n        result = getAlternativesForProd(newDef)\n      } else if (prod instanceof Repetition) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: prod.definition,\n          }),\n        ])\n        result = getAlternativesForProd(newDef)\n      } else if (prod instanceof Alternation) {\n        forEach(prod.definition, (currAlt) => {\n          // TODO: this is a limited check for empty alternatives\n          //   It would prevent a common case of infinite loops during parser initialization.\n          //   However **in-directly** empty alternatives may still cause issues.\n          if (isEmpty(currAlt.definition) === false) {\n            result = getAlternativesForProd(currAlt.definition)\n          }\n        })\n        return result\n      } else if (prod instanceof Terminal) {\n        currPath.push(prod.terminalType)\n      } else {\n        throw Error('non exhaustive match')\n      }\n      i++\n    }\n    result.push({\n      partialPath: currPath,\n      suffixDef: drop(targetDef, i),\n    })\n    return result\n  }\n  function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = 'EXIT_NONE_TERMINAL'\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n    const EXIT_ALTERNATIVE = 'EXIT_ALTERNATIVE'\n    let foundCompletePath = false\n    const tokenVectorLength = tokenVector.length\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n    const result = []\n    const possiblePaths = []\n    possiblePaths.push({\n      idx: -1,\n      def: initialDef,\n      ruleStack: [],\n      occurrenceStack: [],\n    })\n    while (!isEmpty(possiblePaths)) {\n      const currPath = possiblePaths.pop()\n      // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n      if (currPath === EXIT_ALTERNATIVE) {\n        if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n          // remove irrelevant alternative\n          possiblePaths.pop()\n        }\n        continue\n      }\n      const currDef = currPath.def\n      const currIdx = currPath.idx\n      const currRuleStack = currPath.ruleStack\n      const currOccurrenceStack = currPath.occurrenceStack\n      // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n      if (isEmpty(currDef)) {\n        continue\n      }\n      const prod = currDef[0]\n      /* istanbul ignore else */\n      if (prod === EXIT_NON_TERMINAL) {\n        const nextPath = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: dropRight(currRuleStack),\n          occurrenceStack: dropRight(currOccurrenceStack),\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof Terminal) {\n        /* istanbul ignore else */\n        if (currIdx < tokenVectorLength - 1) {\n          const nextIdx = currIdx + 1\n          const actualToken = tokenVector[nextIdx]\n          if (tokMatcher(actualToken, prod.terminalType)) {\n            const nextPath = {\n              idx: nextIdx,\n              def: drop(currDef),\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack,\n            }\n            possiblePaths.push(nextPath)\n          }\n          // end of the line\n        } else if (currIdx === tokenVectorLength - 1) {\n          // IGNORE ABOVE ELSE\n          result.push({\n            nextTokenType: prod.terminalType,\n            nextTokenOccurrence: prod.idx,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          })\n          foundCompletePath = true\n        } else {\n          throw Error('non exhaustive match')\n        }\n      } else if (prod instanceof NonTerminal) {\n        const newRuleStack = clone(currRuleStack)\n        newRuleStack.push(prod.nonTerminalName)\n        const newOccurrenceStack = clone(currOccurrenceStack)\n        newOccurrenceStack.push(prod.idx)\n        const nextPath = {\n          idx: currIdx,\n          def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n          ruleStack: newRuleStack,\n          occurrenceStack: newOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof Option) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        const nextPathWith = {\n          idx: currIdx,\n          def: prod.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof RepetitionMandatory) {\n        // TODO:(THE NEW operators here take a while...) (convert once?)\n        const secondIteration = new Repetition({\n          definition: prod.definition,\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n        const nextPath = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        // TODO:(THE NEW operators here take a while...) (convert once?)\n        const separatorGast = new Terminal({\n          terminalType: prod.separator,\n        })\n        const secondIteration = new Repetition({\n          definition: [separatorGast].concat(prod.definition),\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n        const nextPath = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof RepetitionWithSeparator) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        const separatorGast = new Terminal({\n          terminalType: prod.separator,\n        })\n        const nthRepetition = new Repetition({\n          definition: [separatorGast].concat(prod.definition),\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n        const nextPathWith = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof Repetition) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n        const nthRepetition = new Repetition({\n          definition: prod.definition,\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n        const nextPathWith = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof Alternation) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        for (let i = prod.definition.length - 1; i >= 0; i--) {\n          const currAlt = prod.definition[i]\n          const currAltPath = {\n            idx: currIdx,\n            def: currAlt.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          }\n          possiblePaths.push(currAltPath)\n          possiblePaths.push(EXIT_ALTERNATIVE)\n        }\n      } else if (prod instanceof Alternative) {\n        possiblePaths.push({\n          idx: currIdx,\n          def: prod.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        })\n      } else if (prod instanceof Rule) {\n        // last because we should only encounter at most a single one of these per invocation.\n        possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack))\n      } else {\n        throw Error('non exhaustive match')\n      }\n    }\n    return result\n  }\n  function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack)\n    newRuleStack.push(topRule.name)\n    const newCurrOccurrenceStack = clone(currOccurrenceStack)\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1)\n    return {\n      idx: currIdx,\n      def: topRule.definition,\n      ruleStack: newRuleStack,\n      occurrenceStack: newCurrOccurrenceStack,\n    }\n  }\n\n  var PROD_TYPE\n  ;(function (PROD_TYPE) {\n    PROD_TYPE[(PROD_TYPE['OPTION'] = 0)] = 'OPTION'\n    PROD_TYPE[(PROD_TYPE['REPETITION'] = 1)] = 'REPETITION'\n    PROD_TYPE[(PROD_TYPE['REPETITION_MANDATORY'] = 2)] = 'REPETITION_MANDATORY'\n    PROD_TYPE[(PROD_TYPE['REPETITION_MANDATORY_WITH_SEPARATOR'] = 3)] = 'REPETITION_MANDATORY_WITH_SEPARATOR'\n    PROD_TYPE[(PROD_TYPE['REPETITION_WITH_SEPARATOR'] = 4)] = 'REPETITION_WITH_SEPARATOR'\n    PROD_TYPE[(PROD_TYPE['ALTERNATION'] = 5)] = 'ALTERNATION'\n  })(PROD_TYPE || (PROD_TYPE = {}))\n  function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === 'Option') {\n      return PROD_TYPE.OPTION\n    } else if (prod instanceof Repetition || prod === 'Repetition') {\n      return PROD_TYPE.REPETITION\n    } else if (prod instanceof RepetitionMandatory || prod === 'RepetitionMandatory') {\n      return PROD_TYPE.REPETITION_MANDATORY\n    } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === 'RepetitionMandatoryWithSeparator') {\n      return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n    } else if (prod instanceof RepetitionWithSeparator || prod === 'RepetitionWithSeparator') {\n      return PROD_TYPE.REPETITION_WITH_SEPARATOR\n    } else if (prod instanceof Alternation || prod === 'Alternation') {\n      return PROD_TYPE.ALTERNATION\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function buildLookaheadFuncForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead,\n    hasPredicates,\n    dynamicTokensEnabled,\n    laFuncBuilder,\n  ) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead)\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled)\n  }\n  /**\n   *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n   *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n   *\n   *  Example: given a production:\n   *  ABC(DE)?DF\n   *\n   *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n   *  alternatives.\n   *\n   *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n   */\n  function buildLookaheadFuncForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    k,\n    dynamicTokensEnabled,\n    prodType,\n    lookaheadBuilder,\n  ) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k)\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n  }\n  function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n      return every(currAlt, (currPath) => {\n        return currPath.length === 1\n      })\n    })\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function (orAlts) {\n        // unfortunately the predicates must be extracted every single time\n        // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n        // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n        const predicates = map(orAlts, (currAlt) => currAlt.GATE)\n        for (let t = 0; t < numOfAlts; t++) {\n          const currAlt = alts[t]\n          const currNumOfPaths = currAlt.length\n          const currPredicate = predicates[t]\n          if (currPredicate !== undefined && currPredicate.call(this) === false) {\n            // if the predicate does not match there is no point in checking the paths\n            continue\n          }\n          nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j]\n            const currPathLength = currPath.length\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1)\n              if (tokenMatcher(nextToken, currPath[i]) === false) {\n                // mismatch in current path\n                // try the next pth\n                continue nextPath\n              }\n            }\n            // found a full path that matches.\n            // this will also work for an empty ALT as the loop will be skipped\n            return t\n          }\n          // none of the paths for the current alternative matched\n          // try the next alternative\n        }\n        // none of the alternatives could be matched\n        return undefined\n      }\n    } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n      // optimized (common) case of all the lookaheads paths requiring only\n      // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n      const singleTokenAlts = map(alts, (currAlt) => {\n        return flatten(currAlt)\n      })\n      const choiceToAlt = reduce(\n        singleTokenAlts,\n        (result, currAlt, idx) => {\n          forEach(currAlt, (currTokType) => {\n            if (!has(result, currTokType.tokenTypeIdx)) {\n              result[currTokType.tokenTypeIdx] = idx\n            }\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              if (!has(result, currExtendingType)) {\n                result[currExtendingType] = idx\n              }\n            })\n          })\n          return result\n        },\n        {},\n      )\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function () {\n        const nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx]\n      }\n    } else {\n      // optimized lookahead without needing to check the predicates at all.\n      // this causes code duplication which is intentional to improve performance.\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function () {\n        for (let t = 0; t < numOfAlts; t++) {\n          const currAlt = alts[t]\n          const currNumOfPaths = currAlt.length\n          nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j]\n            const currPathLength = currPath.length\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1)\n              if (tokenMatcher(nextToken, currPath[i]) === false) {\n                // mismatch in current path\n                // try the next pth\n                continue nextPath\n              }\n            }\n            // found a full path that matches.\n            // this will also work for an empty ALT as the loop will be skipped\n            return t\n          }\n          // none of the paths for the current alternative matched\n          // try the next alternative\n        }\n        // none of the alternatives could be matched\n        return undefined\n      }\n    }\n  }\n  function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n      return currPath.length === 1\n    })\n    const numOfPaths = alt.length\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n      const singleTokensTypes = flatten(alt)\n      if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n        const expectedTokenType = singleTokensTypes[0]\n        const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx\n        return function () {\n          return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n        }\n      } else {\n        const choiceToAlt = reduce(\n          singleTokensTypes,\n          (result, currTokType, idx) => {\n            result[currTokType.tokenTypeIdx] = true\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = true\n            })\n            return result\n          },\n          [],\n        )\n        return function () {\n          const nextToken = this.LA(1)\n          return choiceToAlt[nextToken.tokenTypeIdx] === true\n        }\n      }\n    } else {\n      return function () {\n        nextPath: for (let j = 0; j < numOfPaths; j++) {\n          const currPath = alt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          return true\n        }\n        // none of the paths matched\n        return false\n      }\n    }\n  }\n  class RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n      super()\n      this.topProd = topProd\n      this.targetOccurrence = targetOccurrence\n      this.targetProdType = targetProdType\n    }\n    startWalking() {\n      this.walk(this.topProd)\n      return this.restDef\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n      if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n        this.restDef = currRest.concat(prevRest)\n        return true\n      }\n      // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n      return false\n    }\n    walkOption(optionProd, currRest, prevRest) {\n      if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n        super.walkOption(optionProd, currRest, prevRest)\n      }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n        super.walkOption(atLeastOneProd, currRest, prevRest)\n      }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n      if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n        super.walkOption(atLeastOneSepProd, currRest, prevRest)\n      }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n      if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n        super.walkOption(manyProd, currRest, prevRest)\n      }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n      if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n        super.walkOption(manySepProd, currRest, prevRest)\n      }\n    }\n  }\n  /**\n   * Returns the definition of a target production in a top level level rule.\n   */\n  class InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n      super()\n      this.targetOccurrence = targetOccurrence\n      this.targetProdType = targetProdType\n      this.targetRef = targetRef\n      this.result = []\n    }\n    checkIsTarget(node, expectedProdName) {\n      if (\n        node.idx === this.targetOccurrence &&\n        this.targetProdType === expectedProdName &&\n        (this.targetRef === undefined || node === this.targetRef)\n      ) {\n        this.result = node.definition\n      }\n    }\n    visitOption(node) {\n      this.checkIsTarget(node, PROD_TYPE.OPTION)\n    }\n    visitRepetition(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION)\n    }\n    visitRepetitionMandatory(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n    }\n    visitRepetitionWithSeparator(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n    }\n    visitAlternation(node) {\n      this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n    }\n  }\n  function initializeArrayOfArrays(size) {\n    const result = new Array(size)\n    for (let i = 0; i < size; i++) {\n      result[i] = []\n    }\n    return result\n  }\n  /**\n   * A sort of hash function between a Path in the grammar and a string.\n   * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n   * -  A single path with categories may match multiple **actual** paths.\n   */\n  function pathToHashKeys(path) {\n    let keys = ['']\n    for (let i = 0; i < path.length; i++) {\n      const tokType = path[i]\n      const longerKeys = []\n      for (let j = 0; j < keys.length; j++) {\n        const currShorterKey = keys[j]\n        longerKeys.push(currShorterKey + '_' + tokType.tokenTypeIdx)\n        for (let t = 0; t < tokType.categoryMatches.length; t++) {\n          const categoriesKeySuffix = '_' + tokType.categoryMatches[t]\n          longerKeys.push(currShorterKey + categoriesKeySuffix)\n        }\n      }\n      keys = longerKeys\n    }\n    return keys\n  }\n  /**\n   * Imperative style due to being called from a hot spot\n   */\n  function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n      // We only want to test vs the other alternatives\n      if (currAltIdx === idx) {\n        continue\n      }\n      const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n      for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n        const searchKey = searchPathKeys[searchIdx]\n        if (otherAltKnownPathsKeys[searchKey] === true) {\n          return false\n        }\n      }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true\n  }\n  function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1))\n    const finalResult = initializeArrayOfArrays(partialAlts.length)\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n      const dict = {}\n      forEach(currAltPaths, (item) => {\n        const keys = pathToHashKeys(item.partialPath)\n        forEach(keys, (currKey) => {\n          dict[currKey] = true\n        })\n      })\n      return dict\n    })\n    let newData = partialAlts\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n      const currDataset = newData\n      newData = initializeArrayOfArrays(currDataset.length)\n      // alternatives loop\n      for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n        const currAltPathsAndSuffixes = currDataset[altIdx]\n        // paths in current alternative loop\n        for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n          const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n          const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n          const prefixKeys = pathToHashKeys(currPathPrefix)\n          const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n          // End of the line for this path.\n          if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n            const currAltResult = finalResult[altIdx]\n            // TODO: Can we implement a containsPath using Maps/Dictionaries?\n            if (containsPath(currAltResult, currPathPrefix) === false) {\n              currAltResult.push(currPathPrefix)\n              // Update all new  keys for the current path.\n              for (let j = 0; j < prefixKeys.length; j++) {\n                const currKey = prefixKeys[j]\n                altsHashes[altIdx][currKey] = true\n              }\n            }\n          }\n          // Expand longer paths\n          else {\n            const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix)\n            newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n            // Update keys for new known paths\n            forEach(newPartialPathsAndSuffixes, (item) => {\n              const prefixKeys = pathToHashKeys(item.partialPath)\n              forEach(prefixKeys, (key) => {\n                altsHashes[altIdx][key] = true\n              })\n            })\n          }\n        }\n      }\n    }\n    return finalResult\n  }\n  function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd)\n    ruleGrammar.accept(visitor)\n    return lookAheadSequenceFromAlternatives(visitor.result, k)\n  }\n  function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType)\n    ruleGrammar.accept(insideDefVisitor)\n    const insideDef = insideDefVisitor.result\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType)\n    const afterDef = afterDefWalker.startWalking()\n    const insideFlat = new Alternative({ definition: insideDef })\n    const afterFlat = new Alternative({ definition: afterDef })\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n  }\n  function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n      const otherPath = alternative[i]\n      if (otherPath.length !== searchPath.length) {\n        continue\n      }\n      for (let j = 0; j < otherPath.length; j++) {\n        const searchTok = searchPath[j]\n        const otherTok = otherPath[j]\n        const matchingTokens =\n          searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined\n        if (matchingTokens === false) {\n          continue compareOtherPath\n        }\n      }\n      return true\n    }\n    return false\n  }\n  function isStrictPrefixOfPath(prefix, other) {\n    return (\n      prefix.length < other.length &&\n      every(prefix, (tokType, idx) => {\n        const otherTokType = other[idx]\n        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]\n      })\n    )\n  }\n  function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) =>\n      every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))),\n    )\n  }\n\n  function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n      rules: options.rules,\n      tokenTypes: options.tokenTypes,\n      grammarName: options.grammarName,\n    })\n    return map(lookaheadValidationErrorMessages, (errorMessage) =>\n      Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage),\n    )\n  }\n  function validateGrammar$1(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) =>\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\n    )\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider)\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider))\n    const duplicateRulesError = flatMap(topLevels, (curRule) =>\n      validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider),\n    )\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)\n  }\n  function validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector()\n    topLevelRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    const productionGroups = groupBy$1(allRuleProductions, identifyProductionForDuplicates)\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n      return currGroup.length > 1\n    })\n    const errors = map(values(duplicates), (currDuplicates) => {\n      const firstProd = head(currDuplicates)\n      const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates)\n      const dslName = getProductionDslName(firstProd)\n      const defError = {\n        message: msg,\n        type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n        ruleName: topLevelRule.name,\n        dslName: dslName,\n        occurrence: firstProd.idx,\n      }\n      const param = getExtraProductionArgument(firstProd)\n      if (param) {\n        defError.parameter = param\n      }\n      return defError\n    })\n    return errors\n  }\n  function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`\n  }\n  function getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n      return prod.terminalType.name\n    } else if (prod instanceof NonTerminal) {\n      return prod.nonTerminalName\n    } else {\n      return ''\n    }\n  }\n  class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.allProductions = []\n    }\n    visitNonTerminal(subrule) {\n      this.allProductions.push(subrule)\n    }\n    visitOption(option) {\n      this.allProductions.push(option)\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.allProductions.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.allProductions.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.allProductions.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.allProductions.push(many)\n    }\n    visitAlternation(or) {\n      this.allProductions.push(or)\n    }\n    visitTerminal(terminal) {\n      this.allProductions.push(terminal)\n    }\n  }\n  function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = []\n    const occurrences = reduce(\n      allRules,\n      (result, curRule) => {\n        if (curRule.name === rule.name) {\n          return result + 1\n        }\n        return result\n      },\n      0,\n    )\n    if (occurrences > 1) {\n      const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n        topLevelRule: rule,\n        grammarName: className,\n      })\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: rule.name,\n      })\n    }\n    return errors\n  }\n  // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n  // This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n  // The grammar structure, only at runtime.\n  function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = []\n    let errMsg\n    if (!includes(definedRulesNames, ruleName)) {\n      errMsg =\n        `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n        `as it is not defined in any of the super grammars `\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n        ruleName: ruleName,\n      })\n    }\n    return errors\n  }\n  function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = []\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n    if (isEmpty(nextNonTerminals)) {\n      return []\n    } else {\n      const ruleName = topRule.name\n      const foundLeftRecursion = includes(nextNonTerminals, topRule)\n      if (foundLeftRecursion) {\n        errors.push({\n          message: errMsgProvider.buildLeftRecursionError({\n            topLevelRule: topRule,\n            leftRecursionPath: path,\n          }),\n          type: ParserDefinitionErrorType.LEFT_RECURSION,\n          ruleName: ruleName,\n        })\n      }\n      // we are only looking for cyclic paths leading back to the specific topRule\n      // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n      const validNextSteps = difference$1(nextNonTerminals, path.concat([topRule]))\n      const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n        const newPath = clone(path)\n        newPath.push(currRefRule)\n        return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath)\n      })\n      return errors.concat(errorsFromNextSteps)\n    }\n  }\n  function getFirstNoneTerminal(definition) {\n    let result = []\n    if (isEmpty(definition)) {\n      return result\n    }\n    const firstProd = head(definition)\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n      result.push(firstProd.referencedRule)\n    } else if (\n      firstProd instanceof Alternative ||\n      firstProd instanceof Option ||\n      firstProd instanceof RepetitionMandatory ||\n      firstProd instanceof RepetitionMandatoryWithSeparator ||\n      firstProd instanceof RepetitionWithSeparator ||\n      firstProd instanceof Repetition\n    ) {\n      result = result.concat(getFirstNoneTerminal(firstProd.definition))\n    } else if (firstProd instanceof Alternation) {\n      // each sub definition in alternation is a FLAT\n      result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)))\n    } else if (firstProd instanceof Terminal);\n    else {\n      throw Error('non exhaustive match')\n    }\n    const isFirstOptional = isOptionalProd(firstProd)\n    const hasMore = definition.length > 1\n    if (isFirstOptional && hasMore) {\n      const rest = drop(definition)\n      return result.concat(getFirstNoneTerminal(rest))\n    } else {\n      return result\n    }\n  }\n  class OrCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.alternations = []\n    }\n    visitAlternation(node) {\n      this.alternations.push(node)\n    }\n  }\n  function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    const ors = orCollector.alternations\n    const errors = flatMap(ors, (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1)\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx,\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1,\n            },\n          ]\n        } else {\n          return []\n        }\n      })\n    })\n    return errors\n  }\n  function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    let ors = orCollector.alternations\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n    const errors = flatMap(ors, (currOr) => {\n      const currOccurrence = currOr.idx\n      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n      const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr)\n      const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider)\n      const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider,\n      )\n      return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n    })\n    return errors\n  }\n  class RepetitionCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.allProductions = []\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.allProductions.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.allProductions.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.allProductions.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.allProductions.push(many)\n    }\n  }\n  function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    const ors = orCollector.alternations\n    const errors = flatMap(ors, (currOr) => {\n      if (currOr.definition.length > 255) {\n        return [\n          {\n            message: errMsgProvider.buildTooManyAlternativesError({\n              topLevelRule: topLevelRule,\n              alternation: currOr,\n            }),\n            type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx,\n          },\n        ]\n      } else {\n        return []\n      }\n    })\n    return errors\n  }\n  function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = []\n    forEach(topLevelRules, (currTopRule) => {\n      const collectorVisitor = new RepetitionCollector()\n      currTopRule.accept(collectorVisitor)\n      const allRuleProductions = collectorVisitor.allProductions\n      forEach(allRuleProductions, (currProd) => {\n        const prodType = getProdType(currProd)\n        const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n        const currOccurrence = currProd.idx\n        const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead)\n        const pathsInsideProduction = paths[0]\n        if (isEmpty(flatten(pathsInsideProduction))) {\n          const errMsg = errMsgProvider.buildEmptyRepetitionError({\n            topLevelRule: currTopRule,\n            repetition: currProd,\n          })\n          errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n            ruleName: currTopRule.name,\n          })\n        }\n      })\n    })\n    return errors\n  }\n  function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = []\n    const identicalAmbiguities = reduce(\n      alternatives,\n      (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n          return result\n        }\n        forEach(currAlt, (currPath) => {\n          const altsCurrPathAppearsIn = [currAltIdx]\n          forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n            if (\n              currAltIdx !== currOtherAltIdx &&\n              containsPath(currOtherAlt, currPath) &&\n              // ignore (skip) ambiguities with this \"other\" alternative\n              alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n            ) {\n              altsCurrPathAppearsIn.push(currOtherAltIdx)\n            }\n          })\n          if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n            foundAmbiguousPaths.push(currPath)\n            result.push({\n              alts: altsCurrPathAppearsIn,\n              path: currPath,\n            })\n          }\n        })\n        return result\n      },\n      [],\n    )\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n      const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1)\n      const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbDescriptor.path,\n      })\n      return {\n        message: currMessage,\n        type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n        ruleName: rule.name,\n        occurrence: alternation.idx,\n        alternatives: currAmbDescriptor.alts,\n      }\n    })\n    return currErrors\n  }\n  function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(\n      alternatives,\n      (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n          return { idx: idx, path: currPath }\n        })\n        return result.concat(currPathsAndIdx)\n      },\n      [],\n    )\n    const errors = compact(\n      flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx]\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n          return []\n        }\n        const targetIdx = currPathAndIdx.idx\n        const targetPath = currPathAndIdx.path\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        })\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? '' : alternation.idx\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path,\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices,\n          }\n        })\n        return currPathPrefixErrors\n      }),\n    )\n    return errors\n  }\n  function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = []\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n    forEach(topLevels, (currRule) => {\n      const currRuleName = currRule.name\n      if (includes(tokenNames, currRuleName)) {\n        const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n          ruleName: currRuleName,\n        })\n      }\n    })\n    return errors\n  }\n\n  function resolveGrammar(options) {\n    const actualOptions = defaults$1(options, {\n      errMsgProvider: defaultGrammarResolverErrorProvider,\n    })\n    const topRulesTable = {}\n    forEach(options.rules, (rule) => {\n      topRulesTable[rule.name] = rule\n    })\n    return resolveGrammar$1(topRulesTable, actualOptions.errMsgProvider)\n  }\n  function validateGrammar(options) {\n    options = defaults$1(options, {\n      errMsgProvider: defaultGrammarValidatorErrorProvider,\n    })\n    return validateGrammar$1(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName)\n  }\n\n  const MISMATCHED_TOKEN_EXCEPTION = 'MismatchedTokenException'\n  const NO_VIABLE_ALT_EXCEPTION = 'NoViableAltException'\n  const EARLY_EXIT_EXCEPTION = 'EarlyExitException'\n  const NOT_ALL_INPUT_PARSED_EXCEPTION = 'NotAllInputParsedException'\n  const RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n  ]\n  Object.freeze(RECOGNITION_EXCEPTION_NAMES)\n  // hacks to bypass no support for custom Errors in javascript/typescript\n  function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name)\n  }\n  class RecognitionException extends Error {\n    constructor(message, token) {\n      super(message)\n      this.token = token\n      this.resyncedTokens = []\n      // fix prototype chain when typescript target is ES5\n      Object.setPrototypeOf(this, new.target.prototype)\n      /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor)\n      }\n    }\n  }\n  class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = MISMATCHED_TOKEN_EXCEPTION\n    }\n  }\n  class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = NO_VIABLE_ALT_EXCEPTION\n    }\n  }\n  class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n      super(message, token)\n      this.name = NOT_ALL_INPUT_PARSED_EXCEPTION\n    }\n  }\n  class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = EARLY_EXIT_EXCEPTION\n    }\n  }\n\n  const EOF_FOLLOW_KEY = {}\n  const IN_RULE_RECOVERY_EXCEPTION = 'InRuleRecoveryException'\n  class InRuleRecoveryException extends Error {\n    constructor(message) {\n      super(message)\n      this.name = IN_RULE_RECOVERY_EXCEPTION\n    }\n  }\n  /**\n   * This trait is responsible for the error recovery and fault tolerant logic\n   */\n  class Recoverable {\n    initRecoverable(config) {\n      this.firstAfterRepMap = {}\n      this.resyncFollows = {}\n      this.recoveryEnabled = has(config, 'recoveryEnabled')\n        ? config.recoveryEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.recoveryEnabled\n      // performance optimization, NOOP will be inlined which\n      // effectively means that this optional feature does not exist\n      // when not used.\n      if (this.recoveryEnabled) {\n        this.attemptInRepetitionRecovery = attemptInRepetitionRecovery\n      }\n    }\n    getTokenToInsert(tokType) {\n      const tokToInsert = createTokenInstance(tokType, '', NaN, NaN, NaN, NaN, NaN, NaN)\n      tokToInsert.isInsertedInRecovery = true\n      return tokToInsert\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n      return true\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n      return true\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n      // TODO: can the resyncTokenType be cached?\n      const reSyncTokType = this.findReSyncTokenType()\n      const savedLexerState = this.exportLexerState()\n      const resyncedTokens = []\n      let passedResyncPoint = false\n      const nextTokenWithoutResync = this.LA(1)\n      let currToken = this.LA(1)\n      const generateErrorMessage = () => {\n        const previousToken = this.LA(0)\n        // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n        // the error that would have been thrown\n        const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n          expected: expectedTokType,\n          actual: nextTokenWithoutResync,\n          previous: previousToken,\n          ruleName: this.getCurrRuleFullName(),\n        })\n        const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0))\n        // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n        error.resyncedTokens = dropRight(resyncedTokens)\n        this.SAVE_ERROR(error)\n      }\n      while (!passedResyncPoint) {\n        // re-synced to a point where we can safely exit the repetition/\n        if (this.tokenMatcher(currToken, expectedTokType)) {\n          generateErrorMessage()\n          return // must return here to avoid reverting the inputIdx\n        } else if (lookAheadFunc.call(this)) {\n          // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n          generateErrorMessage()\n          // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n          grammarRule.apply(this, grammarRuleArgs)\n          return // must return here to avoid reverting the inputIdx\n        } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n          passedResyncPoint = true\n        } else {\n          currToken = this.SKIP_TOKEN()\n          this.addToResyncTokens(currToken, resyncedTokens)\n        }\n      }\n      // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n      // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n      // \"between rules\" resync recovery later in the flow.\n      this.importLexerState(savedLexerState)\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n      // Edge case of arriving from a MANY repetition which is stuck\n      // Attempting recovery in this case could cause an infinite loop\n      if (notStuck === false) {\n        return false\n      }\n      // no need to recover, next token is what we expect...\n      if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n        return false\n      }\n      // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n      // and prefer some backtracking path that includes recovered errors.\n      if (this.isBackTracking()) {\n        return false\n      }\n      // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n      // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n      //noinspection RedundantIfStatementJS\n      if (\n        this.canPerformInRuleRecovery(\n          expectTokAfterLastMatch,\n          this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx),\n        )\n      ) {\n        return false\n      }\n      return true\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n      const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule)\n      const follows = this.getNextPossibleTokenTypes(grammarPath)\n      return follows\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n      if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n        const tokToInsert = this.getTokenToInsert(expectedTokType)\n        return tokToInsert\n      }\n      if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n        const nextTok = this.SKIP_TOKEN()\n        this.consumeToken()\n        return nextTok\n      }\n      throw new InRuleRecoveryException('sad sad panda')\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n      return (\n        this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n        this.canRecoverWithSingleTokenDeletion(expectedToken)\n      )\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n      if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n        return false\n      }\n      // must know the possible following tokens to perform single token insertion\n      if (isEmpty(follows)) {\n        return false\n      }\n      const mismatchedTok = this.LA(1)\n      const isMisMatchedTokInFollows =\n        find$1(follows, (possibleFollowsTokType) => {\n          return this.tokenMatcher(mismatchedTok, possibleFollowsTokType)\n        }) !== undefined\n      return isMisMatchedTokInFollows\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n      if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n        return false\n      }\n      const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType)\n      return isNextTokenWhatIsExpected\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n      const followKey = this.getCurrFollowKey()\n      const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey)\n      return includes(currentRuleReSyncSet, tokenTypeIdx)\n    }\n    findReSyncTokenType() {\n      const allPossibleReSyncTokTypes = this.flattenFollowSet()\n      // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n      let nextToken = this.LA(1)\n      let k = 2\n      while (true) {\n        const foundMatch = find$1(allPossibleReSyncTokTypes, (resyncTokType) => {\n          const canMatch = tokenMatcher(nextToken, resyncTokType)\n          return canMatch\n        })\n        if (foundMatch !== undefined) {\n          return foundMatch\n        }\n        nextToken = this.LA(k)\n        k++\n      }\n    }\n    getCurrFollowKey() {\n      // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n      if (this.RULE_STACK.length === 1) {\n        return EOF_FOLLOW_KEY\n      }\n      const currRuleShortName = this.getLastExplicitRuleShortName()\n      const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex()\n      const prevRuleShortName = this.getPreviousExplicitRuleShortName()\n      return {\n        ruleName: this.shortRuleNameToFullName(currRuleShortName),\n        idxInCallingRule: currRuleIdx,\n        inRule: this.shortRuleNameToFullName(prevRuleShortName),\n      }\n    }\n    buildFullFollowKeyStack() {\n      const explicitRuleStack = this.RULE_STACK\n      const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK\n      return map(explicitRuleStack, (ruleName, idx) => {\n        if (idx === 0) {\n          return EOF_FOLLOW_KEY\n        }\n        return {\n          ruleName: this.shortRuleNameToFullName(ruleName),\n          idxInCallingRule: explicitOccurrenceStack[idx],\n          inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n        }\n      })\n    }\n    flattenFollowSet() {\n      const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n        return this.getFollowSetFromFollowKey(currKey)\n      })\n      return flatten(followStack)\n    }\n    getFollowSetFromFollowKey(followKey) {\n      if (followKey === EOF_FOLLOW_KEY) {\n        return [EOF]\n      }\n      const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule\n      return this.resyncFollows[followName]\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n      if (!this.tokenMatcher(token, EOF)) {\n        resyncTokens.push(token)\n      }\n      return resyncTokens\n    }\n    reSyncTo(tokType) {\n      const resyncedTokens = []\n      let nextTok = this.LA(1)\n      while (this.tokenMatcher(nextTok, tokType) === false) {\n        nextTok = this.SKIP_TOKEN()\n        this.addToResyncTokens(nextTok, resyncedTokens)\n      }\n      // the last token is not part of the error.\n      return dropRight(resyncedTokens)\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n      // by default this is a NO-OP\n      // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n      const pathRuleStack = this.getHumanReadableRuleStack()\n      const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK)\n      const grammarPath = {\n        ruleStack: pathRuleStack,\n        occurrenceStack: pathOccurrenceStack,\n        lastTok: tokType,\n        lastTokOccurrence: tokIdxInRule,\n      }\n      return grammarPath\n    }\n    getHumanReadableRuleStack() {\n      return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName))\n    }\n  }\n  function attemptInRepetitionRecovery(\n    prodFunc,\n    args,\n    lookaheadFunc,\n    dslMethodIdx,\n    prodOccurrence,\n    nextToksWalker,\n    notStuck,\n  ) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence)\n    let firstAfterRepInfo = this.firstAfterRepMap[key]\n    if (firstAfterRepInfo === undefined) {\n      const currRuleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[currRuleName]\n      const walker = new nextToksWalker(ruleGrammar, prodOccurrence)\n      firstAfterRepInfo = walker.startWalking()\n      this.firstAfterRepMap[key] = firstAfterRepInfo\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token\n    let nextTokIdx = firstAfterRepInfo.occurrence\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n      expectTokAfterLastMatch = EOF\n      nextTokIdx = 1\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n      // TODO: performance optimization: instead of passing the original args here, we modify\n      // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n      // to avoid searching the cache for it once more.\n      this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch)\n    }\n  }\n\n  // Lookahead keys are 32Bit integers in the form\n  // TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n  // XXXX -> Occurrence Index bitmap.\n  // YYYY -> DSL Method Type bitmap.\n  // ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n  // TTTTTTTTT -> alternation alternative index bitmap\n  const BITS_FOR_METHOD_TYPE = 4\n  const BITS_FOR_OCCURRENCE_IDX = 8\n  // short string used as part of mapping keys.\n  // being short improves the performance when composing KEYS for maps out of these\n  // The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n  const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\n  const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\n  const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\n  const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\n  const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\n  const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n  // this actually returns a number, but it is always used as a string (object prop key)\n  function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx\n  }\n\n  class LLkLookaheadStrategy {\n    constructor(options) {\n      var _a\n      this.maxLookahead =\n        (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0\n          ? _a\n          : DEFAULT_PARSER_CONFIG.maxLookahead\n    }\n    validate(options) {\n      const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n      if (isEmpty(leftRecursionErrors)) {\n        const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n        const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead)\n        const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead)\n        const allErrors = [...leftRecursionErrors, ...emptyAltErrors, ...ambiguousAltsErrors, ...emptyRepetitionErrors]\n        return allErrors\n      }\n      return leftRecursionErrors\n    }\n    validateNoLeftRecursion(rules) {\n      return flatMap(rules, (currTopRule) =>\n        validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateEmptyOrAlternatives(rules) {\n      return flatMap(rules, (currTopRule) =>\n        validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n      return flatMap(rules, (currTopRule) =>\n        validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n      return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider)\n    }\n    buildLookaheadForAlternation(options) {\n      return buildLookaheadFuncForOr(\n        options.prodOccurrence,\n        options.rule,\n        options.maxLookahead,\n        options.hasPredicates,\n        options.dynamicTokensEnabled,\n        buildAlternativesLookAheadFunc,\n      )\n    }\n    buildLookaheadForOptional(options) {\n      return buildLookaheadFuncForOptionalProd(\n        options.prodOccurrence,\n        options.rule,\n        options.maxLookahead,\n        options.dynamicTokensEnabled,\n        getProdType(options.prodType),\n        buildSingleAlternativeLookaheadFunction,\n      )\n    }\n  }\n\n  /**\n   * Trait responsible for the lookahead related utilities and optimizations.\n   */\n  class LooksAhead {\n    initLooksAhead(config) {\n      this.dynamicTokensEnabled = has(config, 'dynamicTokensEnabled')\n        ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n      this.maxLookahead = has(config, 'maxLookahead')\n        ? config.maxLookahead // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.maxLookahead\n      this.lookaheadStrategy = has(config, 'lookaheadStrategy')\n        ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n        : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n      this.lookAheadFuncsCache = new Map()\n    }\n    preComputeLookaheadFunctions(rules) {\n      forEach(rules, (currRule) => {\n        this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n          const {\n            alternation,\n            repetition,\n            option,\n            repetitionMandatory,\n            repetitionMandatoryWithSeparator,\n            repetitionWithSeparator,\n          } = collectMethods(currRule)\n          forEach(alternation, (currProd) => {\n            const prodIdx = currProd.idx === 0 ? '' : currProd.idx\n            this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n              const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                prodOccurrence: currProd.idx,\n                rule: currRule,\n                maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                hasPredicates: currProd.hasPredicates,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n              })\n              const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx)\n              this.setLaFuncCache(key, laFunc)\n            })\n          })\n          forEach(repetition, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              MANY_IDX,\n              'Repetition',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(option, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              OPTION_IDX,\n              'Option',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionMandatory, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              AT_LEAST_ONE_IDX,\n              'RepetitionMandatory',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionMandatoryWithSeparator, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              AT_LEAST_ONE_SEP_IDX,\n              'RepetitionMandatoryWithSeparator',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionWithSeparator, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              MANY_SEP_IDX,\n              'RepetitionWithSeparator',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n        })\n      })\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n      this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? '' : prodOccurrence}`, () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType,\n        })\n        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence)\n        this.setLaFuncCache(key, laFunc)\n      })\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n      const currRuleShortName = this.getLastExplicitRuleShortName()\n      return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence)\n    }\n    getLaFuncFromCache(key) {\n      return this.lookAheadFuncsCache.get(key)\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n      this.lookAheadFuncsCache.set(key, value)\n    }\n  }\n  class DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.dslMethods = {\n        option: [],\n        alternation: [],\n        repetition: [],\n        repetitionWithSeparator: [],\n        repetitionMandatory: [],\n        repetitionMandatoryWithSeparator: [],\n      }\n    }\n    reset() {\n      this.dslMethods = {\n        option: [],\n        alternation: [],\n        repetition: [],\n        repetitionWithSeparator: [],\n        repetitionMandatory: [],\n        repetitionMandatoryWithSeparator: [],\n      }\n    }\n    visitOption(option) {\n      this.dslMethods.option.push(option)\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.dslMethods.repetitionWithSeparator.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.dslMethods.repetitionMandatory.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.dslMethods.repetition.push(many)\n    }\n    visitAlternation(or) {\n      this.dslMethods.alternation.push(or)\n    }\n  }\n  const collectorVisitor = new DslMethodsCollectorVisitor()\n  function collectMethods(rule) {\n    collectorVisitor.reset()\n    rule.accept(collectorVisitor)\n    const dslMethods = collectorVisitor.dslMethods\n    // avoid uncleaned references\n    collectorVisitor.reset()\n    return dslMethods\n  }\n\n  /**\n   * This nodeLocation tracking is not efficient and should only be used\n   * when error recovery is enabled or the Token Vector contains virtual Tokens\n   * (e.g, Python Indent/Outdent)\n   * As it executes the calculation for every single terminal/nonTerminal\n   * and does not rely on the fact the token vector is **sorted**\n   */\n  function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n      // assumption1: Token location information is either NaN or a valid number\n      // assumption2: Token location information is fully valid if it exist\n      // (both start/end offsets exist and are numbers).\n      currNodeLocation.startOffset = newLocationInfo.startOffset\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n    }\n  }\n  /**\n   * This nodeLocation tracking is not efficient and should only be used\n   * when error recovery is enabled or the Token Vector contains virtual Tokens\n   * (e.g, Python Indent/Outdent)\n   * As it executes the calculation for every single terminal/nonTerminal\n   * and does not rely on the fact the token vector is **sorted**\n   */\n  function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n      // assumption1: Token location information is either NaN or a valid number\n      // assumption2: Token location information is fully valid if it exist\n      // (all start/end props exist and are numbers).\n      currNodeLocation.startOffset = newLocationInfo.startOffset\n      currNodeLocation.startColumn = newLocationInfo.startColumn\n      currNodeLocation.startLine = newLocationInfo.startLine\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n      currNodeLocation.endColumn = newLocationInfo.endColumn\n      currNodeLocation.endLine = newLocationInfo.endLine\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n      currNodeLocation.endColumn = newLocationInfo.endColumn\n      currNodeLocation.endLine = newLocationInfo.endLine\n    }\n  }\n  function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n      node.children[tokenTypeName] = [token]\n    } else {\n      node.children[tokenTypeName].push(token)\n    }\n  }\n  function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n      node.children[ruleName] = [ruleResult]\n    } else {\n      node.children[ruleName].push(ruleResult)\n    }\n  }\n\n  const NAME = 'name'\n  function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: nameValue,\n    })\n  }\n\n  function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx)\n    const childrenNamesLength = childrenNames.length\n    for (let i = 0; i < childrenNamesLength; i++) {\n      const currChildName = childrenNames[i]\n      const currChildArray = ctx[currChildName]\n      const currChildArrayLength = currChildArray.length\n      for (let j = 0; j < currChildArrayLength; j++) {\n        const currChild = currChildArray[j]\n        // distinction between Tokens Children and CstNode children\n        if (currChild.tokenTypeIdx === undefined) {\n          this[currChild.name](currChild.children, param)\n        }\n      }\n    }\n    // defaultVisit does not support generic out param\n  }\n  function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () {}\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + 'BaseSemantics')\n    const semanticProto = {\n      visit: function (cstNode, param) {\n        // enables writing more concise visitor methods when CstNode has only a single child\n        if (isArray$1(cstNode)) {\n          // A CST Node's children dictionary can never have empty arrays as values\n          // If a key is defined there will be at least one element in the corresponding value array.\n          cstNode = cstNode[0]\n        }\n        // enables passing optional CstNodes concisely.\n        if (isUndefined(cstNode)) {\n          return undefined\n        }\n        return this[cstNode.name](cstNode.children, param)\n      },\n      validateVisitor: function () {\n        const semanticDefinitionErrors = validateVisitor(this, ruleNames)\n        if (!isEmpty(semanticDefinitionErrors)) {\n          const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg)\n          throw Error(\n            `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n              `${errorMessages.join('\\n\\n').replace(/\\n/g, '\\n\\t')}`,\n          )\n        }\n      },\n    }\n    derivedConstructor.prototype = semanticProto\n    derivedConstructor.prototype.constructor = derivedConstructor\n    derivedConstructor._RULE_NAMES = ruleNames\n    return derivedConstructor\n  }\n  function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () {}\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + 'BaseSemanticsWithDefaults')\n    const withDefaultsProto = Object.create(baseConstructor.prototype)\n    forEach(ruleNames, (ruleName) => {\n      withDefaultsProto[ruleName] = defaultVisit\n    })\n    derivedConstructor.prototype = withDefaultsProto\n    derivedConstructor.prototype.constructor = derivedConstructor\n    return derivedConstructor\n  }\n  var CstVisitorDefinitionError\n  ;(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[(CstVisitorDefinitionError['REDUNDANT_METHOD'] = 0)] = 'REDUNDANT_METHOD'\n    CstVisitorDefinitionError[(CstVisitorDefinitionError['MISSING_METHOD'] = 1)] = 'MISSING_METHOD'\n  })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}))\n  function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames)\n    return missingErrors\n  }\n  function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n      return isFunction(visitorInstance[currRuleName]) === false\n    })\n    const errors = map(missingRuleNames, (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName,\n      }\n    })\n    return compact(errors)\n  }\n\n  /**\n   * This trait is responsible for the CST building logic.\n   */\n  class TreeBuilder {\n    initTreeBuilder(config) {\n      this.CST_STACK = []\n      // outputCst is no longer exposed/defined in the pubic API\n      this.outputCst = config.outputCst\n      this.nodeLocationTracking = has(config, 'nodeLocationTracking')\n        ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n      if (!this.outputCst) {\n        this.cstInvocationStateUpdate = noop\n        this.cstFinallyStateUpdate = noop\n        this.cstPostTerminal = noop\n        this.cstPostNonTerminal = noop\n        this.cstPostRule = noop\n      } else {\n        if (/full/i.test(this.nodeLocationTracking)) {\n          if (this.recoveryEnabled) {\n            this.setNodeLocationFromToken = setNodeLocationFull\n            this.setNodeLocationFromNode = setNodeLocationFull\n            this.cstPostRule = noop\n            this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n          } else {\n            this.setNodeLocationFromToken = noop\n            this.setNodeLocationFromNode = noop\n            this.cstPostRule = this.cstPostRuleFull\n            this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n          }\n        } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n          if (this.recoveryEnabled) {\n            this.setNodeLocationFromToken = setNodeLocationOnlyOffset\n            this.setNodeLocationFromNode = setNodeLocationOnlyOffset\n            this.cstPostRule = noop\n            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery\n          } else {\n            this.setNodeLocationFromToken = noop\n            this.setNodeLocationFromNode = noop\n            this.cstPostRule = this.cstPostRuleOnlyOffset\n            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular\n          }\n        } else if (/none/i.test(this.nodeLocationTracking)) {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = noop\n          this.setInitialNodeLocation = noop\n        } else {\n          throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`)\n        }\n      }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n      cstNode.location = {\n        startOffset: NaN,\n        endOffset: NaN,\n      }\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n      cstNode.location = {\n        // without error recovery the starting Location of a new CstNode is guaranteed\n        // To be the next Token's startOffset (for valid inputs).\n        // For invalid inputs there won't be any CSTOutput so this potential\n        // inaccuracy does not matter\n        startOffset: this.LA(1).startOffset,\n        endOffset: NaN,\n      }\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n      cstNode.location = {\n        startOffset: NaN,\n        startLine: NaN,\n        startColumn: NaN,\n        endOffset: NaN,\n        endLine: NaN,\n        endColumn: NaN,\n      }\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n      const nextToken = this.LA(1)\n      cstNode.location = {\n        startOffset: nextToken.startOffset,\n        startLine: nextToken.startLine,\n        startColumn: nextToken.startColumn,\n        endOffset: NaN,\n        endLine: NaN,\n        endColumn: NaN,\n      }\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n      const cstNode = {\n        name: fullRuleName,\n        children: Object.create(null),\n      }\n      this.setInitialNodeLocation(cstNode)\n      this.CST_STACK.push(cstNode)\n    }\n    cstFinallyStateUpdate() {\n      this.CST_STACK.pop()\n    }\n    cstPostRuleFull(ruleCstNode) {\n      // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n      const prevToken = this.LA(0)\n      const loc = ruleCstNode.location\n      // If this condition is true it means we consumed at least one Token\n      // In this CstNode.\n      if (loc.startOffset <= prevToken.startOffset === true) {\n        loc.endOffset = prevToken.endOffset\n        loc.endLine = prevToken.endLine\n        loc.endColumn = prevToken.endColumn\n      }\n      // \"empty\" CstNode edge case\n      else {\n        loc.startOffset = NaN\n        loc.startLine = NaN\n        loc.startColumn = NaN\n      }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n      const prevToken = this.LA(0)\n      // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n      const loc = ruleCstNode.location\n      // If this condition is true it means we consumed at least one Token\n      // In this CstNode.\n      if (loc.startOffset <= prevToken.startOffset === true) {\n        loc.endOffset = prevToken.endOffset\n      }\n      // \"empty\" CstNode edge case\n      else {\n        loc.startOffset = NaN\n      }\n    }\n    cstPostTerminal(key, consumedToken) {\n      const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n      addTerminalToCst(rootCst, consumedToken, key)\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromToken(rootCst.location, consumedToken)\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n      const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location)\n    }\n    getBaseCstVisitorConstructor() {\n      if (isUndefined(this.baseCstVisitorConstructor)) {\n        const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n          this.className,\n          keys(this.gastProductionsCache),\n        )\n        this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n        return newBaseCstVisitorConstructor\n      }\n      return this.baseCstVisitorConstructor\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n      if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n        const newConstructor = createBaseVisitorConstructorWithDefaults(\n          this.className,\n          keys(this.gastProductionsCache),\n          this.getBaseCstVisitorConstructor(),\n        )\n        this.baseCstVisitorWithDefaultsConstructor = newConstructor\n        return newConstructor\n      }\n      return this.baseCstVisitorWithDefaultsConstructor\n    }\n    getLastExplicitRuleShortName() {\n      const ruleStack = this.RULE_STACK\n      return ruleStack[ruleStack.length - 1]\n    }\n    getPreviousExplicitRuleShortName() {\n      const ruleStack = this.RULE_STACK\n      return ruleStack[ruleStack.length - 2]\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n      const occurrenceStack = this.RULE_OCCURRENCE_STACK\n      return occurrenceStack[occurrenceStack.length - 1]\n    }\n  }\n\n  /**\n   * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n   *\n   * This could be generalized to support other kinds of lexers, e.g.\n   * - Just in Time Lexing / Lexer-Less parsing.\n   * - Streaming Lexer.\n   */\n  class LexerAdapter {\n    initLexerAdapter() {\n      this.tokVector = []\n      this.tokVectorLength = 0\n      this.currIdx = -1\n    }\n    set input(newInput) {\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      if (this.selfAnalysisDone !== true) {\n        throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`)\n      }\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      this.reset()\n      this.tokVector = newInput\n      this.tokVectorLength = newInput.length\n    }\n    get input() {\n      return this.tokVector\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n      if (this.currIdx <= this.tokVector.length - 2) {\n        this.consumeToken()\n        return this.LA(1)\n      } else {\n        return END_OF_FILE\n      }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n      const soughtIdx = this.currIdx + howMuch\n      if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n        return END_OF_FILE\n      } else {\n        return this.tokVector[soughtIdx]\n      }\n    }\n    consumeToken() {\n      this.currIdx++\n    }\n    exportLexerState() {\n      return this.currIdx\n    }\n    importLexerState(newState) {\n      this.currIdx = newState\n    }\n    resetLexerState() {\n      this.currIdx = -1\n    }\n    moveToTerminatedState() {\n      this.currIdx = this.tokVector.length - 1\n    }\n    getLexerPosition() {\n      return this.exportLexerState()\n    }\n  }\n\n  /**\n   * This trait is responsible for implementing the public API\n   * for defining Chevrotain parsers, i.e:\n   * - CONSUME\n   * - RULE\n   * - OPTION\n   * - ...\n   */\n  class RecognizerApi {\n    ACTION(impl) {\n      return impl.call(this)\n    }\n    consume(idx, tokType, options) {\n      return this.consumeInternal(tokType, idx, options)\n    }\n    subrule(idx, ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, idx, options)\n    }\n    option(idx, actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, idx)\n    }\n    or(idx, altsOrOpts) {\n      return this.orInternal(altsOrOpts, idx)\n    }\n    many(idx, actionORMethodDef) {\n      return this.manyInternal(idx, actionORMethodDef)\n    }\n    atLeastOne(idx, actionORMethodDef) {\n      return this.atLeastOneInternal(idx, actionORMethodDef)\n    }\n    CONSUME(tokType, options) {\n      return this.consumeInternal(tokType, 0, options)\n    }\n    CONSUME1(tokType, options) {\n      return this.consumeInternal(tokType, 1, options)\n    }\n    CONSUME2(tokType, options) {\n      return this.consumeInternal(tokType, 2, options)\n    }\n    CONSUME3(tokType, options) {\n      return this.consumeInternal(tokType, 3, options)\n    }\n    CONSUME4(tokType, options) {\n      return this.consumeInternal(tokType, 4, options)\n    }\n    CONSUME5(tokType, options) {\n      return this.consumeInternal(tokType, 5, options)\n    }\n    CONSUME6(tokType, options) {\n      return this.consumeInternal(tokType, 6, options)\n    }\n    CONSUME7(tokType, options) {\n      return this.consumeInternal(tokType, 7, options)\n    }\n    CONSUME8(tokType, options) {\n      return this.consumeInternal(tokType, 8, options)\n    }\n    CONSUME9(tokType, options) {\n      return this.consumeInternal(tokType, 9, options)\n    }\n    SUBRULE(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 0, options)\n    }\n    SUBRULE1(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 1, options)\n    }\n    SUBRULE2(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 2, options)\n    }\n    SUBRULE3(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 3, options)\n    }\n    SUBRULE4(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 4, options)\n    }\n    SUBRULE5(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 5, options)\n    }\n    SUBRULE6(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 6, options)\n    }\n    SUBRULE7(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 7, options)\n    }\n    SUBRULE8(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 8, options)\n    }\n    SUBRULE9(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 9, options)\n    }\n    OPTION(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 0)\n    }\n    OPTION1(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 1)\n    }\n    OPTION2(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 2)\n    }\n    OPTION3(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 3)\n    }\n    OPTION4(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 4)\n    }\n    OPTION5(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 5)\n    }\n    OPTION6(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 6)\n    }\n    OPTION7(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 7)\n    }\n    OPTION8(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 8)\n    }\n    OPTION9(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 9)\n    }\n    OR(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 0)\n    }\n    OR1(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 1)\n    }\n    OR2(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 2)\n    }\n    OR3(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 3)\n    }\n    OR4(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 4)\n    }\n    OR5(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 5)\n    }\n    OR6(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 6)\n    }\n    OR7(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 7)\n    }\n    OR8(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 8)\n    }\n    OR9(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 9)\n    }\n    MANY(actionORMethodDef) {\n      this.manyInternal(0, actionORMethodDef)\n    }\n    MANY1(actionORMethodDef) {\n      this.manyInternal(1, actionORMethodDef)\n    }\n    MANY2(actionORMethodDef) {\n      this.manyInternal(2, actionORMethodDef)\n    }\n    MANY3(actionORMethodDef) {\n      this.manyInternal(3, actionORMethodDef)\n    }\n    MANY4(actionORMethodDef) {\n      this.manyInternal(4, actionORMethodDef)\n    }\n    MANY5(actionORMethodDef) {\n      this.manyInternal(5, actionORMethodDef)\n    }\n    MANY6(actionORMethodDef) {\n      this.manyInternal(6, actionORMethodDef)\n    }\n    MANY7(actionORMethodDef) {\n      this.manyInternal(7, actionORMethodDef)\n    }\n    MANY8(actionORMethodDef) {\n      this.manyInternal(8, actionORMethodDef)\n    }\n    MANY9(actionORMethodDef) {\n      this.manyInternal(9, actionORMethodDef)\n    }\n    MANY_SEP(options) {\n      this.manySepFirstInternal(0, options)\n    }\n    MANY_SEP1(options) {\n      this.manySepFirstInternal(1, options)\n    }\n    MANY_SEP2(options) {\n      this.manySepFirstInternal(2, options)\n    }\n    MANY_SEP3(options) {\n      this.manySepFirstInternal(3, options)\n    }\n    MANY_SEP4(options) {\n      this.manySepFirstInternal(4, options)\n    }\n    MANY_SEP5(options) {\n      this.manySepFirstInternal(5, options)\n    }\n    MANY_SEP6(options) {\n      this.manySepFirstInternal(6, options)\n    }\n    MANY_SEP7(options) {\n      this.manySepFirstInternal(7, options)\n    }\n    MANY_SEP8(options) {\n      this.manySepFirstInternal(8, options)\n    }\n    MANY_SEP9(options) {\n      this.manySepFirstInternal(9, options)\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n      this.atLeastOneInternal(0, actionORMethodDef)\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n      return this.atLeastOneInternal(1, actionORMethodDef)\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n      this.atLeastOneInternal(2, actionORMethodDef)\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n      this.atLeastOneInternal(3, actionORMethodDef)\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n      this.atLeastOneInternal(4, actionORMethodDef)\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n      this.atLeastOneInternal(5, actionORMethodDef)\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n      this.atLeastOneInternal(6, actionORMethodDef)\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n      this.atLeastOneInternal(7, actionORMethodDef)\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n      this.atLeastOneInternal(8, actionORMethodDef)\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n      this.atLeastOneInternal(9, actionORMethodDef)\n    }\n    AT_LEAST_ONE_SEP(options) {\n      this.atLeastOneSepFirstInternal(0, options)\n    }\n    AT_LEAST_ONE_SEP1(options) {\n      this.atLeastOneSepFirstInternal(1, options)\n    }\n    AT_LEAST_ONE_SEP2(options) {\n      this.atLeastOneSepFirstInternal(2, options)\n    }\n    AT_LEAST_ONE_SEP3(options) {\n      this.atLeastOneSepFirstInternal(3, options)\n    }\n    AT_LEAST_ONE_SEP4(options) {\n      this.atLeastOneSepFirstInternal(4, options)\n    }\n    AT_LEAST_ONE_SEP5(options) {\n      this.atLeastOneSepFirstInternal(5, options)\n    }\n    AT_LEAST_ONE_SEP6(options) {\n      this.atLeastOneSepFirstInternal(6, options)\n    }\n    AT_LEAST_ONE_SEP7(options) {\n      this.atLeastOneSepFirstInternal(7, options)\n    }\n    AT_LEAST_ONE_SEP8(options) {\n      this.atLeastOneSepFirstInternal(8, options)\n    }\n    AT_LEAST_ONE_SEP9(options) {\n      this.atLeastOneSepFirstInternal(9, options)\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n      if (includes(this.definedRulesNames, name)) {\n        const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className,\n        })\n        const error = {\n          message: errMsg,\n          type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n          ruleName: name,\n        }\n        this.definitionErrors.push(error)\n      }\n      this.definedRulesNames.push(name)\n      const ruleImplementation = this.defineRule(name, implementation, config)\n      this[name] = ruleImplementation\n      return ruleImplementation\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n      const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className)\n      this.definitionErrors = this.definitionErrors.concat(ruleErrors)\n      const ruleImplementation = this.defineRule(name, impl, config)\n      this[name] = ruleImplementation\n      return ruleImplementation\n    }\n    BACKTRACK(grammarRule, args) {\n      return function () {\n        // save org state\n        this.isBackTrackingStack.push(1)\n        const orgState = this.saveRecogState()\n        try {\n          grammarRule.apply(this, args)\n          // if no exception was thrown we have succeed parsing the rule.\n          return true\n        } catch (e) {\n          if (isRecognitionException(e)) {\n            return false\n          } else {\n            throw e\n          }\n        } finally {\n          this.reloadRecogState(orgState)\n          this.isBackTrackingStack.pop()\n        }\n      }\n    }\n    // GAST export APIs\n    getGAstProductions() {\n      return this.gastProductionsCache\n    }\n    getSerializedGastProductions() {\n      return serializeGrammar(values(this.gastProductionsCache))\n    }\n  }\n\n  /**\n   * This trait is responsible for the runtime parsing engine\n   * Used by the official API (recognizer_api.ts)\n   */\n  class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n      this.className = this.constructor.name\n      // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n      this.shortRuleNameToFull = {}\n      this.fullRuleNameToShort = {}\n      this.ruleShortNameIdx = 256\n      this.tokenMatcher = tokenStructuredMatcherNoCategories\n      this.subruleIdx = 0\n      this.definedRulesNames = []\n      this.tokensMap = {}\n      this.isBackTrackingStack = []\n      this.RULE_STACK = []\n      this.RULE_OCCURRENCE_STACK = []\n      this.gastProductionsCache = {}\n      if (has(config, 'serializedGrammar')) {\n        throw Error(\n          \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n            '\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n' +\n            '\\tFor Further details.',\n        )\n      }\n      if (isArray$1(tokenVocabulary)) {\n        // This only checks for Token vocabularies provided as arrays.\n        // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n        // rather than all edge cases of empty Token vocabularies.\n        if (isEmpty(tokenVocabulary)) {\n          throw Error(\n            'A Token Vocabulary cannot be empty.\\n' +\n              '\\tNote that the first argument for the parser constructor\\n' +\n              '\\tis no longer a Token vector (since v4.0).',\n          )\n        }\n        if (typeof tokenVocabulary[0].startOffset === 'number') {\n          throw Error(\n            'The Parser constructor no longer accepts a token vector as the first argument.\\n' +\n              '\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n' +\n              '\\tFor Further details.',\n          )\n        }\n      }\n      if (isArray$1(tokenVocabulary)) {\n        this.tokensMap = reduce(\n          tokenVocabulary,\n          (acc, tokType) => {\n            acc[tokType.name] = tokType\n            return acc\n          },\n          {},\n        )\n      } else if (has(tokenVocabulary, 'modes') && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n        const allTokenTypes = flatten(values(tokenVocabulary.modes))\n        const uniqueTokens = uniq(allTokenTypes)\n        this.tokensMap = reduce(\n          uniqueTokens,\n          (acc, tokType) => {\n            acc[tokType.name] = tokType\n            return acc\n          },\n          {},\n        )\n      } else if (isObject(tokenVocabulary)) {\n        this.tokensMap = clone(tokenVocabulary)\n      } else {\n        throw new Error(\n          '<tokensDictionary> argument must be An Array of Token constructors,' +\n            ' A dictionary of Token constructors or an IMultiModeLexerDefinition',\n        )\n      }\n      // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n      // parsed with a clear error message (\"expecting EOF but found ...\")\n      this.tokensMap['EOF'] = EOF\n      const allTokenTypes = has(tokenVocabulary, 'modes')\n        ? flatten(values(tokenVocabulary.modes))\n        : values(tokenVocabulary)\n      const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n        isEmpty(tokenConstructor.categoryMatches),\n      )\n      this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher\n      // Because ES2015+ syntax should be supported for creating Token classes\n      // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n      // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n      augmentTokenTypes(values(this.tokensMap))\n    }\n    defineRule(ruleName, impl, config) {\n      if (this.selfAnalysisDone) {\n        throw Error(\n          `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n            `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`,\n        )\n      }\n      const resyncEnabled = has(config, 'resyncEnabled')\n        ? config.resyncEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_RULE_CONFIG.resyncEnabled\n      const recoveryValueFunc = has(config, 'recoveryValueFunc')\n        ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n        : DEFAULT_RULE_CONFIG.recoveryValueFunc\n      // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n      // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n      const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n      this.ruleShortNameIdx++\n      this.shortRuleNameToFull[shortName] = ruleName\n      this.fullRuleNameToShort[ruleName] = shortName\n      let invokeRuleWithTry\n      // Micro optimization, only check the condition **once** on rule definition\n      // instead of **every single** rule invocation.\n      if (this.outputCst === true) {\n        invokeRuleWithTry = function invokeRuleWithTry(...args) {\n          try {\n            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n            impl.apply(this, args)\n            const cst = this.CST_STACK[this.CST_STACK.length - 1]\n            this.cstPostRule(cst)\n            return cst\n          } catch (e) {\n            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n          } finally {\n            this.ruleFinallyStateUpdate()\n          }\n        }\n      } else {\n        invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n          try {\n            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n            return impl.apply(this, args)\n          } catch (e) {\n            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n          } finally {\n            this.ruleFinallyStateUpdate()\n          }\n        }\n      }\n      const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl })\n      return wrappedGrammarRule\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n      const isFirstInvokedRule = this.RULE_STACK.length === 1\n      // note the reSync is always enabled for the first rule invocation, because we must always be able to\n      // reSync with EOF and just output some INVALID ParseTree\n      // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n      // path is really the most valid one\n      const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n      if (isRecognitionException(e)) {\n        const recogError = e\n        if (reSyncEnabled) {\n          const reSyncTokType = this.findReSyncTokenType()\n          if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n            recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n            if (this.outputCst) {\n              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1]\n              partialCstResult.recoveredNode = true\n              return partialCstResult\n            } else {\n              return recoveryValueFunc(e)\n            }\n          } else {\n            if (this.outputCst) {\n              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1]\n              partialCstResult.recoveredNode = true\n              recogError.partialCstResult = partialCstResult\n            }\n            // to be handled Further up the call stack\n            throw recogError\n          }\n        } else if (isFirstInvokedRule) {\n          // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n          this.moveToTerminatedState()\n          // the parser should never throw one of its own errors outside its flow.\n          // even if error recovery is disabled\n          return recoveryValueFunc(e)\n        } else {\n          // to be recovered Further up the call stack\n          throw recogError\n        }\n      } else {\n        // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n        throw e\n      }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n      const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n      return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n      let lookAheadFunc = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookAheadFunc\n          lookAheadFunc = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      if (lookAheadFunc.call(this) === true) {\n        return action.call(this)\n      }\n      return undefined\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence)\n      return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n      let lookAheadFunc = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookAheadFunc\n          lookAheadFunc = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      if (lookAheadFunc.call(this) === true) {\n        let notStuck = this.doSingleRepetition(action)\n        while (lookAheadFunc.call(this) === true && notStuck === true) {\n          notStuck = this.doSingleRepetition(action)\n        }\n      } else {\n        throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG)\n      }\n      // note that while it may seem that this can cause an error because by using a recursive call to\n      // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n      // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.atLeastOneInternal,\n        [prodOccurrence, actionORMethodDef],\n        lookAheadFunc,\n        AT_LEAST_ONE_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneWalker,\n      )\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence)\n      this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n      const action = options.DEF\n      const separator = options.SEP\n      const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n      // 1st iteration\n      if (firstIterationLookaheadFunc.call(this) === true) {\n        action.call(this)\n        //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n        //  because it is only needed in error recovery scenarios.\n        const separatorLookAheadFunc = () => {\n          return this.tokenMatcher(this.LA(1), separator)\n        }\n        // 2nd..nth iterations\n        while (this.tokenMatcher(this.LA(1), separator) === true) {\n          // note that this CONSUME will never enter recovery because\n          // the separatorLookAheadFunc checks that the separator really does exist.\n          this.CONSUME(separator)\n          // No need for checking infinite loop here due to consuming the separator.\n          action.call(this)\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(\n          this.repetitionSepSecondInternal,\n          [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker],\n          separatorLookAheadFunc,\n          AT_LEAST_ONE_SEP_IDX,\n          prodOccurrence,\n          NextTerminalAfterAtLeastOneSepWalker,\n        )\n      } else {\n        throw this.raiseEarlyExitException(\n          prodOccurrence,\n          PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n          options.ERR_MSG,\n        )\n      }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n      const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n      return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n      let lookaheadFunction = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookaheadFunction\n          lookaheadFunction = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      let notStuck = true\n      while (lookaheadFunction.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action)\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.manyInternal,\n        [prodOccurrence, actionORMethodDef],\n        lookaheadFunction,\n        MANY_IDX,\n        prodOccurrence,\n        NextTerminalAfterManyWalker,\n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck,\n      )\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n      const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n      this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n      const action = options.DEF\n      const separator = options.SEP\n      const firstIterationLaFunc = this.getLaFuncFromCache(key)\n      // 1st iteration\n      if (firstIterationLaFunc.call(this) === true) {\n        action.call(this)\n        const separatorLookAheadFunc = () => {\n          return this.tokenMatcher(this.LA(1), separator)\n        }\n        // 2nd..nth iterations\n        while (this.tokenMatcher(this.LA(1), separator) === true) {\n          // note that this CONSUME will never enter recovery because\n          // the separatorLookAheadFunc checks that the separator really does exist.\n          this.CONSUME(separator)\n          // No need for checking infinite loop here due to consuming the separator.\n          action.call(this)\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(\n          this.repetitionSepSecondInternal,\n          [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker],\n          separatorLookAheadFunc,\n          MANY_SEP_IDX,\n          prodOccurrence,\n          NextTerminalAfterManySepWalker,\n        )\n      }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n      while (separatorLookAheadFunc()) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        action.call(this)\n      }\n      // we can only arrive to this function after an error\n      // has occurred (hence the name 'second') so the following\n      // IF will always be entered, its possible to remove it...\n      // however it is kept to avoid confusion and be consistent.\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      /* istanbul ignore else */\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        nextTerminalAfterWalker,\n      )\n    }\n    doSingleRepetition(action) {\n      const beforeIteration = this.getLexerPosition()\n      action.call(this)\n      const afterIteration = this.getLexerPosition()\n      // This boolean will indicate if this repetition progressed\n      // or if we are \"stuck\" (potential infinite loop in the repetition).\n      return afterIteration > beforeIteration\n    }\n    orInternal(altsOrOpts, occurrence) {\n      const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n      const alts = isArray$1(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF\n      const laFunc = this.getLaFuncFromCache(laKey)\n      const altIdxToTake = laFunc.call(this, alts)\n      if (altIdxToTake !== undefined) {\n        const chosenAlternative = alts[altIdxToTake]\n        return chosenAlternative.ALT.call(this)\n      }\n      this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG)\n    }\n    ruleFinallyStateUpdate() {\n      this.RULE_STACK.pop()\n      this.RULE_OCCURRENCE_STACK.pop()\n      // NOOP when cst is disabled\n      this.cstFinallyStateUpdate()\n      if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n        const firstRedundantTok = this.LA(1)\n        const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n          firstRedundant: firstRedundantTok,\n          ruleName: this.getCurrRuleFullName(),\n        })\n        this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n      }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n      let ruleResult\n      try {\n        const args = options !== undefined ? options.ARGS : undefined\n        this.subruleIdx = idx\n        ruleResult = ruleToCall.apply(this, args)\n        this.cstPostNonTerminal(\n          ruleResult,\n          options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName,\n        )\n        return ruleResult\n      } catch (e) {\n        throw this.subruleInternalError(e, options, ruleToCall.ruleName)\n      }\n    }\n    subruleInternalError(e, options, ruleName) {\n      if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n        this.cstPostNonTerminal(\n          e.partialCstResult,\n          options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName,\n        )\n        delete e.partialCstResult\n      }\n      throw e\n    }\n    consumeInternal(tokType, idx, options) {\n      let consumedToken\n      try {\n        const nextToken = this.LA(1)\n        if (this.tokenMatcher(nextToken, tokType) === true) {\n          this.consumeToken()\n          consumedToken = nextToken\n        } else {\n          this.consumeInternalError(tokType, nextToken, options)\n        }\n      } catch (eFromConsumption) {\n        consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption)\n      }\n      this.cstPostTerminal(\n        options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name,\n        consumedToken,\n      )\n      return consumedToken\n    }\n    consumeInternalError(tokType, nextToken, options) {\n      let msg\n      const previousToken = this.LA(0)\n      if (options !== undefined && options.ERR_MSG) {\n        msg = options.ERR_MSG\n      } else {\n        msg = this.errorMessageProvider.buildMismatchTokenMessage({\n          expected: tokType,\n          actual: nextToken,\n          previous: previousToken,\n          ruleName: this.getCurrRuleFullName(),\n        })\n      }\n      throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken))\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n      // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n      // but the original syntax could have been parsed successfully without any backtracking + recovery\n      if (\n        this.recoveryEnabled &&\n        // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n        eFromConsumption.name === 'MismatchedTokenException' &&\n        !this.isBackTracking()\n      ) {\n        const follows = this.getFollowsForInRuleRecovery(tokType, idx)\n        try {\n          return this.tryInRuleRecovery(tokType, follows)\n        } catch (eFromInRuleRecovery) {\n          if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n            // failed in RuleRecovery.\n            // throw the original error in order to trigger reSync error recovery\n            throw eFromConsumption\n          } else {\n            throw eFromInRuleRecovery\n          }\n        }\n      } else {\n        throw eFromConsumption\n      }\n    }\n    saveRecogState() {\n      // errors is a getter which will clone the errors array\n      const savedErrors = this.errors\n      const savedRuleStack = clone(this.RULE_STACK)\n      return {\n        errors: savedErrors,\n        lexerState: this.exportLexerState(),\n        RULE_STACK: savedRuleStack,\n        CST_STACK: this.CST_STACK,\n      }\n    }\n    reloadRecogState(newState) {\n      this.errors = newState.errors\n      this.importLexerState(newState.lexerState)\n      this.RULE_STACK = newState.RULE_STACK\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n      this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n      this.RULE_STACK.push(shortName)\n      // NOOP when cst is disabled\n      this.cstInvocationStateUpdate(fullName)\n    }\n    isBackTracking() {\n      return this.isBackTrackingStack.length !== 0\n    }\n    getCurrRuleFullName() {\n      const shortName = this.getLastExplicitRuleShortName()\n      return this.shortRuleNameToFull[shortName]\n    }\n    shortRuleNameToFullName(shortName) {\n      return this.shortRuleNameToFull[shortName]\n    }\n    isAtEndOfInput() {\n      return this.tokenMatcher(this.LA(1), EOF)\n    }\n    reset() {\n      this.resetLexerState()\n      this.subruleIdx = 0\n      this.isBackTrackingStack = []\n      this.errors = []\n      this.RULE_STACK = []\n      // TODO: extract a specific reset for TreeBuilder trait\n      this.CST_STACK = []\n      this.RULE_OCCURRENCE_STACK = []\n    }\n  }\n\n  /**\n   * Trait responsible for runtime parsing errors.\n   */\n  class ErrorHandler {\n    initErrorHandler(config) {\n      this._errors = []\n      this.errorMessageProvider = has(config, 'errorMessageProvider')\n        ? config.errorMessageProvider // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.errorMessageProvider\n    }\n    SAVE_ERROR(error) {\n      if (isRecognitionException(error)) {\n        error.context = {\n          ruleStack: this.getHumanReadableRuleStack(),\n          ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n        }\n        this._errors.push(error)\n        return error\n      } else {\n        throw Error('Trying to save an Error which is not a RecognitionException')\n      }\n    }\n    get errors() {\n      return clone(this._errors)\n    }\n    set errors(newErrors) {\n      this._errors = newErrors\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n      const ruleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[ruleName]\n      const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n        occurrence,\n        ruleGrammar,\n        prodType,\n        this.maxLookahead,\n      )\n      const insideProdPaths = lookAheadPathsPerAlternative[0]\n      const actualTokens = []\n      for (let i = 1; i <= this.maxLookahead; i++) {\n        actualTokens.push(this.LA(i))\n      }\n      const msg = this.errorMessageProvider.buildEarlyExitMessage({\n        expectedIterationPaths: insideProdPaths,\n        actual: actualTokens,\n        previous: this.LA(0),\n        customUserDescription: userDefinedErrMsg,\n        ruleName: ruleName,\n      })\n      throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n      const ruleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[ruleName]\n      // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n      const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead)\n      const actualTokens = []\n      for (let i = 1; i <= this.maxLookahead; i++) {\n        actualTokens.push(this.LA(i))\n      }\n      const previousToken = this.LA(0)\n      const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n        expectedPathsPerAlt: lookAheadPathsPerAlternative,\n        actual: actualTokens,\n        previous: previousToken,\n        customUserDescription: errMsgTypes,\n        ruleName: this.getCurrRuleFullName(),\n      })\n      throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken))\n    }\n  }\n\n  class ContentAssist {\n    initContentAssist() {}\n    computeContentAssist(startRuleName, precedingInput) {\n      const startRuleGast = this.gastProductionsCache[startRuleName]\n      if (isUndefined(startRuleGast)) {\n        throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n      }\n      return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead)\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n      const topRuleName = head(grammarPath.ruleStack)\n      const gastProductions = this.getGAstProductions()\n      const topProduction = gastProductions[topRuleName]\n      const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking()\n      return nextPossibleTokenTypes\n    }\n  }\n\n  const RECORDING_NULL_OBJECT = {\n    description: 'This Object indicates the Parser is during Recording Phase',\n  }\n  Object.freeze(RECORDING_NULL_OBJECT)\n  const HANDLE_SEPARATOR = true\n  const MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n  const RFT = createToken({ name: 'RECORDING_PHASE_TOKEN', pattern: Lexer.NA })\n  augmentTokenTypes([RFT])\n  const RECORDING_PHASE_TOKEN = createTokenInstance(\n    RFT,\n    'This IToken indicates the Parser is in Recording Phase\\n\\t' +\n      '' +\n      'See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details',\n    // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n    // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n  )\n  Object.freeze(RECORDING_PHASE_TOKEN)\n  const RECORDING_PHASE_CSTNODE = {\n    name:\n      'This CSTNode indicates the Parser is in Recording Phase\\n\\t' +\n      'See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details',\n    children: {},\n  }\n  /**\n   * This trait handles the creation of the GAST structure for Chevrotain Grammars\n   */\n  class GastRecorder {\n    initGastRecorder(config) {\n      this.recordingProdStack = []\n      this.RECORDING_PHASE = false\n    }\n    enableRecording() {\n      this.RECORDING_PHASE = true\n      this.TRACE_INIT('Enable Recording', () => {\n        /**\n         * Warning Dark Voodoo Magic upcoming!\n         * We are \"replacing\" the public parsing DSL methods API\n         * With **new** alternative implementations on the Parser **instance**\n         *\n         * So far this is the only way I've found to avoid performance regressions during parsing time.\n         * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n         *   implementations directly instead.\n         */\n        for (let i = 0; i < 10; i++) {\n          const idx = i > 0 ? i : ''\n          this[`CONSUME${idx}`] = function (arg1, arg2) {\n            return this.consumeInternalRecord(arg1, i, arg2)\n          }\n          this[`SUBRULE${idx}`] = function (arg1, arg2) {\n            return this.subruleInternalRecord(arg1, i, arg2)\n          }\n          this[`OPTION${idx}`] = function (arg1) {\n            return this.optionInternalRecord(arg1, i)\n          }\n          this[`OR${idx}`] = function (arg1) {\n            return this.orInternalRecord(arg1, i)\n          }\n          this[`MANY${idx}`] = function (arg1) {\n            this.manyInternalRecord(i, arg1)\n          }\n          this[`MANY_SEP${idx}`] = function (arg1) {\n            this.manySepFirstInternalRecord(i, arg1)\n          }\n          this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n            this.atLeastOneInternalRecord(i, arg1)\n          }\n          this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n            this.atLeastOneSepFirstInternalRecord(i, arg1)\n          }\n        }\n        // DSL methods with the idx(suffix) as an argument\n        this[`consume`] = function (idx, arg1, arg2) {\n          return this.consumeInternalRecord(arg1, idx, arg2)\n        }\n        this[`subrule`] = function (idx, arg1, arg2) {\n          return this.subruleInternalRecord(arg1, idx, arg2)\n        }\n        this[`option`] = function (idx, arg1) {\n          return this.optionInternalRecord(arg1, idx)\n        }\n        this[`or`] = function (idx, arg1) {\n          return this.orInternalRecord(arg1, idx)\n        }\n        this[`many`] = function (idx, arg1) {\n          this.manyInternalRecord(idx, arg1)\n        }\n        this[`atLeastOne`] = function (idx, arg1) {\n          this.atLeastOneInternalRecord(idx, arg1)\n        }\n        this.ACTION = this.ACTION_RECORD\n        this.BACKTRACK = this.BACKTRACK_RECORD\n        this.LA = this.LA_RECORD\n      })\n    }\n    disableRecording() {\n      this.RECORDING_PHASE = false\n      // By deleting these **instance** properties, any future invocation\n      // will be deferred to the original methods on the **prototype** object\n      // This seems to get rid of any incorrect optimizations that V8 may\n      // do during the recording phase.\n      this.TRACE_INIT('Deleting Recording methods', () => {\n        const that = this\n        for (let i = 0; i < 10; i++) {\n          const idx = i > 0 ? i : ''\n          delete that[`CONSUME${idx}`]\n          delete that[`SUBRULE${idx}`]\n          delete that[`OPTION${idx}`]\n          delete that[`OR${idx}`]\n          delete that[`MANY${idx}`]\n          delete that[`MANY_SEP${idx}`]\n          delete that[`AT_LEAST_ONE${idx}`]\n          delete that[`AT_LEAST_ONE_SEP${idx}`]\n        }\n        delete that[`consume`]\n        delete that[`subrule`]\n        delete that[`option`]\n        delete that[`or`]\n        delete that[`many`]\n        delete that[`atLeastOne`]\n        delete that.ACTION\n        delete that.BACKTRACK\n        delete that.LA\n      })\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n      // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n      return () => true\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n      // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n      // On LA return EOF at the end of the input so an infinite loop may occur.\n      return END_OF_FILE\n    }\n    topLevelRuleRecord(name, def) {\n      try {\n        const newTopLevelRule = new Rule({ definition: [], name: name })\n        newTopLevelRule.name = name\n        this.recordingProdStack.push(newTopLevelRule)\n        def.call(this)\n        this.recordingProdStack.pop()\n        return newTopLevelRule\n      } catch (originalError) {\n        if (originalError.KNOWN_RECORDER_ERROR !== true) {\n          try {\n            originalError.message =\n              originalError.message +\n              '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n              'https://chevrotain.io/docs/guide/internals.html#grammar-recording'\n          } catch (mutabilityError) {\n            // We may not be able to modify the original error object\n            throw originalError\n          }\n        }\n        throw originalError\n      }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n      return recordProd.call(this, Option, actionORMethodDef, occurrence)\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n      recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n      recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR)\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n      recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n      recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR)\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n      return recordOrProd.call(this, altsOrOpts, occurrence)\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n      assertMethodIdxIsValid(occurrence)\n      if (!ruleToCall || has(ruleToCall, 'ruleName') === false) {\n        const error = new Error(\n          `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n            ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n            `\\n inside top level rule: <${this.recordingProdStack[0].name}>`,\n        )\n        error.KNOWN_RECORDER_ERROR = true\n        throw error\n      }\n      const prevProd = last(this.recordingProdStack)\n      const ruleName = ruleToCall.ruleName\n      const newNoneTerminal = new NonTerminal({\n        idx: occurrence,\n        nonTerminalName: ruleName,\n        label: options === null || options === void 0 ? void 0 : options.LABEL,\n        // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n        referencedRule: undefined,\n      })\n      prevProd.definition.push(newNoneTerminal)\n      return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n      assertMethodIdxIsValid(occurrence)\n      if (!hasShortKeyProperty(tokType)) {\n        const error = new Error(\n          `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n            ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n            `\\n inside top level rule: <${this.recordingProdStack[0].name}>`,\n        )\n        error.KNOWN_RECORDER_ERROR = true\n        throw error\n      }\n      const prevProd = last(this.recordingProdStack)\n      const newNoneTerminal = new Terminal({\n        idx: occurrence,\n        terminalType: tokType,\n        label: options === null || options === void 0 ? void 0 : options.LABEL,\n      })\n      prevProd.definition.push(newNoneTerminal)\n      return RECORDING_PHASE_TOKEN\n    }\n  }\n  function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence)\n    const prevProd = last(this.recordingProdStack)\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n    const newProd = new prodConstructor({ definition: [], idx: occurrence })\n    if (handleSep) {\n      newProd.separator = mainProdArg.SEP\n    }\n    if (has(mainProdArg, 'MAX_LOOKAHEAD')) {\n      newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n    }\n    this.recordingProdStack.push(newProd)\n    grammarAction.call(this)\n    prevProd.definition.push(newProd)\n    this.recordingProdStack.pop()\n    return RECORDING_NULL_OBJECT\n  }\n  function recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence)\n    const prevProd = last(this.recordingProdStack)\n    // Only an array of alternatives\n    const hasOptions = isArray$1(mainProdArg) === false\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF\n    const newOrProd = new Alternation({\n      definition: [],\n      idx: occurrence,\n      ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    })\n    if (has(mainProdArg, 'MAX_LOOKAHEAD')) {\n      newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE))\n    newOrProd.hasPredicates = hasPredicates\n    prevProd.definition.push(newOrProd)\n    forEach(alts, (currAlt) => {\n      const currAltFlat = new Alternative({ definition: [] })\n      newOrProd.definition.push(currAltFlat)\n      if (has(currAlt, 'IGNORE_AMBIGUITIES')) {\n        currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES // assumes end user provides the correct config value/type\n      }\n      // **implicit** ignoreAmbiguities due to usage of gate\n      else if (has(currAlt, 'GATE')) {\n        currAltFlat.ignoreAmbiguities = true\n      }\n      this.recordingProdStack.push(currAltFlat)\n      currAlt.ALT.call(this)\n      this.recordingProdStack.pop()\n    })\n    return RECORDING_NULL_OBJECT\n  }\n  function getIdxSuffix(idx) {\n    return idx === 0 ? '' : `${idx}`\n  }\n  function assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n      const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n          `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`,\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n  }\n\n  /**\n   * Trait responsible for runtime parsing errors.\n   */\n  class PerformanceTracer {\n    initPerformanceTracer(config) {\n      if (has(config, 'traceInitPerf')) {\n        const userTraceInitPerf = config.traceInitPerf\n        const traceIsNumber = typeof userTraceInitPerf === 'number'\n        this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity\n        this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf // assumes end user provides the correct config value/type\n      } else {\n        this.traceInitMaxIdent = 0\n        this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf\n      }\n      this.traceInitIndent = -1\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n      // No need to optimize this using NOOP pattern because\n      // It is not called in a hot spot...\n      if (this.traceInitPerf === true) {\n        this.traceInitIndent++\n        const indent = new Array(this.traceInitIndent + 1).join('\\t')\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          console.log(`${indent}--> <${phaseDesc}>`)\n        }\n        const { time, value } = timer(phaseImpl)\n        /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n        const traceMethod = time > 10 ? console.warn : console.log\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n        }\n        this.traceInitIndent--\n        return value\n      } else {\n        return phaseImpl()\n      }\n    }\n  }\n\n  function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n      const baseProto = baseCtor.prototype\n      Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n        if (propName === 'constructor') {\n          return\n        }\n        const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName)\n        // Handle Accessors\n        if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n          Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor)\n        } else {\n          derivedCtor.prototype[propName] = baseCtor.prototype[propName]\n        }\n      })\n    })\n  }\n\n  const END_OF_FILE = createTokenInstance(EOF, '', NaN, NaN, NaN, NaN, NaN, NaN)\n  Object.freeze(END_OF_FILE)\n  const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: 'none',\n    traceInitPerf: false,\n    skipValidations: false,\n  })\n  const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n  })\n  var ParserDefinitionErrorType\n  ;(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_RULE_NAME'] = 0)] = 'INVALID_RULE_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['DUPLICATE_RULE_NAME'] = 1)] = 'DUPLICATE_RULE_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_RULE_OVERRIDE'] = 2)] = 'INVALID_RULE_OVERRIDE'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['DUPLICATE_PRODUCTIONS'] = 3)] = 'DUPLICATE_PRODUCTIONS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['UNRESOLVED_SUBRULE_REF'] = 4)] = 'UNRESOLVED_SUBRULE_REF'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['LEFT_RECURSION'] = 5)] = 'LEFT_RECURSION'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['NONE_LAST_EMPTY_ALT'] = 6)] = 'NONE_LAST_EMPTY_ALT'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['AMBIGUOUS_ALTS'] = 7)] = 'AMBIGUOUS_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['CONFLICT_TOKENS_RULES_NAMESPACE'] = 8)] =\n      'CONFLICT_TOKENS_RULES_NAMESPACE'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_TOKEN_NAME'] = 9)] = 'INVALID_TOKEN_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['NO_NON_EMPTY_LOOKAHEAD'] = 10)] = 'NO_NON_EMPTY_LOOKAHEAD'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['AMBIGUOUS_PREFIX_ALTS'] = 11)] = 'AMBIGUOUS_PREFIX_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['TOO_MANY_ALTS'] = 12)] = 'TOO_MANY_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['CUSTOM_LOOKAHEAD_VALIDATION'] = 13)] =\n      'CUSTOM_LOOKAHEAD_VALIDATION'\n  })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}))\n  class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n      throw Error(\n        'The **static** `performSelfAnalysis` method has been deprecated.' +\n          '\\t\\nUse the **instance** method with the same name instead.',\n      )\n    }\n    performSelfAnalysis() {\n      this.TRACE_INIT('performSelfAnalysis', () => {\n        let defErrorsMsgs\n        this.selfAnalysisDone = true\n        const className = this.className\n        this.TRACE_INIT('toFastProps', () => {\n          // Without this voodoo magic the parser would be x3-x4 slower\n          // It seems it is better to invoke `toFastProperties` **before**\n          // Any manipulations of the `this` object done during the recording phase.\n          toFastProperties(this)\n        })\n        this.TRACE_INIT('Grammar Recording', () => {\n          try {\n            this.enableRecording()\n            // Building the GAST\n            forEach(this.definedRulesNames, (currRuleName) => {\n              const wrappedRule = this[currRuleName]\n              const originalGrammarAction = wrappedRule['originalGrammarAction']\n              let recordedRuleGast\n              this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction)\n              })\n              this.gastProductionsCache[currRuleName] = recordedRuleGast\n            })\n          } finally {\n            this.disableRecording()\n          }\n        })\n        let resolverErrors = []\n        this.TRACE_INIT('Grammar Resolving', () => {\n          resolverErrors = resolveGrammar({\n            rules: values(this.gastProductionsCache),\n          })\n          this.definitionErrors = this.definitionErrors.concat(resolverErrors)\n        })\n        this.TRACE_INIT('Grammar Validations', () => {\n          // only perform additional grammar validations IFF no resolving errors have occurred.\n          // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n          if (isEmpty(resolverErrors) && this.skipValidations === false) {\n            const validationErrors = validateGrammar({\n              rules: values(this.gastProductionsCache),\n              tokenTypes: values(this.tokensMap),\n              errMsgProvider: defaultGrammarValidatorErrorProvider,\n              grammarName: className,\n            })\n            const lookaheadValidationErrors = validateLookahead({\n              lookaheadStrategy: this.lookaheadStrategy,\n              rules: values(this.gastProductionsCache),\n              tokenTypes: values(this.tokensMap),\n              grammarName: className,\n            })\n            this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors)\n          }\n        })\n        // this analysis may fail if the grammar is not perfectly valid\n        if (isEmpty(this.definitionErrors)) {\n          // The results of these computations are not needed unless error recovery is enabled.\n          if (this.recoveryEnabled) {\n            this.TRACE_INIT('computeAllProdsFollows', () => {\n              const allFollows = computeAllProdsFollows(values(this.gastProductionsCache))\n              this.resyncFollows = allFollows\n            })\n          }\n          this.TRACE_INIT('ComputeLookaheadFunctions', () => {\n            var _a, _b\n            ;(_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0\n              ? void 0\n              : _b.call(_a, {\n                  rules: values(this.gastProductionsCache),\n                })\n            this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n          })\n        }\n        if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty(this.definitionErrors)) {\n          defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message)\n          throw new Error(\n            `Parser Definition Errors detected:\\n ${defErrorsMsgs.join('\\n-------------------------------\\n')}`,\n          )\n        }\n      })\n    }\n    constructor(tokenVocabulary, config) {\n      this.definitionErrors = []\n      this.selfAnalysisDone = false\n      const that = this\n      that.initErrorHandler(config)\n      that.initLexerAdapter()\n      that.initLooksAhead(config)\n      that.initRecognizerEngine(tokenVocabulary, config)\n      that.initRecoverable(config)\n      that.initTreeBuilder(config)\n      that.initContentAssist()\n      that.initGastRecorder(config)\n      that.initPerformanceTracer(config)\n      if (has(config, 'ignoredIssues')) {\n        throw new Error(\n          'The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t' +\n            'Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t' +\n            'See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t' +\n            'For further details.',\n        )\n      }\n      this.skipValidations = has(config, 'skipValidations')\n        ? config.skipValidations // casting assumes the end user passing the correct type\n        : DEFAULT_PARSER_CONFIG.skipValidations\n    }\n  }\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  Parser.DEFER_DEFINITION_ERRORS_HANDLING = false\n  applyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n  ])\n  class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n      const configClone = clone(config)\n      configClone.outputCst = true\n      super(tokenVocabulary, configClone)\n    }\n  }\n\n  return { CstParser, Lexer, createToken }\n})()\n\nexport { CstParser, Lexer, createToken }\n", "/**\n * @author Deepkolos / https://github.com/deepkolos\n */\n\nexport class WorkerPool {\n  constructor(pool = 4) {\n    this.pool = pool\n    this.queue = []\n    this.workers = []\n    this.workersResolve = []\n    this.workerStatus = 0\n  }\n\n  _initWorker(workerId) {\n    if (!this.workers[workerId]) {\n      const worker = this.workerCreator()\n      worker.addEventListener('message', this._onMessage.bind(this, workerId))\n      this.workers[workerId] = worker\n    }\n  }\n\n  _getIdleWorker() {\n    for (let i = 0; i < this.pool; i++) if (!(this.workerStatus & (1 << i))) return i\n\n    return -1\n  }\n\n  _onMessage(workerId, msg) {\n    const resolve = this.workersResolve[workerId]\n    resolve && resolve(msg)\n\n    if (this.queue.length) {\n      const { resolve, msg, transfer } = this.queue.shift()\n      this.workersResolve[workerId] = resolve\n      this.workers[workerId].postMessage(msg, transfer)\n    } else {\n      this.workerStatus ^= 1 << workerId\n    }\n  }\n\n  setWorkerCreator(workerCreator) {\n    this.workerCreator = workerCreator\n  }\n\n  setWorkerLimit(pool) {\n    this.pool = pool\n  }\n\n  postMessage(msg, transfer) {\n    return new Promise((resolve) => {\n      const workerId = this._getIdleWorker()\n\n      if (workerId !== -1) {\n        this._initWorker(workerId)\n        this.workerStatus |= 1 << workerId\n        this.workersResolve[workerId] = resolve\n        this.workers[workerId].postMessage(msg, transfer)\n      } else {\n        this.queue.push({ resolve, msg, transfer })\n      }\n    })\n  }\n\n  dispose() {\n    this.workers.forEach((worker) => worker.terminate())\n    this.workersResolve.length = 0\n    this.workers.length = 0\n    this.queue.length = 0\n    this.workerStatus = 0\n  }\n}\n", "///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\nconst KHR_SUPERCOMPRESSION_NONE = 0\nconst KHR_SUPERCOMPRESSION_BASISLZ = 1\nconst KHR_SUPERCOMPRESSION_ZSTD = 2\nconst KHR_SUPERCOMPRESSION_ZLIB = 3 ///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nconst KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0\nconst KHR_DF_VENDORID_KHRONOS = 0\nconst KHR_DF_VERSION = 2\nconst KHR_DF_MODEL_UNSPECIFIED = 0\nconst KHR_DF_MODEL_RGBSDA = 1 // ...\n\nconst KHR_DF_MODEL_ETC1 = 160\nconst KHR_DF_MODEL_ETC2 = 161\nconst KHR_DF_MODEL_ASTC = 162\nconst KHR_DF_MODEL_ETC1S = 163\nconst KHR_DF_MODEL_UASTC = 166\nconst KHR_DF_FLAG_ALPHA_STRAIGHT = 0\nconst KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1\nconst KHR_DF_TRANSFER_UNSPECIFIED = 0\nconst KHR_DF_TRANSFER_LINEAR = 1\nconst KHR_DF_TRANSFER_SRGB = 2\nconst KHR_DF_TRANSFER_ITU = 3\nconst KHR_DF_TRANSFER_NTSC = 4\nconst KHR_DF_TRANSFER_SLOG = 5\nconst KHR_DF_TRANSFER_SLOG2 = 6\nconst KHR_DF_TRANSFER_BT1886 = 7\nconst KHR_DF_TRANSFER_HLG_OETF = 8\nconst KHR_DF_TRANSFER_HLG_EOTF = 9\nconst KHR_DF_TRANSFER_PQ_EOTF = 10\nconst KHR_DF_TRANSFER_PQ_OETF = 11\nconst KHR_DF_TRANSFER_DCIP3 = 12\nconst KHR_DF_TRANSFER_PAL_OETF = 13\nconst KHR_DF_TRANSFER_PAL625_EOTF = 14\nconst KHR_DF_TRANSFER_ST240 = 15\nconst KHR_DF_TRANSFER_ACESCC = 16\nconst KHR_DF_TRANSFER_ACESCCT = 17\nconst KHR_DF_TRANSFER_ADOBERGB = 18\nconst KHR_DF_PRIMARIES_UNSPECIFIED = 0\nconst KHR_DF_PRIMARIES_BT709 = 1\nconst KHR_DF_PRIMARIES_BT601_EBU = 2\nconst KHR_DF_PRIMARIES_BT601_SMPTE = 3\nconst KHR_DF_PRIMARIES_BT2020 = 4\nconst KHR_DF_PRIMARIES_CIEXYZ = 5\nconst KHR_DF_PRIMARIES_ACES = 6\nconst KHR_DF_PRIMARIES_ACESCC = 7\nconst KHR_DF_PRIMARIES_NTSC1953 = 8\nconst KHR_DF_PRIMARIES_PAL525 = 9\nconst KHR_DF_PRIMARIES_DISPLAYP3 = 10\nconst KHR_DF_PRIMARIES_ADOBERGB = 11\nconst KHR_DF_CHANNEL_RGBSDA_RED = 0\nconst KHR_DF_CHANNEL_RGBSDA_GREEN = 1\nconst KHR_DF_CHANNEL_RGBSDA_BLUE = 2\nconst KHR_DF_CHANNEL_RGBSDA_STENCIL = 13\nconst KHR_DF_CHANNEL_RGBSDA_DEPTH = 14\nconst KHR_DF_CHANNEL_RGBSDA_ALPHA = 15\nconst KHR_DF_SAMPLE_DATATYPE_FLOAT = 0x80\nconst KHR_DF_SAMPLE_DATATYPE_SIGNED = 0x40\nconst KHR_DF_SAMPLE_DATATYPE_EXPONENT = 0x20\nconst KHR_DF_SAMPLE_DATATYPE_LINEAR = 0x10 ///////////////////////////////////////////////////\n// VK FORMAT.\n///////////////////////////////////////////////////\n\nconst VK_FORMAT_UNDEFINED = 0\nconst VK_FORMAT_R4G4_UNORM_PACK8 = 1\nconst VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2\nconst VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3\nconst VK_FORMAT_R5G6B5_UNORM_PACK16 = 4\nconst VK_FORMAT_B5G6R5_UNORM_PACK16 = 5\nconst VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6\nconst VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7\nconst VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8\nconst VK_FORMAT_R8_UNORM = 9\nconst VK_FORMAT_R8_SNORM = 10\nconst VK_FORMAT_R8_UINT = 13\nconst VK_FORMAT_R8_SINT = 14\nconst VK_FORMAT_R8_SRGB = 15\nconst VK_FORMAT_R8G8_UNORM = 16\nconst VK_FORMAT_R8G8_SNORM = 17\nconst VK_FORMAT_R8G8_UINT = 20\nconst VK_FORMAT_R8G8_SINT = 21\nconst VK_FORMAT_R8G8_SRGB = 22\nconst VK_FORMAT_R8G8B8_UNORM = 23\nconst VK_FORMAT_R8G8B8_SNORM = 24\nconst VK_FORMAT_R8G8B8_UINT = 27\nconst VK_FORMAT_R8G8B8_SINT = 28\nconst VK_FORMAT_R8G8B8_SRGB = 29\nconst VK_FORMAT_B8G8R8_UNORM = 30\nconst VK_FORMAT_B8G8R8_SNORM = 31\nconst VK_FORMAT_B8G8R8_UINT = 34\nconst VK_FORMAT_B8G8R8_SINT = 35\nconst VK_FORMAT_B8G8R8_SRGB = 36\nconst VK_FORMAT_R8G8B8A8_UNORM = 37\nconst VK_FORMAT_R8G8B8A8_SNORM = 38\nconst VK_FORMAT_R8G8B8A8_UINT = 41\nconst VK_FORMAT_R8G8B8A8_SINT = 42\nconst VK_FORMAT_R8G8B8A8_SRGB = 43\nconst VK_FORMAT_B8G8R8A8_UNORM = 44\nconst VK_FORMAT_B8G8R8A8_SNORM = 45\nconst VK_FORMAT_B8G8R8A8_UINT = 48\nconst VK_FORMAT_B8G8R8A8_SINT = 49\nconst VK_FORMAT_B8G8R8A8_SRGB = 50\nconst VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58\nconst VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59\nconst VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62\nconst VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63\nconst VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64\nconst VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65\nconst VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68\nconst VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69\nconst VK_FORMAT_R16_UNORM = 70\nconst VK_FORMAT_R16_SNORM = 71\nconst VK_FORMAT_R16_UINT = 74\nconst VK_FORMAT_R16_SINT = 75\nconst VK_FORMAT_R16_SFLOAT = 76\nconst VK_FORMAT_R16G16_UNORM = 77\nconst VK_FORMAT_R16G16_SNORM = 78\nconst VK_FORMAT_R16G16_UINT = 81\nconst VK_FORMAT_R16G16_SINT = 82\nconst VK_FORMAT_R16G16_SFLOAT = 83\nconst VK_FORMAT_R16G16B16_UNORM = 84\nconst VK_FORMAT_R16G16B16_SNORM = 85\nconst VK_FORMAT_R16G16B16_UINT = 88\nconst VK_FORMAT_R16G16B16_SINT = 89\nconst VK_FORMAT_R16G16B16_SFLOAT = 90\nconst VK_FORMAT_R16G16B16A16_UNORM = 91\nconst VK_FORMAT_R16G16B16A16_SNORM = 92\nconst VK_FORMAT_R16G16B16A16_UINT = 95\nconst VK_FORMAT_R16G16B16A16_SINT = 96\nconst VK_FORMAT_R16G16B16A16_SFLOAT = 97\nconst VK_FORMAT_R32_UINT = 98\nconst VK_FORMAT_R32_SINT = 99\nconst VK_FORMAT_R32_SFLOAT = 100\nconst VK_FORMAT_R32G32_UINT = 101\nconst VK_FORMAT_R32G32_SINT = 102\nconst VK_FORMAT_R32G32_SFLOAT = 103\nconst VK_FORMAT_R32G32B32_UINT = 104\nconst VK_FORMAT_R32G32B32_SINT = 105\nconst VK_FORMAT_R32G32B32_SFLOAT = 106\nconst VK_FORMAT_R32G32B32A32_UINT = 107\nconst VK_FORMAT_R32G32B32A32_SINT = 108\nconst VK_FORMAT_R32G32B32A32_SFLOAT = 109\nconst VK_FORMAT_R64_UINT = 110\nconst VK_FORMAT_R64_SINT = 111\nconst VK_FORMAT_R64_SFLOAT = 112\nconst VK_FORMAT_R64G64_UINT = 113\nconst VK_FORMAT_R64G64_SINT = 114\nconst VK_FORMAT_R64G64_SFLOAT = 115\nconst VK_FORMAT_R64G64B64_UINT = 116\nconst VK_FORMAT_R64G64B64_SINT = 117\nconst VK_FORMAT_R64G64B64_SFLOAT = 118\nconst VK_FORMAT_R64G64B64A64_UINT = 119\nconst VK_FORMAT_R64G64B64A64_SINT = 120\nconst VK_FORMAT_R64G64B64A64_SFLOAT = 121\nconst VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122\nconst VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123\nconst VK_FORMAT_D16_UNORM = 124\nconst VK_FORMAT_X8_D24_UNORM_PACK32 = 125\nconst VK_FORMAT_D32_SFLOAT = 126\nconst VK_FORMAT_S8_UINT = 127\nconst VK_FORMAT_D16_UNORM_S8_UINT = 128\nconst VK_FORMAT_D24_UNORM_S8_UINT = 129\nconst VK_FORMAT_D32_SFLOAT_S8_UINT = 130\nconst VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131\nconst VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132\nconst VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133\nconst VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134\nconst VK_FORMAT_BC2_UNORM_BLOCK = 135\nconst VK_FORMAT_BC2_SRGB_BLOCK = 136\nconst VK_FORMAT_BC3_UNORM_BLOCK = 137\nconst VK_FORMAT_BC3_SRGB_BLOCK = 138\nconst VK_FORMAT_BC4_UNORM_BLOCK = 139\nconst VK_FORMAT_BC4_SNORM_BLOCK = 140\nconst VK_FORMAT_BC5_UNORM_BLOCK = 141\nconst VK_FORMAT_BC5_SNORM_BLOCK = 142\nconst VK_FORMAT_BC6H_UFLOAT_BLOCK = 143\nconst VK_FORMAT_BC6H_SFLOAT_BLOCK = 144\nconst VK_FORMAT_BC7_UNORM_BLOCK = 145\nconst VK_FORMAT_BC7_SRGB_BLOCK = 146\nconst VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147\nconst VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148\nconst VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149\nconst VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150\nconst VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151\nconst VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152\nconst VK_FORMAT_EAC_R11_UNORM_BLOCK = 153\nconst VK_FORMAT_EAC_R11_SNORM_BLOCK = 154\nconst VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155\nconst VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156\nconst VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157\nconst VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158\nconst VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159\nconst VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160\nconst VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161\nconst VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162\nconst VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163\nconst VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164\nconst VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165\nconst VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166\nconst VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167\nconst VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168\nconst VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169\nconst VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170\nconst VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171\nconst VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172\nconst VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173\nconst VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174\nconst VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175\nconst VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176\nconst VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177\nconst VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178\nconst VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179\nconst VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180\nconst VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181\nconst VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182\nconst VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183\nconst VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184\nconst VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007\nconst VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008\nconst VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009\nconst VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010\nconst VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011\nconst VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017\nconst VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018\nconst VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019\nconst VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020\nconst VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021\nconst VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000\nconst VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001\nconst VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002\nconst VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003\nconst VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004\nconst VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005\nconst VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006\nconst VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007\nconst VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000\nconst VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001\nconst VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002\nconst VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003\nconst VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004\nconst VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005\nconst VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006\nconst VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007\nconst VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008\nconst VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009\nconst VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010\nconst VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011\nconst VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012\nconst VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013\nconst VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000\nconst VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\n\nclass KTX2Container {\n  constructor() {\n    this.vkFormat = VK_FORMAT_UNDEFINED\n    this.typeSize = 1\n    this.pixelWidth = 0\n    this.pixelHeight = 0\n    this.pixelDepth = 0\n    this.layerCount = 0\n    this.faceCount = 1\n    this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE\n    this.levels = []\n    this.dataFormatDescriptor = [\n      {\n        vendorId: KHR_DF_VENDORID_KHRONOS,\n        descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n        descriptorBlockSize: 0,\n        versionNumber: KHR_DF_VERSION,\n        colorModel: KHR_DF_MODEL_UNSPECIFIED,\n        colorPrimaries: KHR_DF_PRIMARIES_BT709,\n        transferFunction: KHR_DF_TRANSFER_SRGB,\n        flags: KHR_DF_FLAG_ALPHA_STRAIGHT,\n        texelBlockDimension: [0, 0, 0, 0],\n        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],\n        samples: [],\n      },\n    ]\n    this.keyValue = {}\n    this.globalData = null\n  }\n}\n\nclass BufferReader {\n  constructor(data, byteOffset, byteLength, littleEndian) {\n    this._dataView = void 0\n    this._littleEndian = void 0\n    this._offset = void 0\n    this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength)\n    this._littleEndian = littleEndian\n    this._offset = 0\n  }\n\n  _nextUint8() {\n    const value = this._dataView.getUint8(this._offset)\n\n    this._offset += 1\n    return value\n  }\n\n  _nextUint16() {\n    const value = this._dataView.getUint16(this._offset, this._littleEndian)\n\n    this._offset += 2\n    return value\n  }\n\n  _nextUint32() {\n    const value = this._dataView.getUint32(this._offset, this._littleEndian)\n\n    this._offset += 4\n    return value\n  }\n\n  _nextUint64() {\n    const left = this._dataView.getUint32(this._offset, this._littleEndian)\n\n    const right = this._dataView.getUint32(this._offset + 4, this._littleEndian) // TODO(cleanup): Just test this...\n    // const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\n    const value = left + 2 ** 32 * right\n    this._offset += 8\n    return value\n  }\n\n  _nextInt32() {\n    const value = this._dataView.getInt32(this._offset, this._littleEndian)\n\n    this._offset += 4\n    return value\n  }\n\n  _nextUint8Array(len) {\n    const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len)\n    this._offset += len\n    return value\n  }\n\n  _skip(bytes) {\n    this._offset += bytes\n    return this\n  }\n\n  _scan(maxByteLength, term) {\n    if (term === void 0) {\n      term = 0x00\n    }\n\n    const byteOffset = this._offset\n    let byteLength = 0\n\n    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n      byteLength++\n      this._offset++\n    }\n\n    if (byteLength < maxByteLength) this._offset++\n    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength)\n  }\n}\n\n///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\nconst KTX_WRITER = 'KTX-Parse v' + '0.6.0'\nconst NUL = new Uint8Array([0x00]) ///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nconst KTX2_ID = [\n  // '', 'K', 'T', 'X', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\n  0xab,\n  0x4b,\n  0x54,\n  0x58,\n  0x20,\n  0x32,\n  0x30,\n  0xbb,\n  0x0d,\n  0x0a,\n  0x1a,\n  0x0a,\n]\nconst HEADER_BYTE_LENGTH = 68 // 13 * 4 + 2 * 8\n\n/** Encodes text to an ArrayBuffer. */\nfunction encodeText(text) {\n  if (typeof TextEncoder !== 'undefined') {\n    return new TextEncoder().encode(text)\n  }\n\n  return Buffer.from(text)\n}\n/** Decodes an ArrayBuffer to text. */\n\nfunction decodeText(buffer) {\n  if (typeof TextDecoder !== 'undefined') {\n    return new TextDecoder().decode(buffer)\n  }\n\n  return Buffer.from(buffer).toString('utf8')\n}\n/** Concatenates N ArrayBuffers. */\n\nfunction concat(buffers) {\n  let totalByteLength = 0\n\n  for (const buffer of buffers) {\n    totalByteLength += buffer.byteLength\n  }\n\n  const result = new Uint8Array(totalByteLength)\n  let byteOffset = 0\n\n  for (const buffer of buffers) {\n    result.set(new Uint8Array(buffer), byteOffset)\n    byteOffset += buffer.byteLength\n  }\n\n  return result\n}\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\n\nfunction read(data) {\n  ///////////////////////////////////////////////////\n  // KTX 2.0 Identifier.\n  ///////////////////////////////////////////////////\n  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length)\n\n  if (\n    id[0] !== KTX2_ID[0] || // ''\n    id[1] !== KTX2_ID[1] || // 'K'\n    id[2] !== KTX2_ID[2] || // 'T'\n    id[3] !== KTX2_ID[3] || // 'X'\n    id[4] !== KTX2_ID[4] || // ' '\n    id[5] !== KTX2_ID[5] || // '2'\n    id[6] !== KTX2_ID[6] || // '0'\n    id[7] !== KTX2_ID[7] || // ''\n    id[8] !== KTX2_ID[8] || // '\\r'\n    id[9] !== KTX2_ID[9] || // '\\n'\n    id[10] !== KTX2_ID[10] || // '\\x1A'\n    id[11] !== KTX2_ID[11] // '\\n'\n  ) {\n    throw new Error('Missing KTX 2.0 identifier.')\n  }\n\n  const container = new KTX2Container() ///////////////////////////////////////////////////\n  // Header.\n  ///////////////////////////////////////////////////\n\n  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT\n  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true)\n  container.vkFormat = headerReader._nextUint32()\n  container.typeSize = headerReader._nextUint32()\n  container.pixelWidth = headerReader._nextUint32()\n  container.pixelHeight = headerReader._nextUint32()\n  container.pixelDepth = headerReader._nextUint32()\n  container.layerCount = headerReader._nextUint32()\n  container.faceCount = headerReader._nextUint32()\n\n  const levelCount = headerReader._nextUint32()\n\n  container.supercompressionScheme = headerReader._nextUint32()\n\n  const dfdByteOffset = headerReader._nextUint32()\n\n  const dfdByteLength = headerReader._nextUint32()\n\n  const kvdByteOffset = headerReader._nextUint32()\n\n  const kvdByteLength = headerReader._nextUint32()\n\n  const sgdByteOffset = headerReader._nextUint64()\n\n  const sgdByteLength = headerReader._nextUint64() ///////////////////////////////////////////////////\n  // Level Index.\n  ///////////////////////////////////////////////////\n\n  const levelByteLength = levelCount * 3 * 8\n  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true)\n\n  for (let i = 0; i < levelCount; i++) {\n    container.levels.push({\n      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n      uncompressedByteLength: levelReader._nextUint64(),\n    })\n  } ///////////////////////////////////////////////////\n  // Data Format Descriptor (DFD).\n  ///////////////////////////////////////////////////\n\n  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true)\n  const dfd = {\n    vendorId: dfdReader\n      ._skip(\n        4,\n        /* totalSize */\n      )\n      ._nextUint16(),\n    descriptorType: dfdReader._nextUint16(),\n    versionNumber: dfdReader._nextUint16(),\n    descriptorBlockSize: dfdReader._nextUint16(),\n    colorModel: dfdReader._nextUint8(),\n    colorPrimaries: dfdReader._nextUint8(),\n    transferFunction: dfdReader._nextUint8(),\n    flags: dfdReader._nextUint8(),\n    texelBlockDimension: [\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n    ],\n    bytesPlane: [\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n    ],\n    samples: [],\n  }\n  const sampleStart = 6\n  const sampleWords = 4\n  const numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords\n\n  for (let i = 0; i < numSamples; i++) {\n    const sample = {\n      bitOffset: dfdReader._nextUint16(),\n      bitLength: dfdReader._nextUint8(),\n      channelType: dfdReader._nextUint8(),\n      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],\n      sampleLower: -Infinity,\n      sampleUpper: Infinity,\n    }\n\n    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n      sample.sampleLower = dfdReader._nextInt32()\n      sample.sampleUpper = dfdReader._nextInt32()\n    } else {\n      sample.sampleLower = dfdReader._nextUint32()\n      sample.sampleUpper = dfdReader._nextUint32()\n    }\n\n    dfd.samples[i] = sample\n  }\n\n  container.dataFormatDescriptor.length = 0\n  container.dataFormatDescriptor.push(dfd) ///////////////////////////////////////////////////\n  // Key/Value Data (KVD).\n  ///////////////////////////////////////////////////\n\n  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true)\n\n  while (kvdReader._offset < kvdByteLength) {\n    const keyValueByteLength = kvdReader._nextUint32()\n\n    const keyData = kvdReader._scan(keyValueByteLength)\n\n    const key = decodeText(keyData)\n    container.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1)\n\n    if (key.match(/^ktx/i)) {\n      const text = decodeText(container.keyValue[key])\n      container.keyValue[key] = text.substring(0, text.lastIndexOf('\\x00'))\n    }\n\n    const kvPadding = keyValueByteLength % 4 ? 4 - (keyValueByteLength % 4) : 0 // align(4)\n    // 4-byte alignment.\n\n    kvdReader._skip(kvPadding)\n  } ///////////////////////////////////////////////////\n  // Supercompression Global Data (SGD).\n  ///////////////////////////////////////////////////\n\n  if (sgdByteLength <= 0) return container\n  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true)\n\n  const endpointCount = sgdReader._nextUint16()\n\n  const selectorCount = sgdReader._nextUint16()\n\n  const endpointsByteLength = sgdReader._nextUint32()\n\n  const selectorsByteLength = sgdReader._nextUint32()\n\n  const tablesByteLength = sgdReader._nextUint32()\n\n  const extendedByteLength = sgdReader._nextUint32()\n\n  const imageDescs = []\n\n  for (let i = 0; i < levelCount; i++) {\n    imageDescs.push({\n      imageFlags: sgdReader._nextUint32(),\n      rgbSliceByteOffset: sgdReader._nextUint32(),\n      rgbSliceByteLength: sgdReader._nextUint32(),\n      alphaSliceByteOffset: sgdReader._nextUint32(),\n      alphaSliceByteLength: sgdReader._nextUint32(),\n    })\n  }\n\n  const endpointsByteOffset = sgdByteOffset + sgdReader._offset\n  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength\n  const tablesByteOffset = selectorsByteOffset + selectorsByteLength\n  const extendedByteOffset = tablesByteOffset + tablesByteLength\n  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength)\n  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength)\n  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength)\n  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength)\n  container.globalData = {\n    endpointCount,\n    selectorCount,\n    imageDescs,\n    endpointsData,\n    selectorsData,\n    tablesData,\n    extendedData,\n  }\n  return container\n}\n\nconst DEFAULT_OPTIONS = {\n  keepWriter: false,\n}\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\n\nfunction write(container, options) {\n  if (options === void 0) {\n    options = {}\n  }\n\n  options = { ...DEFAULT_OPTIONS, ...options } ///////////////////////////////////////////////////\n  // Supercompression Global Data (SGD).\n  ///////////////////////////////////////////////////\n\n  let sgdBuffer = new ArrayBuffer(0)\n\n  if (container.globalData) {\n    const sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4)\n    const sgdHeaderView = new DataView(sgdHeaderBuffer)\n    sgdHeaderView.setUint16(0, container.globalData.endpointCount, true)\n    sgdHeaderView.setUint16(2, container.globalData.selectorCount, true)\n    sgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true)\n    sgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true)\n    sgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true)\n    sgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true)\n\n    for (let i = 0; i < container.globalData.imageDescs.length; i++) {\n      const imageDesc = container.globalData.imageDescs[i]\n      sgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true)\n      sgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true)\n      sgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true)\n      sgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true)\n      sgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true)\n    }\n\n    sgdBuffer = concat([\n      sgdHeaderBuffer,\n      container.globalData.endpointsData,\n      container.globalData.selectorsData,\n      container.globalData.tablesData,\n      container.globalData.extendedData,\n    ])\n  } ///////////////////////////////////////////////////\n  // Key/Value Data (KVD).\n  ///////////////////////////////////////////////////\n\n  const keyValueData = []\n  let keyValue = container.keyValue\n\n  if (!options.keepWriter) {\n    keyValue = { ...container.keyValue, KTXwriter: KTX_WRITER }\n  }\n\n  for (const key in keyValue) {\n    const value = keyValue[key]\n    const keyData = encodeText(key)\n    const valueData = typeof value === 'string' ? concat([encodeText(value), NUL]) : value\n    const kvByteLength = keyData.byteLength + 1 + valueData.byteLength\n    const kvPadding = kvByteLength % 4 ? 4 - (kvByteLength % 4) : 0 // align(4)\n\n    keyValueData.push(\n      concat([\n        new Uint32Array([kvByteLength]),\n        keyData,\n        NUL,\n        valueData,\n        new Uint8Array(kvPadding).fill(0x00), // align(4)\n      ]),\n    )\n  }\n\n  const kvdBuffer = concat(keyValueData) ///////////////////////////////////////////////////\n  // Data Format Descriptor (DFD).\n  ///////////////////////////////////////////////////\n\n  if (\n    container.dataFormatDescriptor.length !== 1 ||\n    container.dataFormatDescriptor[0].descriptorType !== KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT\n  ) {\n    throw new Error('Only BASICFORMAT Data Format Descriptor output supported.')\n  }\n\n  const dfd = container.dataFormatDescriptor[0]\n  const dfdBuffer = new ArrayBuffer(28 + dfd.samples.length * 16)\n  const dfdView = new DataView(dfdBuffer)\n  const descriptorBlockSize = 24 + dfd.samples.length * 16\n  dfdView.setUint32(0, dfdBuffer.byteLength, true)\n  dfdView.setUint16(4, dfd.vendorId, true)\n  dfdView.setUint16(6, dfd.descriptorType, true)\n  dfdView.setUint16(8, dfd.versionNumber, true)\n  dfdView.setUint16(10, descriptorBlockSize, true)\n  dfdView.setUint8(12, dfd.colorModel)\n  dfdView.setUint8(13, dfd.colorPrimaries)\n  dfdView.setUint8(14, dfd.transferFunction)\n  dfdView.setUint8(15, dfd.flags)\n\n  if (!Array.isArray(dfd.texelBlockDimension)) {\n    throw new Error('texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.')\n  }\n\n  dfdView.setUint8(16, dfd.texelBlockDimension[0])\n  dfdView.setUint8(17, dfd.texelBlockDimension[1])\n  dfdView.setUint8(18, dfd.texelBlockDimension[2])\n  dfdView.setUint8(19, dfd.texelBlockDimension[3])\n\n  for (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i])\n\n  for (let i = 0; i < dfd.samples.length; i++) {\n    const sample = dfd.samples[i]\n    const sampleByteOffset = 28 + i * 16\n\n    if (sample.channelID) {\n      throw new Error('channelID has been renamed to channelType.')\n    }\n\n    dfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true)\n    dfdView.setUint8(sampleByteOffset + 2, sample.bitLength)\n    dfdView.setUint8(sampleByteOffset + 3, sample.channelType)\n    dfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0])\n    dfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1])\n    dfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2])\n    dfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3])\n\n    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n      dfdView.setInt32(sampleByteOffset + 8, sample.sampleLower, true)\n      dfdView.setInt32(sampleByteOffset + 12, sample.sampleUpper, true)\n    } else {\n      dfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true)\n      dfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true)\n    }\n  } ///////////////////////////////////////////////////\n  // Data alignment.\n  ///////////////////////////////////////////////////\n\n  const dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8\n  const kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength\n  let sgdByteOffset = sgdBuffer.byteLength > 0 ? kvdByteOffset + kvdBuffer.byteLength : 0\n  if (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8) // align(8)\n  ///////////////////////////////////////////////////\n  // Level Index.\n  ///////////////////////////////////////////////////\n\n  const levelData = []\n  const levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8))\n  let levelDataByteOffset = (sgdByteOffset || kvdByteOffset + kvdBuffer.byteLength) + sgdBuffer.byteLength\n\n  for (let i = 0; i < container.levels.length; i++) {\n    const level = container.levels[i]\n    levelData.push(level.levelData)\n    levelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffset), true)\n    levelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true)\n    levelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true)\n    levelDataByteOffset += level.levelData.byteLength\n  } ///////////////////////////////////////////////////\n  // Header.\n  ///////////////////////////////////////////////////\n\n  const headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH)\n  const headerView = new DataView(headerBuffer)\n  headerView.setUint32(0, container.vkFormat, true)\n  headerView.setUint32(4, container.typeSize, true)\n  headerView.setUint32(8, container.pixelWidth, true)\n  headerView.setUint32(12, container.pixelHeight, true)\n  headerView.setUint32(16, container.pixelDepth, true)\n  headerView.setUint32(20, container.layerCount, true)\n  headerView.setUint32(24, container.faceCount, true)\n  headerView.setUint32(28, container.levels.length, true)\n  headerView.setUint32(32, container.supercompressionScheme, true)\n  headerView.setUint32(36, dfdByteOffset, true)\n  headerView.setUint32(40, dfdBuffer.byteLength, true)\n  headerView.setUint32(44, kvdByteOffset, true)\n  headerView.setUint32(48, kvdBuffer.byteLength, true)\n  headerView.setBigUint64(52, BigInt(sgdBuffer.byteLength > 0 ? sgdByteOffset : 0), true)\n  headerView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true) ///////////////////////////////////////////////////\n  // Compose.\n  ///////////////////////////////////////////////////\n\n  return new Uint8Array(\n    concat([\n      new Uint8Array(KTX2_ID).buffer,\n      headerBuffer,\n      levelIndex.buffer,\n      dfdBuffer,\n      kvdBuffer,\n      sgdByteOffset > 0\n        ? new ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)) // align(8)\n        : new ArrayBuffer(0),\n      sgdBuffer,\n      ...levelData,\n    ]),\n  )\n}\n\nexport {\n  KHR_DF_CHANNEL_RGBSDA_ALPHA,\n  KHR_DF_CHANNEL_RGBSDA_BLUE,\n  KHR_DF_CHANNEL_RGBSDA_DEPTH,\n  KHR_DF_CHANNEL_RGBSDA_GREEN,\n  KHR_DF_CHANNEL_RGBSDA_RED,\n  KHR_DF_CHANNEL_RGBSDA_STENCIL,\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_FLAG_ALPHA_STRAIGHT,\n  KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n  KHR_DF_MODEL_ASTC,\n  KHR_DF_MODEL_ETC1,\n  KHR_DF_MODEL_ETC1S,\n  KHR_DF_MODEL_ETC2,\n  KHR_DF_MODEL_RGBSDA,\n  KHR_DF_MODEL_UASTC,\n  KHR_DF_MODEL_UNSPECIFIED,\n  KHR_DF_PRIMARIES_ACES,\n  KHR_DF_PRIMARIES_ACESCC,\n  KHR_DF_PRIMARIES_ADOBERGB,\n  KHR_DF_PRIMARIES_BT2020,\n  KHR_DF_PRIMARIES_BT601_EBU,\n  KHR_DF_PRIMARIES_BT601_SMPTE,\n  KHR_DF_PRIMARIES_BT709,\n  KHR_DF_PRIMARIES_CIEXYZ,\n  KHR_DF_PRIMARIES_DISPLAYP3,\n  KHR_DF_PRIMARIES_NTSC1953,\n  KHR_DF_PRIMARIES_PAL525,\n  KHR_DF_PRIMARIES_UNSPECIFIED,\n  KHR_DF_SAMPLE_DATATYPE_EXPONENT,\n  KHR_DF_SAMPLE_DATATYPE_FLOAT,\n  KHR_DF_SAMPLE_DATATYPE_LINEAR,\n  KHR_DF_SAMPLE_DATATYPE_SIGNED,\n  KHR_DF_TRANSFER_ACESCC,\n  KHR_DF_TRANSFER_ACESCCT,\n  KHR_DF_TRANSFER_ADOBERGB,\n  KHR_DF_TRANSFER_BT1886,\n  KHR_DF_TRANSFER_DCIP3,\n  KHR_DF_TRANSFER_HLG_EOTF,\n  KHR_DF_TRANSFER_HLG_OETF,\n  KHR_DF_TRANSFER_ITU,\n  KHR_DF_TRANSFER_LINEAR,\n  KHR_DF_TRANSFER_NTSC,\n  KHR_DF_TRANSFER_PAL625_EOTF,\n  KHR_DF_TRANSFER_PAL_OETF,\n  KHR_DF_TRANSFER_PQ_EOTF,\n  KHR_DF_TRANSFER_PQ_OETF,\n  KHR_DF_TRANSFER_SLOG,\n  KHR_DF_TRANSFER_SLOG2,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_DF_TRANSFER_ST240,\n  KHR_DF_TRANSFER_UNSPECIFIED,\n  KHR_DF_VENDORID_KHRONOS,\n  KHR_DF_VERSION,\n  KHR_SUPERCOMPRESSION_BASISLZ,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZLIB,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  KTX2Container,\n  VK_FORMAT_A1R5G5B5_UNORM_PACK16,\n  VK_FORMAT_A2B10G10R10_SINT_PACK32,\n  VK_FORMAT_A2B10G10R10_SNORM_PACK32,\n  VK_FORMAT_A2B10G10R10_UINT_PACK32,\n  VK_FORMAT_A2B10G10R10_UNORM_PACK32,\n  VK_FORMAT_A2R10G10B10_SINT_PACK32,\n  VK_FORMAT_A2R10G10B10_SNORM_PACK32,\n  VK_FORMAT_A2R10G10B10_UINT_PACK32,\n  VK_FORMAT_A2R10G10B10_UNORM_PACK32,\n  VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT,\n  VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT,\n  VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_10x10_SRGB_BLOCK,\n  VK_FORMAT_ASTC_10x10_UNORM_BLOCK,\n  VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_10x5_SRGB_BLOCK,\n  VK_FORMAT_ASTC_10x5_UNORM_BLOCK,\n  VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_10x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_10x6_UNORM_BLOCK,\n  VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_10x8_SRGB_BLOCK,\n  VK_FORMAT_ASTC_10x8_UNORM_BLOCK,\n  VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_12x10_SRGB_BLOCK,\n  VK_FORMAT_ASTC_12x10_UNORM_BLOCK,\n  VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_12x12_SRGB_BLOCK,\n  VK_FORMAT_ASTC_12x12_UNORM_BLOCK,\n  VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_4x4_SRGB_BLOCK,\n  VK_FORMAT_ASTC_4x4_UNORM_BLOCK,\n  VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_5x4_SRGB_BLOCK,\n  VK_FORMAT_ASTC_5x4_UNORM_BLOCK,\n  VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_5x5_SRGB_BLOCK,\n  VK_FORMAT_ASTC_5x5_UNORM_BLOCK,\n  VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_6x5_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x5_UNORM_BLOCK,\n  VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n  VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_8x5_SRGB_BLOCK,\n  VK_FORMAT_ASTC_8x5_UNORM_BLOCK,\n  VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_8x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_8x6_UNORM_BLOCK,\n  VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT,\n  VK_FORMAT_ASTC_8x8_SRGB_BLOCK,\n  VK_FORMAT_ASTC_8x8_UNORM_BLOCK,\n  VK_FORMAT_B10G11R11_UFLOAT_PACK32,\n  VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,\n  VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,\n  VK_FORMAT_B4G4R4A4_UNORM_PACK16,\n  VK_FORMAT_B5G5R5A1_UNORM_PACK16,\n  VK_FORMAT_B5G6R5_UNORM_PACK16,\n  VK_FORMAT_B8G8R8A8_SINT,\n  VK_FORMAT_B8G8R8A8_SNORM,\n  VK_FORMAT_B8G8R8A8_SRGB,\n  VK_FORMAT_B8G8R8A8_UINT,\n  VK_FORMAT_B8G8R8A8_UNORM,\n  VK_FORMAT_B8G8R8_SINT,\n  VK_FORMAT_B8G8R8_SNORM,\n  VK_FORMAT_B8G8R8_SRGB,\n  VK_FORMAT_B8G8R8_UINT,\n  VK_FORMAT_B8G8R8_UNORM,\n  VK_FORMAT_BC1_RGBA_SRGB_BLOCK,\n  VK_FORMAT_BC1_RGBA_UNORM_BLOCK,\n  VK_FORMAT_BC1_RGB_SRGB_BLOCK,\n  VK_FORMAT_BC1_RGB_UNORM_BLOCK,\n  VK_FORMAT_BC2_SRGB_BLOCK,\n  VK_FORMAT_BC2_UNORM_BLOCK,\n  VK_FORMAT_BC3_SRGB_BLOCK,\n  VK_FORMAT_BC3_UNORM_BLOCK,\n  VK_FORMAT_BC4_SNORM_BLOCK,\n  VK_FORMAT_BC4_UNORM_BLOCK,\n  VK_FORMAT_BC5_SNORM_BLOCK,\n  VK_FORMAT_BC5_UNORM_BLOCK,\n  VK_FORMAT_BC6H_SFLOAT_BLOCK,\n  VK_FORMAT_BC6H_UFLOAT_BLOCK,\n  VK_FORMAT_BC7_SRGB_BLOCK,\n  VK_FORMAT_BC7_UNORM_BLOCK,\n  VK_FORMAT_D16_UNORM,\n  VK_FORMAT_D16_UNORM_S8_UINT,\n  VK_FORMAT_D24_UNORM_S8_UINT,\n  VK_FORMAT_D32_SFLOAT,\n  VK_FORMAT_D32_SFLOAT_S8_UINT,\n  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,\n  VK_FORMAT_EAC_R11G11_SNORM_BLOCK,\n  VK_FORMAT_EAC_R11G11_UNORM_BLOCK,\n  VK_FORMAT_EAC_R11_SNORM_BLOCK,\n  VK_FORMAT_EAC_R11_UNORM_BLOCK,\n  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,\n  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,\n  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,\n  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,\n  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,\n  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,\n  VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,\n  VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,\n  VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,\n  VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,\n  VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,\n  VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,\n  VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,\n  VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,\n  VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,\n  VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,\n  VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,\n  VK_FORMAT_R10X6G10X6_UNORM_2PACK16,\n  VK_FORMAT_R10X6_UNORM_PACK16,\n  VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,\n  VK_FORMAT_R12X4G12X4_UNORM_2PACK16,\n  VK_FORMAT_R12X4_UNORM_PACK16,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R16G16B16A16_SINT,\n  VK_FORMAT_R16G16B16A16_SNORM,\n  VK_FORMAT_R16G16B16A16_UINT,\n  VK_FORMAT_R16G16B16A16_UNORM,\n  VK_FORMAT_R16G16B16_SFLOAT,\n  VK_FORMAT_R16G16B16_SINT,\n  VK_FORMAT_R16G16B16_SNORM,\n  VK_FORMAT_R16G16B16_UINT,\n  VK_FORMAT_R16G16B16_UNORM,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16G16_SINT,\n  VK_FORMAT_R16G16_SNORM,\n  VK_FORMAT_R16G16_UINT,\n  VK_FORMAT_R16G16_UNORM,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R16_SINT,\n  VK_FORMAT_R16_SNORM,\n  VK_FORMAT_R16_UINT,\n  VK_FORMAT_R16_UNORM,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SINT,\n  VK_FORMAT_R32G32B32A32_UINT,\n  VK_FORMAT_R32G32B32_SFLOAT,\n  VK_FORMAT_R32G32B32_SINT,\n  VK_FORMAT_R32G32B32_UINT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32G32_SINT,\n  VK_FORMAT_R32G32_UINT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R32_SINT,\n  VK_FORMAT_R32_UINT,\n  VK_FORMAT_R4G4B4A4_UNORM_PACK16,\n  VK_FORMAT_R4G4_UNORM_PACK8,\n  VK_FORMAT_R5G5B5A1_UNORM_PACK16,\n  VK_FORMAT_R5G6B5_UNORM_PACK16,\n  VK_FORMAT_R64G64B64A64_SFLOAT,\n  VK_FORMAT_R64G64B64A64_SINT,\n  VK_FORMAT_R64G64B64A64_UINT,\n  VK_FORMAT_R64G64B64_SFLOAT,\n  VK_FORMAT_R64G64B64_SINT,\n  VK_FORMAT_R64G64B64_UINT,\n  VK_FORMAT_R64G64_SFLOAT,\n  VK_FORMAT_R64G64_SINT,\n  VK_FORMAT_R64G64_UINT,\n  VK_FORMAT_R64_SFLOAT,\n  VK_FORMAT_R64_SINT,\n  VK_FORMAT_R64_UINT,\n  VK_FORMAT_R8G8B8A8_SINT,\n  VK_FORMAT_R8G8B8A8_SNORM,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UINT,\n  VK_FORMAT_R8G8B8A8_UNORM,\n  VK_FORMAT_R8G8B8_SINT,\n  VK_FORMAT_R8G8B8_SNORM,\n  VK_FORMAT_R8G8B8_SRGB,\n  VK_FORMAT_R8G8B8_UINT,\n  VK_FORMAT_R8G8B8_UNORM,\n  VK_FORMAT_R8G8_SINT,\n  VK_FORMAT_R8G8_SNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UINT,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8_SINT,\n  VK_FORMAT_R8_SNORM,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UINT,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_S8_UINT,\n  VK_FORMAT_UNDEFINED,\n  VK_FORMAT_X8_D24_UNORM_PACK32,\n  read,\n  write,\n}\n//# sourceMappingURL=ktx-parse.esm.js.map\n", "interface DecoderExports {\n  memory: Uint8Array\n\n  ZSTD_findDecompressedSize: (compressedPtr: number, compressedSize: number) => BigInt\n  ZSTD_decompress: (\n    uncompressedPtr: number,\n    uncompressedSize: number,\n    compressedPtr: number,\n    compressedSize: number,\n  ) => number\n  malloc: (ptr: number) => number\n  free: (ptr: number) => void\n}\n\nlet init: Promise<void>\nlet instance: { exports: DecoderExports }\nlet heap: Uint8Array\n\nconst IMPORT_OBJECT = {\n  env: {\n    emscripten_notify_memory_growth: function (index: number): void {\n      heap = new Uint8Array(instance.exports.memory.buffer)\n    },\n  },\n}\n\n/**\n * ZSTD (Zstandard) decoder.\n */\nexport class ZSTDDecoder {\n  init(): Promise<void> {\n    if (init) return init\n\n    if (typeof fetch !== 'undefined') {\n      // Web.\n\n      init = fetch('data:application/wasm;base64,' + wasm)\n        .then((response) => response.arrayBuffer())\n        .then((arrayBuffer) => WebAssembly.instantiate(arrayBuffer, IMPORT_OBJECT))\n        .then(this._init)\n    } else {\n      // Node.js.\n\n      init = WebAssembly.instantiate(Buffer.from(wasm, 'base64'), IMPORT_OBJECT).then(this._init)\n    }\n\n    return init\n  }\n\n  _init(result: WebAssembly.WebAssemblyInstantiatedSource): void {\n    instance = (result.instance as unknown) as { exports: DecoderExports }\n\n    IMPORT_OBJECT.env.emscripten_notify_memory_growth(0) // initialize heap.\n  }\n\n  decode(array: Uint8Array, uncompressedSize = 0): Uint8Array {\n    if (!instance) throw new Error(`ZSTDDecoder: Await .init() before decoding.`)\n\n    // Write compressed data into WASM memory.\n    const compressedSize = array.byteLength\n    const compressedPtr = instance.exports.malloc(compressedSize)\n    heap.set(array, compressedPtr)\n\n    // Decompress into WASM memory.\n    uncompressedSize =\n      uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize))\n    const uncompressedPtr = instance.exports.malloc(uncompressedSize)\n    const actualSize = instance.exports.ZSTD_decompress(\n      uncompressedPtr,\n      uncompressedSize,\n      compressedPtr,\n      compressedSize,\n    )\n\n    // Read decompressed data and free WASM memory.\n    const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize)\n    instance.exports.free(compressedPtr)\n    instance.exports.free(uncompressedPtr)\n\n    return dec\n  }\n}\n\n/**\n * BSD License\n *\n * For Zstandard software\n *\n * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name Facebook nor the names of its contributors may be used to\n *    endorse or promote products derived from this software without specific\n *    prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// wasm:begin\nconst wasm =\n  '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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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'\n// wasm:end\n", "import { CompressedTexture, CubeReflectionMapping } from 'three'\n\nclass CompressedCubeTexture extends CompressedTexture {\n  constructor(images, format, type) {\n    super(undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping)\n\n    this.isCompressedCubeTexture = true\n    this.isCubeTexture = true\n\n    this.image = images\n  }\n}\n\nexport { CompressedCubeTexture }\n", "import { CompressedTexture, ClampToEdgeWrapping } from 'three'\n\nclass CompressedArrayTexture extends CompressedTexture {\n  constructor(mipmaps, width, height, depth, format, type) {\n    super(mipmaps, width, height, format, type)\n    this.isCompressedArrayTexture = true\n    this.image.depth = depth\n    this.wrapR = ClampToEdgeWrapping\n  }\n}\n\nexport { CompressedArrayTexture }\n", "/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats, as well as some\n * uncompressed DataTexture and Data3DTexture formats.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nimport {\n  CompressedTexture,\n  DataTexture,\n  FileLoader,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RedFormat,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  RGBA_ASTC_4x4_Format,\n  RGBA_ASTC_6x6_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGBAFormat,\n  RGFormat,\n  UnsignedByteType,\n} from 'three'\nimport { WorkerPool } from '../utils/WorkerPool'\nimport {\n  read,\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  VK_FORMAT_UNDEFINED,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UNORM,\n  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n  KHR_DF_PRIMARIES_UNSPECIFIED,\n  KHR_DF_PRIMARIES_BT709,\n  KHR_DF_PRIMARIES_DISPLAYP3,\n} from '../libs/ktx-parse'\nimport { ZSTDDecoder } from '../libs/zstddec'\nimport { CompressedCubeTexture } from '../_polyfill/CompressedCubeTexture'\nimport { CompressedArrayTexture } from '../_polyfill/CompressedArrayTexture'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nconst LinearEncoding = 3000\nconst sRGBEncoding = 3001\n\nconst NoColorSpace = ''\nconst DisplayP3ColorSpace = 'display-p3'\nconst LinearDisplayP3ColorSpace = 'display-p3-linear'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst SRGBColorSpace = 'srgb'\n\nconst _taskCache = new WeakMap()\n\nlet _activeLoaders = 0\n\nlet _zstd\n\nclass KTX2Loader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    /** @type KTX2Loader.EngineFormat */\n    const EngineFormat = _EngineFormat\n    /** @type KTX2Loader.TranscoderFormat */\n    const TranscoderFormat = _TranscoderFormat\n    /** @type KTX2Loader.BasisFormat */\n    const BasisFormat = _BasisFormat\n\n    self.addEventListener('message', function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer)\n\n              self.postMessage(\n                { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags },\n                buffers,\n              )\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    })\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n\n        if (BasisModule.KTX2File === undefined) {\n          console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.')\n        }\n      })\n    }\n\n    function transcode(buffer) {\n      const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer))\n\n      function cleanup() {\n        ktx2File.close()\n        ktx2File.delete()\n      }\n\n      if (!ktx2File.isValid()) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file')\n      }\n\n      const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = ktx2File.getWidth()\n      const height = ktx2File.getHeight()\n      const layerCount = ktx2File.getLayers() || 1\n      const levelCount = ktx2File.getLevels()\n      const faceCount = ktx2File.getFaces()\n      const hasAlpha = ktx2File.getHasAlpha()\n      const dfdFlags = ktx2File.getDFDFlags()\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levelCount) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader:\tInvalid texture')\n      }\n\n      if (!ktx2File.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.KTX2Loader: .startTranscoding failed')\n      }\n\n      const faces = []\n      const buffers = []\n\n      for (let face = 0; face < faceCount; face++) {\n        const mipmaps = []\n\n        for (let mip = 0; mip < levelCount; mip++) {\n          const layerMips = []\n\n          let mipWidth, mipHeight\n\n          for (let layer = 0; layer < layerCount; layer++) {\n            const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face)\n\n            if (\n              face === 0 &&\n              mip === 0 &&\n              layer === 0 &&\n              (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)\n            ) {\n              console.warn('THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.')\n            }\n\n            if (levelCount > 1) {\n              mipWidth = levelInfo.origWidth\n              mipHeight = levelInfo.origHeight\n            } else {\n              // Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with\n              // mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.\n              // See mrdoob/three.js#25908.\n              mipWidth = levelInfo.width\n              mipHeight = levelInfo.height\n            }\n\n            const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat))\n            const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1)\n\n            if (!status) {\n              cleanup()\n              throw new Error('THREE.KTX2Loader: .transcodeImage failed.')\n            }\n\n            layerMips.push(dst)\n          }\n\n          const mipData = concat(layerMips)\n\n          mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight })\n          buffers.push(mipData.buffer)\n        }\n\n        faces.push({ mipmaps, width, height, format: engineFormat })\n      }\n\n      cleanup()\n\n      return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (hasAlpha && opt.transcoderFormat.length < 2) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n\n    /** Concatenates N byte arrays. */\n    function concat(arrays) {\n      if (arrays.length === 1) return arrays[0]\n\n      let totalByteLength = 0\n\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i]\n        totalByteLength += array.byteLength\n      }\n\n      const result = new Uint8Array(totalByteLength)\n\n      let byteOffset = 0\n\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i]\n        result.set(array, byteOffset)\n\n        byteOffset += array.byteLength\n      }\n\n      return result\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerPool = new WorkerPool()\n    this.workerSourceURL = ''\n    this.workerConfig = null\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn(\n        'THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' +\n          ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.',\n      )\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num)\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    if (renderer.capabilities.isWebGL2) {\n      // https://github.com/mrdoob/three.js/pull/22928\n      this.workerConfig.etc1Supported = false\n    }\n\n    return this\n  }\n\n  init() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = jsLoader.loadAsync('basis_transcoder.js')\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm')\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = KTX2Loader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL)\n          const transcoderBinary = this.transcoderBinary.slice(0)\n\n          worker.postMessage({ type: 'init', config: this.workerConfig, transcoderBinary }, [transcoderBinary])\n\n          return worker\n        })\n      })\n\n      if (_activeLoaders > 0) {\n        // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\n\n        console.warn(\n          'THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' +\n            ' Use a single KTX2Loader instance, or call .dispose() on old instances.',\n        )\n      }\n\n      _activeLoaders++\n    }\n\n    return this.transcoderPending\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.')\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture(buffer)\n          .then((texture) => (onLoad ? onLoad(texture) : null))\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  _createTextureFrom(transcodeResult, container) {\n    const { faces, width, height, format, type, error, dfdFlags } = transcodeResult\n\n    if (type === 'error') return Promise.reject(error)\n\n    let texture\n\n    if (container.faceCount === 6) {\n      texture = new CompressedCubeTexture(faces, format, UnsignedByteType)\n    } else {\n      const mipmaps = faces[0].mipmaps\n\n      texture =\n        container.layerCount > 1\n          ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType)\n          : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n    }\n\n    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n    texture.magFilter = LinearFilter\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const colorSpace = parseColorSpace(container)\n    if ('colorSpace' in texture) texture.colorSpace = colorSpace\n    else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED)\n\n    return texture\n  }\n\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n   */\n  async _createTexture(buffer, config = {}) {\n    const container = read(new Uint8Array(buffer))\n\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createRawTexture(container)\n    }\n\n    //\n\n    const taskConfig = config\n    const texturePending = this.init()\n      .then(() => {\n        return this.workerPool.postMessage({ type: 'transcode', buffer, taskConfig: taskConfig }, [buffer])\n      })\n      .then((e) => this._createTextureFrom(e.data, container))\n\n    // Cache the task result.\n    _taskCache.set(buffer, { promise: texturePending })\n\n    return texturePending\n  }\n\n  dispose() {\n    this.workerPool.dispose()\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL)\n\n    _activeLoaders--\n\n    return this\n  }\n}\n\n//\n// Parsing for non-Basis textures. These textures are may have supercompression\n// like Zstd, but they do not require transcoding.\n\nconst UNCOMPRESSED_FORMATS = new Set([RGBAFormat, RGFormat, RedFormat])\n\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format,\n}\n\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType,\n}\n\nasync function createRawTexture(container) {\n  const { vkFormat } = container\n\n  if (FORMAT_MAP[vkFormat] === undefined) {\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.')\n  }\n\n  //\n\n  let zstd\n\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async (resolve) => {\n        const zstd = new ZSTDDecoder()\n        await zstd.init()\n        resolve(zstd)\n      })\n    }\n\n    zstd = await _zstd\n  }\n\n  //\n\n  const mipmaps = []\n\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex)\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex)\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0\n\n    const level = container.levels[levelIndex]\n\n    let levelData\n\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength)\n    } else {\n      throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.')\n    }\n\n    let data\n\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT,\n      )\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT,\n      )\n    } else {\n      data = levelData\n    }\n\n    mipmaps.push({\n      data: data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth,\n    })\n  }\n\n  let texture\n\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture =\n      container.pixelDepth === 0\n        ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight)\n        : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth)\n  } else {\n    if (container.pixelDepth > 0) throw new Error('THREE.KTX2Loader: Unsupported pixelDepth.')\n\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight)\n  }\n\n  texture.mipmaps = mipmaps\n\n  texture.type = TYPE_MAP[vkFormat]\n  texture.format = FORMAT_MAP[vkFormat]\n  texture.needsUpdate = true\n\n  const colorSpace = parseColorSpace(container)\n  if ('colorSpace' in texture) texture.colorSpace = colorSpace\n  else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n\n  //\n\n  return Promise.resolve(texture)\n}\n\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0]\n\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`)\n    return NoColorSpace\n  }\n}\n\nexport { KTX2Loader }\n", "const lottie = (() => {\n  if (typeof navigator === 'undefined' || typeof document === 'undefined') return {}\n\n  const svgNS = 'http://www.w3.org/2000/svg'\n\n  let locationHref = ''\n  let _useWebWorker = false\n\n  const initialDefaultFrame = -999999\n\n  const setWebWorker = (flag) => {\n    _useWebWorker = !!flag\n  }\n  const getWebWorker = () => _useWebWorker\n\n  const setLocationHref = (value) => {\n    locationHref = value\n  }\n  const getLocationHref = () => locationHref\n\n  function createTag(type) {\n    // return {appendChild:function(){},setAttribute:function(){},style:{}}\n    return document.createElement(type)\n  }\n\n  function extendPrototype(sources, destination) {\n    var i\n    var len = sources.length\n    var sourcePrototype\n    for (i = 0; i < len; i += 1) {\n      sourcePrototype = sources[i].prototype\n      for (var attr in sourcePrototype) {\n        if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr))\n          destination.prototype[attr] = sourcePrototype[attr]\n      }\n    }\n  }\n\n  function getDescriptor(object, prop) {\n    return Object.getOwnPropertyDescriptor(object, prop)\n  }\n\n  function createProxyFunction(prototype) {\n    function ProxyFunction() {}\n    ProxyFunction.prototype = prototype\n    return ProxyFunction\n  }\n\n  // import Howl from '../../3rd_party/howler';\n\n  const audioControllerFactory = (function () {\n    function AudioController(audioFactory) {\n      this.audios = []\n      this.audioFactory = audioFactory\n      this._volume = 1\n      this._isMuted = false\n    }\n\n    AudioController.prototype = {\n      addAudio: function (audio) {\n        this.audios.push(audio)\n      },\n      pause: function () {\n        var i\n        var len = this.audios.length\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].pause()\n        }\n      },\n      resume: function () {\n        var i\n        var len = this.audios.length\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].resume()\n        }\n      },\n      setRate: function (rateValue) {\n        var i\n        var len = this.audios.length\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].setRate(rateValue)\n        }\n      },\n      createAudio: function (assetPath) {\n        if (this.audioFactory) {\n          return this.audioFactory(assetPath)\n        }\n        if (window.Howl) {\n          return new window.Howl({\n            src: [assetPath],\n          })\n        }\n        return {\n          isPlaying: false,\n          play: function () {\n            this.isPlaying = true\n          },\n          seek: function () {\n            this.isPlaying = false\n          },\n          playing: function () {},\n          rate: function () {},\n          setVolume: function () {},\n        }\n      },\n      setAudioFactory: function (audioFactory) {\n        this.audioFactory = audioFactory\n      },\n      setVolume: function (value) {\n        this._volume = value\n        this._updateVolume()\n      },\n      mute: function () {\n        this._isMuted = true\n        this._updateVolume()\n      },\n      unmute: function () {\n        this._isMuted = false\n        this._updateVolume()\n      },\n      getVolume: function () {\n        return this._volume\n      },\n      _updateVolume: function () {\n        var i\n        var len = this.audios.length\n        for (i = 0; i < len; i += 1) {\n          this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1))\n        }\n      },\n    }\n\n    return function () {\n      return new AudioController()\n    }\n  })()\n\n  const createTypedArray = (function () {\n    function createRegularArray(type, len) {\n      var i = 0\n      var arr = []\n      var value\n      switch (type) {\n        case 'int16':\n        case 'uint8c':\n          value = 1\n          break\n        default:\n          value = 1.1\n          break\n      }\n      for (i = 0; i < len; i += 1) {\n        arr.push(value)\n      }\n      return arr\n    }\n    function createTypedArrayFactory(type, len) {\n      if (type === 'float32') {\n        return new Float32Array(len)\n      }\n      if (type === 'int16') {\n        return new Int16Array(len)\n      }\n      if (type === 'uint8c') {\n        return new Uint8ClampedArray(len)\n      }\n      return createRegularArray(type, len)\n    }\n    if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {\n      return createTypedArrayFactory\n    }\n    return createRegularArray\n  })()\n\n  function createSizedArray(len) {\n    return Array.apply(null, { length: len })\n  }\n\n  let subframeEnabled = true\n  let expressionsPlugin = null\n  let idPrefix$1 = ''\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n  let _shouldRoundValues = false\n  const bmPow = Math.pow\n  const bmSqrt = Math.sqrt\n  const bmFloor = Math.floor\n  const bmMax = Math.max\n  const bmMin = Math.min\n\n  const BMMath = {}\n  ;(function () {\n    var propertyNames = [\n      'abs',\n      'acos',\n      'acosh',\n      'asin',\n      'asinh',\n      'atan',\n      'atanh',\n      'atan2',\n      'ceil',\n      'cbrt',\n      'expm1',\n      'clz32',\n      'cos',\n      'cosh',\n      'exp',\n      'floor',\n      'fround',\n      'hypot',\n      'imul',\n      'log',\n      'log1p',\n      'log2',\n      'log10',\n      'max',\n      'min',\n      'pow',\n      'random',\n      'round',\n      'sign',\n      'sin',\n      'sinh',\n      'sqrt',\n      'tan',\n      'tanh',\n      'trunc',\n      'E',\n      'LN10',\n      'LN2',\n      'LOG10E',\n      'LOG2E',\n      'PI',\n      'SQRT1_2',\n      'SQRT2',\n    ]\n    var i\n    var len = propertyNames.length\n    for (i = 0; i < len; i += 1) {\n      BMMath[propertyNames[i]] = Math[propertyNames[i]]\n    }\n  })()\n\n  function ProjectInterface$1() {\n    return {}\n  }\n  BMMath.random = Math.random\n  BMMath.abs = function (val) {\n    var tOfVal = typeof val\n    if (tOfVal === 'object' && val.length) {\n      var absArr = createSizedArray(val.length)\n      var i\n      var len = val.length\n      for (i = 0; i < len; i += 1) {\n        absArr[i] = Math.abs(val[i])\n      }\n      return absArr\n    }\n    return Math.abs(val)\n  }\n  let defaultCurveSegments = 150\n  const degToRads = Math.PI / 180\n  const roundCorner = 0.5519\n\n  function roundValues(flag) {\n    _shouldRoundValues = !!flag\n  }\n\n  function bmRnd(value) {\n    if (_shouldRoundValues) {\n      return Math.round(value)\n    }\n    return value\n  }\n\n  function styleDiv(element) {\n    element.style.position = 'absolute'\n    element.style.top = 0\n    element.style.left = 0\n    element.style.display = 'block'\n    element.style.transformOrigin = '0 0'\n    element.style.webkitTransformOrigin = '0 0'\n    element.style.backfaceVisibility = 'visible'\n    element.style.webkitBackfaceVisibility = 'visible'\n    element.style.transformStyle = 'preserve-3d'\n    element.style.webkitTransformStyle = 'preserve-3d'\n    element.style.mozTransformStyle = 'preserve-3d'\n  }\n\n  function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {\n    this.type = type\n    this.currentTime = currentTime\n    this.totalTime = totalTime\n    this.direction = frameMultiplier < 0 ? -1 : 1\n  }\n\n  function BMCompleteEvent(type, frameMultiplier) {\n    this.type = type\n    this.direction = frameMultiplier < 0 ? -1 : 1\n  }\n\n  function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {\n    this.type = type\n    this.currentLoop = currentLoop\n    this.totalLoops = totalLoops\n    this.direction = frameMultiplier < 0 ? -1 : 1\n  }\n\n  function BMSegmentStartEvent(type, firstFrame, totalFrames) {\n    this.type = type\n    this.firstFrame = firstFrame\n    this.totalFrames = totalFrames\n  }\n\n  function BMDestroyEvent(type, target) {\n    this.type = type\n    this.target = target\n  }\n\n  function BMRenderFrameErrorEvent(nativeError, currentTime) {\n    this.type = 'renderFrameError'\n    this.nativeError = nativeError\n    this.currentTime = currentTime\n  }\n\n  function BMConfigErrorEvent(nativeError) {\n    this.type = 'configError'\n    this.nativeError = nativeError\n  }\n\n  function BMAnimationConfigErrorEvent(type, nativeError) {\n    this.type = type\n    this.nativeError = nativeError\n  }\n\n  const createElementID = (function () {\n    var _count = 0\n    return function createID() {\n      _count += 1\n      return idPrefix$1 + '__lottie_element_' + _count\n    }\n  })()\n\n  function HSVtoRGB(h, s, v) {\n    var r\n    var g\n    var b\n    var i\n    var f\n    var p\n    var q\n    var t\n    i = Math.floor(h * 6)\n    f = h * 6 - i\n    p = v * (1 - s)\n    q = v * (1 - f * s)\n    t = v * (1 - (1 - f) * s)\n    switch (i % 6) {\n      case 0:\n        r = v\n        g = t\n        b = p\n        break\n      case 1:\n        r = q\n        g = v\n        b = p\n        break\n      case 2:\n        r = p\n        g = v\n        b = t\n        break\n      case 3:\n        r = p\n        g = q\n        b = v\n        break\n      case 4:\n        r = t\n        g = p\n        b = v\n        break\n      case 5:\n        r = v\n        g = p\n        b = q\n        break\n      default:\n        break\n    }\n    return [r, g, b]\n  }\n\n  function RGBtoHSV(r, g, b) {\n    var max = Math.max(r, g, b)\n    var min = Math.min(r, g, b)\n    var d = max - min\n    var h\n    var s = max === 0 ? 0 : d / max\n    var v = max / 255\n\n    switch (max) {\n      case min:\n        h = 0\n        break\n      case r:\n        h = g - b + d * (g < b ? 6 : 0)\n        h /= 6 * d\n        break\n      case g:\n        h = b - r + d * 2\n        h /= 6 * d\n        break\n      case b:\n        h = r - g + d * 4\n        h /= 6 * d\n        break\n      default:\n        break\n    }\n\n    return [h, s, v]\n  }\n\n  function addSaturationToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255)\n    hsv[1] += offset\n    if (hsv[1] > 1) {\n      hsv[1] = 1\n    } else if (hsv[1] <= 0) {\n      hsv[1] = 0\n    }\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2])\n  }\n\n  function addBrightnessToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255)\n    hsv[2] += offset\n    if (hsv[2] > 1) {\n      hsv[2] = 1\n    } else if (hsv[2] < 0) {\n      hsv[2] = 0\n    }\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2])\n  }\n\n  function addHueToRGB(color, offset) {\n    var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255)\n    hsv[0] += offset / 360\n    if (hsv[0] > 1) {\n      hsv[0] -= 1\n    } else if (hsv[0] < 0) {\n      hsv[0] += 1\n    }\n    return HSVtoRGB(hsv[0], hsv[1], hsv[2])\n  }\n\n  const rgbToHex = (function () {\n    var colorMap = []\n    var i\n    var hex\n    for (i = 0; i < 256; i += 1) {\n      hex = i.toString(16)\n      colorMap[i] = hex.length === 1 ? '0' + hex : hex\n    }\n\n    return function (r, g, b) {\n      if (r < 0) {\n        r = 0\n      }\n      if (g < 0) {\n        g = 0\n      }\n      if (b < 0) {\n        b = 0\n      }\n      return '#' + colorMap[r] + colorMap[g] + colorMap[b]\n    }\n  })()\n\n  const setSubframeEnabled = (flag) => {\n    subframeEnabled = !!flag\n  }\n  const getSubframeEnabled = () => subframeEnabled\n  const setExpressionsPlugin = (value) => {\n    expressionsPlugin = value\n  }\n  const getExpressionsPlugin = () => expressionsPlugin\n  const setDefaultCurveSegments = (value) => {\n    defaultCurveSegments = value\n  }\n  const getDefaultCurveSegments = () => defaultCurveSegments\n  const setIdPrefix = (value) => {\n    idPrefix$1 = value\n  }\n  const getIdPrefix = () => idPrefix$1\n\n  function createNS(type) {\n    // return {appendChild:function(){},setAttribute:function(){},style:{}}\n    return document.createElementNS(svgNS, type)\n  }\n\n  const dataManager = (function () {\n    var _counterId = 1\n    var processes = []\n    var workerFn\n    var workerInstance\n    var workerProxy = {\n      onmessage: function () {},\n      postMessage: function (path) {\n        workerFn({\n          data: path,\n        })\n      },\n    }\n    var _workerSelf = {\n      postMessage: function (data) {\n        workerProxy.onmessage({\n          data: data,\n        })\n      },\n    }\n    function createWorker(fn) {\n      if (window.Worker && window.Blob && getWebWorker()) {\n        var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], { type: 'text/javascript' })\n        // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });\n        var url = URL.createObjectURL(blob)\n        return new Worker(url)\n      }\n      workerFn = fn\n      return workerProxy\n    }\n\n    function setupWorker() {\n      if (!workerInstance) {\n        workerInstance = createWorker(function workerStart(e) {\n          function dataFunctionManager() {\n            function completeLayers(layers, comps) {\n              var layerData\n              var i\n              var len = layers.length\n              var j\n              var jLen\n              var k\n              var kLen\n              for (i = 0; i < len; i += 1) {\n                layerData = layers[i]\n                if ('ks' in layerData && !layerData.completed) {\n                  layerData.completed = true\n                  if (layerData.tt) {\n                    layers[i - 1].td = layerData.tt\n                  }\n                  if (layerData.hasMask) {\n                    var maskProps = layerData.masksProperties\n                    jLen = maskProps.length\n                    for (j = 0; j < jLen; j += 1) {\n                      if (maskProps[j].pt.k.i) {\n                        convertPathsToAbsoluteValues(maskProps[j].pt.k)\n                      } else {\n                        kLen = maskProps[j].pt.k.length\n                        for (k = 0; k < kLen; k += 1) {\n                          if (maskProps[j].pt.k[k].s) {\n                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0])\n                          }\n                          if (maskProps[j].pt.k[k].e) {\n                            convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0])\n                          }\n                        }\n                      }\n                    }\n                  }\n                  if (layerData.ty === 0) {\n                    layerData.layers = findCompLayers(layerData.refId, comps)\n                    completeLayers(layerData.layers, comps)\n                  } else if (layerData.ty === 4) {\n                    completeShapes(layerData.shapes)\n                  } else if (layerData.ty === 5) {\n                    completeText(layerData)\n                  }\n                }\n              }\n            }\n\n            function completeChars(chars, assets) {\n              if (chars) {\n                var i = 0\n                var len = chars.length\n                for (i = 0; i < len; i += 1) {\n                  if (chars[i].t === 1) {\n                    // var compData = findComp(chars[i].data.refId, assets);\n                    chars[i].data.layers = findCompLayers(chars[i].data.refId, assets)\n                    // chars[i].data.ip = 0;\n                    // chars[i].data.op = 99999;\n                    // chars[i].data.st = 0;\n                    // chars[i].data.sr = 1;\n                    // chars[i].w = compData.w;\n                    // chars[i].data.ks = {\n                    //   a: { k: [0, 0, 0], a: 0 },\n                    //   p: { k: [0, -compData.h, 0], a: 0 },\n                    //   r: { k: 0, a: 0 },\n                    //   s: { k: [100, 100], a: 0 },\n                    //   o: { k: 100, a: 0 },\n                    // };\n                    completeLayers(chars[i].data.layers, assets)\n                  }\n                }\n              }\n            }\n\n            function findComp(id, comps) {\n              var i = 0\n              var len = comps.length\n              while (i < len) {\n                if (comps[i].id === id) {\n                  return comps[i]\n                }\n                i += 1\n              }\n              return null\n            }\n\n            function findCompLayers(id, comps) {\n              var comp = findComp(id, comps)\n              if (comp) {\n                if (!comp.layers.__used) {\n                  comp.layers.__used = true\n                  return comp.layers\n                }\n                return JSON.parse(JSON.stringify(comp.layers))\n              }\n              return null\n            }\n\n            function completeShapes(arr) {\n              var i\n              var len = arr.length\n              var j\n              var jLen\n              for (i = len - 1; i >= 0; i -= 1) {\n                if (arr[i].ty === 'sh') {\n                  if (arr[i].ks.k.i) {\n                    convertPathsToAbsoluteValues(arr[i].ks.k)\n                  } else {\n                    jLen = arr[i].ks.k.length\n                    for (j = 0; j < jLen; j += 1) {\n                      if (arr[i].ks.k[j].s) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0])\n                      }\n                      if (arr[i].ks.k[j].e) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0])\n                      }\n                    }\n                  }\n                } else if (arr[i].ty === 'gr') {\n                  completeShapes(arr[i].it)\n                }\n              }\n            }\n\n            function convertPathsToAbsoluteValues(path) {\n              var i\n              var len = path.i.length\n              for (i = 0; i < len; i += 1) {\n                path.i[i][0] += path.v[i][0]\n                path.i[i][1] += path.v[i][1]\n                path.o[i][0] += path.v[i][0]\n                path.o[i][1] += path.v[i][1]\n              }\n            }\n\n            function checkVersion(minimum, animVersionString) {\n              var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100]\n              if (minimum[0] > animVersion[0]) {\n                return true\n              }\n              if (animVersion[0] > minimum[0]) {\n                return false\n              }\n              if (minimum[1] > animVersion[1]) {\n                return true\n              }\n              if (animVersion[1] > minimum[1]) {\n                return false\n              }\n              if (minimum[2] > animVersion[2]) {\n                return true\n              }\n              if (animVersion[2] > minimum[2]) {\n                return false\n              }\n              return null\n            }\n\n            var checkText = (function () {\n              var minimumVersion = [4, 4, 14]\n\n              function updateTextLayer(textLayer) {\n                var documentData = textLayer.t.d\n                textLayer.t.d = {\n                  k: [\n                    {\n                      s: documentData,\n                      t: 0,\n                    },\n                  ],\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i\n                var len = layers.length\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 5) {\n                    updateTextLayer(layers[i])\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers)\n                  if (animationData.assets) {\n                    var i\n                    var len = animationData.assets.length\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers)\n                      }\n                    }\n                  }\n                }\n              }\n            })()\n\n            var checkChars = (function () {\n              var minimumVersion = [4, 7, 99]\n              return function (animationData) {\n                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n                  var i\n                  var len = animationData.chars.length\n                  for (i = 0; i < len; i += 1) {\n                    var charData = animationData.chars[i]\n                    if (charData.data && charData.data.shapes) {\n                      completeShapes(charData.data.shapes)\n                      charData.data.ip = 0\n                      charData.data.op = 99999\n                      charData.data.st = 0\n                      charData.data.sr = 1\n                      charData.data.ks = {\n                        p: { k: [0, 0], a: 0 },\n                        s: { k: [100, 100], a: 0 },\n                        a: { k: [0, 0], a: 0 },\n                        r: { k: 0, a: 0 },\n                        o: { k: 100, a: 0 },\n                      }\n                      if (!animationData.chars[i].t) {\n                        charData.data.shapes.push({\n                          ty: 'no',\n                        })\n                        charData.data.shapes[0].it.push({\n                          p: { k: [0, 0], a: 0 },\n                          s: { k: [100, 100], a: 0 },\n                          a: { k: [0, 0], a: 0 },\n                          r: { k: 0, a: 0 },\n                          o: { k: 100, a: 0 },\n                          sk: { k: 0, a: 0 },\n                          sa: { k: 0, a: 0 },\n                          ty: 'tr',\n                        })\n                      }\n                    }\n                  }\n                }\n              }\n            })()\n\n            var checkPathProperties = (function () {\n              var minimumVersion = [5, 7, 15]\n\n              function updateTextLayer(textLayer) {\n                var pathData = textLayer.t.p\n                if (typeof pathData.a === 'number') {\n                  pathData.a = {\n                    a: 0,\n                    k: pathData.a,\n                  }\n                }\n                if (typeof pathData.p === 'number') {\n                  pathData.p = {\n                    a: 0,\n                    k: pathData.p,\n                  }\n                }\n                if (typeof pathData.r === 'number') {\n                  pathData.r = {\n                    a: 0,\n                    k: pathData.r,\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i\n                var len = layers.length\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 5) {\n                    updateTextLayer(layers[i])\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers)\n                  if (animationData.assets) {\n                    var i\n                    var len = animationData.assets.length\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers)\n                      }\n                    }\n                  }\n                }\n              }\n            })()\n\n            var checkColors = (function () {\n              var minimumVersion = [4, 1, 9]\n\n              function iterateShapes(shapes) {\n                var i\n                var len = shapes.length\n                var j\n                var jLen\n                for (i = 0; i < len; i += 1) {\n                  if (shapes[i].ty === 'gr') {\n                    iterateShapes(shapes[i].it)\n                  } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {\n                    if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                      jLen = shapes[i].c.k.length\n                      for (j = 0; j < jLen; j += 1) {\n                        if (shapes[i].c.k[j].s) {\n                          shapes[i].c.k[j].s[0] /= 255\n                          shapes[i].c.k[j].s[1] /= 255\n                          shapes[i].c.k[j].s[2] /= 255\n                          shapes[i].c.k[j].s[3] /= 255\n                        }\n                        if (shapes[i].c.k[j].e) {\n                          shapes[i].c.k[j].e[0] /= 255\n                          shapes[i].c.k[j].e[1] /= 255\n                          shapes[i].c.k[j].e[2] /= 255\n                          shapes[i].c.k[j].e[3] /= 255\n                        }\n                      }\n                    } else {\n                      shapes[i].c.k[0] /= 255\n                      shapes[i].c.k[1] /= 255\n                      shapes[i].c.k[2] /= 255\n                      shapes[i].c.k[3] /= 255\n                    }\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var i\n                var len = layers.length\n                for (i = 0; i < len; i += 1) {\n                  if (layers[i].ty === 4) {\n                    iterateShapes(layers[i].shapes)\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers)\n                  if (animationData.assets) {\n                    var i\n                    var len = animationData.assets.length\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers)\n                      }\n                    }\n                  }\n                }\n              }\n            })()\n\n            var checkShapes = (function () {\n              var minimumVersion = [4, 4, 18]\n\n              function completeClosingShapes(arr) {\n                var i\n                var len = arr.length\n                var j\n                var jLen\n                for (i = len - 1; i >= 0; i -= 1) {\n                  if (arr[i].ty === 'sh') {\n                    if (arr[i].ks.k.i) {\n                      arr[i].ks.k.c = arr[i].closed\n                    } else {\n                      jLen = arr[i].ks.k.length\n                      for (j = 0; j < jLen; j += 1) {\n                        if (arr[i].ks.k[j].s) {\n                          arr[i].ks.k[j].s[0].c = arr[i].closed\n                        }\n                        if (arr[i].ks.k[j].e) {\n                          arr[i].ks.k[j].e[0].c = arr[i].closed\n                        }\n                      }\n                    }\n                  } else if (arr[i].ty === 'gr') {\n                    completeClosingShapes(arr[i].it)\n                  }\n                }\n              }\n\n              function iterateLayers(layers) {\n                var layerData\n                var i\n                var len = layers.length\n                var j\n                var jLen\n                var k\n                var kLen\n                for (i = 0; i < len; i += 1) {\n                  layerData = layers[i]\n                  if (layerData.hasMask) {\n                    var maskProps = layerData.masksProperties\n                    jLen = maskProps.length\n                    for (j = 0; j < jLen; j += 1) {\n                      if (maskProps[j].pt.k.i) {\n                        maskProps[j].pt.k.c = maskProps[j].cl\n                      } else {\n                        kLen = maskProps[j].pt.k.length\n                        for (k = 0; k < kLen; k += 1) {\n                          if (maskProps[j].pt.k[k].s) {\n                            maskProps[j].pt.k[k].s[0].c = maskProps[j].cl\n                          }\n                          if (maskProps[j].pt.k[k].e) {\n                            maskProps[j].pt.k[k].e[0].c = maskProps[j].cl\n                          }\n                        }\n                      }\n                    }\n                  }\n                  if (layerData.ty === 4) {\n                    completeClosingShapes(layerData.shapes)\n                  }\n                }\n              }\n\n              return function (animationData) {\n                if (checkVersion(minimumVersion, animationData.v)) {\n                  iterateLayers(animationData.layers)\n                  if (animationData.assets) {\n                    var i\n                    var len = animationData.assets.length\n                    for (i = 0; i < len; i += 1) {\n                      if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers)\n                      }\n                    }\n                  }\n                }\n              }\n            })()\n\n            function completeData(animationData) {\n              if (animationData.__complete) {\n                return\n              }\n              checkColors(animationData)\n              checkText(animationData)\n              checkChars(animationData)\n              checkPathProperties(animationData)\n              checkShapes(animationData)\n              completeLayers(animationData.layers, animationData.assets)\n              completeChars(animationData.chars, animationData.assets)\n              animationData.__complete = true\n            }\n\n            function completeText(data) {\n              if (data.t.a.length === 0 && !('m' in data.t.p)) {\n                // data.singleShape = true;\n              }\n            }\n\n            var moduleOb = {}\n            moduleOb.completeData = completeData\n            moduleOb.checkColors = checkColors\n            moduleOb.checkChars = checkChars\n            moduleOb.checkPathProperties = checkPathProperties\n            moduleOb.checkShapes = checkShapes\n            moduleOb.completeLayers = completeLayers\n\n            return moduleOb\n          }\n          if (!_workerSelf.dataManager) {\n            _workerSelf.dataManager = dataFunctionManager()\n          }\n\n          if (!_workerSelf.assetLoader) {\n            _workerSelf.assetLoader = (function () {\n              function formatResponse(xhr) {\n                // using typeof doubles the time of execution of this method,\n                // so if available, it's better to use the header to validate the type\n                var contentTypeHeader = xhr.getResponseHeader('content-type')\n                if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {\n                  return xhr.response\n                }\n                if (xhr.response && typeof xhr.response === 'object') {\n                  return xhr.response\n                }\n                if (xhr.response && typeof xhr.response === 'string') {\n                  return JSON.parse(xhr.response)\n                }\n                if (xhr.responseText) {\n                  return JSON.parse(xhr.responseText)\n                }\n                return null\n              }\n\n              function loadAsset(path, fullPath, callback, errorCallback) {\n                var response\n                var xhr = new XMLHttpRequest()\n                // set responseType after calling open or IE will break.\n                try {\n                  // This crashes on Android WebView prior to KitKat\n                  xhr.responseType = 'json'\n                } catch (err) {} // eslint-disable-line no-empty\n                xhr.onreadystatechange = function () {\n                  if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                      response = formatResponse(xhr)\n                      callback(response)\n                    } else {\n                      try {\n                        response = formatResponse(xhr)\n                        callback(response)\n                      } catch (err) {\n                        if (errorCallback) {\n                          errorCallback(err)\n                        }\n                      }\n                    }\n                  }\n                }\n                try {\n                  xhr.open('GET', path, true)\n                } catch (error) {\n                  xhr.open('GET', fullPath + '/' + path, true)\n                }\n                xhr.send()\n              }\n              return {\n                load: loadAsset,\n              }\n            })()\n          }\n\n          if (e.data.type === 'loadAnimation') {\n            _workerSelf.assetLoader.load(\n              e.data.path,\n              e.data.fullPath,\n              function (data) {\n                _workerSelf.dataManager.completeData(data)\n                _workerSelf.postMessage({\n                  id: e.data.id,\n                  payload: data,\n                  status: 'success',\n                })\n              },\n              function () {\n                _workerSelf.postMessage({\n                  id: e.data.id,\n                  status: 'error',\n                })\n              },\n            )\n          } else if (e.data.type === 'complete') {\n            var animation = e.data.animation\n            _workerSelf.dataManager.completeData(animation)\n            _workerSelf.postMessage({\n              id: e.data.id,\n              payload: animation,\n              status: 'success',\n            })\n          } else if (e.data.type === 'loadData') {\n            _workerSelf.assetLoader.load(\n              e.data.path,\n              e.data.fullPath,\n              function (data) {\n                _workerSelf.postMessage({\n                  id: e.data.id,\n                  payload: data,\n                  status: 'success',\n                })\n              },\n              function () {\n                _workerSelf.postMessage({\n                  id: e.data.id,\n                  status: 'error',\n                })\n              },\n            )\n          }\n        })\n\n        workerInstance.onmessage = function (event) {\n          var data = event.data\n          var id = data.id\n          var process = processes[id]\n          processes[id] = null\n          if (data.status === 'success') {\n            process.onComplete(data.payload)\n          } else if (process.onError) {\n            process.onError()\n          }\n        }\n      }\n    }\n\n    function createProcess(onComplete, onError) {\n      _counterId += 1\n      var id = 'processId_' + _counterId\n      processes[id] = {\n        onComplete: onComplete,\n        onError: onError,\n      }\n      return id\n    }\n\n    function loadAnimation(path, onComplete, onError) {\n      setupWorker()\n      var processId = createProcess(onComplete, onError)\n      workerInstance.postMessage({\n        type: 'loadAnimation',\n        path: path,\n        fullPath: window.location.origin + window.location.pathname,\n        id: processId,\n      })\n    }\n\n    function loadData(path, onComplete, onError) {\n      setupWorker()\n      var processId = createProcess(onComplete, onError)\n      workerInstance.postMessage({\n        type: 'loadData',\n        path: path,\n        fullPath: window.location.origin + window.location.pathname,\n        id: processId,\n      })\n    }\n\n    function completeAnimation(anim, onComplete, onError) {\n      setupWorker()\n      var processId = createProcess(onComplete, onError)\n      workerInstance.postMessage({\n        type: 'complete',\n        animation: anim,\n        id: processId,\n      })\n    }\n\n    return {\n      loadAnimation: loadAnimation,\n      loadData: loadData,\n      completeAnimation: completeAnimation,\n    }\n  })()\n\n  const ImagePreloader = (function () {\n    var proxyImage = (function () {\n      var canvas = createTag('canvas')\n      canvas.width = 1\n      canvas.height = 1\n      var ctx = canvas.getContext('2d')\n      ctx.fillStyle = 'rgba(0,0,0,0)'\n      ctx.fillRect(0, 0, 1, 1)\n      return canvas\n    })()\n\n    function imageLoaded() {\n      this.loadedAssets += 1\n      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n        if (this.imagesLoadedCb) {\n          this.imagesLoadedCb(null)\n        }\n      }\n    }\n    function footageLoaded() {\n      this.loadedFootagesCount += 1\n      if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n        if (this.imagesLoadedCb) {\n          this.imagesLoadedCb(null)\n        }\n      }\n    }\n\n    function getAssetsPath(assetData, assetsPath, originalPath) {\n      var path = ''\n      if (assetData.e) {\n        path = assetData.p\n      } else if (assetsPath) {\n        var imagePath = assetData.p\n        if (imagePath.indexOf('images/') !== -1) {\n          imagePath = imagePath.split('/')[1]\n        }\n        path = assetsPath + imagePath\n      } else {\n        path = originalPath\n        path += assetData.u ? assetData.u : ''\n        path += assetData.p\n      }\n      return path\n    }\n\n    function testImageLoaded(img) {\n      var _count = 0\n      var intervalId = setInterval(\n        function () {\n          var box = img.getBBox()\n          if (box.width || _count > 500) {\n            this._imageLoaded()\n            clearInterval(intervalId)\n          }\n          _count += 1\n        }.bind(this),\n        50,\n      )\n    }\n\n    function createImageData(assetData) {\n      var path = getAssetsPath(assetData, this.assetsPath, this.path)\n      var img = createNS('image')\n      if (isSafari) {\n        this.testImageLoaded(img)\n      } else {\n        img.addEventListener('load', this._imageLoaded, false)\n      }\n      img.addEventListener(\n        'error',\n        function () {\n          ob.img = proxyImage\n          this._imageLoaded()\n        }.bind(this),\n        false,\n      )\n      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path)\n      if (this._elementHelper.append) {\n        this._elementHelper.append(img)\n      } else {\n        this._elementHelper.appendChild(img)\n      }\n      var ob = {\n        img: img,\n        assetData: assetData,\n      }\n      return ob\n    }\n\n    function createImgData(assetData) {\n      var path = getAssetsPath(assetData, this.assetsPath, this.path)\n      var img = createTag('img')\n      img.crossOrigin = 'anonymous'\n      img.addEventListener('load', this._imageLoaded, false)\n      img.addEventListener(\n        'error',\n        function () {\n          ob.img = proxyImage\n          this._imageLoaded()\n        }.bind(this),\n        false,\n      )\n      img.src = path\n      var ob = {\n        img: img,\n        assetData: assetData,\n      }\n      return ob\n    }\n\n    function createFootageData(data) {\n      var ob = {\n        assetData: data,\n      }\n      var path = getAssetsPath(data, this.assetsPath, this.path)\n      dataManager.loadData(\n        path,\n        function (footageData) {\n          ob.img = footageData\n          this._footageLoaded()\n        }.bind(this),\n        function () {\n          ob.img = {}\n          this._footageLoaded()\n        }.bind(this),\n      )\n      return ob\n    }\n\n    function loadAssets(assets, cb) {\n      this.imagesLoadedCb = cb\n      var i\n      var len = assets.length\n      for (i = 0; i < len; i += 1) {\n        if (!assets[i].layers) {\n          if (!assets[i].t || assets[i].t === 'seq') {\n            this.totalImages += 1\n            this.images.push(this._createImageData(assets[i]))\n          } else if (assets[i].t === 3) {\n            this.totalFootages += 1\n            this.images.push(this.createFootageData(assets[i]))\n          }\n        }\n      }\n    }\n\n    function setPath(path) {\n      this.path = path || ''\n    }\n\n    function setAssetsPath(path) {\n      this.assetsPath = path || ''\n    }\n\n    function getAsset(assetData) {\n      var i = 0\n      var len = this.images.length\n      while (i < len) {\n        if (this.images[i].assetData === assetData) {\n          return this.images[i].img\n        }\n        i += 1\n      }\n      return null\n    }\n\n    function destroy() {\n      this.imagesLoadedCb = null\n      this.images.length = 0\n    }\n\n    function loadedImages() {\n      return this.totalImages === this.loadedAssets\n    }\n\n    function loadedFootages() {\n      return this.totalFootages === this.loadedFootagesCount\n    }\n\n    function setCacheType(type, elementHelper) {\n      if (type === 'svg') {\n        this._elementHelper = elementHelper\n        this._createImageData = this.createImageData.bind(this)\n      } else {\n        this._createImageData = this.createImgData.bind(this)\n      }\n    }\n\n    function ImagePreloaderFactory() {\n      this._imageLoaded = imageLoaded.bind(this)\n      this._footageLoaded = footageLoaded.bind(this)\n      this.testImageLoaded = testImageLoaded.bind(this)\n      this.createFootageData = createFootageData.bind(this)\n      this.assetsPath = ''\n      this.path = ''\n      this.totalImages = 0\n      this.totalFootages = 0\n      this.loadedAssets = 0\n      this.loadedFootagesCount = 0\n      this.imagesLoadedCb = null\n      this.images = []\n    }\n\n    ImagePreloaderFactory.prototype = {\n      loadAssets: loadAssets,\n      setAssetsPath: setAssetsPath,\n      setPath: setPath,\n      loadedImages: loadedImages,\n      loadedFootages: loadedFootages,\n      destroy: destroy,\n      getAsset: getAsset,\n      createImgData: createImgData,\n      createImageData: createImageData,\n      imageLoaded: imageLoaded,\n      footageLoaded: footageLoaded,\n      setCacheType: setCacheType,\n    }\n\n    return ImagePreloaderFactory\n  })()\n\n  function BaseEvent() {}\n  BaseEvent.prototype = {\n    triggerEvent: function (eventName, args) {\n      if (this._cbs[eventName]) {\n        var callbacks = this._cbs[eventName]\n        for (var i = 0; i < callbacks.length; i += 1) {\n          callbacks[i](args)\n        }\n      }\n    },\n    addEventListener: function (eventName, callback) {\n      if (!this._cbs[eventName]) {\n        this._cbs[eventName] = []\n      }\n      this._cbs[eventName].push(callback)\n\n      return function () {\n        this.removeEventListener(eventName, callback)\n      }.bind(this)\n    },\n    removeEventListener: function (eventName, callback) {\n      if (!callback) {\n        this._cbs[eventName] = null\n      } else if (this._cbs[eventName]) {\n        var i = 0\n        var len = this._cbs[eventName].length\n        while (i < len) {\n          if (this._cbs[eventName][i] === callback) {\n            this._cbs[eventName].splice(i, 1)\n            i -= 1\n            len -= 1\n          }\n          i += 1\n        }\n        if (!this._cbs[eventName].length) {\n          this._cbs[eventName] = null\n        }\n      }\n    },\n  }\n\n  const markerParser = (function () {\n    function parsePayloadLines(payload) {\n      var lines = payload.split('\\r\\n')\n      var keys = {}\n      var line\n      var keysCount = 0\n      for (var i = 0; i < lines.length; i += 1) {\n        line = lines[i].split(':')\n        if (line.length === 2) {\n          keys[line[0]] = line[1].trim()\n          keysCount += 1\n        }\n      }\n      if (keysCount === 0) {\n        throw new Error()\n      }\n      return keys\n    }\n\n    return function (_markers) {\n      var markers = []\n      for (var i = 0; i < _markers.length; i += 1) {\n        var _marker = _markers[i]\n        var markerData = {\n          time: _marker.tm,\n          duration: _marker.dr,\n        }\n        try {\n          markerData.payload = JSON.parse(_markers[i].cm)\n        } catch (_) {\n          try {\n            markerData.payload = parsePayloadLines(_markers[i].cm)\n          } catch (__) {\n            markerData.payload = {\n              name: _markers[i].cm,\n            }\n          }\n        }\n        markers.push(markerData)\n      }\n      return markers\n    }\n  })()\n\n  const ProjectInterface = (function () {\n    function registerComposition(comp) {\n      this.compositions.push(comp)\n    }\n\n    return function () {\n      function _thisProjectFunction(name) {\n        var i = 0\n        var len = this.compositions.length\n        while (i < len) {\n          if (this.compositions[i].data && this.compositions[i].data.nm === name) {\n            if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\n              this.compositions[i].prepareFrame(this.currentFrame)\n            }\n            return this.compositions[i].compInterface\n          }\n          i += 1\n        }\n        return null\n      }\n\n      _thisProjectFunction.compositions = []\n      _thisProjectFunction.currentFrame = 0\n\n      _thisProjectFunction.registerComposition = registerComposition\n\n      return _thisProjectFunction\n    }\n  })()\n\n  const renderers = {}\n\n  const registerRenderer = (key, value) => {\n    renderers[key] = value\n  }\n\n  function getRenderer(key) {\n    return renderers[key]\n  }\n\n  const AnimationItem = function () {\n    this._cbs = []\n    this.name = ''\n    this.path = ''\n    this.isLoaded = false\n    this.currentFrame = 0\n    this.currentRawFrame = 0\n    this.firstFrame = 0\n    this.totalFrames = 0\n    this.frameRate = 0\n    this.frameMult = 0\n    this.playSpeed = 1\n    this.playDirection = 1\n    this.playCount = 0\n    this.animationData = {}\n    this.assets = []\n    this.isPaused = true\n    this.autoplay = false\n    this.loop = true\n    this.renderer = null\n    this.animationID = createElementID()\n    this.assetsPath = ''\n    this.timeCompleted = 0\n    this.segmentPos = 0\n    this.isSubframeEnabled = getSubframeEnabled()\n    this.segments = []\n    this._idle = true\n    this._completedLoop = false\n    this.projectInterface = ProjectInterface()\n    this.imagePreloader = new ImagePreloader()\n    this.audioController = audioControllerFactory()\n    this.markers = []\n    this.configAnimation = this.configAnimation.bind(this)\n    this.onSetupError = this.onSetupError.bind(this)\n    this.onSegmentComplete = this.onSegmentComplete.bind(this)\n    this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0)\n  }\n\n  extendPrototype([BaseEvent], AnimationItem)\n\n  AnimationItem.prototype.setParams = function (params) {\n    if (params.wrapper || params.container) {\n      this.wrapper = params.wrapper || params.container\n    }\n    var animType = 'svg'\n    if (params.animType) {\n      animType = params.animType\n    } else if (params.renderer) {\n      animType = params.renderer\n    }\n    const RendererClass = getRenderer(animType)\n    this.renderer = new RendererClass(this, params.rendererSettings)\n    this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs)\n    this.renderer.setProjectInterface(this.projectInterface)\n    this.animType = animType\n    if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {\n      this.loop = true\n    } else if (params.loop === false) {\n      this.loop = false\n    } else {\n      this.loop = parseInt(params.loop, 10)\n    }\n    this.autoplay = 'autoplay' in params ? params.autoplay : true\n    this.name = params.name ? params.name : ''\n    this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments')\n      ? params.autoloadSegments\n      : true\n    this.assetsPath = params.assetsPath\n    this.initialSegment = params.initialSegment\n    if (params.audioFactory) {\n      this.audioController.setAudioFactory(params.audioFactory)\n    }\n    if (params.animationData) {\n      this.setupAnimation(params.animationData)\n    } else if (params.path) {\n      if (params.path.lastIndexOf('\\\\') !== -1) {\n        this.path = params.path.substr(0, params.path.lastIndexOf('\\\\') + 1)\n      } else {\n        this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1)\n      }\n      this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1)\n      this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'))\n      dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError)\n    }\n  }\n\n  AnimationItem.prototype.onSetupError = function () {\n    this.trigger('data_failed')\n  }\n\n  AnimationItem.prototype.setupAnimation = function (data) {\n    dataManager.completeAnimation(data, this.configAnimation)\n  }\n\n  AnimationItem.prototype.setData = function (wrapper, animationData) {\n    if (animationData) {\n      if (typeof animationData !== 'object') {\n        animationData = JSON.parse(animationData)\n      }\n    }\n    var params = {\n      wrapper: wrapper,\n      animationData: animationData,\n    }\n    var wrapperAttributes = wrapper.attributes\n\n    params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-animation-path').value\n      : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-path').value\n      : wrapperAttributes.getNamedItem('bm-path')\n      ? wrapperAttributes.getNamedItem('bm-path').value\n      : ''\n    params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-anim-type').value\n      : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-type').value\n      : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('bm-type').value\n      : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-renderer').value\n      : wrapperAttributes.getNamedItem('bm-renderer')\n      ? wrapperAttributes.getNamedItem('bm-renderer').value\n      : 'canvas'\n\n    var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-anim-loop').value\n      : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-loop').value\n      : wrapperAttributes.getNamedItem('bm-loop')\n      ? wrapperAttributes.getNamedItem('bm-loop').value\n      : ''\n    if (loop === 'false') {\n      params.loop = false\n    } else if (loop === 'true') {\n      params.loop = true\n    } else if (loop !== '') {\n      params.loop = parseInt(loop, 10)\n    }\n    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-anim-autoplay').value\n      : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-autoplay').value\n      : wrapperAttributes.getNamedItem('bm-autoplay')\n      ? wrapperAttributes.getNamedItem('bm-autoplay').value\n      : true\n    params.autoplay = autoplay !== 'false'\n\n    params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-name').value\n      : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-name').value\n      : wrapperAttributes.getNamedItem('bm-name')\n      ? wrapperAttributes.getNamedItem('bm-name').value\n      : ''\n    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-anim-prerender').value\n      : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary\n      ? wrapperAttributes.getNamedItem('data-bm-prerender').value\n      : wrapperAttributes.getNamedItem('bm-prerender')\n      ? wrapperAttributes.getNamedItem('bm-prerender').value\n      : ''\n\n    if (prerender === 'false') {\n      params.prerender = false\n    }\n    this.setParams(params)\n  }\n\n  AnimationItem.prototype.includeLayers = function (data) {\n    if (data.op > this.animationData.op) {\n      this.animationData.op = data.op\n      this.totalFrames = Math.floor(data.op - this.animationData.ip)\n    }\n    var layers = this.animationData.layers\n    var i\n    var len = layers.length\n    var newLayers = data.layers\n    var j\n    var jLen = newLayers.length\n    for (j = 0; j < jLen; j += 1) {\n      i = 0\n      while (i < len) {\n        if (layers[i].id === newLayers[j].id) {\n          layers[i] = newLayers[j]\n          break\n        }\n        i += 1\n      }\n    }\n    if (data.chars || data.fonts) {\n      this.renderer.globalData.fontManager.addChars(data.chars)\n      this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs)\n    }\n    if (data.assets) {\n      len = data.assets.length\n      for (i = 0; i < len; i += 1) {\n        this.animationData.assets.push(data.assets[i])\n      }\n    }\n    this.animationData.__complete = false\n    dataManager.completeAnimation(this.animationData, this.onSegmentComplete)\n  }\n\n  AnimationItem.prototype.onSegmentComplete = function (data) {\n    this.animationData = data\n    var expressionsPlugin = getExpressionsPlugin()\n    if (expressionsPlugin) {\n      expressionsPlugin.initExpressions(this)\n    }\n    this.loadNextSegment()\n  }\n\n  AnimationItem.prototype.loadNextSegment = function () {\n    var segments = this.animationData.segments\n    if (!segments || segments.length === 0 || !this.autoloadSegments) {\n      this.trigger('data_ready')\n      this.timeCompleted = this.totalFrames\n      return\n    }\n    var segment = segments.shift()\n    this.timeCompleted = segment.time * this.frameRate\n    var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json'\n    this.segmentPos += 1\n    dataManager.loadData(\n      segmentPath,\n      this.includeLayers.bind(this),\n      function () {\n        this.trigger('data_failed')\n      }.bind(this),\n    )\n  }\n\n  AnimationItem.prototype.loadSegments = function () {\n    var segments = this.animationData.segments\n    if (!segments) {\n      this.timeCompleted = this.totalFrames\n    }\n    this.loadNextSegment()\n  }\n\n  AnimationItem.prototype.imagesLoaded = function () {\n    this.trigger('loaded_images')\n    this.checkLoaded()\n  }\n\n  AnimationItem.prototype.preloadImages = function () {\n    this.imagePreloader.setAssetsPath(this.assetsPath)\n    this.imagePreloader.setPath(this.path)\n    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))\n  }\n\n  AnimationItem.prototype.configAnimation = function (animData) {\n    if (!this.renderer) {\n      return\n    }\n    try {\n      this.animationData = animData\n      if (this.initialSegment) {\n        this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0])\n        this.firstFrame = Math.round(this.initialSegment[0])\n      } else {\n        this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip)\n        this.firstFrame = Math.round(this.animationData.ip)\n      }\n      this.renderer.configAnimation(animData)\n      if (!animData.assets) {\n        animData.assets = []\n      }\n\n      this.assets = this.animationData.assets\n      this.frameRate = this.animationData.fr\n      this.frameMult = this.animationData.fr / 1000\n      this.renderer.searchExtraCompositions(animData.assets)\n      this.markers = markerParser(animData.markers || [])\n      this.trigger('config_ready')\n      this.preloadImages()\n      this.loadSegments()\n      this.updaFrameModifier()\n      this.waitForFontsLoaded()\n      if (this.isPaused) {\n        this.audioController.pause()\n      }\n    } catch (error) {\n      this.triggerConfigError(error)\n    }\n  }\n\n  AnimationItem.prototype.waitForFontsLoaded = function () {\n    if (!this.renderer) {\n      return\n    }\n    if (this.renderer.globalData.fontManager.isLoaded) {\n      this.checkLoaded()\n    } else {\n      setTimeout(this.waitForFontsLoaded.bind(this), 20)\n    }\n  }\n\n  AnimationItem.prototype.checkLoaded = function () {\n    if (\n      !this.isLoaded &&\n      this.renderer.globalData.fontManager.isLoaded &&\n      (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') &&\n      this.imagePreloader.loadedFootages()\n    ) {\n      this.isLoaded = true\n      var expressionsPlugin = getExpressionsPlugin()\n      if (expressionsPlugin) {\n        expressionsPlugin.initExpressions(this)\n      }\n      this.renderer.initItems()\n      setTimeout(\n        function () {\n          this.trigger('DOMLoaded')\n        }.bind(this),\n        0,\n      )\n      this.gotoFrame()\n      if (this.autoplay) {\n        this.play()\n      }\n    }\n  }\n\n  AnimationItem.prototype.resize = function () {\n    this.renderer.updateContainerSize()\n  }\n\n  AnimationItem.prototype.setSubframe = function (flag) {\n    this.isSubframeEnabled = !!flag\n  }\n\n  AnimationItem.prototype.gotoFrame = function () {\n    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame // eslint-disable-line no-bitwise\n\n    if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {\n      this.currentFrame = this.timeCompleted\n    }\n    this.trigger('enterFrame')\n    this.renderFrame()\n    this.trigger('drawnFrame')\n  }\n\n  AnimationItem.prototype.renderFrame = function () {\n    if (this.isLoaded === false || !this.renderer) {\n      return\n    }\n    try {\n      this.renderer.renderFrame(this.currentFrame + this.firstFrame)\n    } catch (error) {\n      this.triggerRenderFrameError(error)\n    }\n  }\n\n  AnimationItem.prototype.play = function (name) {\n    if (name && this.name !== name) {\n      return\n    }\n    if (this.isPaused === true) {\n      this.isPaused = false\n      this.trigger('_pause')\n      this.audioController.resume()\n      if (this._idle) {\n        this._idle = false\n        this.trigger('_active')\n      }\n    }\n  }\n\n  AnimationItem.prototype.pause = function (name) {\n    if (name && this.name !== name) {\n      return\n    }\n    if (this.isPaused === false) {\n      this.isPaused = true\n      this.trigger('_play')\n      this._idle = true\n      this.trigger('_idle')\n      this.audioController.pause()\n    }\n  }\n\n  AnimationItem.prototype.togglePause = function (name) {\n    if (name && this.name !== name) {\n      return\n    }\n    if (this.isPaused === true) {\n      this.play()\n    } else {\n      this.pause()\n    }\n  }\n\n  AnimationItem.prototype.stop = function (name) {\n    if (name && this.name !== name) {\n      return\n    }\n    this.pause()\n    this.playCount = 0\n    this._completedLoop = false\n    this.setCurrentRawFrameValue(0)\n  }\n\n  AnimationItem.prototype.getMarkerData = function (markerName) {\n    var marker\n    for (var i = 0; i < this.markers.length; i += 1) {\n      marker = this.markers[i]\n      if (marker.payload && marker.payload.name === markerName) {\n        return marker\n      }\n    }\n    return null\n  }\n\n  AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {\n    if (name && this.name !== name) {\n      return\n    }\n    var numValue = Number(value)\n    if (isNaN(numValue)) {\n      var marker = this.getMarkerData(value)\n      if (marker) {\n        this.goToAndStop(marker.time, true)\n      }\n    } else if (isFrame) {\n      this.setCurrentRawFrameValue(value)\n    } else {\n      this.setCurrentRawFrameValue(value * this.frameModifier)\n    }\n    this.pause()\n  }\n\n  AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {\n    if (name && this.name !== name) {\n      return\n    }\n    var numValue = Number(value)\n    if (isNaN(numValue)) {\n      var marker = this.getMarkerData(value)\n      if (marker) {\n        if (!marker.duration) {\n          this.goToAndStop(marker.time, true)\n        } else {\n          this.playSegments([marker.time, marker.time + marker.duration], true)\n        }\n      }\n    } else {\n      this.goToAndStop(numValue, isFrame, name)\n    }\n    this.play()\n  }\n\n  AnimationItem.prototype.advanceTime = function (value) {\n    if (this.isPaused === true || this.isLoaded === false) {\n      return\n    }\n    var nextValue = this.currentRawFrame + value * this.frameModifier\n    var _isComplete = false\n    // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\n    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\n    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\n      if (!this.loop || this.playCount === this.loop) {\n        if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {\n          _isComplete = true\n          nextValue = this.totalFrames - 1\n        }\n      } else if (nextValue >= this.totalFrames) {\n        this.playCount += 1\n        if (!this.checkSegments(nextValue % this.totalFrames)) {\n          this.setCurrentRawFrameValue(nextValue % this.totalFrames)\n          this._completedLoop = true\n          this.trigger('loopComplete')\n        }\n      } else {\n        this.setCurrentRawFrameValue(nextValue)\n      }\n    } else if (nextValue < 0) {\n      if (!this.checkSegments(nextValue % this.totalFrames)) {\n        if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\n          // eslint-disable-line no-plusplus\n          this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames))\n          if (!this._completedLoop) {\n            this._completedLoop = true\n          } else {\n            this.trigger('loopComplete')\n          }\n        } else {\n          _isComplete = true\n          nextValue = 0\n        }\n      }\n    } else {\n      this.setCurrentRawFrameValue(nextValue)\n    }\n    if (_isComplete) {\n      this.setCurrentRawFrameValue(nextValue)\n      this.pause()\n      this.trigger('complete')\n    }\n  }\n\n  AnimationItem.prototype.adjustSegment = function (arr, offset) {\n    this.playCount = 0\n    if (arr[1] < arr[0]) {\n      if (this.frameModifier > 0) {\n        if (this.playSpeed < 0) {\n          this.setSpeed(-this.playSpeed)\n        } else {\n          this.setDirection(-1)\n        }\n      }\n      this.totalFrames = arr[0] - arr[1]\n      this.timeCompleted = this.totalFrames\n      this.firstFrame = arr[1]\n      this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset)\n    } else if (arr[1] > arr[0]) {\n      if (this.frameModifier < 0) {\n        if (this.playSpeed < 0) {\n          this.setSpeed(-this.playSpeed)\n        } else {\n          this.setDirection(1)\n        }\n      }\n      this.totalFrames = arr[1] - arr[0]\n      this.timeCompleted = this.totalFrames\n      this.firstFrame = arr[0]\n      this.setCurrentRawFrameValue(0.001 + offset)\n    }\n    this.trigger('segmentStart')\n  }\n  AnimationItem.prototype.setSegment = function (init, end) {\n    var pendingFrame = -1\n    if (this.isPaused) {\n      if (this.currentRawFrame + this.firstFrame < init) {\n        pendingFrame = init\n      } else if (this.currentRawFrame + this.firstFrame > end) {\n        pendingFrame = end - init\n      }\n    }\n\n    this.firstFrame = init\n    this.totalFrames = end - init\n    this.timeCompleted = this.totalFrames\n    if (pendingFrame !== -1) {\n      this.goToAndStop(pendingFrame, true)\n    }\n  }\n\n  AnimationItem.prototype.playSegments = function (arr, forceFlag) {\n    if (forceFlag) {\n      this.segments.length = 0\n    }\n    if (typeof arr[0] === 'object') {\n      var i\n      var len = arr.length\n      for (i = 0; i < len; i += 1) {\n        this.segments.push(arr[i])\n      }\n    } else {\n      this.segments.push(arr)\n    }\n    if (this.segments.length && forceFlag) {\n      this.adjustSegment(this.segments.shift(), 0)\n    }\n    if (this.isPaused) {\n      this.play()\n    }\n  }\n\n  AnimationItem.prototype.resetSegments = function (forceFlag) {\n    this.segments.length = 0\n    this.segments.push([this.animationData.ip, this.animationData.op])\n    if (forceFlag) {\n      this.checkSegments(0)\n    }\n  }\n  AnimationItem.prototype.checkSegments = function (offset) {\n    if (this.segments.length) {\n      this.adjustSegment(this.segments.shift(), offset)\n      return true\n    }\n    return false\n  }\n\n  AnimationItem.prototype.destroy = function (name) {\n    if ((name && this.name !== name) || !this.renderer) {\n      return\n    }\n    this.renderer.destroy()\n    this.imagePreloader.destroy()\n    this.trigger('destroy')\n    this._cbs = null\n    this.onEnterFrame = null\n    this.onLoopComplete = null\n    this.onComplete = null\n    this.onSegmentStart = null\n    this.onDestroy = null\n    this.renderer = null\n    this.renderer = null\n    this.imagePreloader = null\n    this.projectInterface = null\n  }\n\n  AnimationItem.prototype.setCurrentRawFrameValue = function (value) {\n    this.currentRawFrame = value\n    this.gotoFrame()\n  }\n\n  AnimationItem.prototype.setSpeed = function (val) {\n    this.playSpeed = val\n    this.updaFrameModifier()\n  }\n\n  AnimationItem.prototype.setDirection = function (val) {\n    this.playDirection = val < 0 ? -1 : 1\n    this.updaFrameModifier()\n  }\n\n  AnimationItem.prototype.setVolume = function (val, name) {\n    if (name && this.name !== name) {\n      return\n    }\n    this.audioController.setVolume(val)\n  }\n\n  AnimationItem.prototype.getVolume = function () {\n    return this.audioController.getVolume()\n  }\n\n  AnimationItem.prototype.mute = function (name) {\n    if (name && this.name !== name) {\n      return\n    }\n    this.audioController.mute()\n  }\n\n  AnimationItem.prototype.unmute = function (name) {\n    if (name && this.name !== name) {\n      return\n    }\n    this.audioController.unmute()\n  }\n\n  AnimationItem.prototype.updaFrameModifier = function () {\n    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection\n    this.audioController.setRate(this.playSpeed * this.playDirection)\n  }\n\n  AnimationItem.prototype.getPath = function () {\n    return this.path\n  }\n\n  AnimationItem.prototype.getAssetsPath = function (assetData) {\n    var path = ''\n    if (assetData.e) {\n      path = assetData.p\n    } else if (this.assetsPath) {\n      var imagePath = assetData.p\n      if (imagePath.indexOf('images/') !== -1) {\n        imagePath = imagePath.split('/')[1]\n      }\n      path = this.assetsPath + imagePath\n    } else {\n      path = this.path\n      path += assetData.u ? assetData.u : ''\n      path += assetData.p\n    }\n    return path\n  }\n\n  AnimationItem.prototype.getAssetData = function (id) {\n    var i = 0\n    var len = this.assets.length\n    while (i < len) {\n      if (id === this.assets[i].id) {\n        return this.assets[i]\n      }\n      i += 1\n    }\n    return null\n  }\n\n  AnimationItem.prototype.hide = function () {\n    this.renderer.hide()\n  }\n\n  AnimationItem.prototype.show = function () {\n    this.renderer.show()\n  }\n\n  AnimationItem.prototype.getDuration = function (isFrame) {\n    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate\n  }\n\n  AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {\n    try {\n      var element = this.renderer.getElementByPath(path)\n      element.updateDocumentData(documentData, index)\n    } catch (error) {\n      // TODO: decide how to handle catch case\n    }\n  }\n\n  AnimationItem.prototype.trigger = function (name) {\n    if (this._cbs && this._cbs[name]) {\n      switch (name) {\n        case 'enterFrame':\n          this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier))\n          break\n        case 'drawnFrame':\n          this.drawnFrameEvent.currentTime = this.currentFrame\n          this.drawnFrameEvent.totalTime = this.totalFrames\n          this.drawnFrameEvent.direction = this.frameModifier\n          this.triggerEvent(name, this.drawnFrameEvent)\n          break\n        case 'loopComplete':\n          this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult))\n          break\n        case 'complete':\n          this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult))\n          break\n        case 'segmentStart':\n          this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames))\n          break\n        case 'destroy':\n          this.triggerEvent(name, new BMDestroyEvent(name, this))\n          break\n        default:\n          this.triggerEvent(name)\n      }\n    }\n    if (name === 'enterFrame' && this.onEnterFrame) {\n      this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult))\n    }\n    if (name === 'loopComplete' && this.onLoopComplete) {\n      this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult))\n    }\n    if (name === 'complete' && this.onComplete) {\n      this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult))\n    }\n    if (name === 'segmentStart' && this.onSegmentStart) {\n      this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames))\n    }\n    if (name === 'destroy' && this.onDestroy) {\n      this.onDestroy.call(this, new BMDestroyEvent(name, this))\n    }\n  }\n\n  AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {\n    var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame)\n    this.triggerEvent('error', error)\n\n    if (this.onError) {\n      this.onError.call(this, error)\n    }\n  }\n\n  AnimationItem.prototype.triggerConfigError = function (nativeError) {\n    var error = new BMConfigErrorEvent(nativeError, this.currentFrame)\n    this.triggerEvent('error', error)\n\n    if (this.onError) {\n      this.onError.call(this, error)\n    }\n  }\n\n  const animationManager = (function () {\n    var moduleOb = {}\n    var registeredAnimations = []\n    var initTime = 0\n    var len = 0\n    var playingAnimationsNum = 0\n    var _stopped = true\n    var _isFrozen = false\n\n    function removeElement(ev) {\n      var i = 0\n      var animItem = ev.target\n      while (i < len) {\n        if (registeredAnimations[i].animation === animItem) {\n          registeredAnimations.splice(i, 1)\n          i -= 1\n          len -= 1\n          if (!animItem.isPaused) {\n            subtractPlayingCount()\n          }\n        }\n        i += 1\n      }\n    }\n\n    function registerAnimation(element, animationData) {\n      if (!element) {\n        return null\n      }\n      var i = 0\n      while (i < len) {\n        if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {\n          return registeredAnimations[i].animation\n        }\n        i += 1\n      }\n      var animItem = new AnimationItem()\n      setupAnimation(animItem, element)\n      animItem.setData(element, animationData)\n      return animItem\n    }\n\n    function getRegisteredAnimations() {\n      var i\n      var lenAnims = registeredAnimations.length\n      var animations = []\n      for (i = 0; i < lenAnims; i += 1) {\n        animations.push(registeredAnimations[i].animation)\n      }\n      return animations\n    }\n\n    function addPlayingCount() {\n      playingAnimationsNum += 1\n      activate()\n    }\n\n    function subtractPlayingCount() {\n      playingAnimationsNum -= 1\n    }\n\n    function setupAnimation(animItem, element) {\n      animItem.addEventListener('destroy', removeElement)\n      animItem.addEventListener('_active', addPlayingCount)\n      animItem.addEventListener('_idle', subtractPlayingCount)\n      registeredAnimations.push({ elem: element, animation: animItem })\n      len += 1\n    }\n\n    function loadAnimation(params) {\n      var animItem = new AnimationItem()\n      setupAnimation(animItem, null)\n      animItem.setParams(params)\n      return animItem\n    }\n\n    function setSpeed(val, animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setSpeed(val, animation)\n      }\n    }\n\n    function setDirection(val, animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setDirection(val, animation)\n      }\n    }\n\n    function play(animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.play(animation)\n      }\n    }\n    function resume(nowTime) {\n      var elapsedTime = nowTime - initTime\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.advanceTime(elapsedTime)\n      }\n      initTime = nowTime\n      if (playingAnimationsNum && !_isFrozen) {\n        window.requestAnimationFrame(resume)\n      } else {\n        _stopped = true\n      }\n    }\n\n    function first(nowTime) {\n      initTime = nowTime\n      window.requestAnimationFrame(resume)\n    }\n\n    function pause(animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.pause(animation)\n      }\n    }\n\n    function goToAndStop(value, isFrame, animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.goToAndStop(value, isFrame, animation)\n      }\n    }\n\n    function stop(animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.stop(animation)\n      }\n    }\n\n    function togglePause(animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.togglePause(animation)\n      }\n    }\n\n    function destroy(animation) {\n      var i\n      for (i = len - 1; i >= 0; i -= 1) {\n        registeredAnimations[i].animation.destroy(animation)\n      }\n    }\n\n    function searchAnimations(animationData, standalone, renderer) {\n      var animElements = [].concat(\n        [].slice.call(document.getElementsByClassName('lottie')),\n        [].slice.call(document.getElementsByClassName('bodymovin')),\n      )\n      var i\n      var lenAnims = animElements.length\n      for (i = 0; i < lenAnims; i += 1) {\n        if (renderer) {\n          animElements[i].setAttribute('data-bm-type', renderer)\n        }\n        registerAnimation(animElements[i], animationData)\n      }\n      if (standalone && lenAnims === 0) {\n        if (!renderer) {\n          renderer = 'svg'\n        }\n        var body = document.getElementsByTagName('body')[0]\n        body.innerText = ''\n        var div = createTag('div')\n        div.style.width = '100%'\n        div.style.height = '100%'\n        div.setAttribute('data-bm-type', renderer)\n        body.appendChild(div)\n        registerAnimation(div, animationData)\n      }\n    }\n\n    function resize() {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.resize()\n      }\n    }\n\n    function activate() {\n      if (!_isFrozen && playingAnimationsNum) {\n        if (_stopped) {\n          window.requestAnimationFrame(first)\n          _stopped = false\n        }\n      }\n    }\n\n    function freeze() {\n      _isFrozen = true\n    }\n\n    function unfreeze() {\n      _isFrozen = false\n      activate()\n    }\n\n    function setVolume(val, animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.setVolume(val, animation)\n      }\n    }\n\n    function mute(animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.mute(animation)\n      }\n    }\n\n    function unmute(animation) {\n      var i\n      for (i = 0; i < len; i += 1) {\n        registeredAnimations[i].animation.unmute(animation)\n      }\n    }\n\n    moduleOb.registerAnimation = registerAnimation\n    moduleOb.loadAnimation = loadAnimation\n    moduleOb.setSpeed = setSpeed\n    moduleOb.setDirection = setDirection\n    moduleOb.play = play\n    moduleOb.pause = pause\n    moduleOb.stop = stop\n    moduleOb.togglePause = togglePause\n    moduleOb.searchAnimations = searchAnimations\n    moduleOb.resize = resize\n    // moduleOb.start = start;\n    moduleOb.goToAndStop = goToAndStop\n    moduleOb.destroy = destroy\n    moduleOb.freeze = freeze\n    moduleOb.unfreeze = unfreeze\n    moduleOb.setVolume = setVolume\n    moduleOb.mute = mute\n    moduleOb.unmute = unmute\n    moduleOb.getRegisteredAnimations = getRegisteredAnimations\n    return moduleOb\n  })()\n\n  /* eslint-disable */\n  const BezierFactory = (function () {\n    /**\n     * BezierEasing - use bezier curve for transition easing function\n     * by Gatan Renaudeau 2014 - 2015  MIT License\n     *\n     * Credits: is based on Firefox's nsSMILKeySpline.cpp\n     * Usage:\n     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\n     * spline.get(x) => returns the easing value | x must be in [0, 1] range\n     *\n     */\n\n    var ob = {}\n    ob.getBezierEasing = getBezierEasing\n    var beziers = {}\n\n    function getBezierEasing(a, b, c, d, nm) {\n      var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\\./g, 'p')\n      if (beziers[str]) {\n        return beziers[str]\n      }\n      var bezEasing = new BezierEasing([a, b, c, d])\n      beziers[str] = bezEasing\n      return bezEasing\n    }\n\n    // These values are established by empiricism with tests (tradeoff: performance VS precision)\n    var NEWTON_ITERATIONS = 4\n    var NEWTON_MIN_SLOPE = 0.001\n    var SUBDIVISION_PRECISION = 0.0000001\n    var SUBDIVISION_MAX_ITERATIONS = 10\n\n    var kSplineTableSize = 11\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0)\n\n    var float32ArraySupported = typeof Float32Array === 'function'\n\n    function A(aA1, aA2) {\n      return 1.0 - 3.0 * aA2 + 3.0 * aA1\n    }\n    function B(aA1, aA2) {\n      return 3.0 * aA2 - 6.0 * aA1\n    }\n    function C(aA1) {\n      return 3.0 * aA1\n    }\n\n    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n    function calcBezier(aT, aA1, aA2) {\n      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT\n    }\n\n    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n    function getSlope(aT, aA1, aA2) {\n      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1)\n    }\n\n    function binarySubdivide(aX, aA, aB, mX1, mX2) {\n      var currentX,\n        currentT,\n        i = 0\n      do {\n        currentT = aA + (aB - aA) / 2.0\n        currentX = calcBezier(currentT, mX1, mX2) - aX\n        if (currentX > 0.0) {\n          aB = currentT\n        } else {\n          aA = currentT\n        }\n      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)\n      return currentT\n    }\n\n    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2)\n        if (currentSlope === 0.0) return aGuessT\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX\n        aGuessT -= currentX / currentSlope\n      }\n      return aGuessT\n    }\n\n    /**\n     * points is an array of [ mX1, mY1, mX2, mY2 ]\n     */\n    function BezierEasing(points) {\n      this._p = points\n      this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize)\n      this._precomputed = false\n\n      this.get = this.get.bind(this)\n    }\n\n    BezierEasing.prototype = {\n      get: function (x) {\n        var mX1 = this._p[0],\n          mY1 = this._p[1],\n          mX2 = this._p[2],\n          mY2 = this._p[3]\n        if (!this._precomputed) this._precompute()\n        if (mX1 === mY1 && mX2 === mY2) return x // linear\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n        if (x === 0) return 0\n        if (x === 1) return 1\n        return calcBezier(this._getTForX(x), mY1, mY2)\n      },\n\n      // Private part\n\n      _precompute: function () {\n        var mX1 = this._p[0],\n          mY1 = this._p[1],\n          mX2 = this._p[2],\n          mY2 = this._p[3]\n        this._precomputed = true\n        if (mX1 !== mY1 || mX2 !== mY2) {\n          this._calcSampleValues()\n        }\n      },\n\n      _calcSampleValues: function () {\n        var mX1 = this._p[0],\n          mX2 = this._p[2]\n        for (var i = 0; i < kSplineTableSize; ++i) {\n          this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2)\n        }\n      },\n\n      /**\n       * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\n       */\n      _getTForX: function (aX) {\n        var mX1 = this._p[0],\n          mX2 = this._p[2],\n          mSampleValues = this._mSampleValues\n\n        var intervalStart = 0.0\n        var currentSample = 1\n        var lastSample = kSplineTableSize - 1\n\n        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n          intervalStart += kSampleStepSize\n        }\n        --currentSample\n\n        // Interpolate to provide an initial guess for t\n        var dist =\n          (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample])\n        var guessForT = intervalStart + dist * kSampleStepSize\n\n        var initialSlope = getSlope(guessForT, mX1, mX2)\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n          return newtonRaphsonIterate(aX, guessForT, mX1, mX2)\n        }\n        if (initialSlope === 0.0) {\n          return guessForT\n        }\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2)\n      },\n    }\n\n    return ob\n  })()\n\n  const pooling = (function () {\n    function double(arr) {\n      return arr.concat(createSizedArray(arr.length))\n    }\n\n    return {\n      double: double,\n    }\n  })()\n\n  const poolFactory = (function () {\n    return function (initialLength, _create, _release) {\n      var _length = 0\n      var _maxLength = initialLength\n      var pool = createSizedArray(_maxLength)\n\n      var ob = {\n        newElement: newElement,\n        release: release,\n      }\n\n      function newElement() {\n        var element\n        if (_length) {\n          _length -= 1\n          element = pool[_length]\n        } else {\n          element = _create()\n        }\n        return element\n      }\n\n      function release(element) {\n        if (_length === _maxLength) {\n          pool = pooling.double(pool)\n          _maxLength *= 2\n        }\n        if (_release) {\n          _release(element)\n        }\n        pool[_length] = element\n        _length += 1\n      }\n\n      return ob\n    }\n  })()\n\n  const bezierLengthPool = (function () {\n    function create() {\n      return {\n        addedLength: 0,\n        percents: createTypedArray('float32', getDefaultCurveSegments()),\n        lengths: createTypedArray('float32', getDefaultCurveSegments()),\n      }\n    }\n    return poolFactory(8, create)\n  })()\n\n  const segmentsLengthPool = (function () {\n    function create() {\n      return {\n        lengths: [],\n        totalLength: 0,\n      }\n    }\n\n    function release(element) {\n      var i\n      var len = element.lengths.length\n      for (i = 0; i < len; i += 1) {\n        bezierLengthPool.release(element.lengths[i])\n      }\n      element.lengths.length = 0\n    }\n\n    return poolFactory(8, create, release)\n  })()\n\n  function bezFunction() {\n    var math = Math\n\n    function pointOnLine2D(x1, y1, x2, y2, x3, y3) {\n      var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1\n      return det1 > -0.001 && det1 < 0.001\n    }\n\n    function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\n      if (z1 === 0 && z2 === 0 && z3 === 0) {\n        return pointOnLine2D(x1, y1, x2, y2, x3, y3)\n      }\n      var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2))\n      var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2))\n      var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2))\n      var diffDist\n      if (dist1 > dist2) {\n        if (dist1 > dist3) {\n          diffDist = dist1 - dist2 - dist3\n        } else {\n          diffDist = dist3 - dist2 - dist1\n        }\n      } else if (dist3 > dist2) {\n        diffDist = dist3 - dist2 - dist1\n      } else {\n        diffDist = dist2 - dist1 - dist3\n      }\n      return diffDist > -0.0001 && diffDist < 0.0001\n    }\n\n    var getBezierLength = (function () {\n      return function (pt1, pt2, pt3, pt4) {\n        var curveSegments = getDefaultCurveSegments()\n        var k\n        var i\n        var len\n        var ptCoord\n        var perc\n        var addedLength = 0\n        var ptDistance\n        var point = []\n        var lastPoint = []\n        var lengthData = bezierLengthPool.newElement()\n        len = pt3.length\n        for (k = 0; k < curveSegments; k += 1) {\n          perc = k / (curveSegments - 1)\n          ptDistance = 0\n          for (i = 0; i < len; i += 1) {\n            ptCoord =\n              bmPow(1 - perc, 3) * pt1[i] +\n              3 * bmPow(1 - perc, 2) * perc * pt3[i] +\n              3 * (1 - perc) * bmPow(perc, 2) * pt4[i] +\n              bmPow(perc, 3) * pt2[i]\n            point[i] = ptCoord\n            if (lastPoint[i] !== null) {\n              ptDistance += bmPow(point[i] - lastPoint[i], 2)\n            }\n            lastPoint[i] = point[i]\n          }\n          if (ptDistance) {\n            ptDistance = bmSqrt(ptDistance)\n            addedLength += ptDistance\n          }\n          lengthData.percents[k] = perc\n          lengthData.lengths[k] = addedLength\n        }\n        lengthData.addedLength = addedLength\n        return lengthData\n      }\n    })()\n\n    function getSegmentsLength(shapeData) {\n      var segmentsLength = segmentsLengthPool.newElement()\n      var closed = shapeData.c\n      var pathV = shapeData.v\n      var pathO = shapeData.o\n      var pathI = shapeData.i\n      var i\n      var len = shapeData._length\n      var lengths = segmentsLength.lengths\n      var totalLength = 0\n      for (i = 0; i < len - 1; i += 1) {\n        lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1])\n        totalLength += lengths[i].addedLength\n      }\n      if (closed && len) {\n        lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0])\n        totalLength += lengths[i].addedLength\n      }\n      segmentsLength.totalLength = totalLength\n      return segmentsLength\n    }\n\n    function BezierData(length) {\n      this.segmentLength = 0\n      this.points = new Array(length)\n    }\n\n    function PointData(partial, point) {\n      this.partialLength = partial\n      this.point = point\n    }\n\n    var buildBezierData = (function () {\n      var storedData = {}\n\n      return function (pt1, pt2, pt3, pt4) {\n        var bezierName = (\n          pt1[0] +\n          '_' +\n          pt1[1] +\n          '_' +\n          pt2[0] +\n          '_' +\n          pt2[1] +\n          '_' +\n          pt3[0] +\n          '_' +\n          pt3[1] +\n          '_' +\n          pt4[0] +\n          '_' +\n          pt4[1]\n        ).replace(/\\./g, 'p')\n        if (!storedData[bezierName]) {\n          var curveSegments = getDefaultCurveSegments()\n          var k\n          var i\n          var len\n          var ptCoord\n          var perc\n          var addedLength = 0\n          var ptDistance\n          var point\n          var lastPoint = null\n          if (\n            pt1.length === 2 &&\n            (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) &&\n            pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) &&\n            pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])\n          ) {\n            curveSegments = 2\n          }\n          var bezierData = new BezierData(curveSegments)\n          len = pt3.length\n          for (k = 0; k < curveSegments; k += 1) {\n            point = createSizedArray(len)\n            perc = k / (curveSegments - 1)\n            ptDistance = 0\n            for (i = 0; i < len; i += 1) {\n              ptCoord =\n                bmPow(1 - perc, 3) * pt1[i] +\n                3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) +\n                3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) +\n                bmPow(perc, 3) * pt2[i]\n              point[i] = ptCoord\n              if (lastPoint !== null) {\n                ptDistance += bmPow(point[i] - lastPoint[i], 2)\n              }\n            }\n            ptDistance = bmSqrt(ptDistance)\n            addedLength += ptDistance\n            bezierData.points[k] = new PointData(ptDistance, point)\n            lastPoint = point\n          }\n          bezierData.segmentLength = addedLength\n          storedData[bezierName] = bezierData\n        }\n        return storedData[bezierName]\n      }\n    })()\n\n    function getDistancePerc(perc, bezierData) {\n      var percents = bezierData.percents\n      var lengths = bezierData.lengths\n      var len = percents.length\n      var initPos = bmFloor((len - 1) * perc)\n      var lengthPos = perc * bezierData.addedLength\n      var lPerc = 0\n      if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {\n        return percents[initPos]\n      }\n      var dir = lengths[initPos] > lengthPos ? -1 : 1\n      var flag = true\n      while (flag) {\n        if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {\n          lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos])\n          flag = false\n        } else {\n          initPos += dir\n        }\n        if (initPos < 0 || initPos >= len - 1) {\n          // FIX for TypedArrays that don't store floating point values with enough accuracy\n          if (initPos === len - 1) {\n            return percents[initPos]\n          }\n          flag = false\n        }\n      }\n      return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc\n    }\n\n    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\n      var t1 = getDistancePerc(percent, bezierData)\n      var u1 = 1 - t1\n      var ptX =\n        math.round(\n          (u1 * u1 * u1 * pt1[0] +\n            (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] +\n            (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] +\n            t1 * t1 * t1 * pt2[0]) *\n            1000,\n        ) / 1000\n      var ptY =\n        math.round(\n          (u1 * u1 * u1 * pt1[1] +\n            (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] +\n            (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] +\n            t1 * t1 * t1 * pt2[1]) *\n            1000,\n        ) / 1000\n      return [ptX, ptY]\n    }\n\n    var bezierSegmentPoints = createTypedArray('float32', 8)\n\n    function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {\n      if (startPerc < 0) {\n        startPerc = 0\n      } else if (startPerc > 1) {\n        startPerc = 1\n      }\n      var t0 = getDistancePerc(startPerc, bezierData)\n      endPerc = endPerc > 1 ? 1 : endPerc\n      var t1 = getDistancePerc(endPerc, bezierData)\n      var i\n      var len = pt1.length\n      var u0 = 1 - t0\n      var u1 = 1 - t1\n      var u0u0u0 = u0 * u0 * u0\n      var t0u0u0_3 = t0 * u0 * u0 * 3 // eslint-disable-line camelcase\n      var t0t0u0_3 = t0 * t0 * u0 * 3 // eslint-disable-line camelcase\n      var t0t0t0 = t0 * t0 * t0\n      //\n      var u0u0u1 = u0 * u0 * u1\n      var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1 // eslint-disable-line camelcase\n      var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1 // eslint-disable-line camelcase\n      var t0t0t1 = t0 * t0 * t1\n      //\n      var u0u1u1 = u0 * u1 * u1\n      var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1 // eslint-disable-line camelcase\n      var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1 // eslint-disable-line camelcase\n      var t0t1t1 = t0 * t1 * t1\n      //\n      var u1u1u1 = u1 * u1 * u1\n      var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1 // eslint-disable-line camelcase\n      var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1 // eslint-disable-line camelcase\n      var t1t1t1 = t1 * t1 * t1\n      for (i = 0; i < len; i += 1) {\n        bezierSegmentPoints[i * 4] =\n          math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000 // eslint-disable-line camelcase\n        bezierSegmentPoints[i * 4 + 1] =\n          math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000 // eslint-disable-line camelcase\n        bezierSegmentPoints[i * 4 + 2] =\n          math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000 // eslint-disable-line camelcase\n        bezierSegmentPoints[i * 4 + 3] =\n          math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000 // eslint-disable-line camelcase\n      }\n\n      return bezierSegmentPoints\n    }\n\n    return {\n      getSegmentsLength: getSegmentsLength,\n      getNewSegment: getNewSegment,\n      getPointInSegment: getPointInSegment,\n      buildBezierData: buildBezierData,\n      pointOnLine2D: pointOnLine2D,\n      pointOnLine3D: pointOnLine3D,\n    }\n  }\n\n  const bez = bezFunction()\n\n  const PropertyFactory = (function () {\n    var initFrame = initialDefaultFrame\n    var mathAbs = Math.abs\n\n    function interpolateValue(frameNum, caching) {\n      var offsetTime = this.offsetTime\n      var newValue\n      if (this.propType === 'multidimensional') {\n        newValue = createTypedArray('float32', this.pv.length)\n      }\n      var iterationIndex = caching.lastIndex\n      var i = iterationIndex\n      var len = this.keyframes.length - 1\n      var flag = true\n      var keyData\n      var nextKeyData\n      var keyframeMetadata\n\n      while (flag) {\n        keyData = this.keyframes[i]\n        nextKeyData = this.keyframes[i + 1]\n        if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {\n          if (keyData.h) {\n            keyData = nextKeyData\n          }\n          iterationIndex = 0\n          break\n        }\n        if (nextKeyData.t - offsetTime > frameNum) {\n          iterationIndex = i\n          break\n        }\n        if (i < len - 1) {\n          i += 1\n        } else {\n          iterationIndex = 0\n          flag = false\n        }\n      }\n      keyframeMetadata = this.keyframesMetadata[i] || {}\n\n      var k\n      var kLen\n      var perc\n      var jLen\n      var j\n      var fnc\n      var nextKeyTime = nextKeyData.t - offsetTime\n      var keyTime = keyData.t - offsetTime\n      var endValue\n      if (keyData.to) {\n        if (!keyframeMetadata.bezierData) {\n          keyframeMetadata.bezierData = bez.buildBezierData(\n            keyData.s,\n            nextKeyData.s || keyData.e,\n            keyData.to,\n            keyData.ti,\n          )\n        }\n        var bezierData = keyframeMetadata.bezierData\n        if (frameNum >= nextKeyTime || frameNum < keyTime) {\n          var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0\n          kLen = bezierData.points[ind].point.length\n          for (k = 0; k < kLen; k += 1) {\n            newValue[k] = bezierData.points[ind].point[k]\n          }\n          // caching._lastKeyframeIndex = -1;\n        } else {\n          if (keyframeMetadata.__fnct) {\n            fnc = keyframeMetadata.__fnct\n          } else {\n            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get\n            keyframeMetadata.__fnct = fnc\n          }\n          perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime))\n          var distanceInLine = bezierData.segmentLength * perc\n\n          var segmentPerc\n          var addedLength =\n            caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0\n          j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0\n          flag = true\n          jLen = bezierData.points.length\n          while (flag) {\n            addedLength += bezierData.points[j].partialLength\n            if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\n              kLen = bezierData.points[j].point.length\n              for (k = 0; k < kLen; k += 1) {\n                newValue[k] = bezierData.points[j].point[k]\n              }\n              break\n            } else if (\n              distanceInLine >= addedLength &&\n              distanceInLine < addedLength + bezierData.points[j + 1].partialLength\n            ) {\n              segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength\n              kLen = bezierData.points[j].point.length\n              for (k = 0; k < kLen; k += 1) {\n                newValue[k] =\n                  bezierData.points[j].point[k] +\n                  (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc\n              }\n              break\n            }\n            if (j < jLen - 1) {\n              j += 1\n            } else {\n              flag = false\n            }\n          }\n          caching._lastPoint = j\n          caching._lastAddedLength = addedLength - bezierData.points[j].partialLength\n          caching._lastKeyframeIndex = i\n        }\n      } else {\n        var outX\n        var outY\n        var inX\n        var inY\n        var keyValue\n        len = keyData.s.length\n        endValue = nextKeyData.s || keyData.e\n        if (this.sh && keyData.h !== 1) {\n          if (frameNum >= nextKeyTime) {\n            newValue[0] = endValue[0]\n            newValue[1] = endValue[1]\n            newValue[2] = endValue[2]\n          } else if (frameNum <= keyTime) {\n            newValue[0] = keyData.s[0]\n            newValue[1] = keyData.s[1]\n            newValue[2] = keyData.s[2]\n          } else {\n            var quatStart = createQuaternion(keyData.s)\n            var quatEnd = createQuaternion(endValue)\n            var time = (frameNum - keyTime) / (nextKeyTime - keyTime)\n            quaternionToEuler(newValue, slerp(quatStart, quatEnd, time))\n          }\n        } else {\n          for (i = 0; i < len; i += 1) {\n            if (keyData.h !== 1) {\n              if (frameNum >= nextKeyTime) {\n                perc = 1\n              } else if (frameNum < keyTime) {\n                perc = 0\n              } else {\n                if (keyData.o.x.constructor === Array) {\n                  if (!keyframeMetadata.__fnct) {\n                    keyframeMetadata.__fnct = []\n                  }\n                  if (!keyframeMetadata.__fnct[i]) {\n                    outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i]\n                    outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i]\n                    inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i]\n                    inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i]\n                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get\n                    keyframeMetadata.__fnct[i] = fnc\n                  } else {\n                    fnc = keyframeMetadata.__fnct[i]\n                  }\n                } else if (!keyframeMetadata.__fnct) {\n                  outX = keyData.o.x\n                  outY = keyData.o.y\n                  inX = keyData.i.x\n                  inY = keyData.i.y\n                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get\n                  keyData.keyframeMetadata = fnc\n                } else {\n                  fnc = keyframeMetadata.__fnct\n                }\n                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime))\n              }\n            }\n\n            endValue = nextKeyData.s || keyData.e\n            keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc\n\n            if (this.propType === 'multidimensional') {\n              newValue[i] = keyValue\n            } else {\n              newValue = keyValue\n            }\n          }\n        }\n      }\n      caching.lastIndex = iterationIndex\n      return newValue\n    }\n\n    // based on @Toji's https://github.com/toji/gl-matrix/\n    function slerp(a, b, t) {\n      var out = []\n      var ax = a[0]\n      var ay = a[1]\n      var az = a[2]\n      var aw = a[3]\n      var bx = b[0]\n      var by = b[1]\n      var bz = b[2]\n      var bw = b[3]\n\n      var omega\n      var cosom\n      var sinom\n      var scale0\n      var scale1\n\n      cosom = ax * bx + ay * by + az * bz + aw * bw\n      if (cosom < 0.0) {\n        cosom = -cosom\n        bx = -bx\n        by = -by\n        bz = -bz\n        bw = -bw\n      }\n      if (1.0 - cosom > 0.000001) {\n        omega = Math.acos(cosom)\n        sinom = Math.sin(omega)\n        scale0 = Math.sin((1.0 - t) * omega) / sinom\n        scale1 = Math.sin(t * omega) / sinom\n      } else {\n        scale0 = 1.0 - t\n        scale1 = t\n      }\n      out[0] = scale0 * ax + scale1 * bx\n      out[1] = scale0 * ay + scale1 * by\n      out[2] = scale0 * az + scale1 * bz\n      out[3] = scale0 * aw + scale1 * bw\n\n      return out\n    }\n\n    function quaternionToEuler(out, quat) {\n      var qx = quat[0]\n      var qy = quat[1]\n      var qz = quat[2]\n      var qw = quat[3]\n      var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz)\n      var attitude = Math.asin(2 * qx * qy + 2 * qz * qw)\n      var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz)\n      out[0] = heading / degToRads\n      out[1] = attitude / degToRads\n      out[2] = bank / degToRads\n    }\n\n    function createQuaternion(values) {\n      var heading = values[0] * degToRads\n      var attitude = values[1] * degToRads\n      var bank = values[2] * degToRads\n      var c1 = Math.cos(heading / 2)\n      var c2 = Math.cos(attitude / 2)\n      var c3 = Math.cos(bank / 2)\n      var s1 = Math.sin(heading / 2)\n      var s2 = Math.sin(attitude / 2)\n      var s3 = Math.sin(bank / 2)\n      var w = c1 * c2 * c3 - s1 * s2 * s3\n      var x = s1 * s2 * c3 + c1 * c2 * s3\n      var y = s1 * c2 * c3 + c1 * s2 * s3\n      var z = c1 * s2 * c3 - s1 * c2 * s3\n\n      return [x, y, z, w]\n    }\n\n    function getValueAtCurrentTime() {\n      var frameNum = this.comp.renderedFrame - this.offsetTime\n      var initTime = this.keyframes[0].t - this.offsetTime\n      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime\n      if (\n        !(\n          frameNum === this._caching.lastFrame ||\n          (this._caching.lastFrame !== initFrame &&\n            ((this._caching.lastFrame >= endTime && frameNum >= endTime) ||\n              (this._caching.lastFrame < initTime && frameNum < initTime)))\n        )\n      ) {\n        if (this._caching.lastFrame >= frameNum) {\n          this._caching._lastKeyframeIndex = -1\n          this._caching.lastIndex = 0\n        }\n\n        var renderResult = this.interpolateValue(frameNum, this._caching)\n        this.pv = renderResult\n      }\n      this._caching.lastFrame = frameNum\n      return this.pv\n    }\n\n    function setVValue(val) {\n      var multipliedValue\n      if (this.propType === 'unidimensional') {\n        multipliedValue = val * this.mult\n        if (mathAbs(this.v - multipliedValue) > 0.00001) {\n          this.v = multipliedValue\n          this._mdf = true\n        }\n      } else {\n        var i = 0\n        var len = this.v.length\n        while (i < len) {\n          multipliedValue = val[i] * this.mult\n          if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {\n            this.v[i] = multipliedValue\n            this._mdf = true\n          }\n          i += 1\n        }\n      }\n    }\n\n    function processEffectsSequence() {\n      if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\n        return\n      }\n      if (this.lock) {\n        this.setVValue(this.pv)\n        return\n      }\n      this.lock = true\n      this._mdf = this._isFirstFrame\n      var i\n      var len = this.effectsSequence.length\n      var finalValue = this.kf ? this.pv : this.data.k\n      for (i = 0; i < len; i += 1) {\n        finalValue = this.effectsSequence[i](finalValue)\n      }\n      this.setVValue(finalValue)\n      this._isFirstFrame = false\n      this.lock = false\n      this.frameId = this.elem.globalData.frameId\n    }\n\n    function addEffect(effectFunction) {\n      this.effectsSequence.push(effectFunction)\n      this.container.addDynamicProperty(this)\n    }\n\n    function ValueProperty(elem, data, mult, container) {\n      this.propType = 'unidimensional'\n      this.mult = mult || 1\n      this.data = data\n      this.v = mult ? data.k * mult : data.k\n      this.pv = data.k\n      this._mdf = false\n      this.elem = elem\n      this.container = container\n      this.comp = elem.comp\n      this.k = false\n      this.kf = false\n      this.vel = 0\n      this.effectsSequence = []\n      this._isFirstFrame = true\n      this.getValue = processEffectsSequence\n      this.setVValue = setVValue\n      this.addEffect = addEffect\n    }\n\n    function MultiDimensionalProperty(elem, data, mult, container) {\n      this.propType = 'multidimensional'\n      this.mult = mult || 1\n      this.data = data\n      this._mdf = false\n      this.elem = elem\n      this.container = container\n      this.comp = elem.comp\n      this.k = false\n      this.kf = false\n      this.frameId = -1\n      var i\n      var len = data.k.length\n      this.v = createTypedArray('float32', len)\n      this.pv = createTypedArray('float32', len)\n      this.vel = createTypedArray('float32', len)\n      for (i = 0; i < len; i += 1) {\n        this.v[i] = data.k[i] * this.mult\n        this.pv[i] = data.k[i]\n      }\n      this._isFirstFrame = true\n      this.effectsSequence = []\n      this.getValue = processEffectsSequence\n      this.setVValue = setVValue\n      this.addEffect = addEffect\n    }\n\n    function KeyframedValueProperty(elem, data, mult, container) {\n      this.propType = 'unidimensional'\n      this.keyframes = data.k\n      this.keyframesMetadata = []\n      this.offsetTime = elem.data.st\n      this.frameId = -1\n      this._caching = {\n        lastFrame: initFrame,\n        lastIndex: 0,\n        value: 0,\n        _lastKeyframeIndex: -1,\n      }\n      this.k = true\n      this.kf = true\n      this.data = data\n      this.mult = mult || 1\n      this.elem = elem\n      this.container = container\n      this.comp = elem.comp\n      this.v = initFrame\n      this.pv = initFrame\n      this._isFirstFrame = true\n      this.getValue = processEffectsSequence\n      this.setVValue = setVValue\n      this.interpolateValue = interpolateValue\n      this.effectsSequence = [getValueAtCurrentTime.bind(this)]\n      this.addEffect = addEffect\n    }\n\n    function KeyframedMultidimensionalProperty(elem, data, mult, container) {\n      this.propType = 'multidimensional'\n      var i\n      var len = data.k.length\n      var s\n      var e\n      var to\n      var ti\n      for (i = 0; i < len - 1; i += 1) {\n        if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {\n          s = data.k[i].s\n          e = data.k[i + 1].s\n          to = data.k[i].to\n          ti = data.k[i].ti\n          if (\n            (s.length === 2 &&\n              !(s[0] === e[0] && s[1] === e[1]) &&\n              bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) &&\n              bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1])) ||\n            (s.length === 3 &&\n              !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) &&\n              bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) &&\n              bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2]))\n          ) {\n            data.k[i].to = null\n            data.k[i].ti = null\n          }\n          if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\n            if (s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {\n              data.k[i].to = null\n              data.k[i].ti = null\n            }\n          }\n        }\n      }\n      this.effectsSequence = [getValueAtCurrentTime.bind(this)]\n      this.data = data\n      this.keyframes = data.k\n      this.keyframesMetadata = []\n      this.offsetTime = elem.data.st\n      this.k = true\n      this.kf = true\n      this._isFirstFrame = true\n      this.mult = mult || 1\n      this.elem = elem\n      this.container = container\n      this.comp = elem.comp\n      this.getValue = processEffectsSequence\n      this.setVValue = setVValue\n      this.interpolateValue = interpolateValue\n      this.frameId = -1\n      var arrLen = data.k[0].s.length\n      this.v = createTypedArray('float32', arrLen)\n      this.pv = createTypedArray('float32', arrLen)\n      for (i = 0; i < arrLen; i += 1) {\n        this.v[i] = initFrame\n        this.pv[i] = initFrame\n      }\n      this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray('float32', arrLen) }\n      this.addEffect = addEffect\n    }\n\n    function getProp(elem, data, type, mult, container) {\n      var p\n      if (!data.k.length) {\n        p = new ValueProperty(elem, data, mult, container)\n      } else if (typeof data.k[0] === 'number') {\n        p = new MultiDimensionalProperty(elem, data, mult, container)\n      } else {\n        switch (type) {\n          case 0:\n            p = new KeyframedValueProperty(elem, data, mult, container)\n            break\n          case 1:\n            p = new KeyframedMultidimensionalProperty(elem, data, mult, container)\n            break\n          default:\n            break\n        }\n      }\n      if (p.effectsSequence.length) {\n        container.addDynamicProperty(p)\n      }\n      return p\n    }\n\n    var ob = {\n      getProp: getProp,\n    }\n    return ob\n  })()\n\n  function DynamicPropertyContainer() {}\n  DynamicPropertyContainer.prototype = {\n    addDynamicProperty: function (prop) {\n      if (this.dynamicProperties.indexOf(prop) === -1) {\n        this.dynamicProperties.push(prop)\n        this.container.addDynamicProperty(this)\n        this._isAnimated = true\n      }\n    },\n    iterateDynamicProperties: function () {\n      this._mdf = false\n      var i\n      var len = this.dynamicProperties.length\n      for (i = 0; i < len; i += 1) {\n        this.dynamicProperties[i].getValue()\n        if (this.dynamicProperties[i]._mdf) {\n          this._mdf = true\n        }\n      }\n    },\n    initDynamicPropertyContainer: function (container) {\n      this.container = container\n      this.dynamicProperties = []\n      this._mdf = false\n      this._isAnimated = false\n    },\n  }\n\n  const pointPool = (function () {\n    function create() {\n      return createTypedArray('float32', 2)\n    }\n    return poolFactory(8, create)\n  })()\n\n  function ShapePath() {\n    this.c = false\n    this._length = 0\n    this._maxLength = 8\n    this.v = createSizedArray(this._maxLength)\n    this.o = createSizedArray(this._maxLength)\n    this.i = createSizedArray(this._maxLength)\n  }\n\n  ShapePath.prototype.setPathData = function (closed, len) {\n    this.c = closed\n    this.setLength(len)\n    var i = 0\n    while (i < len) {\n      this.v[i] = pointPool.newElement()\n      this.o[i] = pointPool.newElement()\n      this.i[i] = pointPool.newElement()\n      i += 1\n    }\n  }\n\n  ShapePath.prototype.setLength = function (len) {\n    while (this._maxLength < len) {\n      this.doubleArrayLength()\n    }\n    this._length = len\n  }\n\n  ShapePath.prototype.doubleArrayLength = function () {\n    this.v = this.v.concat(createSizedArray(this._maxLength))\n    this.i = this.i.concat(createSizedArray(this._maxLength))\n    this.o = this.o.concat(createSizedArray(this._maxLength))\n    this._maxLength *= 2\n  }\n\n  ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {\n    var arr\n    this._length = Math.max(this._length, pos + 1)\n    if (this._length >= this._maxLength) {\n      this.doubleArrayLength()\n    }\n    switch (type) {\n      case 'v':\n        arr = this.v\n        break\n      case 'i':\n        arr = this.i\n        break\n      case 'o':\n        arr = this.o\n        break\n      default:\n        arr = []\n        break\n    }\n    if (!arr[pos] || (arr[pos] && !replace)) {\n      arr[pos] = pointPool.newElement()\n    }\n    arr[pos][0] = x\n    arr[pos][1] = y\n  }\n\n  ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {\n    this.setXYAt(vX, vY, 'v', pos, replace)\n    this.setXYAt(oX, oY, 'o', pos, replace)\n    this.setXYAt(iX, iY, 'i', pos, replace)\n  }\n\n  ShapePath.prototype.reverse = function () {\n    var newPath = new ShapePath()\n    newPath.setPathData(this.c, this._length)\n    var vertices = this.v\n    var outPoints = this.o\n    var inPoints = this.i\n    var init = 0\n    if (this.c) {\n      newPath.setTripleAt(\n        vertices[0][0],\n        vertices[0][1],\n        inPoints[0][0],\n        inPoints[0][1],\n        outPoints[0][0],\n        outPoints[0][1],\n        0,\n        false,\n      )\n      init = 1\n    }\n    var cnt = this._length - 1\n    var len = this._length\n\n    var i\n    for (i = init; i < len; i += 1) {\n      newPath.setTripleAt(\n        vertices[cnt][0],\n        vertices[cnt][1],\n        inPoints[cnt][0],\n        inPoints[cnt][1],\n        outPoints[cnt][0],\n        outPoints[cnt][1],\n        i,\n        false,\n      )\n      cnt -= 1\n    }\n    return newPath\n  }\n\n  const shapePool = (function () {\n    function create() {\n      return new ShapePath()\n    }\n\n    function release(shapePath) {\n      var len = shapePath._length\n      var i\n      for (i = 0; i < len; i += 1) {\n        pointPool.release(shapePath.v[i])\n        pointPool.release(shapePath.i[i])\n        pointPool.release(shapePath.o[i])\n        shapePath.v[i] = null\n        shapePath.i[i] = null\n        shapePath.o[i] = null\n      }\n      shapePath._length = 0\n      shapePath.c = false\n    }\n\n    function clone(shape) {\n      var cloned = factory.newElement()\n      var i\n      var len = shape._length === undefined ? shape.v.length : shape._length\n      cloned.setLength(len)\n      cloned.c = shape.c\n\n      for (i = 0; i < len; i += 1) {\n        cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i)\n      }\n      return cloned\n    }\n\n    var factory = poolFactory(4, create, release)\n    factory.clone = clone\n\n    return factory\n  })()\n\n  function ShapeCollection() {\n    this._length = 0\n    this._maxLength = 4\n    this.shapes = createSizedArray(this._maxLength)\n  }\n\n  ShapeCollection.prototype.addShape = function (shapeData) {\n    if (this._length === this._maxLength) {\n      this.shapes = this.shapes.concat(createSizedArray(this._maxLength))\n      this._maxLength *= 2\n    }\n    this.shapes[this._length] = shapeData\n    this._length += 1\n  }\n\n  ShapeCollection.prototype.releaseShapes = function () {\n    var i\n    for (i = 0; i < this._length; i += 1) {\n      shapePool.release(this.shapes[i])\n    }\n    this._length = 0\n  }\n\n  const shapeCollectionPool = (function () {\n    var ob = {\n      newShapeCollection: newShapeCollection,\n      release: release,\n    }\n\n    var _length = 0\n    var _maxLength = 4\n    var pool = createSizedArray(_maxLength)\n\n    function newShapeCollection() {\n      var shapeCollection\n      if (_length) {\n        _length -= 1\n        shapeCollection = pool[_length]\n      } else {\n        shapeCollection = new ShapeCollection()\n      }\n      return shapeCollection\n    }\n\n    function release(shapeCollection) {\n      var i\n      var len = shapeCollection._length\n      for (i = 0; i < len; i += 1) {\n        shapePool.release(shapeCollection.shapes[i])\n      }\n      shapeCollection._length = 0\n\n      if (_length === _maxLength) {\n        pool = pooling.double(pool)\n        _maxLength *= 2\n      }\n      pool[_length] = shapeCollection\n      _length += 1\n    }\n\n    return ob\n  })()\n\n  const ShapePropertyFactory = (function () {\n    var initFrame = -999999\n\n    function interpolateShape(frameNum, previousValue, caching) {\n      var iterationIndex = caching.lastIndex\n      var keyPropS\n      var keyPropE\n      var isHold\n      var j\n      var k\n      var jLen\n      var kLen\n      var perc\n      var vertexValue\n      var kf = this.keyframes\n      if (frameNum < kf[0].t - this.offsetTime) {\n        keyPropS = kf[0].s[0]\n        isHold = true\n        iterationIndex = 0\n      } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {\n        keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0]\n        /* if(kf[kf.length - 1].s){\n                keyPropS = kf[kf.length - 1].s[0];\n            }else{\n                keyPropS = kf[kf.length - 2].e[0];\n            } */\n        isHold = true\n      } else {\n        var i = iterationIndex\n        var len = kf.length - 1\n        var flag = true\n        var keyData\n        var nextKeyData\n        var keyframeMetadata\n        while (flag) {\n          keyData = kf[i]\n          nextKeyData = kf[i + 1]\n          if (nextKeyData.t - this.offsetTime > frameNum) {\n            break\n          }\n          if (i < len - 1) {\n            i += 1\n          } else {\n            flag = false\n          }\n        }\n        keyframeMetadata = this.keyframesMetadata[i] || {}\n        isHold = keyData.h === 1\n        iterationIndex = i\n        if (!isHold) {\n          if (frameNum >= nextKeyData.t - this.offsetTime) {\n            perc = 1\n          } else if (frameNum < keyData.t - this.offsetTime) {\n            perc = 0\n          } else {\n            var fnc\n            if (keyframeMetadata.__fnct) {\n              fnc = keyframeMetadata.__fnct\n            } else {\n              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get\n              keyframeMetadata.__fnct = fnc\n            }\n            perc = fnc(\n              (frameNum - (keyData.t - this.offsetTime)) /\n                (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)),\n            )\n          }\n          keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0]\n        }\n        keyPropS = keyData.s[0]\n      }\n      jLen = previousValue._length\n      kLen = keyPropS.i[0].length\n      caching.lastIndex = iterationIndex\n\n      for (j = 0; j < jLen; j += 1) {\n        for (k = 0; k < kLen; k += 1) {\n          vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc\n          previousValue.i[j][k] = vertexValue\n          vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc\n          previousValue.o[j][k] = vertexValue\n          vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc\n          previousValue.v[j][k] = vertexValue\n        }\n      }\n    }\n\n    function interpolateShapeCurrentTime() {\n      var frameNum = this.comp.renderedFrame - this.offsetTime\n      var initTime = this.keyframes[0].t - this.offsetTime\n      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime\n      var lastFrame = this._caching.lastFrame\n      if (\n        !(\n          lastFrame !== initFrame &&\n          ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime))\n        )\n      ) {\n        /// /\n        this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0\n        this.interpolateShape(frameNum, this.pv, this._caching)\n        /// /\n      }\n      this._caching.lastFrame = frameNum\n      return this.pv\n    }\n\n    function resetShape() {\n      this.paths = this.localShapeCollection\n    }\n\n    function shapesEqual(shape1, shape2) {\n      if (shape1._length !== shape2._length || shape1.c !== shape2.c) {\n        return false\n      }\n      var i\n      var len = shape1._length\n      for (i = 0; i < len; i += 1) {\n        if (\n          shape1.v[i][0] !== shape2.v[i][0] ||\n          shape1.v[i][1] !== shape2.v[i][1] ||\n          shape1.o[i][0] !== shape2.o[i][0] ||\n          shape1.o[i][1] !== shape2.o[i][1] ||\n          shape1.i[i][0] !== shape2.i[i][0] ||\n          shape1.i[i][1] !== shape2.i[i][1]\n        ) {\n          return false\n        }\n      }\n      return true\n    }\n\n    function setVValue(newPath) {\n      if (!shapesEqual(this.v, newPath)) {\n        this.v = shapePool.clone(newPath)\n        this.localShapeCollection.releaseShapes()\n        this.localShapeCollection.addShape(this.v)\n        this._mdf = true\n        this.paths = this.localShapeCollection\n      }\n    }\n\n    function processEffectsSequence() {\n      if (this.elem.globalData.frameId === this.frameId) {\n        return\n      }\n      if (!this.effectsSequence.length) {\n        this._mdf = false\n        return\n      }\n      if (this.lock) {\n        this.setVValue(this.pv)\n        return\n      }\n      this.lock = true\n      this._mdf = false\n      var finalValue\n      if (this.kf) {\n        finalValue = this.pv\n      } else if (this.data.ks) {\n        finalValue = this.data.ks.k\n      } else {\n        finalValue = this.data.pt.k\n      }\n      var i\n      var len = this.effectsSequence.length\n      for (i = 0; i < len; i += 1) {\n        finalValue = this.effectsSequence[i](finalValue)\n      }\n      this.setVValue(finalValue)\n      this.lock = false\n      this.frameId = this.elem.globalData.frameId\n    }\n\n    function ShapeProperty(elem, data, type) {\n      this.propType = 'shape'\n      this.comp = elem.comp\n      this.container = elem\n      this.elem = elem\n      this.data = data\n      this.k = false\n      this.kf = false\n      this._mdf = false\n      var pathData = type === 3 ? data.pt.k : data.ks.k\n      this.v = shapePool.clone(pathData)\n      this.pv = shapePool.clone(this.v)\n      this.localShapeCollection = shapeCollectionPool.newShapeCollection()\n      this.paths = this.localShapeCollection\n      this.paths.addShape(this.v)\n      this.reset = resetShape\n      this.effectsSequence = []\n    }\n\n    function addEffect(effectFunction) {\n      this.effectsSequence.push(effectFunction)\n      this.container.addDynamicProperty(this)\n    }\n\n    ShapeProperty.prototype.interpolateShape = interpolateShape\n    ShapeProperty.prototype.getValue = processEffectsSequence\n    ShapeProperty.prototype.setVValue = setVValue\n    ShapeProperty.prototype.addEffect = addEffect\n\n    function KeyframedShapeProperty(elem, data, type) {\n      this.propType = 'shape'\n      this.comp = elem.comp\n      this.elem = elem\n      this.container = elem\n      this.offsetTime = elem.data.st\n      this.keyframes = type === 3 ? data.pt.k : data.ks.k\n      this.keyframesMetadata = []\n      this.k = true\n      this.kf = true\n      var len = this.keyframes[0].s[0].i.length\n      this.v = shapePool.newElement()\n      this.v.setPathData(this.keyframes[0].s[0].c, len)\n      this.pv = shapePool.clone(this.v)\n      this.localShapeCollection = shapeCollectionPool.newShapeCollection()\n      this.paths = this.localShapeCollection\n      this.paths.addShape(this.v)\n      this.lastFrame = initFrame\n      this.reset = resetShape\n      this._caching = { lastFrame: initFrame, lastIndex: 0 }\n      this.effectsSequence = [interpolateShapeCurrentTime.bind(this)]\n    }\n    KeyframedShapeProperty.prototype.getValue = processEffectsSequence\n    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape\n    KeyframedShapeProperty.prototype.setVValue = setVValue\n    KeyframedShapeProperty.prototype.addEffect = addEffect\n\n    var EllShapeProperty = (function () {\n      var cPoint = roundCorner\n\n      function EllShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement()\n        this.v.setPathData(true, 4)\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection()\n        this.paths = this.localShapeCollection\n        this.localShapeCollection.addShape(this.v)\n        this.d = data.d\n        this.elem = elem\n        this.comp = elem.comp\n        this.frameId = -1\n        this.initDynamicPropertyContainer(elem)\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this)\n        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this)\n        if (this.dynamicProperties.length) {\n          this.k = true\n        } else {\n          this.k = false\n          this.convertEllToPath()\n        }\n      }\n\n      EllShapePropertyFactory.prototype = {\n        reset: resetShape,\n        getValue: function () {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return\n          }\n          this.frameId = this.elem.globalData.frameId\n          this.iterateDynamicProperties()\n\n          if (this._mdf) {\n            this.convertEllToPath()\n          }\n        },\n        convertEllToPath: function () {\n          var p0 = this.p.v[0]\n          var p1 = this.p.v[1]\n          var s0 = this.s.v[0] / 2\n          var s1 = this.s.v[1] / 2\n          var _cw = this.d !== 3\n          var _v = this.v\n          _v.v[0][0] = p0\n          _v.v[0][1] = p1 - s1\n          _v.v[1][0] = _cw ? p0 + s0 : p0 - s0\n          _v.v[1][1] = p1\n          _v.v[2][0] = p0\n          _v.v[2][1] = p1 + s1\n          _v.v[3][0] = _cw ? p0 - s0 : p0 + s0\n          _v.v[3][1] = p1\n          _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint\n          _v.i[0][1] = p1 - s1\n          _v.i[1][0] = _cw ? p0 + s0 : p0 - s0\n          _v.i[1][1] = p1 - s1 * cPoint\n          _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint\n          _v.i[2][1] = p1 + s1\n          _v.i[3][0] = _cw ? p0 - s0 : p0 + s0\n          _v.i[3][1] = p1 + s1 * cPoint\n          _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint\n          _v.o[0][1] = p1 - s1\n          _v.o[1][0] = _cw ? p0 + s0 : p0 - s0\n          _v.o[1][1] = p1 + s1 * cPoint\n          _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint\n          _v.o[2][1] = p1 + s1\n          _v.o[3][0] = _cw ? p0 - s0 : p0 + s0\n          _v.o[3][1] = p1 - s1 * cPoint\n        },\n      }\n\n      extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory)\n\n      return EllShapePropertyFactory\n    })()\n\n    var StarShapeProperty = (function () {\n      function StarShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement()\n        this.v.setPathData(true, 0)\n        this.elem = elem\n        this.comp = elem.comp\n        this.data = data\n        this.frameId = -1\n        this.d = data.d\n        this.initDynamicPropertyContainer(elem)\n        if (data.sy === 1) {\n          this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this)\n          this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this)\n          this.convertToPath = this.convertStarToPath\n        } else {\n          this.convertToPath = this.convertPolygonToPath\n        }\n        this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this)\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this)\n        this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this)\n        this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this)\n        this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this)\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection()\n        this.localShapeCollection.addShape(this.v)\n        this.paths = this.localShapeCollection\n        if (this.dynamicProperties.length) {\n          this.k = true\n        } else {\n          this.k = false\n          this.convertToPath()\n        }\n      }\n\n      StarShapePropertyFactory.prototype = {\n        reset: resetShape,\n        getValue: function () {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return\n          }\n          this.frameId = this.elem.globalData.frameId\n          this.iterateDynamicProperties()\n          if (this._mdf) {\n            this.convertToPath()\n          }\n        },\n        convertStarToPath: function () {\n          var numPts = Math.floor(this.pt.v) * 2\n          var angle = (Math.PI * 2) / numPts\n          /* this.v.v.length = numPts;\n                this.v.i.length = numPts;\n                this.v.o.length = numPts; */\n          var longFlag = true\n          var longRad = this.or.v\n          var shortRad = this.ir.v\n          var longRound = this.os.v\n          var shortRound = this.is.v\n          var longPerimSegment = (2 * Math.PI * longRad) / (numPts * 2)\n          var shortPerimSegment = (2 * Math.PI * shortRad) / (numPts * 2)\n          var i\n          var rad\n          var roundness\n          var perimSegment\n          var currentAng = -Math.PI / 2\n          currentAng += this.r.v\n          var dir = this.data.d === 3 ? -1 : 1\n          this.v._length = 0\n          for (i = 0; i < numPts; i += 1) {\n            rad = longFlag ? longRad : shortRad\n            roundness = longFlag ? longRound : shortRound\n            perimSegment = longFlag ? longPerimSegment : shortPerimSegment\n            var x = rad * Math.cos(currentAng)\n            var y = rad * Math.sin(currentAng)\n            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y)\n            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y)\n            x += +this.p.v[0]\n            y += +this.p.v[1]\n            this.v.setTripleAt(\n              x,\n              y,\n              x - ox * perimSegment * roundness * dir,\n              y - oy * perimSegment * roundness * dir,\n              x + ox * perimSegment * roundness * dir,\n              y + oy * perimSegment * roundness * dir,\n              i,\n              true,\n            )\n\n            /* this.v.v[i] = [x,y];\n                    this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\n                    this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\n                    this.v._length = numPts; */\n            longFlag = !longFlag\n            currentAng += angle * dir\n          }\n        },\n        convertPolygonToPath: function () {\n          var numPts = Math.floor(this.pt.v)\n          var angle = (Math.PI * 2) / numPts\n          var rad = this.or.v\n          var roundness = this.os.v\n          var perimSegment = (2 * Math.PI * rad) / (numPts * 4)\n          var i\n          var currentAng = -Math.PI * 0.5\n          var dir = this.data.d === 3 ? -1 : 1\n          currentAng += this.r.v\n          this.v._length = 0\n          for (i = 0; i < numPts; i += 1) {\n            var x = rad * Math.cos(currentAng)\n            var y = rad * Math.sin(currentAng)\n            var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y)\n            var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y)\n            x += +this.p.v[0]\n            y += +this.p.v[1]\n            this.v.setTripleAt(\n              x,\n              y,\n              x - ox * perimSegment * roundness * dir,\n              y - oy * perimSegment * roundness * dir,\n              x + ox * perimSegment * roundness * dir,\n              y + oy * perimSegment * roundness * dir,\n              i,\n              true,\n            )\n            currentAng += angle * dir\n          }\n          this.paths.length = 0\n          this.paths[0] = this.v\n        },\n      }\n      extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory)\n\n      return StarShapePropertyFactory\n    })()\n\n    var RectShapeProperty = (function () {\n      function RectShapePropertyFactory(elem, data) {\n        this.v = shapePool.newElement()\n        this.v.c = true\n        this.localShapeCollection = shapeCollectionPool.newShapeCollection()\n        this.localShapeCollection.addShape(this.v)\n        this.paths = this.localShapeCollection\n        this.elem = elem\n        this.comp = elem.comp\n        this.frameId = -1\n        this.d = data.d\n        this.initDynamicPropertyContainer(elem)\n        this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this)\n        this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this)\n        this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this)\n        if (this.dynamicProperties.length) {\n          this.k = true\n        } else {\n          this.k = false\n          this.convertRectToPath()\n        }\n      }\n\n      RectShapePropertyFactory.prototype = {\n        convertRectToPath: function () {\n          var p0 = this.p.v[0]\n          var p1 = this.p.v[1]\n          var v0 = this.s.v[0] / 2\n          var v1 = this.s.v[1] / 2\n          var round = bmMin(v0, v1, this.r.v)\n          var cPoint = round * (1 - roundCorner)\n          this.v._length = 0\n\n          if (this.d === 2 || this.d === 1) {\n            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true)\n            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true)\n            if (round !== 0) {\n              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true)\n              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true)\n              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true)\n              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true)\n              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true)\n              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true)\n            } else {\n              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2)\n              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3)\n            }\n          } else {\n            this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true)\n            if (round !== 0) {\n              this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true)\n              this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true)\n              this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true)\n              this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true)\n              this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true)\n              this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true)\n              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true)\n            } else {\n              this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true)\n              this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true)\n              this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true)\n            }\n          }\n        },\n        getValue: function () {\n          if (this.elem.globalData.frameId === this.frameId) {\n            return\n          }\n          this.frameId = this.elem.globalData.frameId\n          this.iterateDynamicProperties()\n          if (this._mdf) {\n            this.convertRectToPath()\n          }\n        },\n        reset: resetShape,\n      }\n      extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory)\n\n      return RectShapePropertyFactory\n    })()\n\n    function getShapeProp(elem, data, type) {\n      var prop\n      if (type === 3 || type === 4) {\n        var dataProp = type === 3 ? data.pt : data.ks\n        var keys = dataProp.k\n        if (keys.length) {\n          prop = new KeyframedShapeProperty(elem, data, type)\n        } else {\n          prop = new ShapeProperty(elem, data, type)\n        }\n      } else if (type === 5) {\n        prop = new RectShapeProperty(elem, data)\n      } else if (type === 6) {\n        prop = new EllShapeProperty(elem, data)\n      } else if (type === 7) {\n        prop = new StarShapeProperty(elem, data)\n      }\n      if (prop.k) {\n        elem.addDynamicProperty(prop)\n      }\n      return prop\n    }\n\n    function getConstructorFunction() {\n      return ShapeProperty\n    }\n\n    function getKeyframedConstructorFunction() {\n      return KeyframedShapeProperty\n    }\n\n    var ob = {}\n    ob.getShapeProp = getShapeProp\n    ob.getConstructorFunction = getConstructorFunction\n    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction\n    return ob\n  })()\n\n  /*!\n Transformation Matrix v2.0\n (c) Epistemex 2014-2015\n www.epistemex.com\n By Ken Fyrstenberg\n Contributions by leeoniya.\n License: MIT, header required.\n */\n\n  /**\n   * 2D transformation matrix object initialized with identity matrix.\n   *\n   * The matrix can synchronize a canvas context by supplying the context\n   * as an argument, or later apply current absolute transform to an\n   * existing context.\n   *\n   * All values are handled as floating point values.\n   *\n   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\n   * @prop {number} a - scale x\n   * @prop {number} b - shear y\n   * @prop {number} c - shear x\n   * @prop {number} d - scale y\n   * @prop {number} e - translate x\n   * @prop {number} f - translate y\n   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\n   * @constructor\n   */\n\n  const Matrix = (function () {\n    var _cos = Math.cos\n    var _sin = Math.sin\n    var _tan = Math.tan\n    var _rnd = Math.round\n\n    function reset() {\n      this.props[0] = 1\n      this.props[1] = 0\n      this.props[2] = 0\n      this.props[3] = 0\n      this.props[4] = 0\n      this.props[5] = 1\n      this.props[6] = 0\n      this.props[7] = 0\n      this.props[8] = 0\n      this.props[9] = 0\n      this.props[10] = 1\n      this.props[11] = 0\n      this.props[12] = 0\n      this.props[13] = 0\n      this.props[14] = 0\n      this.props[15] = 1\n      return this\n    }\n\n    function rotate(angle) {\n      if (angle === 0) {\n        return this\n      }\n      var mCos = _cos(angle)\n      var mSin = _sin(angle)\n      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n    }\n\n    function rotateX(angle) {\n      if (angle === 0) {\n        return this\n      }\n      var mCos = _cos(angle)\n      var mSin = _sin(angle)\n      return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1)\n    }\n\n    function rotateY(angle) {\n      if (angle === 0) {\n        return this\n      }\n      var mCos = _cos(angle)\n      var mSin = _sin(angle)\n      return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1)\n    }\n\n    function rotateZ(angle) {\n      if (angle === 0) {\n        return this\n      }\n      var mCos = _cos(angle)\n      var mSin = _sin(angle)\n      return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n    }\n\n    function shear(sx, sy) {\n      return this._t(1, sy, sx, 1, 0, 0)\n    }\n\n    function skew(ax, ay) {\n      return this.shear(_tan(ax), _tan(ay))\n    }\n\n    function skewFromAxis(ax, angle) {\n      var mCos = _cos(angle)\n      var mSin = _sin(angle)\n      return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n        ._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n        ._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n      // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\n    }\n\n    function scale(sx, sy, sz) {\n      if (!sz && sz !== 0) {\n        sz = 1\n      }\n      if (sx === 1 && sy === 1 && sz === 1) {\n        return this\n      }\n      return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1)\n    }\n\n    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n      this.props[0] = a\n      this.props[1] = b\n      this.props[2] = c\n      this.props[3] = d\n      this.props[4] = e\n      this.props[5] = f\n      this.props[6] = g\n      this.props[7] = h\n      this.props[8] = i\n      this.props[9] = j\n      this.props[10] = k\n      this.props[11] = l\n      this.props[12] = m\n      this.props[13] = n\n      this.props[14] = o\n      this.props[15] = p\n      return this\n    }\n\n    function translate(tx, ty, tz) {\n      tz = tz || 0\n      if (tx !== 0 || ty !== 0 || tz !== 0) {\n        return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1)\n      }\n      return this\n    }\n\n    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\n      var _p = this.props\n\n      if (\n        a2 === 1 &&\n        b2 === 0 &&\n        c2 === 0 &&\n        d2 === 0 &&\n        e2 === 0 &&\n        f2 === 1 &&\n        g2 === 0 &&\n        h2 === 0 &&\n        i2 === 0 &&\n        j2 === 0 &&\n        k2 === 1 &&\n        l2 === 0\n      ) {\n        // NOTE: commenting this condition because TurboFan deoptimizes code when present\n        // if(m2 !== 0 || n2 !== 0 || o2 !== 0){\n        _p[12] = _p[12] * a2 + _p[15] * m2\n        _p[13] = _p[13] * f2 + _p[15] * n2\n        _p[14] = _p[14] * k2 + _p[15] * o2\n        _p[15] *= p2\n        // }\n        this._identityCalculated = false\n        return this\n      }\n\n      var a1 = _p[0]\n      var b1 = _p[1]\n      var c1 = _p[2]\n      var d1 = _p[3]\n      var e1 = _p[4]\n      var f1 = _p[5]\n      var g1 = _p[6]\n      var h1 = _p[7]\n      var i1 = _p[8]\n      var j1 = _p[9]\n      var k1 = _p[10]\n      var l1 = _p[11]\n      var m1 = _p[12]\n      var n1 = _p[13]\n      var o1 = _p[14]\n      var p1 = _p[15]\n\n      /* matrix order (canvas compatible):\n       * ace\n       * bdf\n       * 001\n       */\n      _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2\n      _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2\n      _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2\n      _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2\n\n      _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2\n      _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2\n      _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2\n      _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2\n\n      _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2\n      _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2\n      _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2\n      _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2\n\n      _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2\n      _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2\n      _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2\n      _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2\n\n      this._identityCalculated = false\n      return this\n    }\n\n    function isIdentity() {\n      if (!this._identityCalculated) {\n        this._identity = !(\n          this.props[0] !== 1 ||\n          this.props[1] !== 0 ||\n          this.props[2] !== 0 ||\n          this.props[3] !== 0 ||\n          this.props[4] !== 0 ||\n          this.props[5] !== 1 ||\n          this.props[6] !== 0 ||\n          this.props[7] !== 0 ||\n          this.props[8] !== 0 ||\n          this.props[9] !== 0 ||\n          this.props[10] !== 1 ||\n          this.props[11] !== 0 ||\n          this.props[12] !== 0 ||\n          this.props[13] !== 0 ||\n          this.props[14] !== 0 ||\n          this.props[15] !== 1\n        )\n        this._identityCalculated = true\n      }\n      return this._identity\n    }\n\n    function equals(matr) {\n      var i = 0\n      while (i < 16) {\n        if (matr.props[i] !== this.props[i]) {\n          return false\n        }\n        i += 1\n      }\n      return true\n    }\n\n    function clone(matr) {\n      var i\n      for (i = 0; i < 16; i += 1) {\n        matr.props[i] = this.props[i]\n      }\n      return matr\n    }\n\n    function cloneFromProps(props) {\n      var i\n      for (i = 0; i < 16; i += 1) {\n        this.props[i] = props[i]\n      }\n    }\n\n    function applyToPoint(x, y, z) {\n      return {\n        x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n        y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n        z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],\n      }\n      /* return {\n         x: x * me.a + y * me.c + me.e,\n         y: x * me.b + y * me.d + me.f\n         }; */\n    }\n    function applyToX(x, y, z) {\n      return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12]\n    }\n    function applyToY(x, y, z) {\n      return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13]\n    }\n    function applyToZ(x, y, z) {\n      return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n    }\n\n    function getInverseMatrix() {\n      var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4]\n      var a = this.props[5] / determinant\n      var b = -this.props[1] / determinant\n      var c = -this.props[4] / determinant\n      var d = this.props[0] / determinant\n      var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant\n      var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant\n      var inverseMatrix = new Matrix()\n      inverseMatrix.props[0] = a\n      inverseMatrix.props[1] = b\n      inverseMatrix.props[4] = c\n      inverseMatrix.props[5] = d\n      inverseMatrix.props[12] = e\n      inverseMatrix.props[13] = f\n      return inverseMatrix\n    }\n\n    function inversePoint(pt) {\n      var inverseMatrix = this.getInverseMatrix()\n      return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0)\n    }\n\n    function inversePoints(pts) {\n      var i\n      var len = pts.length\n      var retPts = []\n      for (i = 0; i < len; i += 1) {\n        retPts[i] = inversePoint(pts[i])\n      }\n      return retPts\n    }\n\n    function applyToTriplePoints(pt1, pt2, pt3) {\n      var arr = createTypedArray('float32', 6)\n      if (this.isIdentity()) {\n        arr[0] = pt1[0]\n        arr[1] = pt1[1]\n        arr[2] = pt2[0]\n        arr[3] = pt2[1]\n        arr[4] = pt3[0]\n        arr[5] = pt3[1]\n      } else {\n        var p0 = this.props[0]\n        var p1 = this.props[1]\n        var p4 = this.props[4]\n        var p5 = this.props[5]\n        var p12 = this.props[12]\n        var p13 = this.props[13]\n        arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12\n        arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13\n        arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12\n        arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13\n        arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12\n        arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13\n      }\n      return arr\n    }\n\n    function applyToPointArray(x, y, z) {\n      var arr\n      if (this.isIdentity()) {\n        arr = [x, y, z]\n      } else {\n        arr = [\n          x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n          x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n          x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],\n        ]\n      }\n      return arr\n    }\n\n    function applyToPointStringified(x, y) {\n      if (this.isIdentity()) {\n        return x + ',' + y\n      }\n      var _p = this.props\n      return (\n        Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 +\n        ',' +\n        Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100\n      )\n    }\n\n    function toCSS() {\n      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n      /* if(this.isIdentity()) {\n            return '';\n        } */\n      var i = 0\n      var props = this.props\n      var cssValue = 'matrix3d('\n      var v = 10000\n      while (i < 16) {\n        cssValue += _rnd(props[i] * v) / v\n        cssValue += i === 15 ? ')' : ','\n        i += 1\n      }\n      return cssValue\n    }\n\n    function roundMatrixProperty(val) {\n      var v = 10000\n      if ((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {\n        return _rnd(val * v) / v\n      }\n      return val\n    }\n\n    function to2dCSS() {\n      // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n      /* if(this.isIdentity()) {\n            return '';\n        } */\n      var props = this.props\n      var _a = roundMatrixProperty(props[0])\n      var _b = roundMatrixProperty(props[1])\n      var _c = roundMatrixProperty(props[4])\n      var _d = roundMatrixProperty(props[5])\n      var _e = roundMatrixProperty(props[12])\n      var _f = roundMatrixProperty(props[13])\n      return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')'\n    }\n\n    return function () {\n      this.reset = reset\n      this.rotate = rotate\n      this.rotateX = rotateX\n      this.rotateY = rotateY\n      this.rotateZ = rotateZ\n      this.skew = skew\n      this.skewFromAxis = skewFromAxis\n      this.shear = shear\n      this.scale = scale\n      this.setTransform = setTransform\n      this.translate = translate\n      this.transform = transform\n      this.applyToPoint = applyToPoint\n      this.applyToX = applyToX\n      this.applyToY = applyToY\n      this.applyToZ = applyToZ\n      this.applyToPointArray = applyToPointArray\n      this.applyToTriplePoints = applyToTriplePoints\n      this.applyToPointStringified = applyToPointStringified\n      this.toCSS = toCSS\n      this.to2dCSS = to2dCSS\n      this.clone = clone\n      this.cloneFromProps = cloneFromProps\n      this.equals = equals\n      this.inversePoints = inversePoints\n      this.inversePoint = inversePoint\n      this.getInverseMatrix = getInverseMatrix\n      this._t = this.transform\n      this.isIdentity = isIdentity\n      this._identity = true\n      this._identityCalculated = false\n\n      this.props = createTypedArray('float32', 16)\n      this.reset()\n    }\n  })()\n\n  const lottie = {}\n  var standalone = '__[STANDALONE]__'\n  var animationData = '__[ANIMATIONDATA]__'\n  var renderer = ''\n\n  function setLocation(href) {\n    setLocationHref(href)\n  }\n\n  function searchAnimations() {\n    if (standalone === true) {\n      animationManager.searchAnimations(animationData, standalone, renderer)\n    } else {\n      animationManager.searchAnimations()\n    }\n  }\n\n  function setSubframeRendering(flag) {\n    setSubframeEnabled(flag)\n  }\n\n  function setPrefix(prefix) {\n    setIdPrefix(prefix)\n  }\n\n  function loadAnimation(params) {\n    if (standalone === true) {\n      params.animationData = JSON.parse(animationData)\n    }\n    return animationManager.loadAnimation(params)\n  }\n\n  function setQuality(value) {\n    if (typeof value === 'string') {\n      switch (value) {\n        case 'high':\n          setDefaultCurveSegments(200)\n          break\n        default:\n        case 'medium':\n          setDefaultCurveSegments(50)\n          break\n        case 'low':\n          setDefaultCurveSegments(10)\n          break\n      }\n    } else if (!isNaN(value) && value > 1) {\n      setDefaultCurveSegments(value)\n    }\n    if (getDefaultCurveSegments() >= 50) {\n      roundValues(false)\n    } else {\n      roundValues(true)\n    }\n  }\n\n  function inBrowser() {\n    return typeof navigator !== 'undefined'\n  }\n\n  function installPlugin(type, plugin) {\n    if (type === 'expressions') {\n      setExpressionsPlugin(plugin)\n    }\n  }\n\n  function getFactory(name) {\n    switch (name) {\n      case 'propertyFactory':\n        return PropertyFactory\n      case 'shapePropertyFactory':\n        return ShapePropertyFactory\n      case 'matrix':\n        return Matrix\n      default:\n        return null\n    }\n  }\n\n  lottie.play = animationManager.play\n  lottie.pause = animationManager.pause\n  lottie.setLocationHref = setLocation\n  lottie.togglePause = animationManager.togglePause\n  lottie.setSpeed = animationManager.setSpeed\n  lottie.setDirection = animationManager.setDirection\n  lottie.stop = animationManager.stop\n  lottie.searchAnimations = searchAnimations\n  lottie.registerAnimation = animationManager.registerAnimation\n  lottie.loadAnimation = loadAnimation\n  lottie.setSubframeRendering = setSubframeRendering\n  lottie.resize = animationManager.resize\n  // lottie.start = start;\n  lottie.goToAndStop = animationManager.goToAndStop\n  lottie.destroy = animationManager.destroy\n  lottie.setQuality = setQuality\n  lottie.inBrowser = inBrowser\n  lottie.installPlugin = installPlugin\n  lottie.freeze = animationManager.freeze\n  lottie.unfreeze = animationManager.unfreeze\n  lottie.setVolume = animationManager.setVolume\n  lottie.mute = animationManager.mute\n  lottie.unmute = animationManager.unmute\n  lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations\n  lottie.useWebWorker = setWebWorker\n  lottie.setIDPrefix = setPrefix\n  lottie.__getFactory = getFactory\n  lottie.version = '[[BM_VERSION]]'\n\n  function checkReady() {\n    if (document.readyState === 'complete') {\n      clearInterval(readyStateCheckInterval)\n      searchAnimations()\n    }\n  }\n\n  function getQueryVariable(variable) {\n    var vars = queryString.split('&')\n    for (var i = 0; i < vars.length; i += 1) {\n      var pair = vars[i].split('=')\n      if (decodeURIComponent(pair[0]) == variable) {\n        // eslint-disable-line eqeqeq\n        return decodeURIComponent(pair[1])\n      }\n    }\n    return null\n  }\n  var queryString = ''\n  if (standalone) {\n    var scripts = document.getElementsByTagName('script')\n    var index = scripts.length - 1\n    var myScript = scripts[index] || {\n      src: '',\n    }\n    queryString = myScript.src ? myScript.src.replace(/^[^\\?]+\\??/, '') : '' // eslint-disable-line no-useless-escape\n    renderer = getQueryVariable('renderer')\n  }\n  var readyStateCheckInterval = setInterval(checkReady, 100)\n\n  // this adds bodymovin to the window object for backwards compatibility\n  try {\n    if (\n      !(typeof exports === 'object' && typeof module !== 'undefined') &&\n      !(typeof define === 'function' && define.amd) // eslint-disable-line no-undef\n    ) {\n      window.bodymovin = lottie\n    }\n  } catch (err) {\n    //\n  }\n\n  const ShapeModifiers = (function () {\n    var ob = {}\n    var modifiers = {}\n    ob.registerModifier = registerModifier\n    ob.getModifier = getModifier\n\n    function registerModifier(nm, factory) {\n      if (!modifiers[nm]) {\n        modifiers[nm] = factory\n      }\n    }\n\n    function getModifier(nm, elem, data) {\n      return new modifiers[nm](elem, data)\n    }\n\n    return ob\n  })()\n\n  function ShapeModifier() {}\n  ShapeModifier.prototype.initModifierProperties = function () {}\n  ShapeModifier.prototype.addShapeToModifier = function () {}\n  ShapeModifier.prototype.addShape = function (data) {\n    if (!this.closed) {\n      // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.\n      data.sh.container.addDynamicProperty(data.sh)\n      var shapeData = { shape: data.sh, data: data, localShapeCollection: shapeCollectionPool.newShapeCollection() }\n      this.shapes.push(shapeData)\n      this.addShapeToModifier(shapeData)\n      if (this._isAnimated) {\n        data.setAsAnimated()\n      }\n    }\n  }\n  ShapeModifier.prototype.init = function (elem, data) {\n    this.shapes = []\n    this.elem = elem\n    this.initDynamicPropertyContainer(elem)\n    this.initModifierProperties(elem, data)\n    this.frameId = initialDefaultFrame\n    this.closed = false\n    this.k = false\n    if (this.dynamicProperties.length) {\n      this.k = true\n    } else {\n      this.getValue(true)\n    }\n  }\n  ShapeModifier.prototype.processKeys = function () {\n    if (this.elem.globalData.frameId === this.frameId) {\n      return\n    }\n    this.frameId = this.elem.globalData.frameId\n    this.iterateDynamicProperties()\n  }\n\n  extendPrototype([DynamicPropertyContainer], ShapeModifier)\n\n  function TrimModifier() {}\n  extendPrototype([ShapeModifier], TrimModifier)\n  TrimModifier.prototype.initModifierProperties = function (elem, data) {\n    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this)\n    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this)\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this)\n    this.sValue = 0\n    this.eValue = 0\n    this.getValue = this.processKeys\n    this.m = data.m\n    this._isAnimated =\n      !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length\n  }\n\n  TrimModifier.prototype.addShapeToModifier = function (shapeData) {\n    shapeData.pathsData = []\n  }\n\n  TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {\n    var segments = []\n    if (e <= 1) {\n      segments.push({\n        s: s,\n        e: e,\n      })\n    } else if (s >= 1) {\n      segments.push({\n        s: s - 1,\n        e: e - 1,\n      })\n    } else {\n      segments.push({\n        s: s,\n        e: 1,\n      })\n      segments.push({\n        s: 0,\n        e: e - 1,\n      })\n    }\n    var shapeSegments = []\n    var i\n    var len = segments.length\n    var segmentOb\n    for (i = 0; i < len; i += 1) {\n      segmentOb = segments[i]\n      if (\n        !(\n          segmentOb.e * totalModifierLength < addedLength ||\n          segmentOb.s * totalModifierLength > addedLength + shapeLength\n        )\n      ) {\n        var shapeS\n        var shapeE\n        if (segmentOb.s * totalModifierLength <= addedLength) {\n          shapeS = 0\n        } else {\n          shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength\n        }\n        if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\n          shapeE = 1\n        } else {\n          shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength\n        }\n        shapeSegments.push([shapeS, shapeE])\n      }\n    }\n    if (!shapeSegments.length) {\n      shapeSegments.push([0, 0])\n    }\n    return shapeSegments\n  }\n\n  TrimModifier.prototype.releasePathsData = function (pathsData) {\n    var i\n    var len = pathsData.length\n    for (i = 0; i < len; i += 1) {\n      segmentsLengthPool.release(pathsData[i])\n    }\n    pathsData.length = 0\n    return pathsData\n  }\n\n  TrimModifier.prototype.processShapes = function (_isFirstFrame) {\n    var s\n    var e\n    if (this._mdf || _isFirstFrame) {\n      var o = (this.o.v % 360) / 360\n      if (o < 0) {\n        o += 1\n      }\n      if (this.s.v > 1) {\n        s = 1 + o\n      } else if (this.s.v < 0) {\n        s = 0 + o\n      } else {\n        s = this.s.v + o\n      }\n      if (this.e.v > 1) {\n        e = 1 + o\n      } else if (this.e.v < 0) {\n        e = 0 + o\n      } else {\n        e = this.e.v + o\n      }\n\n      if (s > e) {\n        var _s = s\n        s = e\n        e = _s\n      }\n      s = Math.round(s * 10000) * 0.0001\n      e = Math.round(e * 10000) * 0.0001\n      this.sValue = s\n      this.eValue = e\n    } else {\n      s = this.sValue\n      e = this.eValue\n    }\n    var shapePaths\n    var i\n    var len = this.shapes.length\n    var j\n    var jLen\n    var pathsData\n    var pathData\n    var totalShapeLength\n    var totalModifierLength = 0\n\n    if (e === s) {\n      for (i = 0; i < len; i += 1) {\n        this.shapes[i].localShapeCollection.releaseShapes()\n        this.shapes[i].shape._mdf = true\n        this.shapes[i].shape.paths = this.shapes[i].localShapeCollection\n        if (this._mdf) {\n          this.shapes[i].pathsData.length = 0\n        }\n      }\n    } else if (!((e === 1 && s === 0) || (e === 0 && s === 1))) {\n      var segments = []\n      var shapeData\n      var localShapeCollection\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i]\n        // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\n        if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\n          shapeData.shape.paths = shapeData.localShapeCollection\n        } else {\n          shapePaths = shapeData.shape.paths\n          jLen = shapePaths._length\n          totalShapeLength = 0\n          if (!shapeData.shape._mdf && shapeData.pathsData.length) {\n            totalShapeLength = shapeData.totalShapeLength\n          } else {\n            pathsData = this.releasePathsData(shapeData.pathsData)\n            for (j = 0; j < jLen; j += 1) {\n              pathData = bez.getSegmentsLength(shapePaths.shapes[j])\n              pathsData.push(pathData)\n              totalShapeLength += pathData.totalLength\n            }\n            shapeData.totalShapeLength = totalShapeLength\n            shapeData.pathsData = pathsData\n          }\n\n          totalModifierLength += totalShapeLength\n          shapeData.shape._mdf = true\n        }\n      }\n      var shapeS = s\n      var shapeE = e\n      var addedLength = 0\n      var edges\n      for (i = len - 1; i >= 0; i -= 1) {\n        shapeData = this.shapes[i]\n        if (shapeData.shape._mdf) {\n          localShapeCollection = shapeData.localShapeCollection\n          localShapeCollection.releaseShapes()\n          // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\n          if (this.m === 2 && len > 1) {\n            edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength)\n            addedLength += shapeData.totalShapeLength\n          } else {\n            edges = [[shapeS, shapeE]]\n          }\n          jLen = edges.length\n          for (j = 0; j < jLen; j += 1) {\n            shapeS = edges[j][0]\n            shapeE = edges[j][1]\n            segments.length = 0\n            if (shapeE <= 1) {\n              segments.push({\n                s: shapeData.totalShapeLength * shapeS,\n                e: shapeData.totalShapeLength * shapeE,\n              })\n            } else if (shapeS >= 1) {\n              segments.push({\n                s: shapeData.totalShapeLength * (shapeS - 1),\n                e: shapeData.totalShapeLength * (shapeE - 1),\n              })\n            } else {\n              segments.push({\n                s: shapeData.totalShapeLength * shapeS,\n                e: shapeData.totalShapeLength,\n              })\n              segments.push({\n                s: 0,\n                e: shapeData.totalShapeLength * (shapeE - 1),\n              })\n            }\n            var newShapesData = this.addShapes(shapeData, segments[0])\n            if (segments[0].s !== segments[0].e) {\n              if (segments.length > 1) {\n                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1]\n                if (lastShapeInCollection.c) {\n                  var lastShape = newShapesData.pop()\n                  this.addPaths(newShapesData, localShapeCollection)\n                  newShapesData = this.addShapes(shapeData, segments[1], lastShape)\n                } else {\n                  this.addPaths(newShapesData, localShapeCollection)\n                  newShapesData = this.addShapes(shapeData, segments[1])\n                }\n              }\n              this.addPaths(newShapesData, localShapeCollection)\n            }\n          }\n          shapeData.shape.paths = localShapeCollection\n        }\n      }\n    } else if (this._mdf) {\n      for (i = 0; i < len; i += 1) {\n        // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\n        // Don't remove this even if it's losing cached info.\n        this.shapes[i].pathsData.length = 0\n        this.shapes[i].shape._mdf = true\n      }\n    }\n  }\n\n  TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {\n    var i\n    var len = newPaths.length\n    for (i = 0; i < len; i += 1) {\n      localShapeCollection.addShape(newPaths[i])\n    }\n  }\n\n  TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\n    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos)\n    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1)\n    if (newShape) {\n      shapePath.setXYAt(pt1[0], pt1[1], 'v', pos)\n    }\n    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1)\n  }\n\n  TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {\n    shapePath.setXYAt(points[1], points[5], 'o', pos)\n    shapePath.setXYAt(points[2], points[6], 'i', pos + 1)\n    if (newShape) {\n      shapePath.setXYAt(points[0], points[4], 'v', pos)\n    }\n    shapePath.setXYAt(points[3], points[7], 'v', pos + 1)\n  }\n\n  TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {\n    var pathsData = shapeData.pathsData\n    var shapePaths = shapeData.shape.paths.shapes\n    var i\n    var len = shapeData.shape.paths._length\n    var j\n    var jLen\n    var addedLength = 0\n    var currentLengthData\n    var segmentCount\n    var lengths\n    var segment\n    var shapes = []\n    var initPos\n    var newShape = true\n    if (!shapePath) {\n      shapePath = shapePool.newElement()\n      segmentCount = 0\n      initPos = 0\n    } else {\n      segmentCount = shapePath._length\n      initPos = shapePath._length\n    }\n    shapes.push(shapePath)\n    for (i = 0; i < len; i += 1) {\n      lengths = pathsData[i].lengths\n      shapePath.c = shapePaths[i].c\n      jLen = shapePaths[i].c ? lengths.length : lengths.length + 1\n      for (j = 1; j < jLen; j += 1) {\n        currentLengthData = lengths[j - 1]\n        if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\n          addedLength += currentLengthData.addedLength\n          shapePath.c = false\n        } else if (addedLength > shapeSegment.e) {\n          shapePath.c = false\n          break\n        } else {\n          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\n            this.addSegment(\n              shapePaths[i].v[j - 1],\n              shapePaths[i].o[j - 1],\n              shapePaths[i].i[j],\n              shapePaths[i].v[j],\n              shapePath,\n              segmentCount,\n              newShape,\n            )\n            newShape = false\n          } else {\n            segment = bez.getNewSegment(\n              shapePaths[i].v[j - 1],\n              shapePaths[i].v[j],\n              shapePaths[i].o[j - 1],\n              shapePaths[i].i[j],\n              (shapeSegment.s - addedLength) / currentLengthData.addedLength,\n              (shapeSegment.e - addedLength) / currentLengthData.addedLength,\n              lengths[j - 1],\n            )\n            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape)\n            // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n            newShape = false\n            shapePath.c = false\n          }\n          addedLength += currentLengthData.addedLength\n          segmentCount += 1\n        }\n      }\n      if (shapePaths[i].c && lengths.length) {\n        currentLengthData = lengths[j - 1]\n        if (addedLength <= shapeSegment.e) {\n          var segmentLength = lengths[j - 1].addedLength\n          if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\n            this.addSegment(\n              shapePaths[i].v[j - 1],\n              shapePaths[i].o[j - 1],\n              shapePaths[i].i[0],\n              shapePaths[i].v[0],\n              shapePath,\n              segmentCount,\n              newShape,\n            )\n            newShape = false\n          } else {\n            segment = bez.getNewSegment(\n              shapePaths[i].v[j - 1],\n              shapePaths[i].v[0],\n              shapePaths[i].o[j - 1],\n              shapePaths[i].i[0],\n              (shapeSegment.s - addedLength) / segmentLength,\n              (shapeSegment.e - addedLength) / segmentLength,\n              lengths[j - 1],\n            )\n            this.addSegmentFromArray(segment, shapePath, segmentCount, newShape)\n            // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n            newShape = false\n            shapePath.c = false\n          }\n        } else {\n          shapePath.c = false\n        }\n        addedLength += currentLengthData.addedLength\n        segmentCount += 1\n      }\n      if (shapePath._length) {\n        shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos)\n        shapePath.setXYAt(\n          shapePath.v[shapePath._length - 1][0],\n          shapePath.v[shapePath._length - 1][1],\n          'o',\n          shapePath._length - 1,\n        )\n      }\n      if (addedLength > shapeSegment.e) {\n        break\n      }\n      if (i < len - 1) {\n        shapePath = shapePool.newElement()\n        newShape = true\n        shapes.push(shapePath)\n        segmentCount = 0\n      }\n    }\n    return shapes\n  }\n\n  function PuckerAndBloatModifier() {}\n  extendPrototype([ShapeModifier], PuckerAndBloatModifier)\n  PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys\n    this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this)\n    this._isAnimated = !!this.amount.effectsSequence.length\n  }\n\n  PuckerAndBloatModifier.prototype.processPath = function (path, amount) {\n    var percent = amount / 100\n    var centerPoint = [0, 0]\n    var pathLength = path._length\n    var i = 0\n    for (i = 0; i < pathLength; i += 1) {\n      centerPoint[0] += path.v[i][0]\n      centerPoint[1] += path.v[i][1]\n    }\n    centerPoint[0] /= pathLength\n    centerPoint[1] /= pathLength\n    var clonedPath = shapePool.newElement()\n    clonedPath.c = path.c\n    var vX\n    var vY\n    var oX\n    var oY\n    var iX\n    var iY\n    for (i = 0; i < pathLength; i += 1) {\n      vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent\n      vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent\n      oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent\n      oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent\n      iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent\n      iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent\n      clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i)\n    }\n    return clonedPath\n  }\n\n  PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths\n    var i\n    var len = this.shapes.length\n    var j\n    var jLen\n    var amount = this.amount.v\n\n    if (amount !== 0) {\n      var shapeData\n      var localShapeCollection\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i]\n        localShapeCollection = shapeData.localShapeCollection\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes()\n          shapeData.shape._mdf = true\n          shapePaths = shapeData.shape.paths.shapes\n          jLen = shapeData.shape.paths._length\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], amount))\n          }\n        }\n        shapeData.shape.paths = shapeData.localShapeCollection\n      }\n    }\n    if (!this.dynamicProperties.length) {\n      this._mdf = false\n    }\n  }\n\n  const TransformPropertyFactory = (function () {\n    var defaultVector = [0, 0]\n\n    function applyToMatrix(mat) {\n      var _mdf = this._mdf\n      this.iterateDynamicProperties()\n      this._mdf = this._mdf || _mdf\n      if (this.a) {\n        mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2])\n      }\n      if (this.s) {\n        mat.scale(this.s.v[0], this.s.v[1], this.s.v[2])\n      }\n      if (this.sk) {\n        mat.skewFromAxis(-this.sk.v, this.sa.v)\n      }\n      if (this.r) {\n        mat.rotate(-this.r.v)\n      } else {\n        mat\n          .rotateZ(-this.rz.v)\n          .rotateY(this.ry.v)\n          .rotateX(this.rx.v)\n          .rotateZ(-this.or.v[2])\n          .rotateY(this.or.v[1])\n          .rotateX(this.or.v[0])\n      }\n      if (this.data.p.s) {\n        if (this.data.p.z) {\n          mat.translate(this.px.v, this.py.v, -this.pz.v)\n        } else {\n          mat.translate(this.px.v, this.py.v, 0)\n        }\n      } else {\n        mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2])\n      }\n    }\n    function processKeys(forceRender) {\n      if (this.elem.globalData.frameId === this.frameId) {\n        return\n      }\n      if (this._isDirty) {\n        this.precalculateMatrix()\n        this._isDirty = false\n      }\n\n      this.iterateDynamicProperties()\n\n      if (this._mdf || forceRender) {\n        var frameRate\n        this.v.cloneFromProps(this.pre.props)\n        if (this.appliedTransformations < 1) {\n          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2])\n        }\n        if (this.appliedTransformations < 2) {\n          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2])\n        }\n        if (this.sk && this.appliedTransformations < 3) {\n          this.v.skewFromAxis(-this.sk.v, this.sa.v)\n        }\n        if (this.r && this.appliedTransformations < 4) {\n          this.v.rotate(-this.r.v)\n        } else if (!this.r && this.appliedTransformations < 4) {\n          this.v\n            .rotateZ(-this.rz.v)\n            .rotateY(this.ry.v)\n            .rotateX(this.rx.v)\n            .rotateZ(-this.or.v[2])\n            .rotateY(this.or.v[1])\n            .rotateX(this.or.v[0])\n        }\n        if (this.autoOriented) {\n          var v1\n          var v2\n          frameRate = this.elem.globalData.frameRate\n          if (this.p && this.p.keyframes && this.p.getValueAtTime) {\n            if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {\n              v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0)\n              v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0)\n            } else if (\n              this.p._caching.lastFrame + this.p.offsetTime >=\n              this.p.keyframes[this.p.keyframes.length - 1].t\n            ) {\n              v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0)\n              v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0)\n            } else {\n              v1 = this.p.pv\n              v2 = this.p.getValueAtTime(\n                (this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate,\n                this.p.offsetTime,\n              )\n            }\n          } else if (\n            this.px &&\n            this.px.keyframes &&\n            this.py.keyframes &&\n            this.px.getValueAtTime &&\n            this.py.getValueAtTime\n          ) {\n            v1 = []\n            v2 = []\n            var px = this.px\n            var py = this.py\n            if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {\n              v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0)\n              v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0)\n              v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0)\n              v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0)\n            } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\n              v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0)\n              v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0)\n              v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0)\n              v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0)\n            } else {\n              v1 = [px.pv, py.pv]\n              v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime)\n              v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime)\n            }\n          } else {\n            v2 = defaultVector\n            v1 = v2\n          }\n          this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]))\n        }\n        if (this.data.p && this.data.p.s) {\n          if (this.data.p.z) {\n            this.v.translate(this.px.v, this.py.v, -this.pz.v)\n          } else {\n            this.v.translate(this.px.v, this.py.v, 0)\n          }\n        } else {\n          this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])\n        }\n      }\n      this.frameId = this.elem.globalData.frameId\n    }\n\n    function precalculateMatrix() {\n      if (!this.a.k) {\n        this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2])\n        this.appliedTransformations = 1\n      } else {\n        return\n      }\n      if (!this.s.effectsSequence.length) {\n        this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2])\n        this.appliedTransformations = 2\n      } else {\n        return\n      }\n      if (this.sk) {\n        if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\n          this.pre.skewFromAxis(-this.sk.v, this.sa.v)\n          this.appliedTransformations = 3\n        } else {\n          return\n        }\n      }\n      if (this.r) {\n        if (!this.r.effectsSequence.length) {\n          this.pre.rotate(-this.r.v)\n          this.appliedTransformations = 4\n        }\n      } else if (\n        !this.rz.effectsSequence.length &&\n        !this.ry.effectsSequence.length &&\n        !this.rx.effectsSequence.length &&\n        !this.or.effectsSequence.length\n      ) {\n        this.pre\n          .rotateZ(-this.rz.v)\n          .rotateY(this.ry.v)\n          .rotateX(this.rx.v)\n          .rotateZ(-this.or.v[2])\n          .rotateY(this.or.v[1])\n          .rotateX(this.or.v[0])\n        this.appliedTransformations = 4\n      }\n    }\n\n    function autoOrient() {\n      //\n      // var prevP = this.getValueAtTime();\n    }\n\n    function addDynamicProperty(prop) {\n      this._addDynamicProperty(prop)\n      this.elem.addDynamicProperty(prop)\n      this._isDirty = true\n    }\n\n    function TransformProperty(elem, data, container) {\n      this.elem = elem\n      this.frameId = -1\n      this.propType = 'transform'\n      this.data = data\n      this.v = new Matrix()\n      // Precalculated matrix with non animated properties\n      this.pre = new Matrix()\n      this.appliedTransformations = 0\n      this.initDynamicPropertyContainer(container || elem)\n      if (data.p && data.p.s) {\n        this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this)\n        this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this)\n        if (data.p.z) {\n          this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this)\n        }\n      } else {\n        this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this)\n      }\n      if (data.rx) {\n        this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this)\n        this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this)\n        this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this)\n        if (data.or.k[0].ti) {\n          var i\n          var len = data.or.k.length\n          for (i = 0; i < len; i += 1) {\n            data.or.k[i].to = null\n            data.or.k[i].ti = null\n          }\n        }\n        this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this)\n        // sh Indicates it needs to be capped between -180 and 180\n        this.or.sh = true\n      } else {\n        this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this)\n      }\n      if (data.sk) {\n        this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this)\n        this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this)\n      }\n      this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this)\n      this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this)\n      // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\n      if (data.o) {\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem)\n      } else {\n        this.o = { _mdf: false, v: 1 }\n      }\n      this._isDirty = true\n      if (!this.dynamicProperties.length) {\n        this.getValue(true)\n      }\n    }\n\n    TransformProperty.prototype = {\n      applyToMatrix: applyToMatrix,\n      getValue: processKeys,\n      precalculateMatrix: precalculateMatrix,\n      autoOrient: autoOrient,\n    }\n\n    extendPrototype([DynamicPropertyContainer], TransformProperty)\n    TransformProperty.prototype.addDynamicProperty = addDynamicProperty\n    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty\n\n    function getTransformProperty(elem, data, container) {\n      return new TransformProperty(elem, data, container)\n    }\n\n    return {\n      getTransformProperty: getTransformProperty,\n    }\n  })()\n\n  function RepeaterModifier() {}\n  extendPrototype([ShapeModifier], RepeaterModifier)\n\n  RepeaterModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys\n    this.c = PropertyFactory.getProp(elem, data.c, 0, null, this)\n    this.o = PropertyFactory.getProp(elem, data.o, 0, null, this)\n    this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this)\n    this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this)\n    this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this)\n    this.data = data\n    if (!this.dynamicProperties.length) {\n      this.getValue(true)\n    }\n    this._isAnimated = !!this.dynamicProperties.length\n    this.pMatrix = new Matrix()\n    this.rMatrix = new Matrix()\n    this.sMatrix = new Matrix()\n    this.tMatrix = new Matrix()\n    this.matrix = new Matrix()\n  }\n\n  RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {\n    var dir = inv ? -1 : 1\n    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc)\n    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc)\n    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2])\n    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2])\n    rMatrix.rotate(-transform.r.v * dir * perc)\n    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2])\n    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2])\n    sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY)\n    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2])\n  }\n\n  RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {\n    this.elem = elem\n    this.arr = arr\n    this.pos = pos\n    this.elemsData = elemsData\n    this._currentCopies = 0\n    this._elements = []\n    this._groups = []\n    this.frameId = -1\n    this.initDynamicPropertyContainer(elem)\n    this.initModifierProperties(elem, arr[pos])\n    while (pos > 0) {\n      pos -= 1\n      // this._elements.unshift(arr.splice(pos,1)[0]);\n      this._elements.unshift(arr[pos])\n    }\n    if (this.dynamicProperties.length) {\n      this.k = true\n    } else {\n      this.getValue(true)\n    }\n  }\n\n  RepeaterModifier.prototype.resetElements = function (elements) {\n    var i\n    var len = elements.length\n    for (i = 0; i < len; i += 1) {\n      elements[i]._processed = false\n      if (elements[i].ty === 'gr') {\n        this.resetElements(elements[i].it)\n      }\n    }\n  }\n\n  RepeaterModifier.prototype.cloneElements = function (elements) {\n    var newElements = JSON.parse(JSON.stringify(elements))\n    this.resetElements(newElements)\n    return newElements\n  }\n\n  RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {\n    var i\n    var len = elements.length\n    for (i = 0; i < len; i += 1) {\n      elements[i]._render = renderFlag\n      if (elements[i].ty === 'gr') {\n        this.changeGroupRender(elements[i].it, renderFlag)\n      }\n    }\n  }\n\n  RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {\n    var items\n    var itemsTransform\n    var i\n    var dir\n    var cont\n    var hasReloaded = false\n    if (this._mdf || _isFirstFrame) {\n      var copies = Math.ceil(this.c.v)\n      if (this._groups.length < copies) {\n        while (this._groups.length < copies) {\n          var group = {\n            it: this.cloneElements(this._elements),\n            ty: 'gr',\n          }\n          group.it.push({\n            a: { a: 0, ix: 1, k: [0, 0] },\n            nm: 'Transform',\n            o: { a: 0, ix: 7, k: 100 },\n            p: { a: 0, ix: 2, k: [0, 0] },\n            r: {\n              a: 1,\n              ix: 6,\n              k: [\n                { s: 0, e: 0, t: 0 },\n                { s: 0, e: 0, t: 1 },\n              ],\n            },\n            s: { a: 0, ix: 3, k: [100, 100] },\n            sa: { a: 0, ix: 5, k: 0 },\n            sk: { a: 0, ix: 4, k: 0 },\n            ty: 'tr',\n          })\n\n          this.arr.splice(0, 0, group)\n          this._groups.splice(0, 0, group)\n          this._currentCopies += 1\n        }\n        this.elem.reloadShapes()\n        hasReloaded = true\n      }\n      cont = 0\n      var renderFlag\n      for (i = 0; i <= this._groups.length - 1; i += 1) {\n        renderFlag = cont < copies\n        this._groups[i]._render = renderFlag\n        this.changeGroupRender(this._groups[i].it, renderFlag)\n        if (!renderFlag) {\n          var elems = this.elemsData[i].it\n          var transformData = elems[elems.length - 1]\n          if (transformData.transform.op.v !== 0) {\n            transformData.transform.op._mdf = true\n            transformData.transform.op.v = 0\n          } else {\n            transformData.transform.op._mdf = false\n          }\n        }\n        cont += 1\n      }\n\n      this._currentCopies = copies\n      /// /\n\n      var offset = this.o.v\n      var offsetModulo = offset % 1\n      var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset)\n      var pProps = this.pMatrix.props\n      var rProps = this.rMatrix.props\n      var sProps = this.sMatrix.props\n      this.pMatrix.reset()\n      this.rMatrix.reset()\n      this.sMatrix.reset()\n      this.tMatrix.reset()\n      this.matrix.reset()\n      var iteration = 0\n\n      if (offset > 0) {\n        while (iteration < roundOffset) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false)\n          iteration += 1\n        }\n        if (offsetModulo) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false)\n          iteration += offsetModulo\n        }\n      } else if (offset < 0) {\n        while (iteration > roundOffset) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true)\n          iteration -= 1\n        }\n        if (offsetModulo) {\n          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true)\n          iteration -= offsetModulo\n        }\n      }\n      i = this.data.m === 1 ? 0 : this._currentCopies - 1\n      dir = this.data.m === 1 ? 1 : -1\n      cont = this._currentCopies\n      var j\n      var jLen\n      while (cont) {\n        items = this.elemsData[i].it\n        itemsTransform = items[items.length - 1].transform.mProps.v.props\n        jLen = itemsTransform.length\n        items[items.length - 1].transform.mProps._mdf = true\n        items[items.length - 1].transform.op._mdf = true\n        items[items.length - 1].transform.op.v =\n          this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1))\n\n        if (iteration !== 0) {\n          if ((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)) {\n            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false)\n          }\n          this.matrix.transform(\n            rProps[0],\n            rProps[1],\n            rProps[2],\n            rProps[3],\n            rProps[4],\n            rProps[5],\n            rProps[6],\n            rProps[7],\n            rProps[8],\n            rProps[9],\n            rProps[10],\n            rProps[11],\n            rProps[12],\n            rProps[13],\n            rProps[14],\n            rProps[15],\n          )\n          this.matrix.transform(\n            sProps[0],\n            sProps[1],\n            sProps[2],\n            sProps[3],\n            sProps[4],\n            sProps[5],\n            sProps[6],\n            sProps[7],\n            sProps[8],\n            sProps[9],\n            sProps[10],\n            sProps[11],\n            sProps[12],\n            sProps[13],\n            sProps[14],\n            sProps[15],\n          )\n          this.matrix.transform(\n            pProps[0],\n            pProps[1],\n            pProps[2],\n            pProps[3],\n            pProps[4],\n            pProps[5],\n            pProps[6],\n            pProps[7],\n            pProps[8],\n            pProps[9],\n            pProps[10],\n            pProps[11],\n            pProps[12],\n            pProps[13],\n            pProps[14],\n            pProps[15],\n          )\n\n          for (j = 0; j < jLen; j += 1) {\n            itemsTransform[j] = this.matrix.props[j]\n          }\n          this.matrix.reset()\n        } else {\n          this.matrix.reset()\n          for (j = 0; j < jLen; j += 1) {\n            itemsTransform[j] = this.matrix.props[j]\n          }\n        }\n        iteration += 1\n        cont -= 1\n        i += dir\n      }\n    } else {\n      cont = this._currentCopies\n      i = 0\n      dir = 1\n      while (cont) {\n        items = this.elemsData[i].it\n        itemsTransform = items[items.length - 1].transform.mProps.v.props\n        items[items.length - 1].transform.mProps._mdf = false\n        items[items.length - 1].transform.op._mdf = false\n        cont -= 1\n        i += dir\n      }\n    }\n    return hasReloaded\n  }\n\n  RepeaterModifier.prototype.addShape = function () {}\n\n  function RoundCornersModifier() {}\n  extendPrototype([ShapeModifier], RoundCornersModifier)\n  RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {\n    this.getValue = this.processKeys\n    this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this)\n    this._isAnimated = !!this.rd.effectsSequence.length\n  }\n\n  RoundCornersModifier.prototype.processPath = function (path, round) {\n    var clonedPath = shapePool.newElement()\n    clonedPath.c = path.c\n    var i\n    var len = path._length\n    var currentV\n    var currentI\n    var currentO\n    var closerV\n    var distance\n    var newPosPerc\n    var index = 0\n    var vX\n    var vY\n    var oX\n    var oY\n    var iX\n    var iY\n    for (i = 0; i < len; i += 1) {\n      currentV = path.v[i]\n      currentO = path.o[i]\n      currentI = path.i[i]\n      if (\n        currentV[0] === currentO[0] &&\n        currentV[1] === currentO[1] &&\n        currentV[0] === currentI[0] &&\n        currentV[1] === currentI[1]\n      ) {\n        if ((i === 0 || i === len - 1) && !path.c) {\n          clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index)\n          /* clonedPath.v[index] = currentV;\n                clonedPath.o[index] = currentO;\n                clonedPath.i[index] = currentI; */\n          index += 1\n        } else {\n          if (i === 0) {\n            closerV = path.v[len - 1]\n          } else {\n            closerV = path.v[i - 1]\n          }\n          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2))\n          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0\n          iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc\n          vX = iX\n          iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc\n          vY = iY\n          oX = vX - (vX - currentV[0]) * roundCorner\n          oY = vY - (vY - currentV[1]) * roundCorner\n          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index)\n          index += 1\n\n          if (i === len - 1) {\n            closerV = path.v[0]\n          } else {\n            closerV = path.v[i + 1]\n          }\n          distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2))\n          newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0\n          oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc\n          vX = oX\n          oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc\n          vY = oY\n          iX = vX - (vX - currentV[0]) * roundCorner\n          iY = vY - (vY - currentV[1]) * roundCorner\n          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index)\n          index += 1\n        }\n      } else {\n        clonedPath.setTripleAt(\n          path.v[i][0],\n          path.v[i][1],\n          path.o[i][0],\n          path.o[i][1],\n          path.i[i][0],\n          path.i[i][1],\n          index,\n        )\n        index += 1\n      }\n    }\n    return clonedPath\n  }\n\n  RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {\n    var shapePaths\n    var i\n    var len = this.shapes.length\n    var j\n    var jLen\n    var rd = this.rd.v\n\n    if (rd !== 0) {\n      var shapeData\n      var localShapeCollection\n      for (i = 0; i < len; i += 1) {\n        shapeData = this.shapes[i]\n        localShapeCollection = shapeData.localShapeCollection\n        if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n          localShapeCollection.releaseShapes()\n          shapeData.shape._mdf = true\n          shapePaths = shapeData.shape.paths.shapes\n          jLen = shapeData.shape.paths._length\n          for (j = 0; j < jLen; j += 1) {\n            localShapeCollection.addShape(this.processPath(shapePaths[j], rd))\n          }\n        }\n        shapeData.shape.paths = shapeData.localShapeCollection\n      }\n    }\n    if (!this.dynamicProperties.length) {\n      this._mdf = false\n    }\n  }\n\n  function getFontProperties(fontData) {\n    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : []\n\n    var fWeight = 'normal'\n    var fStyle = 'normal'\n    var len = styles.length\n    var styleName\n    for (var i = 0; i < len; i += 1) {\n      styleName = styles[i].toLowerCase()\n      switch (styleName) {\n        case 'italic':\n          fStyle = 'italic'\n          break\n        case 'bold':\n          fWeight = '700'\n          break\n        case 'black':\n          fWeight = '900'\n          break\n        case 'medium':\n          fWeight = '500'\n          break\n        case 'regular':\n        case 'normal':\n          fWeight = '400'\n          break\n        case 'light':\n        case 'thin':\n          fWeight = '200'\n          break\n        default:\n          break\n      }\n    }\n\n    return {\n      style: fStyle,\n      weight: fontData.fWeight || fWeight,\n    }\n  }\n\n  const FontManager = (function () {\n    var maxWaitingTime = 5000\n    var emptyChar = {\n      w: 0,\n      size: 0,\n      shapes: [],\n      data: {\n        shapes: [],\n      },\n    }\n    var combinedCharacters = []\n    // Hindi characters\n    combinedCharacters = combinedCharacters.concat([\n      2304,\n      2305,\n      2306,\n      2307,\n      2362,\n      2363,\n      2364,\n      2364,\n      2366,\n      2367,\n      2368,\n      2369,\n      2370,\n      2371,\n      2372,\n      2373,\n      2374,\n      2375,\n      2376,\n      2377,\n      2378,\n      2379,\n      2380,\n      2381,\n      2382,\n      2383,\n      2387,\n      2388,\n      2389,\n      2390,\n      2391,\n      2402,\n      2403,\n    ])\n\n    var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff']\n\n    var zeroWidthJoiner = [65039, 8205]\n\n    function trimFontOptions(font) {\n      var familyArray = font.split(',')\n      var i\n      var len = familyArray.length\n      var enabledFamilies = []\n      for (i = 0; i < len; i += 1) {\n        if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {\n          enabledFamilies.push(familyArray[i])\n        }\n      }\n      return enabledFamilies.join(',')\n    }\n\n    function setUpNode(font, family) {\n      var parentNode = createTag('span')\n      // Node is invisible to screen readers.\n      parentNode.setAttribute('aria-hidden', true)\n      parentNode.style.fontFamily = family\n      var node = createTag('span')\n      // Characters that vary significantly among different fonts\n      node.innerText = 'giItT1WQy@!-/#'\n      // Visible - so we can measure it - but not on the screen\n      parentNode.style.position = 'absolute'\n      parentNode.style.left = '-10000px'\n      parentNode.style.top = '-10000px'\n      // Large font size makes even subtle changes obvious\n      parentNode.style.fontSize = '300px'\n      // Reset any font properties\n      parentNode.style.fontVariant = 'normal'\n      parentNode.style.fontStyle = 'normal'\n      parentNode.style.fontWeight = 'normal'\n      parentNode.style.letterSpacing = '0'\n      parentNode.appendChild(node)\n      document.body.appendChild(parentNode)\n\n      // Remember width with no applied web font\n      var width = node.offsetWidth\n      node.style.fontFamily = trimFontOptions(font) + ', ' + family\n      return { node: node, w: width, parent: parentNode }\n    }\n\n    function checkLoadedFonts() {\n      var i\n      var len = this.fonts.length\n      var node\n      var w\n      var loadedCount = len\n      for (i = 0; i < len; i += 1) {\n        if (this.fonts[i].loaded) {\n          loadedCount -= 1\n        } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {\n          this.fonts[i].loaded = true\n        } else {\n          node = this.fonts[i].monoCase.node\n          w = this.fonts[i].monoCase.w\n          if (node.offsetWidth !== w) {\n            loadedCount -= 1\n            this.fonts[i].loaded = true\n          } else {\n            node = this.fonts[i].sansCase.node\n            w = this.fonts[i].sansCase.w\n            if (node.offsetWidth !== w) {\n              loadedCount -= 1\n              this.fonts[i].loaded = true\n            }\n          }\n          if (this.fonts[i].loaded) {\n            this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent)\n            this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent)\n          }\n        }\n      }\n\n      if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {\n        setTimeout(this.checkLoadedFontsBinded, 20)\n      } else {\n        setTimeout(this.setIsLoadedBinded, 10)\n      }\n    }\n\n    function createHelper(fontData, def) {\n      var engine = document.body && def ? 'svg' : 'canvas'\n      var helper\n      var fontProps = getFontProperties(fontData)\n      if (engine === 'svg') {\n        var tHelper = createNS('text')\n        tHelper.style.fontSize = '100px'\n        // tHelper.style.fontFamily = fontData.fFamily;\n        tHelper.setAttribute('font-family', fontData.fFamily)\n        tHelper.setAttribute('font-style', fontProps.style)\n        tHelper.setAttribute('font-weight', fontProps.weight)\n        tHelper.textContent = '1'\n        if (fontData.fClass) {\n          tHelper.style.fontFamily = 'inherit'\n          tHelper.setAttribute('class', fontData.fClass)\n        } else {\n          tHelper.style.fontFamily = fontData.fFamily\n        }\n        def.appendChild(tHelper)\n        helper = tHelper\n      } else {\n        var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d')\n        tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily\n        helper = tCanvasHelper\n      }\n      function measure(text) {\n        if (engine === 'svg') {\n          helper.textContent = text\n          return helper.getComputedTextLength()\n        }\n        return helper.measureText(text).width\n      }\n      return {\n        measureText: measure,\n      }\n    }\n\n    function addFonts(fontData, defs) {\n      if (!fontData) {\n        this.isLoaded = true\n        return\n      }\n      if (this.chars) {\n        this.isLoaded = true\n        this.fonts = fontData.list\n        return\n      }\n      if (!document.body) {\n        this.isLoaded = true\n        fontData.list.forEach((data) => {\n          data.helper = createHelper(data)\n          data.cache = {}\n        })\n        this.fonts = fontData.list\n        return\n      }\n\n      var fontArr = fontData.list\n      var i\n      var len = fontArr.length\n      var _pendingFonts = len\n      for (i = 0; i < len; i += 1) {\n        var shouldLoadFont = true\n        var loadedSelector\n        var j\n        fontArr[i].loaded = false\n        fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace')\n        fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif')\n        if (!fontArr[i].fPath) {\n          fontArr[i].loaded = true\n          _pendingFonts -= 1\n        } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {\n          loadedSelector = document.querySelectorAll(\n            'style[f-forigin=\"p\"][f-family=\"' +\n              fontArr[i].fFamily +\n              '\"], style[f-origin=\"3\"][f-family=\"' +\n              fontArr[i].fFamily +\n              '\"]',\n          )\n\n          if (loadedSelector.length > 0) {\n            shouldLoadFont = false\n          }\n\n          if (shouldLoadFont) {\n            var s = createTag('style')\n            s.setAttribute('f-forigin', fontArr[i].fOrigin)\n            s.setAttribute('f-origin', fontArr[i].origin)\n            s.setAttribute('f-family', fontArr[i].fFamily)\n            s.type = 'text/css'\n            s.innerText =\n              '@font-face {font-family: ' +\n              fontArr[i].fFamily +\n              \"; font-style: normal; src: url('\" +\n              fontArr[i].fPath +\n              \"');}\"\n            defs.appendChild(s)\n          }\n        } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {\n          loadedSelector = document.querySelectorAll('link[f-forigin=\"g\"], link[f-origin=\"1\"]')\n\n          for (j = 0; j < loadedSelector.length; j += 1) {\n            if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {\n              // Font is already loaded\n              shouldLoadFont = false\n            }\n          }\n\n          if (shouldLoadFont) {\n            var l = createTag('link')\n            l.setAttribute('f-forigin', fontArr[i].fOrigin)\n            l.setAttribute('f-origin', fontArr[i].origin)\n            l.type = 'text/css'\n            l.rel = 'stylesheet'\n            l.href = fontArr[i].fPath\n            document.body.appendChild(l)\n          }\n        } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {\n          loadedSelector = document.querySelectorAll('script[f-forigin=\"t\"], script[f-origin=\"2\"]')\n\n          for (j = 0; j < loadedSelector.length; j += 1) {\n            if (fontArr[i].fPath === loadedSelector[j].src) {\n              // Font is already loaded\n              shouldLoadFont = false\n            }\n          }\n\n          if (shouldLoadFont) {\n            var sc = createTag('link')\n            sc.setAttribute('f-forigin', fontArr[i].fOrigin)\n            sc.setAttribute('f-origin', fontArr[i].origin)\n            sc.setAttribute('rel', 'stylesheet')\n            sc.setAttribute('href', fontArr[i].fPath)\n            defs.appendChild(sc)\n          }\n        }\n        fontArr[i].helper = createHelper(fontArr[i], defs)\n        fontArr[i].cache = {}\n        this.fonts.push(fontArr[i])\n      }\n      if (_pendingFonts === 0) {\n        this.isLoaded = true\n      } else {\n        // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\n        // Adding this timeout seems to fix it\n        setTimeout(this.checkLoadedFonts.bind(this), 100)\n      }\n    }\n\n    function addChars(chars) {\n      if (!chars) {\n        return\n      }\n      if (!this.chars) {\n        this.chars = []\n      }\n      var i\n      var len = chars.length\n      var j\n      var jLen = this.chars.length\n      var found\n      for (i = 0; i < len; i += 1) {\n        j = 0\n        found = false\n        while (j < jLen) {\n          if (\n            this.chars[j].style === chars[i].style &&\n            this.chars[j].fFamily === chars[i].fFamily &&\n            this.chars[j].ch === chars[i].ch\n          ) {\n            found = true\n          }\n          j += 1\n        }\n        if (!found) {\n          this.chars.push(chars[i])\n          jLen += 1\n        }\n      }\n    }\n\n    function getCharData(char, style, font) {\n      var i = 0\n      var len = this.chars.length\n      while (i < len) {\n        if (this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font) {\n          return this.chars[i]\n        }\n        i += 1\n      }\n      if (\n        ((typeof char === 'string' && char.charCodeAt(0) !== 13) || !char) &&\n        console &&\n        console.warn && // eslint-disable-line no-console\n        !this._warned\n      ) {\n        this._warned = true\n        console.warn('Missing character from exported characters list: ', char, style, font) // eslint-disable-line no-console\n      }\n      return emptyChar\n    }\n\n    function measureText(char, fontName, size) {\n      var fontData = this.getFontByName(fontName)\n      var index = char.charCodeAt(0)\n      if (!fontData.cache[index + 1]) {\n        var tHelper = fontData.helper\n        if (char === ' ') {\n          var doubleSize = tHelper.measureText('|' + char + '|')\n          var singleSize = tHelper.measureText('||')\n          fontData.cache[index + 1] = (doubleSize - singleSize) / 100\n        } else {\n          fontData.cache[index + 1] = tHelper.measureText(char) / 100\n        }\n      }\n      return fontData.cache[index + 1] * size\n    }\n\n    function getFontByName(name) {\n      var i = 0\n      var len = this.fonts.length\n      while (i < len) {\n        if (this.fonts[i].fName === name) {\n          return this.fonts[i]\n        }\n        i += 1\n      }\n      return this.fonts[0]\n    }\n\n    function isModifier(firstCharCode, secondCharCode) {\n      var sum = firstCharCode.toString(16) + secondCharCode.toString(16)\n      return surrogateModifiers.indexOf(sum) !== -1\n    }\n\n    function isZeroWidthJoiner(firstCharCode, secondCharCode) {\n      if (!secondCharCode) {\n        return firstCharCode === zeroWidthJoiner[1]\n      }\n      return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1]\n    }\n\n    function isCombinedCharacter(char) {\n      return combinedCharacters.indexOf(char) !== -1\n    }\n\n    function setIsLoaded() {\n      this.isLoaded = true\n    }\n\n    var Font = function () {\n      this.fonts = []\n      this.chars = null\n      this.typekitLoaded = 0\n      this.isLoaded = false\n      this._warned = false\n      this.initTime = Date.now()\n      this.setIsLoadedBinded = this.setIsLoaded.bind(this)\n      this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)\n    }\n    Font.isModifier = isModifier\n    Font.isZeroWidthJoiner = isZeroWidthJoiner\n    Font.isCombinedCharacter = isCombinedCharacter\n\n    var fontPrototype = {\n      addChars: addChars,\n      addFonts: addFonts,\n      getCharData: getCharData,\n      getFontByName: getFontByName,\n      measureText: measureText,\n      checkLoadedFonts: checkLoadedFonts,\n      setIsLoaded: setIsLoaded,\n    }\n\n    Font.prototype = fontPrototype\n\n    return Font\n  })()\n\n  function RenderableElement() {}\n\n  RenderableElement.prototype = {\n    initRenderable: function () {\n      // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\n      this.isInRange = false\n      // layer's display state\n      this.hidden = false\n      // If layer's transparency equals 0, it can be hidden\n      this.isTransparent = false\n      // list of animated components\n      this.renderableComponents = []\n    },\n    addRenderableComponent: function (component) {\n      if (this.renderableComponents.indexOf(component) === -1) {\n        this.renderableComponents.push(component)\n      }\n    },\n    removeRenderableComponent: function (component) {\n      if (this.renderableComponents.indexOf(component) !== -1) {\n        this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1)\n      }\n    },\n    prepareRenderableFrame: function (num) {\n      this.checkLayerLimits(num)\n    },\n    checkTransparency: function () {\n      if (this.finalTransform.mProp.o.v <= 0) {\n        if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {\n          this.isTransparent = true\n          this.hide()\n        }\n      } else if (this.isTransparent) {\n        this.isTransparent = false\n        this.show()\n      }\n    },\n    /**\n     * @function\n     * Initializes frame related properties.\n     *\n     * @param {number} num\n     * current frame number in Layer's time\n     *\n     */\n    checkLayerLimits: function (num) {\n      if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {\n        if (this.isInRange !== true) {\n          this.globalData._mdf = true\n          this._mdf = true\n          this.isInRange = true\n          this.show()\n        }\n      } else if (this.isInRange !== false) {\n        this.globalData._mdf = true\n        this.isInRange = false\n        this.hide()\n      }\n    },\n    renderRenderable: function () {\n      var i\n      var len = this.renderableComponents.length\n      for (i = 0; i < len; i += 1) {\n        this.renderableComponents[i].renderFrame(this._isFirstFrame)\n      }\n      /* this.maskManager.renderFrame(this.finalTransform.mat);\n        this.renderableEffectsManager.renderFrame(this._isFirstFrame); */\n    },\n    sourceRectAtTime: function () {\n      return {\n        top: 0,\n        left: 0,\n        width: 100,\n        height: 100,\n      }\n    },\n    getLayerSize: function () {\n      if (this.data.ty === 5) {\n        return { w: this.data.textData.width, h: this.data.textData.height }\n      }\n      return { w: this.data.width, h: this.data.height }\n    },\n  }\n\n  const MaskManagerInterface = (function () {\n    function MaskInterface(mask, data) {\n      this._mask = mask\n      this._data = data\n    }\n    Object.defineProperty(MaskInterface.prototype, 'maskPath', {\n      get: function () {\n        if (this._mask.prop.k) {\n          this._mask.prop.getValue()\n        }\n        return this._mask.prop\n      },\n    })\n    Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {\n      get: function () {\n        if (this._mask.op.k) {\n          this._mask.op.getValue()\n        }\n        return this._mask.op.v * 100\n      },\n    })\n\n    var MaskManager = function (maskManager) {\n      var _masksInterfaces = createSizedArray(maskManager.viewData.length)\n      var i\n      var len = maskManager.viewData.length\n      for (i = 0; i < len; i += 1) {\n        _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i])\n      }\n\n      var maskFunction = function (name) {\n        i = 0\n        while (i < len) {\n          if (maskManager.masksProperties[i].nm === name) {\n            return _masksInterfaces[i]\n          }\n          i += 1\n        }\n        return null\n      }\n      return maskFunction\n    }\n    return MaskManager\n  })()\n\n  const ExpressionPropertyInterface = (function () {\n    var defaultUnidimensionalValue = { pv: 0, v: 0, mult: 1 }\n    var defaultMultidimensionalValue = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }\n\n    function completeProperty(expressionValue, property, type) {\n      Object.defineProperty(expressionValue, 'velocity', {\n        get: function () {\n          return property.getVelocityAtTime(property.comp.currentFrame)\n        },\n      })\n      expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0\n      expressionValue.key = function (pos) {\n        if (!expressionValue.numKeys) {\n          return 0\n        }\n        var value = ''\n        if ('s' in property.keyframes[pos - 1]) {\n          value = property.keyframes[pos - 1].s\n        } else if ('e' in property.keyframes[pos - 2]) {\n          value = property.keyframes[pos - 2].e\n        } else {\n          value = property.keyframes[pos - 2].s\n        }\n        var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value) // eslint-disable-line no-new-wrappers\n        valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate\n        valueProp.value = type === 'unidimensional' ? value[0] : value\n        return valueProp\n      }\n      expressionValue.valueAtTime = property.getValueAtTime\n      expressionValue.speedAtTime = property.getSpeedAtTime\n      expressionValue.velocityAtTime = property.getVelocityAtTime\n      expressionValue.propertyGroup = property.propertyGroup\n    }\n\n    function UnidimensionalPropertyInterface(property) {\n      if (!property || !('pv' in property)) {\n        property = defaultUnidimensionalValue\n      }\n      var mult = 1 / property.mult\n      var val = property.pv * mult\n      var expressionValue = new Number(val) // eslint-disable-line no-new-wrappers\n      expressionValue.value = val\n      completeProperty(expressionValue, property, 'unidimensional')\n\n      return function () {\n        if (property.k) {\n          property.getValue()\n        }\n        val = property.v * mult\n        if (expressionValue.value !== val) {\n          expressionValue = new Number(val) // eslint-disable-line no-new-wrappers\n          expressionValue.value = val\n          completeProperty(expressionValue, property, 'unidimensional')\n        }\n        return expressionValue\n      }\n    }\n\n    function MultidimensionalPropertyInterface(property) {\n      if (!property || !('pv' in property)) {\n        property = defaultMultidimensionalValue\n      }\n      var mult = 1 / property.mult\n      var len = (property.data && property.data.l) || property.pv.length\n      var expressionValue = createTypedArray('float32', len)\n      var arrValue = createTypedArray('float32', len)\n      expressionValue.value = arrValue\n      completeProperty(expressionValue, property, 'multidimensional')\n\n      return function () {\n        if (property.k) {\n          property.getValue()\n        }\n        for (var i = 0; i < len; i += 1) {\n          arrValue[i] = property.v[i] * mult\n          expressionValue[i] = arrValue[i]\n        }\n        return expressionValue\n      }\n    }\n\n    // TODO: try to avoid using this getter\n    function defaultGetter() {\n      return defaultUnidimensionalValue\n    }\n\n    return function (property) {\n      if (!property) {\n        return defaultGetter\n      }\n      if (property.propType === 'unidimensional') {\n        return UnidimensionalPropertyInterface(property)\n      }\n      return MultidimensionalPropertyInterface(property)\n    }\n  })()\n\n  const TransformExpressionInterface = (function () {\n    return function (transform) {\n      function _thisFunction(name) {\n        switch (name) {\n          case 'scale':\n          case 'Scale':\n          case 'ADBE Scale':\n          case 6:\n            return _thisFunction.scale\n          case 'rotation':\n          case 'Rotation':\n          case 'ADBE Rotation':\n          case 'ADBE Rotate Z':\n          case 10:\n            return _thisFunction.rotation\n          case 'ADBE Rotate X':\n            return _thisFunction.xRotation\n          case 'ADBE Rotate Y':\n            return _thisFunction.yRotation\n          case 'position':\n          case 'Position':\n          case 'ADBE Position':\n          case 2:\n            return _thisFunction.position\n          case 'ADBE Position_0':\n            return _thisFunction.xPosition\n          case 'ADBE Position_1':\n            return _thisFunction.yPosition\n          case 'ADBE Position_2':\n            return _thisFunction.zPosition\n          case 'anchorPoint':\n          case 'AnchorPoint':\n          case 'Anchor Point':\n          case 'ADBE AnchorPoint':\n          case 1:\n            return _thisFunction.anchorPoint\n          case 'opacity':\n          case 'Opacity':\n          case 11:\n            return _thisFunction.opacity\n          default:\n            return null\n        }\n      }\n      Object.defineProperty(_thisFunction, 'rotation', {\n        get: ExpressionPropertyInterface(transform.r || transform.rz),\n      })\n\n      Object.defineProperty(_thisFunction, 'zRotation', {\n        get: ExpressionPropertyInterface(transform.rz || transform.r),\n      })\n\n      Object.defineProperty(_thisFunction, 'xRotation', {\n        get: ExpressionPropertyInterface(transform.rx),\n      })\n\n      Object.defineProperty(_thisFunction, 'yRotation', {\n        get: ExpressionPropertyInterface(transform.ry),\n      })\n      Object.defineProperty(_thisFunction, 'scale', {\n        get: ExpressionPropertyInterface(transform.s),\n      })\n      var _px\n      var _py\n      var _pz\n      var _transformFactory\n      if (transform.p) {\n        _transformFactory = ExpressionPropertyInterface(transform.p)\n      } else {\n        _px = ExpressionPropertyInterface(transform.px)\n        _py = ExpressionPropertyInterface(transform.py)\n        if (transform.pz) {\n          _pz = ExpressionPropertyInterface(transform.pz)\n        }\n      }\n      Object.defineProperty(_thisFunction, 'position', {\n        get: function () {\n          if (transform.p) {\n            return _transformFactory()\n          }\n          return [_px(), _py(), _pz ? _pz() : 0]\n        },\n      })\n\n      Object.defineProperty(_thisFunction, 'xPosition', {\n        get: ExpressionPropertyInterface(transform.px),\n      })\n\n      Object.defineProperty(_thisFunction, 'yPosition', {\n        get: ExpressionPropertyInterface(transform.py),\n      })\n\n      Object.defineProperty(_thisFunction, 'zPosition', {\n        get: ExpressionPropertyInterface(transform.pz),\n      })\n\n      Object.defineProperty(_thisFunction, 'anchorPoint', {\n        get: ExpressionPropertyInterface(transform.a),\n      })\n\n      Object.defineProperty(_thisFunction, 'opacity', {\n        get: ExpressionPropertyInterface(transform.o),\n      })\n\n      Object.defineProperty(_thisFunction, 'skew', {\n        get: ExpressionPropertyInterface(transform.sk),\n      })\n\n      Object.defineProperty(_thisFunction, 'skewAxis', {\n        get: ExpressionPropertyInterface(transform.sa),\n      })\n\n      Object.defineProperty(_thisFunction, 'orientation', {\n        get: ExpressionPropertyInterface(transform.or),\n      })\n\n      return _thisFunction\n    }\n  })()\n\n  const LayerExpressionInterface = (function () {\n    function getMatrix(time) {\n      var toWorldMat = new Matrix()\n      if (time !== undefined) {\n        var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time)\n        propMatrix.clone(toWorldMat)\n      } else {\n        var transformMat = this._elem.finalTransform.mProp\n        transformMat.applyToMatrix(toWorldMat)\n      }\n      return toWorldMat\n    }\n\n    function toWorldVec(arr, time) {\n      var toWorldMat = this.getMatrix(time)\n      toWorldMat.props[12] = 0\n      toWorldMat.props[13] = 0\n      toWorldMat.props[14] = 0\n      return this.applyPoint(toWorldMat, arr)\n    }\n\n    function toWorld(arr, time) {\n      var toWorldMat = this.getMatrix(time)\n      return this.applyPoint(toWorldMat, arr)\n    }\n\n    function fromWorldVec(arr, time) {\n      var toWorldMat = this.getMatrix(time)\n      toWorldMat.props[12] = 0\n      toWorldMat.props[13] = 0\n      toWorldMat.props[14] = 0\n      return this.invertPoint(toWorldMat, arr)\n    }\n\n    function fromWorld(arr, time) {\n      var toWorldMat = this.getMatrix(time)\n      return this.invertPoint(toWorldMat, arr)\n    }\n\n    function applyPoint(matrix, arr) {\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i\n        var len = this._elem.hierarchy.length\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix)\n        }\n      }\n      return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0)\n    }\n\n    function invertPoint(matrix, arr) {\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i\n        var len = this._elem.hierarchy.length\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix)\n        }\n      }\n      return matrix.inversePoint(arr)\n    }\n\n    function fromComp(arr) {\n      var toWorldMat = new Matrix()\n      toWorldMat.reset()\n      this._elem.finalTransform.mProp.applyToMatrix(toWorldMat)\n      if (this._elem.hierarchy && this._elem.hierarchy.length) {\n        var i\n        var len = this._elem.hierarchy.length\n        for (i = 0; i < len; i += 1) {\n          this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat)\n        }\n        return toWorldMat.inversePoint(arr)\n      }\n      return toWorldMat.inversePoint(arr)\n    }\n\n    function sampleImage() {\n      return [1, 1, 1, 1]\n    }\n\n    return function (elem) {\n      var transformInterface\n\n      function _registerMaskInterface(maskManager) {\n        _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem)\n      }\n      function _registerEffectsInterface(effects) {\n        _thisLayerFunction.effect = effects\n      }\n\n      function _thisLayerFunction(name) {\n        switch (name) {\n          case 'ADBE Root Vectors Group':\n          case 'Contents':\n          case 2:\n            return _thisLayerFunction.shapeInterface\n          case 1:\n          case 6:\n          case 'Transform':\n          case 'transform':\n          case 'ADBE Transform Group':\n            return transformInterface\n          case 4:\n          case 'ADBE Effect Parade':\n          case 'effects':\n          case 'Effects':\n            return _thisLayerFunction.effect\n          case 'ADBE Text Properties':\n            return _thisLayerFunction.textInterface\n          default:\n            return null\n        }\n      }\n      _thisLayerFunction.getMatrix = getMatrix\n      _thisLayerFunction.invertPoint = invertPoint\n      _thisLayerFunction.applyPoint = applyPoint\n      _thisLayerFunction.toWorld = toWorld\n      _thisLayerFunction.toWorldVec = toWorldVec\n      _thisLayerFunction.fromWorld = fromWorld\n      _thisLayerFunction.fromWorldVec = fromWorldVec\n      _thisLayerFunction.toComp = toWorld\n      _thisLayerFunction.fromComp = fromComp\n      _thisLayerFunction.sampleImage = sampleImage\n      _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem)\n      _thisLayerFunction._elem = elem\n      transformInterface = TransformExpressionInterface(elem.finalTransform.mProp)\n      var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint')\n      Object.defineProperties(_thisLayerFunction, {\n        hasParent: {\n          get: function () {\n            return elem.hierarchy.length\n          },\n        },\n        parent: {\n          get: function () {\n            return elem.hierarchy[0].layerInterface\n          },\n        },\n        rotation: getDescriptor(transformInterface, 'rotation'),\n        scale: getDescriptor(transformInterface, 'scale'),\n        position: getDescriptor(transformInterface, 'position'),\n        opacity: getDescriptor(transformInterface, 'opacity'),\n        anchorPoint: anchorPointDescriptor,\n        anchor_point: anchorPointDescriptor,\n        transform: {\n          get: function () {\n            return transformInterface\n          },\n        },\n        active: {\n          get: function () {\n            return elem.isInRange\n          },\n        },\n      })\n\n      _thisLayerFunction.startTime = elem.data.st\n      _thisLayerFunction.index = elem.data.ind\n      _thisLayerFunction.source = elem.data.refId\n      _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100\n      _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100\n      _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate\n      _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate\n      _thisLayerFunction._name = elem.data.nm\n\n      _thisLayerFunction.registerMaskInterface = _registerMaskInterface\n      _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface\n      return _thisLayerFunction\n    }\n  })()\n\n  const propertyGroupFactory = (function () {\n    return function (interfaceFunction, parentPropertyGroup) {\n      return function (val) {\n        val = val === undefined ? 1 : val\n        if (val <= 0) {\n          return interfaceFunction\n        }\n        return parentPropertyGroup(val - 1)\n      }\n    }\n  })()\n\n  const PropertyInterface = (function () {\n    return function (propertyName, propertyGroup) {\n      var interfaceFunction = {\n        _name: propertyName,\n      }\n\n      function _propertyGroup(val) {\n        val = val === undefined ? 1 : val\n        if (val <= 0) {\n          return interfaceFunction\n        }\n        return propertyGroup(val - 1)\n      }\n\n      return _propertyGroup\n    }\n  })()\n\n  const EffectsExpressionInterface = (function () {\n    var ob = {\n      createEffectsInterface: createEffectsInterface,\n    }\n\n    function createEffectsInterface(elem, propertyGroup) {\n      if (elem.effectsManager) {\n        var effectElements = []\n        var effectsData = elem.data.ef\n        var i\n        var len = elem.effectsManager.effectElements.length\n        for (i = 0; i < len; i += 1) {\n          effectElements.push(\n            createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem),\n          )\n        }\n\n        var effects = elem.data.ef || []\n        var groupInterface = function (name) {\n          i = 0\n          len = effects.length\n          while (i < len) {\n            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n              return effectElements[i]\n            }\n            i += 1\n          }\n          return null\n        }\n        Object.defineProperty(groupInterface, 'numProperties', {\n          get: function () {\n            return effects.length\n          },\n        })\n        return groupInterface\n      }\n      return null\n    }\n\n    function createGroupInterface(data, elements, propertyGroup, elem) {\n      function groupInterface(name) {\n        var effects = data.ef\n        var i = 0\n        var len = effects.length\n        while (i < len) {\n          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n            if (effects[i].ty === 5) {\n              return effectElements[i]\n            }\n            return effectElements[i]()\n          }\n          i += 1\n        }\n        throw new Error()\n      }\n      var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup)\n\n      var effectElements = []\n      var i\n      var len = data.ef.length\n      for (i = 0; i < len; i += 1) {\n        if (data.ef[i].ty === 5) {\n          effectElements.push(\n            createGroupInterface(\n              data.ef[i],\n              elements.effectElements[i],\n              elements.effectElements[i].propertyGroup,\n              elem,\n            ),\n          )\n        } else {\n          effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup))\n        }\n      }\n\n      if (data.mn === 'ADBE Color Control') {\n        Object.defineProperty(groupInterface, 'color', {\n          get: function () {\n            return effectElements[0]()\n          },\n        })\n      }\n      Object.defineProperties(groupInterface, {\n        numProperties: {\n          get: function () {\n            return data.np\n          },\n        },\n        _name: { value: data.nm },\n        propertyGroup: { value: _propertyGroup },\n      })\n      groupInterface.enabled = data.en !== 0\n      groupInterface.active = groupInterface.enabled\n      return groupInterface\n    }\n\n    function createValueInterface(element, type, elem, propertyGroup) {\n      var expressionProperty = ExpressionPropertyInterface(element.p)\n      function interfaceFunction() {\n        if (type === 10) {\n          return elem.comp.compInterface(element.p.v)\n        }\n        return expressionProperty()\n      }\n\n      if (element.p.setGroupProperty) {\n        element.p.setGroupProperty(PropertyInterface('', propertyGroup))\n      }\n\n      return interfaceFunction\n    }\n\n    return ob\n  })()\n\n  const CompExpressionInterface = (function () {\n    return function (comp) {\n      function _thisLayerFunction(name) {\n        var i = 0\n        var len = comp.layers.length\n        while (i < len) {\n          if (comp.layers[i].nm === name || comp.layers[i].ind === name) {\n            return comp.elements[i].layerInterface\n          }\n          i += 1\n        }\n        return null\n        // return {active:false};\n      }\n      Object.defineProperty(_thisLayerFunction, '_name', { value: comp.data.nm })\n      _thisLayerFunction.layer = _thisLayerFunction\n      _thisLayerFunction.pixelAspect = 1\n      _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h\n      _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w\n      _thisLayerFunction.pixelAspect = 1\n      _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate\n      _thisLayerFunction.displayStartTime = 0\n      _thisLayerFunction.numLayers = comp.layers.length\n      return _thisLayerFunction\n    }\n  })()\n\n  const ShapePathInterface = (function () {\n    return function pathInterfaceFactory(shape, view, propertyGroup) {\n      var prop = view.sh\n\n      function interfaceFunction(val) {\n        if (\n          val === 'Shape' ||\n          val === 'shape' ||\n          val === 'Path' ||\n          val === 'path' ||\n          val === 'ADBE Vector Shape' ||\n          val === 2\n        ) {\n          return interfaceFunction.path\n        }\n        return null\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup))\n      Object.defineProperties(interfaceFunction, {\n        path: {\n          get: function () {\n            if (prop.k) {\n              prop.getValue()\n            }\n            return prop\n          },\n        },\n        shape: {\n          get: function () {\n            if (prop.k) {\n              prop.getValue()\n            }\n            return prop\n          },\n        },\n        _name: { value: shape.nm },\n        ix: { value: shape.ix },\n        propertyIndex: { value: shape.ix },\n        mn: { value: shape.mn },\n        propertyGroup: { value: propertyGroup },\n      })\n      return interfaceFunction\n    }\n  })()\n\n  const ShapeExpressionInterface = (function () {\n    function iterateElements(shapes, view, propertyGroup) {\n      var arr = []\n      var i\n      var len = shapes ? shapes.length : 0\n      for (i = 0; i < len; i += 1) {\n        if (shapes[i].ty === 'gr') {\n          arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'fl') {\n          arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'st') {\n          arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'tm') {\n          arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'tr') {\n          // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));\n        } else if (shapes[i].ty === 'el') {\n          arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'sr') {\n          arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'sh') {\n          arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'rc') {\n          arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'rd') {\n          arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'rp') {\n          arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else if (shapes[i].ty === 'gf') {\n          arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup))\n        } else {\n          arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup))\n        }\n      }\n      return arr\n    }\n\n    function contentsInterfaceFactory(shape, view, propertyGroup) {\n      var interfaces\n      var interfaceFunction = function _interfaceFunction(value) {\n        var i = 0\n        var len = interfaces.length\n        while (i < len) {\n          if (\n            interfaces[i]._name === value ||\n            interfaces[i].mn === value ||\n            interfaces[i].propertyIndex === value ||\n            interfaces[i].ix === value ||\n            interfaces[i].ind === value\n          ) {\n            return interfaces[i]\n          }\n          i += 1\n        }\n        if (typeof value === 'number') {\n          return interfaces[value - 1]\n        }\n        return null\n      }\n\n      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup)\n      interfaceFunction.numProperties = interfaces.length\n      var transformInterface = transformInterfaceFactory(\n        shape.it[shape.it.length - 1],\n        view.it[view.it.length - 1],\n        interfaceFunction.propertyGroup,\n      )\n      interfaceFunction.transform = transformInterface\n      interfaceFunction.propertyIndex = shape.cix\n      interfaceFunction._name = shape.nm\n\n      return interfaceFunction\n    }\n\n    function groupInterfaceFactory(shape, view, propertyGroup) {\n      var interfaceFunction = function _interfaceFunction(value) {\n        switch (value) {\n          case 'ADBE Vectors Group':\n          case 'Contents':\n          case 2:\n            return interfaceFunction.content\n          // Not necessary for now. Keeping them here in case a new case appears\n          // case 'ADBE Vector Transform Group':\n          // case 3:\n          default:\n            return interfaceFunction.transform\n        }\n      }\n      interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup)\n      var transformInterface = transformInterfaceFactory(\n        shape.it[shape.it.length - 1],\n        view.it[view.it.length - 1],\n        interfaceFunction.propertyGroup,\n      )\n      interfaceFunction.content = content\n      interfaceFunction.transform = transformInterface\n      Object.defineProperty(interfaceFunction, '_name', {\n        get: function () {\n          return shape.nm\n        },\n      })\n      // interfaceFunction.content = interfaceFunction;\n      interfaceFunction.numProperties = shape.np\n      interfaceFunction.propertyIndex = shape.ix\n      interfaceFunction.nm = shape.nm\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    function fillInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === 'Color' || val === 'color') {\n          return interfaceFunction.color\n        }\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity\n        }\n        return null\n      }\n      Object.defineProperties(interfaceFunction, {\n        color: {\n          get: ExpressionPropertyInterface(view.c),\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o),\n        },\n        _name: { value: shape.nm },\n        mn: { value: shape.mn },\n      })\n\n      view.c.setGroupProperty(PropertyInterface('Color', propertyGroup))\n      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup))\n      return interfaceFunction\n    }\n\n    function gradientFillInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === 'Start Point' || val === 'start point') {\n          return interfaceFunction.startPoint\n        }\n        if (val === 'End Point' || val === 'end point') {\n          return interfaceFunction.endPoint\n        }\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity\n        }\n        return null\n      }\n      Object.defineProperties(interfaceFunction, {\n        startPoint: {\n          get: ExpressionPropertyInterface(view.s),\n        },\n        endPoint: {\n          get: ExpressionPropertyInterface(view.e),\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o),\n        },\n        type: {\n          get: function () {\n            return 'a'\n          },\n        },\n        _name: { value: shape.nm },\n        mn: { value: shape.mn },\n      })\n\n      view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup))\n      view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup))\n      view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup))\n      return interfaceFunction\n    }\n    function defaultInterfaceFactory() {\n      function interfaceFunction() {\n        return null\n      }\n      return interfaceFunction\n    }\n\n    function strokeInterfaceFactory(shape, view, propertyGroup) {\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup)\n      function addPropertyToDashOb(i) {\n        Object.defineProperty(dashOb, shape.d[i].nm, {\n          get: ExpressionPropertyInterface(view.d.dataProps[i].p),\n        })\n      }\n      var i\n      var len = shape.d ? shape.d.length : 0\n      var dashOb = {}\n      for (i = 0; i < len; i += 1) {\n        addPropertyToDashOb(i)\n        view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup)\n      }\n\n      function interfaceFunction(val) {\n        if (val === 'Color' || val === 'color') {\n          return interfaceFunction.color\n        }\n        if (val === 'Opacity' || val === 'opacity') {\n          return interfaceFunction.opacity\n        }\n        if (val === 'Stroke Width' || val === 'stroke width') {\n          return interfaceFunction.strokeWidth\n        }\n        return null\n      }\n      Object.defineProperties(interfaceFunction, {\n        color: {\n          get: ExpressionPropertyInterface(view.c),\n        },\n        opacity: {\n          get: ExpressionPropertyInterface(view.o),\n        },\n        strokeWidth: {\n          get: ExpressionPropertyInterface(view.w),\n        },\n        dash: {\n          get: function () {\n            return dashOb\n          },\n        },\n        _name: { value: shape.nm },\n        mn: { value: shape.mn },\n      })\n\n      view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup))\n      view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup))\n      view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup))\n      return interfaceFunction\n    }\n\n    function trimInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(val) {\n        if (val === shape.e.ix || val === 'End' || val === 'end') {\n          return interfaceFunction.end\n        }\n        if (val === shape.s.ix) {\n          return interfaceFunction.start\n        }\n        if (val === shape.o.ix) {\n          return interfaceFunction.offset\n        }\n        return null\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      interfaceFunction.propertyIndex = shape.ix\n\n      view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup))\n      view.e.setGroupProperty(PropertyInterface('End', _propertyGroup))\n      view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup))\n      interfaceFunction.propertyIndex = shape.ix\n      interfaceFunction.propertyGroup = propertyGroup\n\n      Object.defineProperties(interfaceFunction, {\n        start: {\n          get: ExpressionPropertyInterface(view.s),\n        },\n        end: {\n          get: ExpressionPropertyInterface(view.e),\n        },\n        offset: {\n          get: ExpressionPropertyInterface(view.o),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    function transformInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.a.ix === value || value === 'Anchor Point') {\n          return interfaceFunction.anchorPoint\n        }\n        if (shape.o.ix === value || value === 'Opacity') {\n          return interfaceFunction.opacity\n        }\n        if (shape.p.ix === value || value === 'Position') {\n          return interfaceFunction.position\n        }\n        if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {\n          return interfaceFunction.rotation\n        }\n        if (shape.s.ix === value || value === 'Scale') {\n          return interfaceFunction.scale\n        }\n        if ((shape.sk && shape.sk.ix === value) || value === 'Skew') {\n          return interfaceFunction.skew\n        }\n        if ((shape.sa && shape.sa.ix === value) || value === 'Skew Axis') {\n          return interfaceFunction.skewAxis\n        }\n        return null\n      }\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup))\n      view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup))\n      view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup))\n      view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup))\n      view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup))\n      if (view.transform.mProps.sk) {\n        view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup))\n        view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup))\n      }\n      view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup))\n      Object.defineProperties(interfaceFunction, {\n        opacity: {\n          get: ExpressionPropertyInterface(view.transform.mProps.o),\n        },\n        position: {\n          get: ExpressionPropertyInterface(view.transform.mProps.p),\n        },\n        anchorPoint: {\n          get: ExpressionPropertyInterface(view.transform.mProps.a),\n        },\n        scale: {\n          get: ExpressionPropertyInterface(view.transform.mProps.s),\n        },\n        rotation: {\n          get: ExpressionPropertyInterface(view.transform.mProps.r),\n        },\n        skew: {\n          get: ExpressionPropertyInterface(view.transform.mProps.sk),\n        },\n        skewAxis: {\n          get: ExpressionPropertyInterface(view.transform.mProps.sa),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.ty = 'tr'\n      interfaceFunction.mn = shape.mn\n      interfaceFunction.propertyGroup = propertyGroup\n      return interfaceFunction\n    }\n\n    function ellipseInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position\n        }\n        if (shape.s.ix === value) {\n          return interfaceFunction.size\n        }\n        return null\n      }\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      interfaceFunction.propertyIndex = shape.ix\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh\n      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup))\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup))\n\n      Object.defineProperties(interfaceFunction, {\n        size: {\n          get: ExpressionPropertyInterface(prop.s),\n        },\n        position: {\n          get: ExpressionPropertyInterface(prop.p),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    function starInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position\n        }\n        if (shape.r.ix === value) {\n          return interfaceFunction.rotation\n        }\n        if (shape.pt.ix === value) {\n          return interfaceFunction.points\n        }\n        if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {\n          return interfaceFunction.outerRadius\n        }\n        if (shape.os.ix === value) {\n          return interfaceFunction.outerRoundness\n        }\n        if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {\n          return interfaceFunction.innerRadius\n        }\n        if (shape.is && shape.is.ix === value) {\n          return interfaceFunction.innerRoundness\n        }\n        return null\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh\n      interfaceFunction.propertyIndex = shape.ix\n      prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup))\n      prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup))\n      prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup))\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup))\n      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup))\n      if (shape.ir) {\n        prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup))\n        prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup))\n      }\n\n      Object.defineProperties(interfaceFunction, {\n        position: {\n          get: ExpressionPropertyInterface(prop.p),\n        },\n        rotation: {\n          get: ExpressionPropertyInterface(prop.r),\n        },\n        points: {\n          get: ExpressionPropertyInterface(prop.pt),\n        },\n        outerRadius: {\n          get: ExpressionPropertyInterface(prop.or),\n        },\n        outerRoundness: {\n          get: ExpressionPropertyInterface(prop.os),\n        },\n        innerRadius: {\n          get: ExpressionPropertyInterface(prop.ir),\n        },\n        innerRoundness: {\n          get: ExpressionPropertyInterface(prop.is),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    function rectInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.p.ix === value) {\n          return interfaceFunction.position\n        }\n        if (shape.r.ix === value) {\n          return interfaceFunction.roundness\n        }\n        if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {\n          return interfaceFunction.size\n        }\n        return null\n      }\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n\n      var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh\n      interfaceFunction.propertyIndex = shape.ix\n      prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup))\n      prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup))\n      prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup))\n\n      Object.defineProperties(interfaceFunction, {\n        position: {\n          get: ExpressionPropertyInterface(prop.p),\n        },\n        roundness: {\n          get: ExpressionPropertyInterface(prop.r),\n        },\n        size: {\n          get: ExpressionPropertyInterface(prop.s),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    function roundedInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.r.ix === value || value === 'Round Corners 1') {\n          return interfaceFunction.radius\n        }\n        return null\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      var prop = view\n      interfaceFunction.propertyIndex = shape.ix\n      prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup))\n\n      Object.defineProperties(interfaceFunction, {\n        radius: {\n          get: ExpressionPropertyInterface(prop.rd),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    function repeaterInterfaceFactory(shape, view, propertyGroup) {\n      function interfaceFunction(value) {\n        if (shape.c.ix === value || value === 'Copies') {\n          return interfaceFunction.copies\n        }\n        if (shape.o.ix === value || value === 'Offset') {\n          return interfaceFunction.offset\n        }\n        return null\n      }\n\n      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup)\n      var prop = view\n      interfaceFunction.propertyIndex = shape.ix\n      prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup))\n      prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup))\n      Object.defineProperties(interfaceFunction, {\n        copies: {\n          get: ExpressionPropertyInterface(prop.c),\n        },\n        offset: {\n          get: ExpressionPropertyInterface(prop.o),\n        },\n        _name: { value: shape.nm },\n      })\n      interfaceFunction.mn = shape.mn\n      return interfaceFunction\n    }\n\n    return function (shapes, view, propertyGroup) {\n      var interfaces\n      function _interfaceFunction(value) {\n        if (typeof value === 'number') {\n          value = value === undefined ? 1 : value\n          if (value === 0) {\n            return propertyGroup\n          }\n          return interfaces[value - 1]\n        }\n        var i = 0\n        var len = interfaces.length\n        while (i < len) {\n          if (interfaces[i]._name === value) {\n            return interfaces[i]\n          }\n          i += 1\n        }\n        return null\n      }\n      function parentGroupWrapper() {\n        return propertyGroup\n      }\n      _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper)\n      interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup)\n      _interfaceFunction.numProperties = interfaces.length\n      _interfaceFunction._name = 'Contents'\n      return _interfaceFunction\n    }\n  })()\n\n  const TextExpressionInterface = (function () {\n    return function (elem) {\n      var _prevValue\n      var _sourceText\n      function _thisLayerFunction(name) {\n        switch (name) {\n          case 'ADBE Text Document':\n            return _thisLayerFunction.sourceText\n          default:\n            return null\n        }\n      }\n      Object.defineProperty(_thisLayerFunction, 'sourceText', {\n        get: function () {\n          elem.textProperty.getValue()\n          var stringValue = elem.textProperty.currentData.t\n          if (stringValue !== _prevValue) {\n            elem.textProperty.currentData.t = _prevValue\n            _sourceText = new String(stringValue) // eslint-disable-line no-new-wrappers\n            // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\n            _sourceText.value = stringValue || new String(stringValue) // eslint-disable-line no-new-wrappers\n          }\n          return _sourceText\n        },\n      })\n      return _thisLayerFunction\n    }\n  })()\n\n  const getBlendMode = (function () {\n    var blendModeEnums = {\n      0: 'source-over',\n      1: 'multiply',\n      2: 'screen',\n      3: 'overlay',\n      4: 'darken',\n      5: 'lighten',\n      6: 'color-dodge',\n      7: 'color-burn',\n      8: 'hard-light',\n      9: 'soft-light',\n      10: 'difference',\n      11: 'exclusion',\n      12: 'hue',\n      13: 'saturation',\n      14: 'color',\n      15: 'luminosity',\n    }\n\n    return function (mode) {\n      return blendModeEnums[mode] || ''\n    }\n  })()\n\n  function SliderEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)\n  }\n  function AngleEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)\n  }\n  function ColorEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container)\n  }\n  function PointEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container)\n  }\n  function LayerIndexEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)\n  }\n  function MaskIndexEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)\n  }\n  function CheckboxEffect(data, elem, container) {\n    this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)\n  }\n  function NoValueEffect() {\n    this.p = {}\n  }\n\n  function EffectsManager(data, element) {\n    var effects = data.ef || []\n    this.effectElements = []\n    var i\n    var len = effects.length\n    var effectItem\n    for (i = 0; i < len; i += 1) {\n      effectItem = new GroupEffect(effects[i], element)\n      this.effectElements.push(effectItem)\n    }\n  }\n\n  function GroupEffect(data, element) {\n    this.init(data, element)\n  }\n\n  extendPrototype([DynamicPropertyContainer], GroupEffect)\n\n  GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties\n\n  GroupEffect.prototype.init = function (data, element) {\n    this.data = data\n    this.effectElements = []\n    this.initDynamicPropertyContainer(element)\n    var i\n    var len = this.data.ef.length\n    var eff\n    var effects = this.data.ef\n    for (i = 0; i < len; i += 1) {\n      eff = null\n      switch (effects[i].ty) {\n        case 0:\n          eff = new SliderEffect(effects[i], element, this)\n          break\n        case 1:\n          eff = new AngleEffect(effects[i], element, this)\n          break\n        case 2:\n          eff = new ColorEffect(effects[i], element, this)\n          break\n        case 3:\n          eff = new PointEffect(effects[i], element, this)\n          break\n        case 4:\n        case 7:\n          eff = new CheckboxEffect(effects[i], element, this)\n          break\n        case 10:\n          eff = new LayerIndexEffect(effects[i], element, this)\n          break\n        case 11:\n          eff = new MaskIndexEffect(effects[i], element, this)\n          break\n        case 5:\n          eff = new EffectsManager(effects[i], element, this)\n          break\n        // case 6:\n        default:\n          eff = new NoValueEffect(effects[i], element, this)\n          break\n      }\n      if (eff) {\n        this.effectElements.push(eff)\n      }\n    }\n  }\n\n  function BaseElement() {}\n\n  BaseElement.prototype = {\n    checkMasks: function () {\n      if (!this.data.hasMask) {\n        return false\n      }\n      var i = 0\n      var len = this.data.masksProperties.length\n      while (i < len) {\n        if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {\n          return true\n        }\n        i += 1\n      }\n      return false\n    },\n    initExpressions: function () {\n      this.layerInterface = LayerExpressionInterface(this)\n      if (this.data.hasMask && this.maskManager) {\n        this.layerInterface.registerMaskInterface(this.maskManager)\n      }\n      var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface)\n      this.layerInterface.registerEffectsInterface(effectsInterface)\n\n      if (this.data.ty === 0 || this.data.xt) {\n        this.compInterface = CompExpressionInterface(this)\n      } else if (this.data.ty === 4) {\n        this.layerInterface.shapeInterface = ShapeExpressionInterface(\n          this.shapesData,\n          this.itemsData,\n          this.layerInterface,\n        )\n        this.layerInterface.content = this.layerInterface.shapeInterface\n      } else if (this.data.ty === 5) {\n        this.layerInterface.textInterface = TextExpressionInterface(this)\n        this.layerInterface.text = this.layerInterface.textInterface\n      }\n    },\n    setBlendMode: function () {\n      var blendModeValue = getBlendMode(this.data.bm)\n      var elem = this.baseElement || this.layerElement\n\n      elem.style['mix-blend-mode'] = blendModeValue\n    },\n    initBaseData: function (data, globalData, comp) {\n      this.globalData = globalData\n      this.comp = comp\n      this.data = data\n      this.layerId = createElementID()\n\n      // Stretch factor for old animations missing this property.\n      if (!this.data.sr) {\n        this.data.sr = 1\n      }\n      // effects manager\n      this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)\n    },\n    getType: function () {\n      return this.type\n    },\n    sourceRectAtTime: function () {},\n  }\n\n  /**\n   * @file\n   * Handles element's layer frame update.\n   * Checks layer in point and out point\n   *\n   */\n\n  function FrameElement() {}\n\n  FrameElement.prototype = {\n    /**\n     * @function\n     * Initializes frame related properties.\n     *\n     */\n    initFrame: function () {\n      // set to true when inpoint is rendered\n      this._isFirstFrame = false\n      // list of animated properties\n      this.dynamicProperties = []\n      // If layer has been modified in current tick this will be true\n      this._mdf = false\n    },\n    /**\n     * @function\n     * Calculates all dynamic values\n     *\n     * @param {number} num\n     * current frame number in Layer's time\n     * @param {boolean} isVisible\n     * if layers is currently in range\n     *\n     */\n    prepareProperties: function (num, isVisible) {\n      var i\n      var len = this.dynamicProperties.length\n      for (i = 0; i < len; i += 1) {\n        if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {\n          this.dynamicProperties[i].getValue()\n          if (this.dynamicProperties[i]._mdf) {\n            this.globalData._mdf = true\n            this._mdf = true\n          }\n        }\n      }\n    },\n    addDynamicProperty: function (prop) {\n      if (this.dynamicProperties.indexOf(prop) === -1) {\n        this.dynamicProperties.push(prop)\n      }\n    },\n  }\n\n  const FootageInterface = (function () {\n    var outlineInterfaceFactory = function (elem) {\n      var currentPropertyName = ''\n      var currentProperty = elem.getFootageData()\n      function init() {\n        currentPropertyName = ''\n        currentProperty = elem.getFootageData()\n        return searchProperty\n      }\n      function searchProperty(value) {\n        if (currentProperty[value]) {\n          currentPropertyName = value\n          currentProperty = currentProperty[value]\n          if (typeof currentProperty === 'object') {\n            return searchProperty\n          }\n          return currentProperty\n        }\n        var propertyNameIndex = value.indexOf(currentPropertyName)\n        if (propertyNameIndex !== -1) {\n          var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10)\n          currentProperty = currentProperty[index]\n          if (typeof currentProperty === 'object') {\n            return searchProperty\n          }\n          return currentProperty\n        }\n        return ''\n      }\n      return init\n    }\n\n    var dataInterfaceFactory = function (elem) {\n      function interfaceFunction(value) {\n        if (value === 'Outline') {\n          return interfaceFunction.outlineInterface()\n        }\n        return null\n      }\n\n      interfaceFunction._name = 'Outline'\n      interfaceFunction.outlineInterface = outlineInterfaceFactory(elem)\n      return interfaceFunction\n    }\n\n    return function (elem) {\n      function _interfaceFunction(value) {\n        if (value === 'Data') {\n          return _interfaceFunction.dataInterface\n        }\n        return null\n      }\n\n      _interfaceFunction._name = 'Data'\n      _interfaceFunction.dataInterface = dataInterfaceFactory(elem)\n      return _interfaceFunction\n    }\n  })()\n\n  function FootageElement(data, globalData, comp) {\n    this.initFrame()\n    this.initRenderable()\n    this.assetData = globalData.getAssetData(data.refId)\n    this.footageData = globalData.imageLoader.getAsset(this.assetData)\n    this.initBaseData(data, globalData, comp)\n  }\n\n  FootageElement.prototype.prepareFrame = function () {}\n\n  extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement)\n\n  FootageElement.prototype.getBaseElement = function () {\n    return null\n  }\n\n  FootageElement.prototype.renderFrame = function () {}\n\n  FootageElement.prototype.destroy = function () {}\n\n  FootageElement.prototype.initExpressions = function () {\n    this.layerInterface = FootageInterface(this)\n  }\n\n  FootageElement.prototype.getFootageData = function () {\n    return this.footageData\n  }\n\n  function AudioElement(data, globalData, comp) {\n    this.initFrame()\n    this.initRenderable()\n    this.assetData = globalData.getAssetData(data.refId)\n    this.initBaseData(data, globalData, comp)\n    this._isPlaying = false\n    this._canPlay = false\n    var assetPath = this.globalData.getAssetsPath(this.assetData)\n    this.audio = this.globalData.audioController.createAudio(assetPath)\n    this._currentTime = 0\n    this.globalData.audioController.addAudio(this)\n    this._volumeMultiplier = 1\n    this._volume = 1\n    this._previousVolume = null\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true }\n    this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : { k: [100] }, 1, 0.01, this)\n  }\n\n  AudioElement.prototype.prepareFrame = function (num) {\n    this.prepareRenderableFrame(num, true)\n    this.prepareProperties(num, true)\n    if (!this.tm._placeholder) {\n      var timeRemapped = this.tm.v\n      this._currentTime = timeRemapped\n    } else {\n      this._currentTime = num / this.data.sr\n    }\n    this._volume = this.lv.v[0]\n    var totalVolume = this._volume * this._volumeMultiplier\n    if (this._previousVolume !== totalVolume) {\n      this._previousVolume = totalVolume\n      this.audio.volume(totalVolume)\n    }\n  }\n\n  extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement)\n\n  AudioElement.prototype.renderFrame = function () {\n    if (this.isInRange && this._canPlay) {\n      if (!this._isPlaying) {\n        this.audio.play()\n        this.audio.seek(this._currentTime / this.globalData.frameRate)\n        this._isPlaying = true\n      } else if (\n        !this.audio.playing() ||\n        Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1\n      ) {\n        this.audio.seek(this._currentTime / this.globalData.frameRate)\n      }\n    }\n  }\n\n  AudioElement.prototype.show = function () {\n    // this.audio.play()\n  }\n\n  AudioElement.prototype.hide = function () {\n    this.audio.pause()\n    this._isPlaying = false\n  }\n\n  AudioElement.prototype.pause = function () {\n    this.audio.pause()\n    this._isPlaying = false\n    this._canPlay = false\n  }\n\n  AudioElement.prototype.resume = function () {\n    this._canPlay = true\n  }\n\n  AudioElement.prototype.setRate = function (rateValue) {\n    this.audio.rate(rateValue)\n  }\n\n  AudioElement.prototype.volume = function (volumeValue) {\n    this._volumeMultiplier = volumeValue\n    this._previousVolume = volumeValue * this._volume\n    this.audio.volume(this._previousVolume)\n  }\n\n  AudioElement.prototype.getBaseElement = function () {\n    return null\n  }\n\n  AudioElement.prototype.destroy = function () {}\n\n  AudioElement.prototype.sourceRectAtTime = function () {}\n\n  AudioElement.prototype.initExpressions = function () {}\n\n  function BaseRenderer() {}\n  BaseRenderer.prototype.checkLayers = function (num) {\n    var i\n    var len = this.layers.length\n    var data\n    this.completeLayers = true\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (!this.elements[i]) {\n        data = this.layers[i]\n        if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {\n          this.buildItem(i)\n        }\n      }\n      this.completeLayers = this.elements[i] ? this.completeLayers : false\n    }\n    this.checkPendingElements()\n  }\n\n  BaseRenderer.prototype.createItem = function (layer) {\n    switch (layer.ty) {\n      case 2:\n        return this.createImage(layer)\n      case 0:\n        return this.createComp(layer)\n      case 1:\n        return this.createSolid(layer)\n      case 3:\n        return this.createNull(layer)\n      case 4:\n        return this.createShape(layer)\n      case 5:\n        return this.createText(layer)\n      case 6:\n        return this.createAudio(layer)\n      case 13:\n        return this.createCamera(layer)\n      case 15:\n        return this.createFootage(layer)\n      default:\n        return this.createNull(layer)\n    }\n  }\n\n  BaseRenderer.prototype.createCamera = function () {\n    throw new Error(\"You're using a 3d camera. Try the html renderer.\")\n  }\n\n  BaseRenderer.prototype.createAudio = function (data) {\n    return new AudioElement(data, this.globalData, this)\n  }\n\n  BaseRenderer.prototype.createFootage = function (data) {\n    return new FootageElement(data, this.globalData, this)\n  }\n\n  BaseRenderer.prototype.buildAllItems = function () {\n    var i\n    var len = this.layers.length\n    for (i = 0; i < len; i += 1) {\n      this.buildItem(i)\n    }\n    this.checkPendingElements()\n  }\n\n  BaseRenderer.prototype.includeLayers = function (newLayers) {\n    this.completeLayers = false\n    var i\n    var len = newLayers.length\n    var j\n    var jLen = this.layers.length\n    for (i = 0; i < len; i += 1) {\n      j = 0\n      while (j < jLen) {\n        if (this.layers[j].id === newLayers[i].id) {\n          this.layers[j] = newLayers[i]\n          break\n        }\n        j += 1\n      }\n    }\n  }\n\n  BaseRenderer.prototype.setProjectInterface = function (pInterface) {\n    this.globalData.projectInterface = pInterface\n  }\n\n  BaseRenderer.prototype.initItems = function () {\n    if (!this.globalData.progressiveLoad) {\n      this.buildAllItems()\n    }\n  }\n  BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {\n    var elements = this.elements\n    var layers = this.layers\n    var i = 0\n    var len = layers.length\n    while (i < len) {\n      if (layers[i].ind == parentName) {\n        // eslint-disable-line eqeqeq\n        if (!elements[i] || elements[i] === true) {\n          this.buildItem(i)\n          this.addPendingElement(element)\n        } else {\n          hierarchy.push(elements[i])\n          elements[i].setAsParent()\n          if (layers[i].parent !== undefined) {\n            this.buildElementParenting(element, layers[i].parent, hierarchy)\n          } else {\n            element.setHierarchy(hierarchy)\n          }\n        }\n      }\n      i += 1\n    }\n  }\n\n  BaseRenderer.prototype.addPendingElement = function (element) {\n    this.pendingElements.push(element)\n  }\n\n  BaseRenderer.prototype.searchExtraCompositions = function (assets) {\n    var i\n    var len = assets.length\n    for (i = 0; i < len; i += 1) {\n      if (assets[i].xt) {\n        var comp = this.createComp(assets[i])\n        comp.initExpressions()\n        this.globalData.projectInterface.registerComposition(comp)\n      }\n    }\n  }\n\n  BaseRenderer.prototype.getElementByPath = function (path) {\n    var pathValue = path.shift()\n    var element\n    if (typeof pathValue === 'number') {\n      element = this.elements[pathValue]\n    } else {\n      var i\n      var len = this.elements.length\n      for (i = 0; i < len; i += 1) {\n        if (this.elements[i].data.nm === pathValue) {\n          element = this.elements[i]\n          break\n        }\n      }\n    }\n    if (path.length === 0) {\n      return element\n    }\n    return element.getElementByPath(path)\n  }\n\n  BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {\n    this.globalData.fontManager = new FontManager()\n    this.globalData.fontManager.addChars(animData.chars)\n    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer)\n    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem)\n    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem)\n    this.globalData.imageLoader = this.animationItem.imagePreloader\n    this.globalData.audioController = this.animationItem.audioController\n    this.globalData.frameId = 0\n    this.globalData.frameRate = animData.fr\n    this.globalData.nm = animData.nm\n    this.globalData.compSize = {\n      w: animData.w,\n      h: animData.h,\n    }\n  }\n\n  function TransformElement() {}\n\n  TransformElement.prototype = {\n    initTransform: function () {\n      this.finalTransform = {\n        mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },\n        _matMdf: false,\n        _opMdf: false,\n        mat: new Matrix(),\n      }\n      if (this.data.ao) {\n        this.finalTransform.mProp.autoOriented = true\n      }\n\n      // TODO: check TYPE 11: Guided elements\n      if (this.data.ty !== 11) {\n        // this.createElements();\n      }\n    },\n    renderTransform: function () {\n      this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame\n      this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame\n\n      if (this.hierarchy) {\n        var mat\n        var finalMat = this.finalTransform.mat\n        var i = 0\n        var len = this.hierarchy.length\n        // Checking if any of the transformation matrices in the hierarchy chain has changed.\n        if (!this.finalTransform._matMdf) {\n          while (i < len) {\n            if (this.hierarchy[i].finalTransform.mProp._mdf) {\n              this.finalTransform._matMdf = true\n              break\n            }\n            i += 1\n          }\n        }\n\n        if (this.finalTransform._matMdf) {\n          mat = this.finalTransform.mProp.v.props\n          finalMat.cloneFromProps(mat)\n          for (i = 0; i < len; i += 1) {\n            mat = this.hierarchy[i].finalTransform.mProp.v.props\n            finalMat.transform(\n              mat[0],\n              mat[1],\n              mat[2],\n              mat[3],\n              mat[4],\n              mat[5],\n              mat[6],\n              mat[7],\n              mat[8],\n              mat[9],\n              mat[10],\n              mat[11],\n              mat[12],\n              mat[13],\n              mat[14],\n              mat[15],\n            )\n          }\n        }\n      }\n    },\n    globalToLocal: function (pt) {\n      var transforms = []\n      transforms.push(this.finalTransform)\n      var flag = true\n      var comp = this.comp\n      while (flag) {\n        if (comp.finalTransform) {\n          if (comp.data.hasMask) {\n            transforms.splice(0, 0, comp.finalTransform)\n          }\n          comp = comp.comp\n        } else {\n          flag = false\n        }\n      }\n      var i\n      var len = transforms.length\n      var ptNew\n      for (i = 0; i < len; i += 1) {\n        ptNew = transforms[i].mat.applyToPointArray(0, 0, 0)\n        // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\n        pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0]\n      }\n      return pt\n    },\n    mHelper: new Matrix(),\n  }\n\n  function MaskElement(data, element, globalData) {\n    this.data = data\n    this.element = element\n    this.globalData = globalData\n    this.storedData = []\n    this.masksProperties = this.data.masksProperties || []\n    this.maskElement = null\n    var defs = this.globalData.defs\n    var i\n    var len = this.masksProperties ? this.masksProperties.length : 0\n    this.viewData = createSizedArray(len)\n    this.solidPath = ''\n\n    var path\n    var properties = this.masksProperties\n    var count = 0\n    var currentMasks = []\n    var j\n    var jLen\n    var layerId = createElementID()\n    var rect\n    var expansor\n    var feMorph\n    var x\n    var maskType = 'clipPath'\n    var maskRef = 'clip-path'\n    for (i = 0; i < len; i += 1) {\n      if (\n        (properties[i].mode !== 'a' && properties[i].mode !== 'n') ||\n        properties[i].inv ||\n        properties[i].o.k !== 100 ||\n        properties[i].o.x\n      ) {\n        maskType = 'mask'\n        maskRef = 'mask'\n      }\n\n      if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {\n        rect = createNS('rect')\n        rect.setAttribute('fill', '#ffffff')\n        rect.setAttribute('width', this.element.comp.data.w || 0)\n        rect.setAttribute('height', this.element.comp.data.h || 0)\n        currentMasks.push(rect)\n      } else {\n        rect = null\n      }\n\n      path = createNS('path')\n      if (properties[i].mode === 'n') {\n        // TODO move this to a factory or to a constructor\n        this.viewData[i] = {\n          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n          elem: path,\n          lastPath: '',\n        }\n        defs.appendChild(path)\n      } else {\n        count += 1\n\n        path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff')\n        path.setAttribute('clip-rule', 'nonzero')\n        var filterID\n\n        if (properties[i].x.k !== 0) {\n          maskType = 'mask'\n          maskRef = 'mask'\n          x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element)\n          filterID = createElementID()\n          expansor = createNS('filter')\n          expansor.setAttribute('id', filterID)\n          feMorph = createNS('feMorphology')\n          feMorph.setAttribute('operator', 'erode')\n          feMorph.setAttribute('in', 'SourceGraphic')\n          feMorph.setAttribute('radius', '0')\n          expansor.appendChild(feMorph)\n          defs.appendChild(expansor)\n          path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff')\n        } else {\n          feMorph = null\n          x = null\n        }\n\n        // TODO move this to a factory or to a constructor\n        this.storedData[i] = {\n          elem: path,\n          x: x,\n          expan: feMorph,\n          lastPath: '',\n          lastOperator: '',\n          filterId: filterID,\n          lastRadius: 0,\n        }\n        if (properties[i].mode === 'i') {\n          jLen = currentMasks.length\n          var g = createNS('g')\n          for (j = 0; j < jLen; j += 1) {\n            g.appendChild(currentMasks[j])\n          }\n          var mask = createNS('mask')\n          mask.setAttribute('mask-type', 'alpha')\n          mask.setAttribute('id', layerId + '_' + count)\n          mask.appendChild(path)\n          defs.appendChild(mask)\n          g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')')\n\n          currentMasks.length = 0\n          currentMasks.push(g)\n        } else {\n          currentMasks.push(path)\n        }\n        if (properties[i].inv && !this.solidPath) {\n          this.solidPath = this.createLayerSolidPath()\n        }\n        // TODO move this to a factory or to a constructor\n        this.viewData[i] = {\n          elem: path,\n          lastPath: '',\n          op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n          prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n          invRect: rect,\n        }\n        if (!this.viewData[i].prop.k) {\n          this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i])\n        }\n      }\n    }\n\n    this.maskElement = createNS(maskType)\n\n    len = currentMasks.length\n    for (i = 0; i < len; i += 1) {\n      this.maskElement.appendChild(currentMasks[i])\n    }\n\n    if (count > 0) {\n      this.maskElement.setAttribute('id', layerId)\n      this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')')\n      defs.appendChild(this.maskElement)\n    }\n    if (this.viewData.length) {\n      this.element.addRenderableComponent(this)\n    }\n  }\n\n  MaskElement.prototype.getMaskProperty = function (pos) {\n    return this.viewData[pos].prop\n  }\n\n  MaskElement.prototype.renderFrame = function (isFirstFrame) {\n    var finalMat = this.element.finalTransform.mat\n    var i\n    var len = this.masksProperties.length\n    for (i = 0; i < len; i += 1) {\n      if (this.viewData[i].prop._mdf || isFirstFrame) {\n        this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i])\n      }\n      if (this.viewData[i].op._mdf || isFirstFrame) {\n        this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v)\n      }\n      if (this.masksProperties[i].mode !== 'n') {\n        if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {\n          this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS())\n        }\n        if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {\n          var feMorph = this.storedData[i].expan\n          if (this.storedData[i].x.v < 0) {\n            if (this.storedData[i].lastOperator !== 'erode') {\n              this.storedData[i].lastOperator = 'erode'\n              this.storedData[i].elem.setAttribute(\n                'filter',\n                'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')',\n              )\n            }\n            feMorph.setAttribute('radius', -this.storedData[i].x.v)\n          } else {\n            if (this.storedData[i].lastOperator !== 'dilate') {\n              this.storedData[i].lastOperator = 'dilate'\n              this.storedData[i].elem.setAttribute('filter', null)\n            }\n            this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2)\n          }\n        }\n      }\n    }\n  }\n\n  MaskElement.prototype.getMaskelement = function () {\n    return this.maskElement\n  }\n\n  MaskElement.prototype.createLayerSolidPath = function () {\n    var path = 'M0,0 '\n    path += ' h' + this.globalData.compSize.w\n    path += ' v' + this.globalData.compSize.h\n    path += ' h-' + this.globalData.compSize.w\n    path += ' v-' + this.globalData.compSize.h + ' '\n    return path\n  }\n\n  MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {\n    var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1]\n    var i\n    var len\n    len = pathNodes._length\n    for (i = 1; i < len; i += 1) {\n      // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \" \"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\n      pathString +=\n        ' C' +\n        pathNodes.o[i - 1][0] +\n        ',' +\n        pathNodes.o[i - 1][1] +\n        ' ' +\n        pathNodes.i[i][0] +\n        ',' +\n        pathNodes.i[i][1] +\n        ' ' +\n        pathNodes.v[i][0] +\n        ',' +\n        pathNodes.v[i][1]\n    }\n    // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \" \"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\n    if (pathNodes.c && len > 1) {\n      pathString +=\n        ' C' +\n        pathNodes.o[i - 1][0] +\n        ',' +\n        pathNodes.o[i - 1][1] +\n        ' ' +\n        pathNodes.i[0][0] +\n        ',' +\n        pathNodes.i[0][1] +\n        ' ' +\n        pathNodes.v[0][0] +\n        ',' +\n        pathNodes.v[0][1]\n    }\n    // pathNodes.__renderedString = pathString;\n\n    if (viewData.lastPath !== pathString) {\n      var pathShapeValue = ''\n      if (viewData.elem) {\n        if (pathNodes.c) {\n          pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString\n        }\n        viewData.elem.setAttribute('d', pathShapeValue)\n      }\n      viewData.lastPath = pathString\n    }\n  }\n\n  MaskElement.prototype.destroy = function () {\n    this.element = null\n    this.globalData = null\n    this.maskElement = null\n    this.data = null\n    this.masksProperties = null\n  }\n\n  const filtersFactory = (function () {\n    var ob = {}\n    ob.createFilter = createFilter\n    ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter\n\n    function createFilter(filId, skipCoordinates) {\n      var fil = createNS('filter')\n      fil.setAttribute('id', filId)\n      if (skipCoordinates !== true) {\n        fil.setAttribute('filterUnits', 'objectBoundingBox')\n        fil.setAttribute('x', '0%')\n        fil.setAttribute('y', '0%')\n        fil.setAttribute('width', '100%')\n        fil.setAttribute('height', '100%')\n      }\n      return fil\n    }\n\n    function createAlphaToLuminanceFilter() {\n      var feColorMatrix = createNS('feColorMatrix')\n      feColorMatrix.setAttribute('type', 'matrix')\n      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB')\n      feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1')\n      return feColorMatrix\n    }\n\n    return ob\n  })()\n\n  const featureSupport = (function () {\n    var ob = {\n      maskType: true,\n    }\n    if (\n      /MSIE 10/i.test(navigator.userAgent) ||\n      /MSIE 9/i.test(navigator.userAgent) ||\n      /rv:11.0/i.test(navigator.userAgent) ||\n      /Edge\\/\\d./i.test(navigator.userAgent)\n    ) {\n      ob.maskType = false\n    }\n    return ob\n  })()\n\n  var registeredEffects = {}\n  var idPrefix = 'filter_result_'\n\n  function SVGEffects(elem) {\n    var i\n    var source = 'SourceGraphic'\n    var len = elem.data.ef ? elem.data.ef.length : 0\n    var filId = createElementID()\n    var fil = filtersFactory.createFilter(filId, true)\n    var count = 0\n    this.filters = []\n    var filterManager\n    for (i = 0; i < len; i += 1) {\n      filterManager = null\n      var type = elem.data.ef[i].ty\n      if (registeredEffects[type]) {\n        var Effect = registeredEffects[type].effect\n        filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source)\n        source = idPrefix + count\n        if (registeredEffects[type].countsAsEffect) {\n          count += 1\n        }\n      }\n      if (filterManager) {\n        this.filters.push(filterManager)\n      }\n    }\n    if (count) {\n      elem.globalData.defs.appendChild(fil)\n      elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')')\n    }\n    if (this.filters.length) {\n      elem.addRenderableComponent(this)\n    }\n  }\n\n  SVGEffects.prototype.renderFrame = function (_isFirstFrame) {\n    var i\n    var len = this.filters.length\n    for (i = 0; i < len; i += 1) {\n      this.filters[i].renderFrame(_isFirstFrame)\n    }\n  }\n\n  function registerEffect(id, effect, countsAsEffect) {\n    registeredEffects[id] = {\n      effect,\n      countsAsEffect,\n    }\n  }\n\n  function SVGBaseElement() {}\n\n  SVGBaseElement.prototype = {\n    initRendererElement: function () {\n      this.layerElement = createNS('g')\n    },\n    createContainerElements: function () {\n      this.matteElement = createNS('g')\n      this.transformedElement = this.layerElement\n      this.maskedElement = this.layerElement\n      this._sizeChanged = false\n      var layerElementParent = null\n      // If this layer acts as a mask for the following layer\n      var filId\n      var fil\n      var gg\n      if (this.data.td) {\n        if (this.data.td == 3 || this.data.td == 1) {\n          // eslint-disable-line eqeqeq\n          var masker = createNS('mask')\n          masker.setAttribute('id', this.layerId)\n          masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha') // eslint-disable-line eqeqeq\n          masker.appendChild(this.layerElement)\n          layerElementParent = masker\n          this.globalData.defs.appendChild(masker)\n          // This is only for IE and Edge when mask if of type alpha\n          if (!featureSupport.maskType && this.data.td == 1) {\n            // eslint-disable-line eqeqeq\n            masker.setAttribute('mask-type', 'luminance')\n            filId = createElementID()\n            fil = filtersFactory.createFilter(filId)\n            this.globalData.defs.appendChild(fil)\n            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter())\n            gg = createNS('g')\n            gg.appendChild(this.layerElement)\n            layerElementParent = gg\n            masker.appendChild(gg)\n            gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')')\n          }\n        } else if (this.data.td == 2) {\n          // eslint-disable-line eqeqeq\n          var maskGroup = createNS('mask')\n          maskGroup.setAttribute('id', this.layerId)\n          maskGroup.setAttribute('mask-type', 'alpha')\n          var maskGrouper = createNS('g')\n          maskGroup.appendChild(maskGrouper)\n          filId = createElementID()\n          fil = filtersFactory.createFilter(filId)\n          /// /\n\n          // This solution doesn't work on Android when meta tag with viewport attribute is set\n          /* var feColorMatrix = createNS('feColorMatrix');\n                feColorMatrix.setAttribute('type', 'matrix');\n                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n                feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');\n                fil.appendChild(feColorMatrix); */\n          /// /\n          var feCTr = createNS('feComponentTransfer')\n          feCTr.setAttribute('in', 'SourceGraphic')\n          fil.appendChild(feCTr)\n          var feFunc = createNS('feFuncA')\n          feFunc.setAttribute('type', 'table')\n          feFunc.setAttribute('tableValues', '1.0 0.0')\n          feCTr.appendChild(feFunc)\n          /// /\n          this.globalData.defs.appendChild(fil)\n          var alphaRect = createNS('rect')\n          alphaRect.setAttribute('width', this.comp.data.w)\n          alphaRect.setAttribute('height', this.comp.data.h)\n          alphaRect.setAttribute('x', '0')\n          alphaRect.setAttribute('y', '0')\n          alphaRect.setAttribute('fill', '#ffffff')\n          alphaRect.setAttribute('opacity', '0')\n          maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')')\n          maskGrouper.appendChild(alphaRect)\n          maskGrouper.appendChild(this.layerElement)\n          layerElementParent = maskGrouper\n          if (!featureSupport.maskType) {\n            maskGroup.setAttribute('mask-type', 'luminance')\n            fil.appendChild(filtersFactory.createAlphaToLuminanceFilter())\n            gg = createNS('g')\n            maskGrouper.appendChild(alphaRect)\n            gg.appendChild(this.layerElement)\n            layerElementParent = gg\n            maskGrouper.appendChild(gg)\n          }\n          this.globalData.defs.appendChild(maskGroup)\n        }\n      } else if (this.data.tt) {\n        this.matteElement.appendChild(this.layerElement)\n        layerElementParent = this.matteElement\n        this.baseElement = this.matteElement\n      } else {\n        this.baseElement = this.layerElement\n      }\n      if (this.data.ln) {\n        this.layerElement.setAttribute('id', this.data.ln)\n      }\n      if (this.data.cl) {\n        this.layerElement.setAttribute('class', this.data.cl)\n      }\n      // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\n      if (this.data.ty === 0 && !this.data.hd) {\n        var cp = createNS('clipPath')\n        var pt = createNS('path')\n        pt.setAttribute(\n          'd',\n          'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z',\n        )\n        var clipId = createElementID()\n        cp.setAttribute('id', clipId)\n        cp.appendChild(pt)\n        this.globalData.defs.appendChild(cp)\n\n        if (this.checkMasks()) {\n          var cpGroup = createNS('g')\n          cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')')\n          cpGroup.appendChild(this.layerElement)\n          this.transformedElement = cpGroup\n          if (layerElementParent) {\n            layerElementParent.appendChild(this.transformedElement)\n          } else {\n            this.baseElement = this.transformedElement\n          }\n        } else {\n          this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')')\n        }\n      }\n      if (this.data.bm !== 0) {\n        this.setBlendMode()\n      }\n    },\n    renderElement: function () {\n      if (this.finalTransform._matMdf) {\n        this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS())\n      }\n      if (this.finalTransform._opMdf) {\n        this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v)\n      }\n    },\n    destroyBaseElement: function () {\n      this.layerElement = null\n      this.matteElement = null\n      this.maskManager.destroy()\n    },\n    getBaseElement: function () {\n      if (this.data.hd) {\n        return null\n      }\n      return this.baseElement\n    },\n    createRenderableComponents: function () {\n      this.maskManager = new MaskElement(this.data, this, this.globalData)\n      this.renderableEffectsManager = new SVGEffects(this)\n    },\n    setMatte: function (id) {\n      if (!this.matteElement) {\n        return\n      }\n      this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')')\n    },\n  }\n\n  /**\n   * @file\n   * Handles AE's layer parenting property.\n   *\n   */\n\n  function HierarchyElement() {}\n\n  HierarchyElement.prototype = {\n    /**\n     * @function\n     * Initializes hierarchy properties\n     *\n     */\n    initHierarchy: function () {\n      // element's parent list\n      this.hierarchy = []\n      // if element is parent of another layer _isParent will be true\n      this._isParent = false\n      this.checkParenting()\n    },\n    /**\n     * @function\n     * Sets layer's hierarchy.\n     * @param {array} hierarch\n     * layer's parent list\n     *\n     */\n    setHierarchy: function (hierarchy) {\n      this.hierarchy = hierarchy\n    },\n    /**\n     * @function\n     * Sets layer as parent.\n     *\n     */\n    setAsParent: function () {\n      this._isParent = true\n    },\n    /**\n     * @function\n     * Searches layer's parenting chain\n     *\n     */\n    checkParenting: function () {\n      if (this.data.parent !== undefined) {\n        this.comp.buildElementParenting(this, this.data.parent, [])\n      }\n    },\n  }\n\n  function RenderableDOMElement() {}\n\n  ;(function () {\n    var _prototype = {\n      initElement: function (data, globalData, comp) {\n        this.initFrame()\n        this.initBaseData(data, globalData, comp)\n        this.initTransform(data, globalData, comp)\n        this.initHierarchy()\n        this.initRenderable()\n        this.initRendererElement()\n        this.createContainerElements()\n        this.createRenderableComponents()\n        this.createContent()\n        this.hide()\n      },\n      hide: function () {\n        // console.log('HIDE', this);\n        if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n          var elem = this.baseElement || this.layerElement\n          elem.style.display = 'none'\n          this.hidden = true\n        }\n      },\n      show: function () {\n        // console.log('SHOW', this);\n        if (this.isInRange && !this.isTransparent) {\n          if (!this.data.hd) {\n            var elem = this.baseElement || this.layerElement\n            elem.style.display = 'block'\n          }\n          this.hidden = false\n          this._isFirstFrame = true\n        }\n      },\n      renderFrame: function () {\n        // If it is exported as hidden (data.hd === true) no need to render\n        // If it is not visible no need to render\n        if (this.data.hd || this.hidden) {\n          return\n        }\n        this.renderTransform()\n        this.renderRenderable()\n        this.renderElement()\n        this.renderInnerContent()\n        if (this._isFirstFrame) {\n          this._isFirstFrame = false\n        }\n      },\n      renderInnerContent: function () {},\n      prepareFrame: function (num) {\n        this._mdf = false\n        this.prepareRenderableFrame(num)\n        this.prepareProperties(num, this.isInRange)\n        this.checkTransparency()\n      },\n      destroy: function () {\n        this.innerElem = null\n        this.destroyBaseElement()\n      },\n    }\n    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement)\n  })()\n\n  function IImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId)\n    this.initElement(data, globalData, comp)\n    this.sourceRect = {\n      top: 0,\n      left: 0,\n      width: this.assetData.w,\n      height: this.assetData.h,\n    }\n  }\n\n  extendPrototype(\n    [BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement],\n    IImageElement,\n  )\n\n  IImageElement.prototype.createContent = function () {\n    var assetPath = this.globalData.getAssetsPath(this.assetData)\n\n    this.innerElem = createNS('image')\n    this.innerElem.setAttribute('width', this.assetData.w + 'px')\n    this.innerElem.setAttribute('height', this.assetData.h + 'px')\n    this.innerElem.setAttribute(\n      'preserveAspectRatio',\n      this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio,\n    )\n    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath)\n\n    this.layerElement.appendChild(this.innerElem)\n  }\n\n  IImageElement.prototype.sourceRectAtTime = function () {\n    return this.sourceRect\n  }\n\n  function ProcessedElement(element, position) {\n    this.elem = element\n    this.pos = position\n  }\n\n  function IShapeElement() {}\n\n  IShapeElement.prototype = {\n    addShapeToModifiers: function (data) {\n      var i\n      var len = this.shapeModifiers.length\n      for (i = 0; i < len; i += 1) {\n        this.shapeModifiers[i].addShape(data)\n      }\n    },\n    isShapeInAnimatedModifiers: function (data) {\n      var i = 0\n      var len = this.shapeModifiers.length\n      while (i < len) {\n        if (this.shapeModifiers[i].isAnimatedWithShape(data)) {\n          return true\n        }\n      }\n      return false\n    },\n    renderModifiers: function () {\n      if (!this.shapeModifiers.length) {\n        return\n      }\n      var i\n      var len = this.shapes.length\n      for (i = 0; i < len; i += 1) {\n        this.shapes[i].sh.reset()\n      }\n\n      len = this.shapeModifiers.length\n      var shouldBreakProcess\n      for (i = len - 1; i >= 0; i -= 1) {\n        shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame)\n        // workaround to fix cases where a repeater resets the shape so the following processes get called twice\n        // TODO: find a better solution for this\n        if (shouldBreakProcess) {\n          break\n        }\n      }\n    },\n\n    searchProcessedElement: function (elem) {\n      var elements = this.processedElements\n      var i = 0\n      var len = elements.length\n      while (i < len) {\n        if (elements[i].elem === elem) {\n          return elements[i].pos\n        }\n        i += 1\n      }\n      return 0\n    },\n    addProcessedElement: function (elem, pos) {\n      var elements = this.processedElements\n      var i = elements.length\n      while (i) {\n        i -= 1\n        if (elements[i].elem === elem) {\n          elements[i].pos = pos\n          return\n        }\n      }\n      elements.push(new ProcessedElement(elem, pos))\n    },\n    prepareFrame: function (num) {\n      this.prepareRenderableFrame(num)\n      this.prepareProperties(num, this.isInRange)\n    },\n  }\n\n  const lineCapEnum = {\n    1: 'butt',\n    2: 'round',\n    3: 'square',\n  }\n\n  const lineJoinEnum = {\n    1: 'miter',\n    2: 'round',\n    3: 'bevel',\n  }\n\n  function SVGShapeData(transformers, level, shape) {\n    this.caches = []\n    this.styles = []\n    this.transformers = transformers\n    this.lStr = ''\n    this.sh = shape\n    this.lvl = level\n    // TODO find if there are some cases where _isAnimated can be false.\n    // For now, since shapes add up with other shapes. They have to be calculated every time.\n    // One way of finding out is checking if all styles associated to this shape depend only of this shape\n    this._isAnimated = !!shape.k\n    // TODO: commenting this for now since all shapes are animated\n    var i = 0\n    var len = transformers.length\n    while (i < len) {\n      if (transformers[i].mProps.dynamicProperties.length) {\n        this._isAnimated = true\n        break\n      }\n      i += 1\n    }\n  }\n\n  SVGShapeData.prototype.setAsAnimated = function () {\n    this._isAnimated = true\n  }\n\n  function SVGStyleData(data, level) {\n    this.data = data\n    this.type = data.ty\n    this.d = ''\n    this.lvl = level\n    this._mdf = false\n    this.closed = data.hd === true\n    this.pElem = createNS('path')\n    this.msElem = null\n  }\n\n  SVGStyleData.prototype.reset = function () {\n    this.d = ''\n    this._mdf = false\n  }\n\n  function DashProperty(elem, data, renderer, container) {\n    this.elem = elem\n    this.frameId = -1\n    this.dataProps = createSizedArray(data.length)\n    this.renderer = renderer\n    this.k = false\n    this.dashStr = ''\n    this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0)\n    this.dashoffset = createTypedArray('float32', 1)\n    this.initDynamicPropertyContainer(container)\n    var i\n    var len = data.length || 0\n    var prop\n    for (i = 0; i < len; i += 1) {\n      prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this)\n      this.k = prop.k || this.k\n      this.dataProps[i] = { n: data[i].n, p: prop }\n    }\n    if (!this.k) {\n      this.getValue(true)\n    }\n    this._isAnimated = this.k\n  }\n\n  DashProperty.prototype.getValue = function (forceRender) {\n    if (this.elem.globalData.frameId === this.frameId && !forceRender) {\n      return\n    }\n    this.frameId = this.elem.globalData.frameId\n    this.iterateDynamicProperties()\n    this._mdf = this._mdf || forceRender\n    if (this._mdf) {\n      var i = 0\n      var len = this.dataProps.length\n      if (this.renderer === 'svg') {\n        this.dashStr = ''\n      }\n      for (i = 0; i < len; i += 1) {\n        if (this.dataProps[i].n !== 'o') {\n          if (this.renderer === 'svg') {\n            this.dashStr += ' ' + this.dataProps[i].p.v\n          } else {\n            this.dashArray[i] = this.dataProps[i].p.v\n          }\n        } else {\n          this.dashoffset[0] = this.dataProps[i].p.v\n        }\n      }\n    }\n  }\n  extendPrototype([DynamicPropertyContainer], DashProperty)\n\n  function SVGStrokeStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem)\n    this.getValue = this.iterateDynamicProperties\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this)\n    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this)\n    this.d = new DashProperty(elem, data.d || {}, 'svg', this)\n    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this)\n    this.style = styleOb\n    this._isAnimated = !!this._isAnimated\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData)\n\n  function SVGFillStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem)\n    this.getValue = this.iterateDynamicProperties\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this)\n    this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this)\n    this.style = styleOb\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGFillStyleData)\n\n  function SVGNoStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem)\n    this.getValue = this.iterateDynamicProperties\n    this.style = styleOb\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGNoStyleData)\n\n  function GradientProperty(elem, data, container) {\n    this.data = data\n    this.c = createTypedArray('uint8c', data.p * 4)\n    var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4\n    this.o = createTypedArray('float32', cLength)\n    this._cmdf = false\n    this._omdf = false\n    this._collapsable = this.checkCollapsable()\n    this._hasOpacity = cLength\n    this.initDynamicPropertyContainer(container)\n    this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this)\n    this.k = this.prop.k\n    this.getValue(true)\n  }\n\n  GradientProperty.prototype.comparePoints = function (values, points) {\n    var i = 0\n    var len = this.o.length / 2\n    var diff\n    while (i < len) {\n      diff = Math.abs(values[i * 4] - values[points * 4 + i * 2])\n      if (diff > 0.01) {\n        return false\n      }\n      i += 1\n    }\n    return true\n  }\n\n  GradientProperty.prototype.checkCollapsable = function () {\n    if (this.o.length / 2 !== this.c.length / 4) {\n      return false\n    }\n    if (this.data.k.k[0].s) {\n      var i = 0\n      var len = this.data.k.k.length\n      while (i < len) {\n        if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\n          return false\n        }\n        i += 1\n      }\n    } else if (!this.comparePoints(this.data.k.k, this.data.p)) {\n      return false\n    }\n    return true\n  }\n\n  GradientProperty.prototype.getValue = function (forceRender) {\n    this.prop.getValue()\n    this._mdf = false\n    this._cmdf = false\n    this._omdf = false\n    if (this.prop._mdf || forceRender) {\n      var i\n      var len = this.data.p * 4\n      var mult\n      var val\n      for (i = 0; i < len; i += 1) {\n        mult = i % 4 === 0 ? 100 : 255\n        val = Math.round(this.prop.v[i] * mult)\n        if (this.c[i] !== val) {\n          this.c[i] = val\n          this._cmdf = !forceRender\n        }\n      }\n      if (this.o.length) {\n        len = this.prop.v.length\n        for (i = this.data.p * 4; i < len; i += 1) {\n          mult = i % 2 === 0 ? 100 : 1\n          val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i]\n          if (this.o[i - this.data.p * 4] !== val) {\n            this.o[i - this.data.p * 4] = val\n            this._omdf = !forceRender\n          }\n        }\n      }\n      this._mdf = !forceRender\n    }\n  }\n\n  extendPrototype([DynamicPropertyContainer], GradientProperty)\n\n  function SVGGradientFillStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem)\n    this.getValue = this.iterateDynamicProperties\n    this.initGradientData(elem, data, styleOb)\n  }\n\n  SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this)\n    this.s = PropertyFactory.getProp(elem, data.s, 1, null, this)\n    this.e = PropertyFactory.getProp(elem, data.e, 1, null, this)\n    this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this)\n    this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this)\n    this.g = new GradientProperty(elem, data.g, this)\n    this.style = styleOb\n    this.stops = []\n    this.setGradientData(styleOb.pElem, data)\n    this.setGradientOpacity(data, styleOb)\n    this._isAnimated = !!this._isAnimated\n  }\n\n  SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {\n    var gradientId = createElementID()\n    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient')\n    gfill.setAttribute('id', gradientId)\n    gfill.setAttribute('spreadMethod', 'pad')\n    gfill.setAttribute('gradientUnits', 'userSpaceOnUse')\n    var stops = []\n    var stop\n    var j\n    var jLen\n    jLen = data.g.p * 4\n    for (j = 0; j < jLen; j += 4) {\n      stop = createNS('stop')\n      gfill.appendChild(stop)\n      stops.push(stop)\n    }\n    pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')')\n    this.gf = gfill\n    this.cst = stops\n  }\n\n  SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {\n    if (this.g._hasOpacity && !this.g._collapsable) {\n      var stop\n      var j\n      var jLen\n      var mask = createNS('mask')\n      var maskElement = createNS('path')\n      mask.appendChild(maskElement)\n      var opacityId = createElementID()\n      var maskId = createElementID()\n      mask.setAttribute('id', maskId)\n      var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient')\n      opFill.setAttribute('id', opacityId)\n      opFill.setAttribute('spreadMethod', 'pad')\n      opFill.setAttribute('gradientUnits', 'userSpaceOnUse')\n      jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length\n      var stops = this.stops\n      for (j = data.g.p * 4; j < jLen; j += 2) {\n        stop = createNS('stop')\n        stop.setAttribute('stop-color', 'rgb(255,255,255)')\n        opFill.appendChild(stop)\n        stops.push(stop)\n      }\n      maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')')\n      if (data.ty === 'gs') {\n        maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2])\n        maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2])\n        if (data.lj === 1) {\n          maskElement.setAttribute('stroke-miterlimit', data.ml)\n        }\n      }\n      this.of = opFill\n      this.ms = mask\n      this.ost = stops\n      this.maskId = maskId\n      styleOb.msElem = maskElement\n    }\n  }\n\n  extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData)\n\n  function SVGGradientStrokeStyleData(elem, data, styleOb) {\n    this.initDynamicPropertyContainer(elem)\n    this.getValue = this.iterateDynamicProperties\n    this.w = PropertyFactory.getProp(elem, data.w, 0, null, this)\n    this.d = new DashProperty(elem, data.d || {}, 'svg', this)\n    this.initGradientData(elem, data, styleOb)\n    this._isAnimated = !!this._isAnimated\n  }\n\n  extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData)\n\n  function ShapeGroupData() {\n    this.it = []\n    this.prevViewData = []\n    this.gr = createNS('g')\n  }\n\n  function SVGTransformData(mProps, op, container) {\n    this.transform = {\n      mProps: mProps,\n      op: op,\n      container: container,\n    }\n    this.elements = []\n    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length\n  }\n\n  const buildShapeString = function (pathNodes, length, closed, mat) {\n    if (length === 0) {\n      return ''\n    }\n    var _o = pathNodes.o\n    var _i = pathNodes.i\n    var _v = pathNodes.v\n    var i\n    var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1])\n    for (i = 1; i < length; i += 1) {\n      shapeString +=\n        ' C' +\n        mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) +\n        ' ' +\n        mat.applyToPointStringified(_i[i][0], _i[i][1]) +\n        ' ' +\n        mat.applyToPointStringified(_v[i][0], _v[i][1])\n    }\n    if (closed && length) {\n      shapeString +=\n        ' C' +\n        mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) +\n        ' ' +\n        mat.applyToPointStringified(_i[0][0], _i[0][1]) +\n        ' ' +\n        mat.applyToPointStringified(_v[0][0], _v[0][1])\n      shapeString += 'z'\n    }\n    return shapeString\n  }\n\n  const SVGElementsRenderer = (function () {\n    var _identityMatrix = new Matrix()\n    var _matrixHelper = new Matrix()\n\n    var ob = {\n      createRenderFunction: createRenderFunction,\n    }\n\n    function createRenderFunction(data) {\n      switch (data.ty) {\n        case 'fl':\n          return renderFill\n        case 'gf':\n          return renderGradient\n        case 'gs':\n          return renderGradientStroke\n        case 'st':\n          return renderStroke\n        case 'sh':\n        case 'el':\n        case 'rc':\n        case 'sr':\n          return renderPath\n        case 'tr':\n          return renderContentTransform\n        case 'no':\n          return renderNoop\n        default:\n          return null\n      }\n    }\n\n    function renderContentTransform(styleData, itemData, isFirstFrame) {\n      if (isFirstFrame || itemData.transform.op._mdf) {\n        itemData.transform.container.setAttribute('opacity', itemData.transform.op.v)\n      }\n      if (isFirstFrame || itemData.transform.mProps._mdf) {\n        itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS())\n      }\n    }\n\n    function renderNoop() {}\n\n    function renderPath(styleData, itemData, isFirstFrame) {\n      var j\n      var jLen\n      var pathStringTransformed\n      var redraw\n      var pathNodes\n      var l\n      var lLen = itemData.styles.length\n      var lvl = itemData.lvl\n      var paths\n      var mat\n      var props\n      var iterations\n      var k\n      for (l = 0; l < lLen; l += 1) {\n        redraw = itemData.sh._mdf || isFirstFrame\n        if (itemData.styles[l].lvl < lvl) {\n          mat = _matrixHelper.reset()\n          iterations = lvl - itemData.styles[l].lvl\n          k = itemData.transformers.length - 1\n          while (!redraw && iterations > 0) {\n            redraw = itemData.transformers[k].mProps._mdf || redraw\n            iterations -= 1\n            k -= 1\n          }\n          if (redraw) {\n            iterations = lvl - itemData.styles[l].lvl\n            k = itemData.transformers.length - 1\n            while (iterations > 0) {\n              props = itemData.transformers[k].mProps.v.props\n              mat.transform(\n                props[0],\n                props[1],\n                props[2],\n                props[3],\n                props[4],\n                props[5],\n                props[6],\n                props[7],\n                props[8],\n                props[9],\n                props[10],\n                props[11],\n                props[12],\n                props[13],\n                props[14],\n                props[15],\n              )\n              iterations -= 1\n              k -= 1\n            }\n          }\n        } else {\n          mat = _identityMatrix\n        }\n        paths = itemData.sh.paths\n        jLen = paths._length\n        if (redraw) {\n          pathStringTransformed = ''\n          for (j = 0; j < jLen; j += 1) {\n            pathNodes = paths.shapes[j]\n            if (pathNodes && pathNodes._length) {\n              pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat)\n            }\n          }\n          itemData.caches[l] = pathStringTransformed\n        } else {\n          pathStringTransformed = itemData.caches[l]\n        }\n        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed\n        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf\n      }\n    }\n\n    function renderFill(styleData, itemData, isFirstFrame) {\n      var styleElem = itemData.style\n\n      if (itemData.c._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute(\n          'fill',\n          'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')',\n        )\n      }\n      if (itemData.o._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('fill-opacity', itemData.o.v)\n      }\n    }\n\n    function renderGradientStroke(styleData, itemData, isFirstFrame) {\n      renderGradient(styleData, itemData, isFirstFrame)\n      renderStroke(styleData, itemData, isFirstFrame)\n    }\n\n    function renderGradient(styleData, itemData, isFirstFrame) {\n      var gfill = itemData.gf\n      var hasOpacity = itemData.g._hasOpacity\n      var pt1 = itemData.s.v\n      var pt2 = itemData.e.v\n\n      if (itemData.o._mdf || isFirstFrame) {\n        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity'\n        itemData.style.pElem.setAttribute(attr, itemData.o.v)\n      }\n      if (itemData.s._mdf || isFirstFrame) {\n        var attr1 = styleData.t === 1 ? 'x1' : 'cx'\n        var attr2 = attr1 === 'x1' ? 'y1' : 'cy'\n        gfill.setAttribute(attr1, pt1[0])\n        gfill.setAttribute(attr2, pt1[1])\n        if (hasOpacity && !itemData.g._collapsable) {\n          itemData.of.setAttribute(attr1, pt1[0])\n          itemData.of.setAttribute(attr2, pt1[1])\n        }\n      }\n      var stops\n      var i\n      var len\n      var stop\n      if (itemData.g._cmdf || isFirstFrame) {\n        stops = itemData.cst\n        var cValues = itemData.g.c\n        len = stops.length\n        for (i = 0; i < len; i += 1) {\n          stop = stops[i]\n          stop.setAttribute('offset', cValues[i * 4] + '%')\n          stop.setAttribute(\n            'stop-color',\n            'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')',\n          )\n        }\n      }\n      if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\n        var oValues = itemData.g.o\n        if (itemData.g._collapsable) {\n          stops = itemData.cst\n        } else {\n          stops = itemData.ost\n        }\n        len = stops.length\n        for (i = 0; i < len; i += 1) {\n          stop = stops[i]\n          if (!itemData.g._collapsable) {\n            stop.setAttribute('offset', oValues[i * 2] + '%')\n          }\n          stop.setAttribute('stop-opacity', oValues[i * 2 + 1])\n        }\n      }\n      if (styleData.t === 1) {\n        if (itemData.e._mdf || isFirstFrame) {\n          gfill.setAttribute('x2', pt2[0])\n          gfill.setAttribute('y2', pt2[1])\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('x2', pt2[0])\n            itemData.of.setAttribute('y2', pt2[1])\n          }\n        }\n      } else {\n        var rad\n        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\n          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2))\n          gfill.setAttribute('r', rad)\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('r', rad)\n          }\n        }\n        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\n          if (!rad) {\n            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2))\n          }\n          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0])\n\n          var percent = itemData.h.v\n          if (percent >= 1) {\n            percent = 0.99\n          } else if (percent <= -1) {\n            percent = -0.99\n          }\n          var dist = rad * percent\n          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0]\n          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1]\n          gfill.setAttribute('fx', x)\n          gfill.setAttribute('fy', y)\n          if (hasOpacity && !itemData.g._collapsable) {\n            itemData.of.setAttribute('fx', x)\n            itemData.of.setAttribute('fy', y)\n          }\n        }\n        // gfill.setAttribute('fy','200');\n      }\n    }\n\n    function renderStroke(styleData, itemData, isFirstFrame) {\n      var styleElem = itemData.style\n      var d = itemData.d\n      if (d && (d._mdf || isFirstFrame) && d.dashStr) {\n        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr)\n        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0])\n      }\n      if (itemData.c && (itemData.c._mdf || isFirstFrame)) {\n        styleElem.pElem.setAttribute(\n          'stroke',\n          'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')',\n        )\n      }\n      if (itemData.o._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v)\n      }\n      if (itemData.w._mdf || isFirstFrame) {\n        styleElem.pElem.setAttribute('stroke-width', itemData.w.v)\n        if (styleElem.msElem) {\n          styleElem.msElem.setAttribute('stroke-width', itemData.w.v)\n        }\n      }\n    }\n\n    return ob\n  })()\n\n  function SVGShapeElement(data, globalData, comp) {\n    // List of drawable elements\n    this.shapes = []\n    // Full shape data\n    this.shapesData = data.shapes\n    // List of styles that will be applied to shapes\n    this.stylesList = []\n    // List of modifiers that will be applied to shapes\n    this.shapeModifiers = []\n    // List of items in shape tree\n    this.itemsData = []\n    // List of items in previous shape tree\n    this.processedElements = []\n    // List of animated components\n    this.animatedContents = []\n    this.initElement(data, globalData, comp)\n    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    // List of elements that have been created\n    this.prevViewData = []\n    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n  }\n\n  extendPrototype(\n    [\n      BaseElement,\n      TransformElement,\n      SVGBaseElement,\n      IShapeElement,\n      HierarchyElement,\n      FrameElement,\n      RenderableDOMElement,\n    ],\n    SVGShapeElement,\n  )\n\n  SVGShapeElement.prototype.initSecondaryElement = function () {}\n\n  SVGShapeElement.prototype.identityMatrix = new Matrix()\n\n  SVGShapeElement.prototype.buildExpressionInterface = function () {}\n\n  SVGShapeElement.prototype.createContent = function () {\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true)\n    this.filterUniqueShapes()\n  }\n\n  /*\nThis method searches for multiple shapes that affect a single element and one of them is animated\n*/\n  SVGShapeElement.prototype.filterUniqueShapes = function () {\n    var i\n    var len = this.shapes.length\n    var shape\n    var j\n    var jLen = this.stylesList.length\n    var style\n    var tempShapes = []\n    var areAnimated = false\n    for (j = 0; j < jLen; j += 1) {\n      style = this.stylesList[j]\n      areAnimated = false\n      tempShapes.length = 0\n      for (i = 0; i < len; i += 1) {\n        shape = this.shapes[i]\n        if (shape.styles.indexOf(style) !== -1) {\n          tempShapes.push(shape)\n          areAnimated = shape._isAnimated || areAnimated\n        }\n      }\n      if (tempShapes.length > 1 && areAnimated) {\n        this.setShapesAsAnimated(tempShapes)\n      }\n    }\n  }\n\n  SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {\n    var i\n    var len = shapes.length\n    for (i = 0; i < len; i += 1) {\n      shapes[i].setAsAnimated()\n    }\n  }\n\n  SVGShapeElement.prototype.createStyleElement = function (data, level) {\n    // TODO: prevent drawing of hidden styles\n    var elementData\n    var styleOb = new SVGStyleData(data, level)\n\n    var pathElement = styleOb.pElem\n    if (data.ty === 'st') {\n      elementData = new SVGStrokeStyleData(this, data, styleOb)\n    } else if (data.ty === 'fl') {\n      elementData = new SVGFillStyleData(this, data, styleOb)\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\n      var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData\n      elementData = new GradientConstructor(this, data, styleOb)\n      this.globalData.defs.appendChild(elementData.gf)\n      if (elementData.maskId) {\n        this.globalData.defs.appendChild(elementData.ms)\n        this.globalData.defs.appendChild(elementData.of)\n        pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')')\n      }\n    } else if (data.ty === 'no') {\n      elementData = new SVGNoStyleData(this, data, styleOb)\n    }\n\n    if (data.ty === 'st' || data.ty === 'gs') {\n      pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2])\n      pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2])\n      pathElement.setAttribute('fill-opacity', '0')\n      if (data.lj === 1) {\n        pathElement.setAttribute('stroke-miterlimit', data.ml)\n      }\n    }\n\n    if (data.r === 2) {\n      pathElement.setAttribute('fill-rule', 'evenodd')\n    }\n\n    if (data.ln) {\n      pathElement.setAttribute('id', data.ln)\n    }\n    if (data.cl) {\n      pathElement.setAttribute('class', data.cl)\n    }\n    if (data.bm) {\n      pathElement.style['mix-blend-mode'] = getBlendMode(data.bm)\n    }\n    this.stylesList.push(styleOb)\n    this.addToAnimatedContents(data, elementData)\n    return elementData\n  }\n\n  SVGShapeElement.prototype.createGroupElement = function (data) {\n    var elementData = new ShapeGroupData()\n    if (data.ln) {\n      elementData.gr.setAttribute('id', data.ln)\n    }\n    if (data.cl) {\n      elementData.gr.setAttribute('class', data.cl)\n    }\n    if (data.bm) {\n      elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm)\n    }\n    return elementData\n  }\n\n  SVGShapeElement.prototype.createTransformElement = function (data, container) {\n    var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this)\n    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container)\n    this.addToAnimatedContents(data, elementData)\n    return elementData\n  }\n\n  SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {\n    var ty = 4\n    if (data.ty === 'rc') {\n      ty = 5\n    } else if (data.ty === 'el') {\n      ty = 6\n    } else if (data.ty === 'sr') {\n      ty = 7\n    }\n    var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this)\n    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty)\n    this.shapes.push(elementData)\n    this.addShapeToModifiers(elementData)\n    this.addToAnimatedContents(data, elementData)\n    return elementData\n  }\n\n  SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {\n    var i = 0\n    var len = this.animatedContents.length\n    while (i < len) {\n      if (this.animatedContents[i].element === element) {\n        return\n      }\n      i += 1\n    }\n    this.animatedContents.push({\n      fn: SVGElementsRenderer.createRenderFunction(data),\n      element: element,\n      data: data,\n    })\n  }\n\n  SVGShapeElement.prototype.setElementStyles = function (elementData) {\n    var arr = elementData.styles\n    var j\n    var jLen = this.stylesList.length\n    for (j = 0; j < jLen; j += 1) {\n      if (!this.stylesList[j].closed) {\n        arr.push(this.stylesList[j])\n      }\n    }\n  }\n\n  SVGShapeElement.prototype.reloadShapes = function () {\n    this._isFirstFrame = true\n    var i\n    var len = this.itemsData.length\n    for (i = 0; i < len; i += 1) {\n      this.prevViewData[i] = this.itemsData[i]\n    }\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true)\n    this.filterUniqueShapes()\n    len = this.dynamicProperties.length\n    for (i = 0; i < len; i += 1) {\n      this.dynamicProperties[i].getValue()\n    }\n    this.renderModifiers()\n  }\n\n  SVGShapeElement.prototype.searchShapes = function (\n    arr,\n    itemsData,\n    prevViewData,\n    container,\n    level,\n    transformers,\n    render,\n  ) {\n    var ownTransformers = [].concat(transformers)\n    var i\n    var len = arr.length - 1\n    var j\n    var jLen\n    var ownStyles = []\n    var ownModifiers = []\n    var currentTransform\n    var modifier\n    var processedPos\n    for (i = len; i >= 0; i -= 1) {\n      processedPos = this.searchProcessedElement(arr[i])\n      if (!processedPos) {\n        arr[i]._render = render\n      } else {\n        itemsData[i] = prevViewData[processedPos - 1]\n      }\n      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {\n        if (!processedPos) {\n          itemsData[i] = this.createStyleElement(arr[i], level)\n        } else {\n          itemsData[i].style.closed = false\n        }\n        if (arr[i]._render) {\n          if (itemsData[i].style.pElem.parentNode !== container) {\n            container.appendChild(itemsData[i].style.pElem)\n          }\n        }\n        ownStyles.push(itemsData[i].style)\n      } else if (arr[i].ty === 'gr') {\n        if (!processedPos) {\n          itemsData[i] = this.createGroupElement(arr[i])\n        } else {\n          jLen = itemsData[i].it.length\n          for (j = 0; j < jLen; j += 1) {\n            itemsData[i].prevViewData[j] = itemsData[i].it[j]\n          }\n        }\n        this.searchShapes(\n          arr[i].it,\n          itemsData[i].it,\n          itemsData[i].prevViewData,\n          itemsData[i].gr,\n          level + 1,\n          ownTransformers,\n          render,\n        )\n        if (arr[i]._render) {\n          if (itemsData[i].gr.parentNode !== container) {\n            container.appendChild(itemsData[i].gr)\n          }\n        }\n      } else if (arr[i].ty === 'tr') {\n        if (!processedPos) {\n          itemsData[i] = this.createTransformElement(arr[i], container)\n        }\n        currentTransform = itemsData[i].transform\n        ownTransformers.push(currentTransform)\n      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n        if (!processedPos) {\n          itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level)\n        }\n        this.setElementStyles(itemsData[i])\n      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty)\n          modifier.init(this, arr[i])\n          itemsData[i] = modifier\n          this.shapeModifiers.push(modifier)\n        } else {\n          modifier = itemsData[i]\n          modifier.closed = false\n        }\n        ownModifiers.push(modifier)\n      } else if (arr[i].ty === 'rp') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty)\n          itemsData[i] = modifier\n          modifier.init(this, arr, i, itemsData)\n          this.shapeModifiers.push(modifier)\n          render = false\n        } else {\n          modifier = itemsData[i]\n          modifier.closed = true\n        }\n        ownModifiers.push(modifier)\n      }\n      this.addProcessedElement(arr[i], i + 1)\n    }\n    len = ownStyles.length\n    for (i = 0; i < len; i += 1) {\n      ownStyles[i].closed = true\n    }\n    len = ownModifiers.length\n    for (i = 0; i < len; i += 1) {\n      ownModifiers[i].closed = true\n    }\n  }\n\n  SVGShapeElement.prototype.renderInnerContent = function () {\n    this.renderModifiers()\n    var i\n    var len = this.stylesList.length\n    for (i = 0; i < len; i += 1) {\n      this.stylesList[i].reset()\n    }\n    this.renderShape()\n    for (i = 0; i < len; i += 1) {\n      if (this.stylesList[i]._mdf || this._isFirstFrame) {\n        if (this.stylesList[i].msElem) {\n          this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d)\n          // Adding M0 0 fixes same mask bug on all browsers\n          this.stylesList[i].d = 'M0 0' + this.stylesList[i].d\n        }\n        this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0')\n      }\n    }\n  }\n\n  SVGShapeElement.prototype.renderShape = function () {\n    var i\n    var len = this.animatedContents.length\n    var animatedContent\n    for (i = 0; i < len; i += 1) {\n      animatedContent = this.animatedContents[i]\n      if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\n        animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame)\n      }\n    }\n  }\n\n  SVGShapeElement.prototype.destroy = function () {\n    this.destroyBaseElement()\n    this.shapesData = null\n    this.itemsData = null\n  }\n\n  function LetterProps(o, sw, sc, fc, m, p) {\n    this.o = o\n    this.sw = sw\n    this.sc = sc\n    this.fc = fc\n    this.m = m\n    this.p = p\n    this._mdf = {\n      o: true,\n      sw: !!sw,\n      sc: !!sc,\n      fc: !!fc,\n      m: true,\n      p: true,\n    }\n  }\n\n  LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {\n    this._mdf.o = false\n    this._mdf.sw = false\n    this._mdf.sc = false\n    this._mdf.fc = false\n    this._mdf.m = false\n    this._mdf.p = false\n    var updated = false\n\n    if (this.o !== o) {\n      this.o = o\n      this._mdf.o = true\n      updated = true\n    }\n    if (this.sw !== sw) {\n      this.sw = sw\n      this._mdf.sw = true\n      updated = true\n    }\n    if (this.sc !== sc) {\n      this.sc = sc\n      this._mdf.sc = true\n      updated = true\n    }\n    if (this.fc !== fc) {\n      this.fc = fc\n      this._mdf.fc = true\n      updated = true\n    }\n    if (this.m !== m) {\n      this.m = m\n      this._mdf.m = true\n      updated = true\n    }\n    if (\n      p.length &&\n      (this.p[0] !== p[0] ||\n        this.p[1] !== p[1] ||\n        this.p[4] !== p[4] ||\n        this.p[5] !== p[5] ||\n        this.p[12] !== p[12] ||\n        this.p[13] !== p[13])\n    ) {\n      this.p = p\n      this._mdf.p = true\n      updated = true\n    }\n    return updated\n  }\n\n  function TextProperty(elem, data) {\n    this._frameId = initialDefaultFrame\n    this.pv = ''\n    this.v = ''\n    this.kf = false\n    this._isFirstFrame = true\n    this._mdf = false\n    this.data = data\n    this.elem = elem\n    this.comp = this.elem.comp\n    this.keysIndex = 0\n    this.canResize = false\n    this.minimumFontSize = 1\n    this.effectsSequence = []\n    this.currentData = {\n      ascent: 0,\n      boxWidth: this.defaultBoxWidth,\n      f: '',\n      fStyle: '',\n      fWeight: '',\n      fc: '',\n      j: '',\n      justifyOffset: '',\n      l: [],\n      lh: 0,\n      lineWidths: [],\n      ls: '',\n      of: '',\n      s: '',\n      sc: '',\n      sw: 0,\n      t: 0,\n      tr: 0,\n      sz: 0,\n      ps: null,\n      fillColorAnim: false,\n      strokeColorAnim: false,\n      strokeWidthAnim: false,\n      yOffset: 0,\n      finalSize: 0,\n      finalText: [],\n      finalLineHeight: 0,\n      __complete: false,\n    }\n    this.copyData(this.currentData, this.data.d.k[0].s)\n\n    if (!this.searchProperty()) {\n      this.completeTextData(this.currentData)\n    }\n  }\n\n  TextProperty.prototype.defaultBoxWidth = [0, 0]\n\n  TextProperty.prototype.copyData = function (obj, data) {\n    for (var s in data) {\n      if (Object.prototype.hasOwnProperty.call(data, s)) {\n        obj[s] = data[s]\n      }\n    }\n    return obj\n  }\n\n  TextProperty.prototype.setCurrentData = function (data) {\n    if (!data.__complete) {\n      this.completeTextData(data)\n    }\n    this.currentData = data\n    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth\n    this._mdf = true\n  }\n\n  TextProperty.prototype.searchProperty = function () {\n    return this.searchKeyframes()\n  }\n\n  TextProperty.prototype.searchKeyframes = function () {\n    this.kf = this.data.d.k.length > 1\n    if (this.kf) {\n      this.addEffect(this.getKeyframeValue.bind(this))\n    }\n    return this.kf\n  }\n\n  TextProperty.prototype.addEffect = function (effectFunction) {\n    this.effectsSequence.push(effectFunction)\n    this.elem.addDynamicProperty(this)\n  }\n\n  TextProperty.prototype.getValue = function (_finalValue) {\n    if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\n      return\n    }\n    this.currentData.t = this.data.d.k[this.keysIndex].s.t\n    var currentValue = this.currentData\n    var currentIndex = this.keysIndex\n    if (this.lock) {\n      this.setCurrentData(this.currentData)\n      return\n    }\n    this.lock = true\n    this._mdf = false\n    var i\n    var len = this.effectsSequence.length\n    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s\n    for (i = 0; i < len; i += 1) {\n      // Checking if index changed to prevent creating a new object every time the expression updates.\n      if (currentIndex !== this.keysIndex) {\n        finalValue = this.effectsSequence[i](finalValue, finalValue.t)\n      } else {\n        finalValue = this.effectsSequence[i](this.currentData, finalValue.t)\n      }\n    }\n    if (currentValue !== finalValue) {\n      this.setCurrentData(finalValue)\n    }\n    this.v = this.currentData\n    this.pv = this.v\n    this.lock = false\n    this.frameId = this.elem.globalData.frameId\n  }\n\n  TextProperty.prototype.getKeyframeValue = function () {\n    var textKeys = this.data.d.k\n    var frameNum = this.elem.comp.renderedFrame\n    var i = 0\n    var len = textKeys.length\n    while (i <= len - 1) {\n      if (i === len - 1 || textKeys[i + 1].t > frameNum) {\n        break\n      }\n      i += 1\n    }\n    if (this.keysIndex !== i) {\n      this.keysIndex = i\n    }\n    return this.data.d.k[this.keysIndex].s\n  }\n\n  TextProperty.prototype.buildFinalText = function (text) {\n    var charactersArray = []\n    var i = 0\n    var len = text.length\n    var charCode\n    var secondCharCode\n    var shouldCombine = false\n    while (i < len) {\n      charCode = text.charCodeAt(i)\n      if (FontManager.isCombinedCharacter(charCode)) {\n        charactersArray[charactersArray.length - 1] += text.charAt(i)\n      } else if (charCode >= 0xd800 && charCode <= 0xdbff) {\n        secondCharCode = text.charCodeAt(i + 1)\n        if (secondCharCode >= 0xdc00 && secondCharCode <= 0xdfff) {\n          if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {\n            charactersArray[charactersArray.length - 1] += text.substr(i, 2)\n            shouldCombine = false\n          } else {\n            charactersArray.push(text.substr(i, 2))\n          }\n          i += 1\n        } else {\n          charactersArray.push(text.charAt(i))\n        }\n      } else if (charCode > 0xdbff) {\n        secondCharCode = text.charCodeAt(i + 1)\n        if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {\n          shouldCombine = true\n          charactersArray[charactersArray.length - 1] += text.substr(i, 2)\n          i += 1\n        } else {\n          charactersArray.push(text.charAt(i))\n        }\n      } else if (FontManager.isZeroWidthJoiner(charCode)) {\n        charactersArray[charactersArray.length - 1] += text.charAt(i)\n        shouldCombine = true\n      } else {\n        charactersArray.push(text.charAt(i))\n      }\n      i += 1\n    }\n    return charactersArray\n  }\n\n  TextProperty.prototype.completeTextData = function (documentData) {\n    documentData.__complete = true\n    var fontManager = this.elem.globalData.fontManager\n    var data = this.data\n    var letters = []\n    var i\n    var len\n    var newLineFlag\n    var index = 0\n    var val\n    var anchorGrouping = data.m.g\n    var currentSize = 0\n    var currentPos = 0\n    var currentLine = 0\n    var lineWidths = []\n    var lineWidth = 0\n    var maxLineWidth = 0\n    var j\n    var jLen\n    var fontData = fontManager.getFontByName(documentData.f)\n    var charData\n    var cLength = 0\n\n    var fontProps = getFontProperties(fontData)\n    documentData.fWeight = fontProps.weight\n    documentData.fStyle = fontProps.style\n    documentData.finalSize = documentData.s\n    documentData.finalText = this.buildFinalText(documentData.t)\n    len = documentData.finalText.length\n    documentData.finalLineHeight = documentData.lh\n    var trackingOffset = (documentData.tr / 1000) * documentData.finalSize\n    var charCode\n    if (documentData.sz) {\n      var flag = true\n      var boxWidth = documentData.sz[0]\n      var boxHeight = documentData.sz[1]\n      var currentHeight\n      var finalText\n      while (flag) {\n        finalText = this.buildFinalText(documentData.t)\n        currentHeight = 0\n        lineWidth = 0\n        len = finalText.length\n        trackingOffset = (documentData.tr / 1000) * documentData.finalSize\n        var lastSpaceIndex = -1\n        for (i = 0; i < len; i += 1) {\n          charCode = finalText[i].charCodeAt(0)\n          newLineFlag = false\n          if (finalText[i] === ' ') {\n            lastSpaceIndex = i\n          } else if (charCode === 13 || charCode === 3) {\n            lineWidth = 0\n            newLineFlag = true\n            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2\n          }\n          if (fontManager.chars) {\n            charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily)\n            cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100\n          } else {\n            // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\n            cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize)\n          }\n          if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {\n            if (lastSpaceIndex === -1) {\n              len += 1\n            } else {\n              i = lastSpaceIndex\n            }\n            currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2\n            finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\\r')\n            // finalText = finalText.substr(0,i) + \"\\r\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\n            lastSpaceIndex = -1\n            lineWidth = 0\n          } else {\n            lineWidth += cLength\n            lineWidth += trackingOffset\n          }\n        }\n        currentHeight += (fontData.ascent * documentData.finalSize) / 100\n        if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\n          documentData.finalSize -= 1\n          documentData.finalLineHeight = (documentData.finalSize * documentData.lh) / documentData.s\n        } else {\n          documentData.finalText = finalText\n          len = documentData.finalText.length\n          flag = false\n        }\n      }\n    }\n    lineWidth = -trackingOffset\n    cLength = 0\n    var uncollapsedSpaces = 0\n    var currentChar\n    for (i = 0; i < len; i += 1) {\n      newLineFlag = false\n      currentChar = documentData.finalText[i]\n      charCode = currentChar.charCodeAt(0)\n      if (charCode === 13 || charCode === 3) {\n        uncollapsedSpaces = 0\n        lineWidths.push(lineWidth)\n        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth\n        lineWidth = -2 * trackingOffset\n        val = ''\n        newLineFlag = true\n        currentLine += 1\n      } else {\n        val = currentChar\n      }\n      if (fontManager.chars) {\n        charData = fontManager.getCharData(\n          currentChar,\n          fontData.fStyle,\n          fontManager.getFontByName(documentData.f).fFamily,\n        )\n        cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100\n      } else {\n        // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\n        // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\n        cLength = fontManager.measureText(val, documentData.f, documentData.finalSize)\n      }\n\n      //\n      if (currentChar === ' ') {\n        uncollapsedSpaces += cLength + trackingOffset\n      } else {\n        lineWidth += cLength + trackingOffset + uncollapsedSpaces\n        uncollapsedSpaces = 0\n      }\n      letters.push({\n        l: cLength,\n        an: cLength,\n        add: currentSize,\n        n: newLineFlag,\n        anIndexes: [],\n        val: val,\n        line: currentLine,\n        animatorJustifyOffset: 0,\n      })\n      if (anchorGrouping == 2) {\n        // eslint-disable-line eqeqeq\n        currentSize += cLength\n        if (val === '' || val === ' ' || i === len - 1) {\n          if (val === '' || val === ' ') {\n            currentSize -= cLength\n          }\n          while (currentPos <= i) {\n            letters[currentPos].an = currentSize\n            letters[currentPos].ind = index\n            letters[currentPos].extra = cLength\n            currentPos += 1\n          }\n          index += 1\n          currentSize = 0\n        }\n      } else if (anchorGrouping == 3) {\n        // eslint-disable-line eqeqeq\n        currentSize += cLength\n        if (val === '' || i === len - 1) {\n          if (val === '') {\n            currentSize -= cLength\n          }\n          while (currentPos <= i) {\n            letters[currentPos].an = currentSize\n            letters[currentPos].ind = index\n            letters[currentPos].extra = cLength\n            currentPos += 1\n          }\n          currentSize = 0\n          index += 1\n        }\n      } else {\n        letters[index].ind = index\n        letters[index].extra = 0\n        index += 1\n      }\n    }\n    documentData.l = letters\n    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth\n    lineWidths.push(lineWidth)\n    if (documentData.sz) {\n      documentData.boxWidth = documentData.sz[0]\n      documentData.justifyOffset = 0\n    } else {\n      documentData.boxWidth = maxLineWidth\n      switch (documentData.j) {\n        case 1:\n          documentData.justifyOffset = -documentData.boxWidth\n          break\n        case 2:\n          documentData.justifyOffset = -documentData.boxWidth / 2\n          break\n        default:\n          documentData.justifyOffset = 0\n      }\n    }\n    documentData.lineWidths = lineWidths\n\n    var animators = data.a\n    var animatorData\n    var letterData\n    jLen = animators.length\n    var based\n    var ind\n    var indexes = []\n    for (j = 0; j < jLen; j += 1) {\n      animatorData = animators[j]\n      if (animatorData.a.sc) {\n        documentData.strokeColorAnim = true\n      }\n      if (animatorData.a.sw) {\n        documentData.strokeWidthAnim = true\n      }\n      if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {\n        documentData.fillColorAnim = true\n      }\n      ind = 0\n      based = animatorData.s.b\n      for (i = 0; i < len; i += 1) {\n        letterData = letters[i]\n        letterData.anIndexes[j] = ind\n        if (\n          (based == 1 && letterData.val !== '') ||\n          (based == 2 && letterData.val !== '' && letterData.val !== ' ') ||\n          (based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1)) ||\n          (based == 4 && (letterData.n || i == len - 1))\n        ) {\n          // eslint-disable-line eqeqeq\n          if (animatorData.s.rn === 1) {\n            indexes.push(ind)\n          }\n          ind += 1\n        }\n      }\n      data.a[j].s.totalChars = ind\n      var currentInd = -1\n      var newInd\n      if (animatorData.s.rn === 1) {\n        for (i = 0; i < len; i += 1) {\n          letterData = letters[i]\n          if (currentInd != letterData.anIndexes[j]) {\n            // eslint-disable-line eqeqeq\n            currentInd = letterData.anIndexes[j]\n            newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0]\n          }\n          letterData.anIndexes[j] = newInd\n        }\n      }\n    }\n    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2\n    documentData.ls = documentData.ls || 0\n    documentData.ascent = (fontData.ascent * documentData.finalSize) / 100\n  }\n\n  TextProperty.prototype.updateDocumentData = function (newData, index) {\n    index = index === undefined ? this.keysIndex : index\n    var dData = this.copyData({}, this.data.d.k[index].s)\n    dData = this.copyData(dData, newData)\n    this.data.d.k[index].s = dData\n    this.recalculate(index)\n    this.elem.addDynamicProperty(this)\n  }\n\n  TextProperty.prototype.recalculate = function (index) {\n    var dData = this.data.d.k[index].s\n    dData.__complete = false\n    this.keysIndex = 0\n    this._isFirstFrame = true\n    this.getValue(dData)\n  }\n\n  TextProperty.prototype.canResizeFont = function (_canResize) {\n    this.canResize = _canResize\n    this.recalculate(this.keysIndex)\n    this.elem.addDynamicProperty(this)\n  }\n\n  TextProperty.prototype.setMinimumFontSize = function (_fontValue) {\n    this.minimumFontSize = Math.floor(_fontValue) || 1\n    this.recalculate(this.keysIndex)\n    this.elem.addDynamicProperty(this)\n  }\n\n  const TextSelectorProp = (function () {\n    var max = Math.max\n    var min = Math.min\n    var floor = Math.floor\n\n    function TextSelectorPropFactory(elem, data) {\n      this._currentTextLength = -1\n      this.k = false\n      this.data = data\n      this.elem = elem\n      this.comp = elem.comp\n      this.finalS = 0\n      this.finalE = 0\n      this.initDynamicPropertyContainer(elem)\n      this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this)\n      if ('e' in data) {\n        this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this)\n      } else {\n        this.e = { v: 100 }\n      }\n      this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this)\n      this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this)\n      this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this)\n      this.sm = PropertyFactory.getProp(elem, data.sm || { k: 100 }, 0, 0, this)\n      this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this)\n      if (!this.dynamicProperties.length) {\n        this.getValue()\n      }\n    }\n\n    TextSelectorPropFactory.prototype = {\n      getMult: function (ind) {\n        if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\n          this.getValue()\n        }\n        var x1 = 0\n        var y1 = 0\n        var x2 = 1\n        var y2 = 1\n        if (this.ne.v > 0) {\n          x1 = this.ne.v / 100.0\n        } else {\n          y1 = -this.ne.v / 100.0\n        }\n        if (this.xe.v > 0) {\n          x2 = 1.0 - this.xe.v / 100.0\n        } else {\n          y2 = 1.0 + this.xe.v / 100.0\n        }\n        var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get\n\n        var mult = 0\n        var s = this.finalS\n        var e = this.finalE\n        var type = this.data.sh\n        if (type === 2) {\n          if (e === s) {\n            mult = ind >= e ? 1 : 0\n          } else {\n            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1))\n          }\n          mult = easer(mult)\n        } else if (type === 3) {\n          if (e === s) {\n            mult = ind >= e ? 0 : 1\n          } else {\n            mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1))\n          }\n\n          mult = easer(mult)\n        } else if (type === 4) {\n          if (e === s) {\n            mult = 0\n          } else {\n            mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1))\n            if (mult < 0.5) {\n              mult *= 2\n            } else {\n              mult = 1 - 2 * (mult - 0.5)\n            }\n          }\n          mult = easer(mult)\n        } else if (type === 5) {\n          if (e === s) {\n            mult = 0\n          } else {\n            var tot = e - s\n            /* ind += 0.5;\n                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */\n            ind = min(max(0, ind + 0.5 - s), e - s)\n            var x = -tot / 2 + ind\n            var a = tot / 2\n            mult = Math.sqrt(1 - (x * x) / (a * a))\n          }\n          mult = easer(mult)\n        } else if (type === 6) {\n          if (e === s) {\n            mult = 0\n          } else {\n            ind = min(max(0, ind + 0.5 - s), e - s)\n            mult = (1 + Math.cos(Math.PI + (Math.PI * 2 * ind) / (e - s))) / 2 // eslint-disable-line\n          }\n          mult = easer(mult)\n        } else {\n          if (ind >= floor(s)) {\n            if (ind - s < 0) {\n              mult = max(0, min(min(e, 1) - (s - ind), 1))\n            } else {\n              mult = max(0, min(e - ind, 1))\n            }\n          }\n          mult = easer(mult)\n        }\n        // Smoothness implementation.\n        // The smoothness represents a reduced range of the original [0; 1] range.\n        // if smoothness is 25%, the new range will be [0.375; 0.625]\n        // Steps are:\n        // - find the lower value of the new range (threshold)\n        // - if multiplier is smaller than that value, floor it to 0\n        // - if it is larger,\n        //     - subtract the threshold\n        //     - divide it by the smoothness (this will return the range to [0; 1])\n        // Note: If it doesn't work on some scenarios, consider applying it before the easer.\n        if (this.sm.v !== 100) {\n          var smoothness = this.sm.v * 0.01\n          if (smoothness === 0) {\n            smoothness = 0.00000001\n          }\n          var threshold = 0.5 - smoothness * 0.5\n          if (mult < threshold) {\n            mult = 0\n          } else {\n            mult = (mult - threshold) / smoothness\n            if (mult > 1) {\n              mult = 1\n            }\n          }\n        }\n        return mult * this.a.v\n      },\n      getValue: function (newCharsFlag) {\n        this.iterateDynamicProperties()\n        this._mdf = newCharsFlag || this._mdf\n        this._currentTextLength = this.elem.textProperty.currentData.l.length || 0\n        if (newCharsFlag && this.data.r === 2) {\n          this.e.v = this._currentTextLength\n        }\n        var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars\n        var o = this.o.v / divisor\n        var s = this.s.v / divisor + o\n        var e = this.e.v / divisor + o\n        if (s > e) {\n          var _s = s\n          s = e\n          e = _s\n        }\n        this.finalS = s\n        this.finalE = e\n      },\n    }\n    extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory)\n\n    function getTextSelectorProp(elem, data, arr) {\n      return new TextSelectorPropFactory(elem, data, arr)\n    }\n\n    return {\n      getTextSelectorProp: getTextSelectorProp,\n    }\n  })()\n\n  function TextAnimatorDataProperty(elem, animatorProps, container) {\n    var defaultData = { propType: false }\n    var getProp = PropertyFactory.getProp\n    var textAnimatorAnimatables = animatorProps.a\n    this.a = {\n      r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,\n      rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,\n      ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,\n      sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,\n      sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,\n      s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,\n      a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,\n      o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,\n      p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,\n      sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,\n      sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,\n      fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,\n      fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,\n      fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,\n      fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,\n      t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData,\n    }\n\n    this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container)\n    this.s.t = animatorProps.s.t\n  }\n\n  function TextAnimatorProperty(textData, renderType, elem) {\n    this._isFirstFrame = true\n    this._hasMaskedPath = false\n    this._frameId = -1\n    this._textData = textData\n    this._renderType = renderType\n    this._elem = elem\n    this._animatorsData = createSizedArray(this._textData.a.length)\n    this._pathData = {}\n    this._moreOptions = {\n      alignment: {},\n    }\n    this.renderedLetters = []\n    this.lettersChangedFlag = false\n    this.initDynamicPropertyContainer(elem)\n  }\n\n  TextAnimatorProperty.prototype.searchProperties = function () {\n    var i\n    var len = this._textData.a.length\n    var animatorProps\n    var getProp = PropertyFactory.getProp\n    for (i = 0; i < len; i += 1) {\n      animatorProps = this._textData.a[i]\n      this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this)\n    }\n    if (this._textData.p && 'm' in this._textData.p) {\n      this._pathData = {\n        a: getProp(this._elem, this._textData.p.a, 0, 0, this),\n        f: getProp(this._elem, this._textData.p.f, 0, 0, this),\n        l: getProp(this._elem, this._textData.p.l, 0, 0, this),\n        r: getProp(this._elem, this._textData.p.r, 0, 0, this),\n        p: getProp(this._elem, this._textData.p.p, 0, 0, this),\n        m: this._elem.maskManager.getMaskProperty(this._textData.p.m),\n      }\n      this._hasMaskedPath = true\n    } else {\n      this._hasMaskedPath = false\n    }\n    this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this)\n  }\n\n  TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {\n    this.lettersChangedFlag = lettersChangedFlag\n    if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\n      return\n    }\n    this._isFirstFrame = false\n    var alignment = this._moreOptions.alignment.v\n    var animators = this._animatorsData\n    var textData = this._textData\n    var matrixHelper = this.mHelper\n    var renderType = this._renderType\n    var renderedLettersCount = this.renderedLetters.length\n    var xPos\n    var yPos\n    var i\n    var len\n    var letters = documentData.l\n    var pathInfo\n    var currentLength\n    var currentPoint\n    var segmentLength\n    var flag\n    var pointInd\n    var segmentInd\n    var prevPoint\n    var points\n    var segments\n    var partialLength\n    var totalLength\n    var perc\n    var tanAngle\n    var mask\n    if (this._hasMaskedPath) {\n      mask = this._pathData.m\n      if (!this._pathData.n || this._pathData._mdf) {\n        var paths = mask.v\n        if (this._pathData.r.v) {\n          paths = paths.reverse()\n        }\n        // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\n        pathInfo = {\n          tLength: 0,\n          segments: [],\n        }\n        len = paths._length - 1\n        var bezierData\n        totalLength = 0\n        for (i = 0; i < len; i += 1) {\n          bezierData = bez.buildBezierData(\n            paths.v[i],\n            paths.v[i + 1],\n            [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],\n            [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]],\n          )\n          pathInfo.tLength += bezierData.segmentLength\n          pathInfo.segments.push(bezierData)\n          totalLength += bezierData.segmentLength\n        }\n        i = len\n        if (mask.v.c) {\n          bezierData = bez.buildBezierData(\n            paths.v[i],\n            paths.v[0],\n            [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],\n            [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]],\n          )\n          pathInfo.tLength += bezierData.segmentLength\n          pathInfo.segments.push(bezierData)\n          totalLength += bezierData.segmentLength\n        }\n        this._pathData.pi = pathInfo\n      }\n      pathInfo = this._pathData.pi\n\n      currentLength = this._pathData.f.v\n      segmentInd = 0\n      pointInd = 1\n      segmentLength = 0\n      flag = true\n      segments = pathInfo.segments\n      if (currentLength < 0 && mask.v.c) {\n        if (pathInfo.tLength < Math.abs(currentLength)) {\n          currentLength = -Math.abs(currentLength) % pathInfo.tLength\n        }\n        segmentInd = segments.length - 1\n        points = segments[segmentInd].points\n        pointInd = points.length - 1\n        while (currentLength < 0) {\n          currentLength += points[pointInd].partialLength\n          pointInd -= 1\n          if (pointInd < 0) {\n            segmentInd -= 1\n            points = segments[segmentInd].points\n            pointInd = points.length - 1\n          }\n        }\n      }\n      points = segments[segmentInd].points\n      prevPoint = points[pointInd - 1]\n      currentPoint = points[pointInd]\n      partialLength = currentPoint.partialLength\n    }\n\n    len = letters.length\n    xPos = 0\n    yPos = 0\n    var yOff = documentData.finalSize * 1.2 * 0.714\n    var firstLine = true\n    var animatorProps\n    var animatorSelector\n    var j\n    var jLen\n    var letterValue\n\n    jLen = animators.length\n\n    var mult\n    var ind = -1\n    var offf\n    var xPathPos\n    var yPathPos\n    var initPathPos = currentLength\n    var initSegmentInd = segmentInd\n    var initPointInd = pointInd\n    var currentLine = -1\n    var elemOpacity\n    var sc\n    var sw\n    var fc\n    var k\n    var letterSw\n    var letterSc\n    var letterFc\n    var letterM = ''\n    var letterP = this.defaultPropsArray\n    var letterO\n\n    //\n    if (documentData.j === 2 || documentData.j === 1) {\n      var animatorJustifyOffset = 0\n      var animatorFirstCharOffset = 0\n      var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1\n      var lastIndex = 0\n      var isNewLine = true\n\n      for (i = 0; i < len; i += 1) {\n        if (letters[i].n) {\n          if (animatorJustifyOffset) {\n            animatorJustifyOffset += animatorFirstCharOffset\n          }\n          while (lastIndex < i) {\n            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset\n            lastIndex += 1\n          }\n          animatorJustifyOffset = 0\n          isNewLine = true\n        } else {\n          for (j = 0; j < jLen; j += 1) {\n            animatorProps = animators[j].a\n            if (animatorProps.t.propType) {\n              if (isNewLine && documentData.j === 2) {\n                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult\n              }\n              animatorSelector = animators[j].s\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n              if (mult.length) {\n                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult\n              } else {\n                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult\n              }\n            }\n          }\n          isNewLine = false\n        }\n      }\n      if (animatorJustifyOffset) {\n        animatorJustifyOffset += animatorFirstCharOffset\n      }\n      while (lastIndex < i) {\n        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset\n        lastIndex += 1\n      }\n    }\n    //\n\n    for (i = 0; i < len; i += 1) {\n      matrixHelper.reset()\n      elemOpacity = 1\n      if (letters[i].n) {\n        xPos = 0\n        yPos += documentData.yOffset\n        yPos += firstLine ? 1 : 0\n        currentLength = initPathPos\n        firstLine = false\n        if (this._hasMaskedPath) {\n          segmentInd = initSegmentInd\n          pointInd = initPointInd\n          points = segments[segmentInd].points\n          prevPoint = points[pointInd - 1]\n          currentPoint = points[pointInd]\n          partialLength = currentPoint.partialLength\n          segmentLength = 0\n        }\n        letterM = ''\n        letterFc = ''\n        letterSw = ''\n        letterO = ''\n        letterP = this.defaultPropsArray\n      } else {\n        if (this._hasMaskedPath) {\n          if (currentLine !== letters[i].line) {\n            switch (documentData.j) {\n              case 1:\n                currentLength += totalLength - documentData.lineWidths[letters[i].line]\n                break\n              case 2:\n                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2\n                break\n              default:\n                break\n            }\n            currentLine = letters[i].line\n          }\n          if (ind !== letters[i].ind) {\n            if (letters[ind]) {\n              currentLength += letters[ind].extra\n            }\n            currentLength += letters[i].an / 2\n            ind = letters[i].ind\n          }\n          currentLength += alignment[0] * letters[i].an * 0.005\n          var animatorOffset = 0\n          for (j = 0; j < jLen; j += 1) {\n            animatorProps = animators[j].a\n            if (animatorProps.p.propType) {\n              animatorSelector = animators[j].s\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n              if (mult.length) {\n                animatorOffset += animatorProps.p.v[0] * mult[0]\n              } else {\n                animatorOffset += animatorProps.p.v[0] * mult\n              }\n            }\n            if (animatorProps.a.propType) {\n              animatorSelector = animators[j].s\n              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n              if (mult.length) {\n                animatorOffset += animatorProps.a.v[0] * mult[0]\n              } else {\n                animatorOffset += animatorProps.a.v[0] * mult\n              }\n            }\n          }\n          flag = true\n          // Force alignment only works with a single line for now\n          if (this._pathData.a.v) {\n            currentLength =\n              letters[0].an * 0.5 +\n              ((totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind) /\n                (len - 1)\n            currentLength += this._pathData.f.v\n          }\n          while (flag) {\n            if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\n              perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength\n              xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc\n              yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc\n              matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01)\n              flag = false\n            } else if (points) {\n              segmentLength += currentPoint.partialLength\n              pointInd += 1\n              if (pointInd >= points.length) {\n                pointInd = 0\n                segmentInd += 1\n                if (!segments[segmentInd]) {\n                  if (mask.v.c) {\n                    pointInd = 0\n                    segmentInd = 0\n                    points = segments[segmentInd].points\n                  } else {\n                    segmentLength -= currentPoint.partialLength\n                    points = null\n                  }\n                } else {\n                  points = segments[segmentInd].points\n                }\n              }\n              if (points) {\n                prevPoint = currentPoint\n                currentPoint = points[pointInd]\n                partialLength = currentPoint.partialLength\n              }\n            }\n          }\n          offf = letters[i].an / 2 - letters[i].add\n          matrixHelper.translate(-offf, 0, 0)\n        } else {\n          offf = letters[i].an / 2 - letters[i].add\n          matrixHelper.translate(-offf, 0, 0)\n\n          // Grouping alignment\n          matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0)\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a\n          if (animatorProps.t.propType) {\n            animatorSelector = animators[j].s\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n            // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \"isNewLine\"\n            if (xPos !== 0 || documentData.j !== 0) {\n              if (this._hasMaskedPath) {\n                if (mult.length) {\n                  currentLength += animatorProps.t.v * mult[0]\n                } else {\n                  currentLength += animatorProps.t.v * mult\n                }\n              } else if (mult.length) {\n                xPos += animatorProps.t.v * mult[0]\n              } else {\n                xPos += animatorProps.t.v * mult\n              }\n            }\n          }\n        }\n        if (documentData.strokeWidthAnim) {\n          sw = documentData.sw || 0\n        }\n        if (documentData.strokeColorAnim) {\n          if (documentData.sc) {\n            sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]]\n          } else {\n            sc = [0, 0, 0]\n          }\n        }\n        if (documentData.fillColorAnim && documentData.fc) {\n          fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]]\n        }\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a\n          if (animatorProps.a.propType) {\n            animatorSelector = animators[j].s\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n\n            if (mult.length) {\n              matrixHelper.translate(\n                -animatorProps.a.v[0] * mult[0],\n                -animatorProps.a.v[1] * mult[1],\n                animatorProps.a.v[2] * mult[2],\n              )\n            } else {\n              matrixHelper.translate(\n                -animatorProps.a.v[0] * mult,\n                -animatorProps.a.v[1] * mult,\n                animatorProps.a.v[2] * mult,\n              )\n            }\n          }\n        }\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a\n          if (animatorProps.s.propType) {\n            animatorSelector = animators[j].s\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n            if (mult.length) {\n              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1)\n            } else {\n              matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1)\n            }\n          }\n        }\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a\n          animatorSelector = animators[j].s\n          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n          if (animatorProps.sk.propType) {\n            if (mult.length) {\n              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1])\n            } else {\n              matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult)\n            }\n          }\n          if (animatorProps.r.propType) {\n            if (mult.length) {\n              matrixHelper.rotateZ(-animatorProps.r.v * mult[2])\n            } else {\n              matrixHelper.rotateZ(-animatorProps.r.v * mult)\n            }\n          }\n          if (animatorProps.ry.propType) {\n            if (mult.length) {\n              matrixHelper.rotateY(animatorProps.ry.v * mult[1])\n            } else {\n              matrixHelper.rotateY(animatorProps.ry.v * mult)\n            }\n          }\n          if (animatorProps.rx.propType) {\n            if (mult.length) {\n              matrixHelper.rotateX(animatorProps.rx.v * mult[0])\n            } else {\n              matrixHelper.rotateX(animatorProps.rx.v * mult)\n            }\n          }\n          if (animatorProps.o.propType) {\n            if (mult.length) {\n              elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0]\n            } else {\n              elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult\n            }\n          }\n          if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\n            if (mult.length) {\n              sw += animatorProps.sw.v * mult[0]\n            } else {\n              sw += animatorProps.sw.v * mult\n            }\n          }\n          if (documentData.strokeColorAnim && animatorProps.sc.propType) {\n            for (k = 0; k < 3; k += 1) {\n              if (mult.length) {\n                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0]\n              } else {\n                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult\n              }\n            }\n          }\n          if (documentData.fillColorAnim && documentData.fc) {\n            if (animatorProps.fc.propType) {\n              for (k = 0; k < 3; k += 1) {\n                if (mult.length) {\n                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0]\n                } else {\n                  fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult\n                }\n              }\n            }\n            if (animatorProps.fh.propType) {\n              if (mult.length) {\n                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0])\n              } else {\n                fc = addHueToRGB(fc, animatorProps.fh.v * mult)\n              }\n            }\n            if (animatorProps.fs.propType) {\n              if (mult.length) {\n                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0])\n              } else {\n                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult)\n              }\n            }\n            if (animatorProps.fb.propType) {\n              if (mult.length) {\n                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0])\n              } else {\n                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult)\n              }\n            }\n          }\n        }\n\n        for (j = 0; j < jLen; j += 1) {\n          animatorProps = animators[j].a\n\n          if (animatorProps.p.propType) {\n            animatorSelector = animators[j].s\n            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)\n            if (this._hasMaskedPath) {\n              if (mult.length) {\n                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1])\n              } else {\n                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult)\n              }\n            } else if (mult.length) {\n              matrixHelper.translate(\n                animatorProps.p.v[0] * mult[0],\n                animatorProps.p.v[1] * mult[1],\n                -animatorProps.p.v[2] * mult[2],\n              )\n            } else {\n              matrixHelper.translate(\n                animatorProps.p.v[0] * mult,\n                animatorProps.p.v[1] * mult,\n                -animatorProps.p.v[2] * mult,\n              )\n            }\n          }\n        }\n        if (documentData.strokeWidthAnim) {\n          letterSw = sw < 0 ? 0 : sw\n        }\n        if (documentData.strokeColorAnim) {\n          letterSc =\n            'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')'\n        }\n        if (documentData.fillColorAnim && documentData.fc) {\n          letterFc =\n            'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')'\n        }\n\n        if (this._hasMaskedPath) {\n          matrixHelper.translate(0, -documentData.ls)\n\n          matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0)\n          if (this._pathData.p.v) {\n            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0])\n            var rot = (Math.atan(tanAngle) * 180) / Math.PI\n            if (currentPoint.point[0] < prevPoint.point[0]) {\n              rot += 180\n            }\n            matrixHelper.rotate((-rot * Math.PI) / 180)\n          }\n          matrixHelper.translate(xPathPos, yPathPos, 0)\n          currentLength -= alignment[0] * letters[i].an * 0.005\n          if (letters[i + 1] && ind !== letters[i + 1].ind) {\n            currentLength += letters[i].an / 2\n            currentLength += documentData.tr * 0.001 * documentData.finalSize\n          }\n        } else {\n          matrixHelper.translate(xPos, yPos, 0)\n\n          if (documentData.ps) {\n            // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\n            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0)\n          }\n          switch (documentData.j) {\n            case 1:\n              matrixHelper.translate(\n                letters[i].animatorJustifyOffset +\n                  documentData.justifyOffset +\n                  (documentData.boxWidth - documentData.lineWidths[letters[i].line]),\n                0,\n                0,\n              )\n              break\n            case 2:\n              matrixHelper.translate(\n                letters[i].animatorJustifyOffset +\n                  documentData.justifyOffset +\n                  (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2,\n                0,\n                0,\n              )\n              break\n            default:\n              break\n          }\n          matrixHelper.translate(0, -documentData.ls)\n          matrixHelper.translate(offf, 0, 0)\n          matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0)\n          xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize\n        }\n        if (renderType === 'html') {\n          letterM = matrixHelper.toCSS()\n        } else if (renderType === 'svg') {\n          letterM = matrixHelper.to2dCSS()\n        } else {\n          letterP = [\n            matrixHelper.props[0],\n            matrixHelper.props[1],\n            matrixHelper.props[2],\n            matrixHelper.props[3],\n            matrixHelper.props[4],\n            matrixHelper.props[5],\n            matrixHelper.props[6],\n            matrixHelper.props[7],\n            matrixHelper.props[8],\n            matrixHelper.props[9],\n            matrixHelper.props[10],\n            matrixHelper.props[11],\n            matrixHelper.props[12],\n            matrixHelper.props[13],\n            matrixHelper.props[14],\n            matrixHelper.props[15],\n          ]\n        }\n        letterO = elemOpacity\n      }\n\n      if (renderedLettersCount <= i) {\n        letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP)\n        this.renderedLetters.push(letterValue)\n        renderedLettersCount += 1\n        this.lettersChangedFlag = true\n      } else {\n        letterValue = this.renderedLetters[i]\n        this.lettersChangedFlag =\n          letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag\n      }\n    }\n  }\n\n  TextAnimatorProperty.prototype.getValue = function () {\n    if (this._elem.globalData.frameId === this._frameId) {\n      return\n    }\n    this._frameId = this._elem.globalData.frameId\n    this.iterateDynamicProperties()\n  }\n\n  TextAnimatorProperty.prototype.mHelper = new Matrix()\n  TextAnimatorProperty.prototype.defaultPropsArray = []\n  extendPrototype([DynamicPropertyContainer], TextAnimatorProperty)\n\n  function ITextElement() {}\n\n  ITextElement.prototype.initElement = function (data, globalData, comp) {\n    this.lettersChangedFlag = true\n    this.initFrame()\n    this.initBaseData(data, globalData, comp)\n    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties)\n    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this)\n    this.initTransform(data, globalData, comp)\n    this.initHierarchy()\n    this.initRenderable()\n    this.initRendererElement()\n    this.createContainerElements()\n    this.createRenderableComponents()\n    this.createContent()\n    this.hide()\n    this.textAnimator.searchProperties(this.dynamicProperties)\n  }\n\n  ITextElement.prototype.prepareFrame = function (num) {\n    this._mdf = false\n    this.prepareRenderableFrame(num)\n    this.prepareProperties(num, this.isInRange)\n    if (this.textProperty._mdf || this.textProperty._isFirstFrame) {\n      this.buildNewText()\n      this.textProperty._isFirstFrame = false\n      this.textProperty._mdf = false\n    }\n  }\n\n  ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {\n    var j\n    var jLen = shapes.length\n    var pathNodes\n    var shapeStr = ''\n    for (j = 0; j < jLen; j += 1) {\n      if (shapes[j].ty === 'sh') {\n        pathNodes = shapes[j].ks.k\n        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper)\n      }\n    }\n    return shapeStr\n  }\n\n  ITextElement.prototype.updateDocumentData = function (newData, index) {\n    this.textProperty.updateDocumentData(newData, index)\n  }\n\n  ITextElement.prototype.canResizeFont = function (_canResize) {\n    this.textProperty.canResizeFont(_canResize)\n  }\n\n  ITextElement.prototype.setMinimumFontSize = function (_fontSize) {\n    this.textProperty.setMinimumFontSize(_fontSize)\n  }\n\n  ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {\n    if (documentData.ps) {\n      matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0)\n    }\n    matrixHelper.translate(0, -documentData.ls, 0)\n    switch (documentData.j) {\n      case 1:\n        matrixHelper.translate(\n          documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]),\n          0,\n          0,\n        )\n        break\n      case 2:\n        matrixHelper.translate(\n          documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2,\n          0,\n          0,\n        )\n        break\n      default:\n        break\n    }\n    matrixHelper.translate(xPos, yPos, 0)\n  }\n\n  ITextElement.prototype.buildColor = function (colorData) {\n    return (\n      'rgb(' +\n      Math.round(colorData[0] * 255) +\n      ',' +\n      Math.round(colorData[1] * 255) +\n      ',' +\n      Math.round(colorData[2] * 255) +\n      ')'\n    )\n  }\n\n  ITextElement.prototype.emptyProp = new LetterProps()\n\n  ITextElement.prototype.destroy = function () {}\n\n  var emptyShapeData = {\n    shapes: [],\n  }\n\n  function SVGTextLottieElement(data, globalData, comp) {\n    this.textSpans = []\n    this.renderType = 'svg'\n    this.initElement(data, globalData, comp)\n  }\n\n  extendPrototype(\n    [BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement],\n    SVGTextLottieElement,\n  )\n\n  SVGTextLottieElement.prototype.createContent = function () {\n    if (this.data.singleShape && !this.globalData.fontManager.chars) {\n      this.textContainer = createNS('text')\n    }\n  }\n\n  SVGTextLottieElement.prototype.buildTextContents = function (textArray) {\n    var i = 0\n    var len = textArray.length\n    var textContents = []\n    var currentTextContent = ''\n    while (i < len) {\n      if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\n        textContents.push(currentTextContent)\n        currentTextContent = ''\n      } else {\n        currentTextContent += textArray[i]\n      }\n      i += 1\n    }\n    textContents.push(currentTextContent)\n    return textContents\n  }\n\n  SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {\n    // data should probably be cloned to apply scale separately to each instance of a text on different layers\n    // but since text internal content gets only rendered once and then it's never rerendered,\n    // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.\n    // Avoiding cloning is preferred since cloning each character shape data is expensive\n    if (data.shapes && data.shapes.length) {\n      var shape = data.shapes[0]\n      if (shape.it) {\n        var shapeItem = shape.it[shape.it.length - 1]\n        if (shapeItem.s) {\n          shapeItem.s.k[0] = scale\n          shapeItem.s.k[1] = scale\n        }\n      }\n    }\n    return data\n  }\n\n  SVGTextLottieElement.prototype.buildNewText = function () {\n    this.addDynamicProperty(this)\n    var i\n    var len\n\n    var documentData = this.textProperty.currentData\n    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0)\n    if (documentData.fc) {\n      this.layerElement.setAttribute('fill', this.buildColor(documentData.fc))\n    } else {\n      this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)')\n    }\n    if (documentData.sc) {\n      this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc))\n      this.layerElement.setAttribute('stroke-width', documentData.sw)\n    }\n    this.layerElement.setAttribute('font-size', documentData.finalSize)\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f)\n    if (fontData.fClass) {\n      this.layerElement.setAttribute('class', fontData.fClass)\n    } else {\n      this.layerElement.setAttribute('font-family', fontData.fFamily)\n      var fWeight = documentData.fWeight\n      var fStyle = documentData.fStyle\n      this.layerElement.setAttribute('font-style', fStyle)\n      this.layerElement.setAttribute('font-weight', fWeight)\n    }\n    this.layerElement.setAttribute('aria-label', documentData.t)\n\n    var letters = documentData.l || []\n    var usesGlyphs = !!this.globalData.fontManager.chars\n    len = letters.length\n\n    var tSpan\n    var matrixHelper = this.mHelper\n    var shapeStr = ''\n    var singleShape = this.data.singleShape\n    var xPos = 0\n    var yPos = 0\n    var firstLine = true\n    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize\n    if (singleShape && !usesGlyphs && !documentData.sz) {\n      var tElement = this.textContainer\n      var justify = 'start'\n      switch (documentData.j) {\n        case 1:\n          justify = 'end'\n          break\n        case 2:\n          justify = 'middle'\n          break\n        default:\n          justify = 'start'\n          break\n      }\n      tElement.setAttribute('text-anchor', justify)\n      tElement.setAttribute('letter-spacing', trackingOffset)\n      var textContent = this.buildTextContents(documentData.finalText)\n      len = textContent.length\n      yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0\n      for (i = 0; i < len; i += 1) {\n        tSpan = this.textSpans[i].span || createNS('tspan')\n        tSpan.textContent = textContent[i]\n        tSpan.setAttribute('x', 0)\n        tSpan.setAttribute('y', yPos)\n        tSpan.style.display = 'inherit'\n        tElement.appendChild(tSpan)\n        if (!this.textSpans[i]) {\n          this.textSpans[i] = {\n            span: null,\n            glyph: null,\n          }\n        }\n        this.textSpans[i].span = tSpan\n        yPos += documentData.finalLineHeight\n      }\n\n      this.layerElement.appendChild(tElement)\n    } else {\n      var cachedSpansLength = this.textSpans.length\n      var charData\n      for (i = 0; i < len; i += 1) {\n        if (!this.textSpans[i]) {\n          this.textSpans[i] = {\n            span: null,\n            childSpan: null,\n            glyph: null,\n          }\n        }\n        if (!usesGlyphs || !singleShape || i === 0) {\n          tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text')\n          if (cachedSpansLength <= i) {\n            tSpan.setAttribute('stroke-linecap', 'butt')\n            tSpan.setAttribute('stroke-linejoin', 'round')\n            tSpan.setAttribute('stroke-miterlimit', '4')\n            this.textSpans[i].span = tSpan\n            if (usesGlyphs) {\n              var childSpan = createNS('g')\n              tSpan.appendChild(childSpan)\n              this.textSpans[i].childSpan = childSpan\n            }\n            this.textSpans[i].span = tSpan\n            this.layerElement.appendChild(tSpan)\n          }\n          tSpan.style.display = 'inherit'\n        }\n\n        matrixHelper.reset()\n        if (singleShape) {\n          if (letters[i].n) {\n            xPos = -trackingOffset\n            yPos += documentData.yOffset\n            yPos += firstLine ? 1 : 0\n            firstLine = false\n          }\n          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos)\n          xPos += letters[i].l || 0\n          // xPos += letters[i].val === ' ' ? 0 : trackingOffset;\n          xPos += trackingOffset\n        }\n        if (usesGlyphs) {\n          charData = this.globalData.fontManager.getCharData(\n            documentData.finalText[i],\n            fontData.fStyle,\n            this.globalData.fontManager.getFontByName(documentData.f).fFamily,\n          )\n          var glyphElement\n          // t === 1 means the character has been replaced with an animated shaped\n          if (charData.t === 1) {\n            glyphElement = new SVGCompElement(charData.data, this.globalData, this)\n          } else {\n            var data = emptyShapeData\n            if (charData.data && charData.data.shapes) {\n              data = this.buildShapeData(charData.data, documentData.finalSize)\n            }\n            glyphElement = new SVGShapeElement(data, this.globalData, this)\n          }\n          if (this.textSpans[i].glyph) {\n            var glyph = this.textSpans[i].glyph\n            this.textSpans[i].childSpan.removeChild(glyph.layerElement)\n            glyph.destroy()\n          }\n          this.textSpans[i].glyph = glyphElement\n          glyphElement._debug = true\n          glyphElement.prepareFrame(0)\n          glyphElement.renderFrame()\n          this.textSpans[i].childSpan.appendChild(glyphElement.layerElement)\n          // when using animated shapes, the layer will be scaled instead of replacing the internal scale\n          // this might have issues with strokes and might need a different solution\n          if (charData.t === 1) {\n            this.textSpans[i].childSpan.setAttribute(\n              'transform',\n              'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')',\n            )\n          }\n        } else {\n          if (singleShape) {\n            tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')')\n          }\n          tSpan.textContent = letters[i].val\n          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve')\n        }\n        //\n      }\n      if (singleShape && tSpan) {\n        tSpan.setAttribute('d', shapeStr)\n      }\n    }\n    while (i < this.textSpans.length) {\n      this.textSpans[i].span.style.display = 'none'\n      i += 1\n    }\n\n    this._sizeChanged = true\n  }\n\n  SVGTextLottieElement.prototype.sourceRectAtTime = function () {\n    this.prepareFrame(this.comp.renderedFrame - this.data.st)\n    this.renderInnerContent()\n    if (this._sizeChanged) {\n      this._sizeChanged = false\n      var textBox = this.layerElement.getBBox()\n      this.bbox = {\n        top: textBox.y,\n        left: textBox.x,\n        width: textBox.width,\n        height: textBox.height,\n      }\n    }\n    return this.bbox\n  }\n\n  SVGTextLottieElement.prototype.getValue = function () {\n    var i\n    var len = this.textSpans.length\n    var glyphElement\n    this.renderedFrame = this.comp.renderedFrame\n    for (i = 0; i < len; i += 1) {\n      glyphElement = this.textSpans[i].glyph\n      if (glyphElement) {\n        glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st)\n        if (glyphElement._mdf) {\n          this._mdf = true\n        }\n      }\n    }\n  }\n\n  SVGTextLottieElement.prototype.renderInnerContent = function () {\n    if (!this.data.singleShape || this._mdf) {\n      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag)\n      if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {\n        this._sizeChanged = true\n        var i\n        var len\n        var renderedLetters = this.textAnimator.renderedLetters\n\n        var letters = this.textProperty.currentData.l\n\n        len = letters.length\n        var renderedLetter\n        var textSpan\n        var glyphElement\n        for (i = 0; i < len; i += 1) {\n          if (!letters[i].n) {\n            renderedLetter = renderedLetters[i]\n            textSpan = this.textSpans[i].span\n            glyphElement = this.textSpans[i].glyph\n            if (glyphElement) {\n              glyphElement.renderFrame()\n            }\n            if (renderedLetter._mdf.m) {\n              textSpan.setAttribute('transform', renderedLetter.m)\n            }\n            if (renderedLetter._mdf.o) {\n              textSpan.setAttribute('opacity', renderedLetter.o)\n            }\n            if (renderedLetter._mdf.sw) {\n              textSpan.setAttribute('stroke-width', renderedLetter.sw)\n            }\n            if (renderedLetter._mdf.sc) {\n              textSpan.setAttribute('stroke', renderedLetter.sc)\n            }\n            if (renderedLetter._mdf.fc) {\n              textSpan.setAttribute('fill', renderedLetter.fc)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function ISolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp)\n  }\n  extendPrototype([IImageElement], ISolidElement)\n\n  ISolidElement.prototype.createContent = function () {\n    var rect = createNS('rect')\n    /// /rect.style.width = this.data.sw;\n    /// /rect.style.height = this.data.sh;\n    /// /rect.style.fill = this.data.sc;\n    rect.setAttribute('width', this.data.sw)\n    rect.setAttribute('height', this.data.sh)\n    rect.setAttribute('fill', this.data.sc)\n    this.layerElement.appendChild(rect)\n  }\n\n  function NullElement(data, globalData, comp) {\n    this.initFrame()\n    this.initBaseData(data, globalData, comp)\n    this.initFrame()\n    this.initTransform(data, globalData, comp)\n    this.initHierarchy()\n  }\n\n  NullElement.prototype.prepareFrame = function (num) {\n    this.prepareProperties(num, true)\n  }\n\n  NullElement.prototype.renderFrame = function () {}\n\n  NullElement.prototype.getBaseElement = function () {\n    return null\n  }\n\n  NullElement.prototype.destroy = function () {}\n\n  NullElement.prototype.sourceRectAtTime = function () {}\n\n  NullElement.prototype.hide = function () {}\n\n  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement)\n\n  function SVGRendererBase() {}\n\n  extendPrototype([BaseRenderer], SVGRendererBase)\n\n  SVGRendererBase.prototype.createNull = function (data) {\n    return new NullElement(data, this.globalData, this)\n  }\n\n  SVGRendererBase.prototype.createShape = function (data) {\n    return new SVGShapeElement(data, this.globalData, this)\n  }\n\n  SVGRendererBase.prototype.createText = function (data) {\n    return new SVGTextLottieElement(data, this.globalData, this)\n  }\n\n  SVGRendererBase.prototype.createImage = function (data) {\n    return new IImageElement(data, this.globalData, this)\n  }\n\n  SVGRendererBase.prototype.createSolid = function (data) {\n    return new ISolidElement(data, this.globalData, this)\n  }\n\n  SVGRendererBase.prototype.configAnimation = function (animData) {\n    this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg')\n    if (this.renderConfig.viewBoxSize) {\n      this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize)\n    } else {\n      this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h)\n    }\n\n    if (!this.renderConfig.viewBoxOnly) {\n      this.svgElement.setAttribute('width', animData.w)\n      this.svgElement.setAttribute('height', animData.h)\n      this.svgElement.style.width = '100%'\n      this.svgElement.style.height = '100%'\n      this.svgElement.style.transform = 'translate3d(0,0,0)'\n      this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility\n    }\n    if (this.renderConfig.width) {\n      this.svgElement.setAttribute('width', this.renderConfig.width)\n    }\n    if (this.renderConfig.height) {\n      this.svgElement.setAttribute('height', this.renderConfig.height)\n    }\n    if (this.renderConfig.className) {\n      this.svgElement.setAttribute('class', this.renderConfig.className)\n    }\n    if (this.renderConfig.id) {\n      this.svgElement.setAttribute('id', this.renderConfig.id)\n    }\n    if (this.renderConfig.focusable !== undefined) {\n      this.svgElement.setAttribute('focusable', this.renderConfig.focusable)\n    }\n    this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio)\n    // this.layerElement.style.transform = 'translate3d(0,0,0)';\n    // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \"0px 0px 0px\";\n    this.animationItem.wrapper.appendChild(this.svgElement)\n    // Mask animation\n    var defs = this.globalData.defs\n\n    this.setupGlobalData(animData, defs)\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad\n    this.data = animData\n\n    var maskElement = createNS('clipPath')\n    var rect = createNS('rect')\n    rect.setAttribute('width', animData.w)\n    rect.setAttribute('height', animData.h)\n    rect.setAttribute('x', 0)\n    rect.setAttribute('y', 0)\n    var maskId = createElementID()\n    maskElement.setAttribute('id', maskId)\n    maskElement.appendChild(rect)\n    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')')\n\n    defs.appendChild(maskElement)\n    this.layers = animData.layers\n    this.elements = createSizedArray(animData.layers.length)\n  }\n\n  SVGRendererBase.prototype.destroy = function () {\n    if (this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = ''\n    }\n    this.layerElement = null\n    this.globalData.defs = null\n    var i\n    var len = this.layers ? this.layers.length : 0\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy()\n      }\n    }\n    this.elements.length = 0\n    this.destroyed = true\n    this.animationItem = null\n  }\n\n  SVGRendererBase.prototype.updateContainerSize = function () {}\n\n  SVGRendererBase.prototype.buildItem = function (pos) {\n    var elements = this.elements\n    if (elements[pos] || this.layers[pos].ty === 99) {\n      return\n    }\n    elements[pos] = true\n    var element = this.createItem(this.layers[pos])\n\n    elements[pos] = element\n    if (getExpressionsPlugin()) {\n      if (this.layers[pos].ty === 0) {\n        this.globalData.projectInterface.registerComposition(element)\n      }\n      element.initExpressions()\n    }\n    this.appendElementInPos(element, pos)\n    if (this.layers[pos].tt) {\n      if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {\n        this.buildItem(pos - 1)\n        this.addPendingElement(element)\n      } else {\n        element.setMatte(elements[pos - 1].layerId)\n      }\n    }\n  }\n\n  SVGRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop()\n      element.checkParenting()\n      if (element.data.tt) {\n        var i = 0\n        var len = this.elements.length\n        while (i < len) {\n          if (this.elements[i] === element) {\n            element.setMatte(this.elements[i - 1].layerId)\n            break\n          }\n          i += 1\n        }\n      }\n    }\n  }\n\n  SVGRendererBase.prototype.renderFrame = function (num) {\n    if (this.renderedFrame === num || this.destroyed) {\n      return\n    }\n    if (num === null) {\n      num = this.renderedFrame\n    } else {\n      this.renderedFrame = num\n    }\n    // console.log('-------');\n    // console.log('FRAME ',num);\n    this.globalData.frameNum = num\n    this.globalData.frameId += 1\n    this.globalData.projectInterface.currentFrame = num\n    this.globalData._mdf = false\n    var i\n    var len = this.layers.length\n    if (!this.completeLayers) {\n      this.checkLayers(num)\n    }\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(num - this.layers[i].st)\n      }\n    }\n    if (this.globalData._mdf) {\n      for (i = 0; i < len; i += 1) {\n        if (this.completeLayers || this.elements[i]) {\n          this.elements[i].renderFrame()\n        }\n      }\n    }\n  }\n\n  SVGRendererBase.prototype.appendElementInPos = function (element, pos) {\n    var newElement = element.getBaseElement()\n    if (!newElement) {\n      return\n    }\n    var i = 0\n    var nextElement\n    while (i < pos) {\n      if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {\n        nextElement = this.elements[i].getBaseElement()\n      }\n      i += 1\n    }\n    if (nextElement) {\n      this.layerElement.insertBefore(newElement, nextElement)\n    } else {\n      this.layerElement.appendChild(newElement)\n    }\n  }\n\n  SVGRendererBase.prototype.hide = function () {\n    this.layerElement.style.display = 'none'\n  }\n\n  SVGRendererBase.prototype.show = function () {\n    this.layerElement.style.display = 'block'\n  }\n\n  function ICompElement() {}\n\n  extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement)\n\n  ICompElement.prototype.initElement = function (data, globalData, comp) {\n    this.initFrame()\n    this.initBaseData(data, globalData, comp)\n    this.initTransform(data, globalData, comp)\n    this.initRenderable()\n    this.initHierarchy()\n    this.initRendererElement()\n    this.createContainerElements()\n    this.createRenderableComponents()\n    if (this.data.xt || !globalData.progressiveLoad) {\n      this.buildAllItems()\n    }\n    this.hide()\n  }\n\n  /* ICompElement.prototype.hide = function(){\n    if(!this.hidden){\n        this.hideElement();\n        var i,len = this.elements.length;\n        for( i = 0; i < len; i+=1 ){\n            if(this.elements[i]){\n                this.elements[i].hide();\n            }\n        }\n    }\n}; */\n\n  ICompElement.prototype.prepareFrame = function (num) {\n    this._mdf = false\n    this.prepareRenderableFrame(num)\n    this.prepareProperties(num, this.isInRange)\n    if (!this.isInRange && !this.data.xt) {\n      return\n    }\n\n    if (!this.tm._placeholder) {\n      var timeRemapped = this.tm.v\n      if (timeRemapped === this.data.op) {\n        timeRemapped = this.data.op - 1\n      }\n      this.renderedFrame = timeRemapped\n    } else {\n      this.renderedFrame = num / this.data.sr\n    }\n    var i\n    var len = this.elements.length\n    if (!this.completeLayers) {\n      this.checkLayers(this.renderedFrame)\n    }\n    // This iteration needs to be backwards because of how expressions connect between each other\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st)\n        if (this.elements[i]._mdf) {\n          this._mdf = true\n        }\n      }\n    }\n  }\n\n  ICompElement.prototype.renderInnerContent = function () {\n    var i\n    var len = this.layers.length\n    for (i = 0; i < len; i += 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].renderFrame()\n      }\n    }\n  }\n\n  ICompElement.prototype.setElements = function (elems) {\n    this.elements = elems\n  }\n\n  ICompElement.prototype.getElements = function () {\n    return this.elements\n  }\n\n  ICompElement.prototype.destroyElements = function () {\n    var i\n    var len = this.layers.length\n    for (i = 0; i < len; i += 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy()\n      }\n    }\n  }\n\n  ICompElement.prototype.destroy = function () {\n    this.destroyElements()\n    this.destroyBaseElement()\n  }\n\n  function SVGCompElement(data, globalData, comp) {\n    this.layers = data.layers\n    this.supports3d = true\n    this.completeLayers = false\n    this.pendingElements = []\n    this.elements = this.layers ? createSizedArray(this.layers.length) : []\n    this.initElement(data, globalData, comp)\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true }\n  }\n\n  extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement)\n\n  SVGCompElement.prototype.createComp = function (data) {\n    return new SVGCompElement(data, this.globalData, this)\n  }\n\n  function SVGRenderer(animationItem, config) {\n    this.animationItem = animationItem\n    this.layers = null\n    this.renderedFrame = -1\n    this.svgElement = createNS('svg')\n    var ariaLabel = ''\n    if (config && config.title) {\n      var titleElement = createNS('title')\n      var titleId = createElementID()\n      titleElement.setAttribute('id', titleId)\n      titleElement.textContent = config.title\n      this.svgElement.appendChild(titleElement)\n      ariaLabel += titleId\n    }\n    if (config && config.description) {\n      var descElement = createNS('desc')\n      var descId = createElementID()\n      descElement.setAttribute('id', descId)\n      descElement.textContent = config.description\n      this.svgElement.appendChild(descElement)\n      ariaLabel += ' ' + descId\n    }\n    if (ariaLabel) {\n      this.svgElement.setAttribute('aria-labelledby', ariaLabel)\n    }\n    var defs = createNS('defs')\n    this.svgElement.appendChild(defs)\n    var maskElement = createNS('g')\n    this.svgElement.appendChild(maskElement)\n    this.layerElement = maskElement\n    this.renderConfig = {\n      preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',\n      imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',\n      contentVisibility: (config && config.contentVisibility) || 'visible',\n      progressiveLoad: (config && config.progressiveLoad) || false,\n      hideOnTransparent: !(config && config.hideOnTransparent === false),\n      viewBoxOnly: (config && config.viewBoxOnly) || false,\n      viewBoxSize: (config && config.viewBoxSize) || false,\n      className: (config && config.className) || '',\n      id: (config && config.id) || '',\n      focusable: config && config.focusable,\n      filterSize: {\n        width: (config && config.filterSize && config.filterSize.width) || '100%',\n        height: (config && config.filterSize && config.filterSize.height) || '100%',\n        x: (config && config.filterSize && config.filterSize.x) || '0%',\n        y: (config && config.filterSize && config.filterSize.y) || '0%',\n      },\n      width: config && config.width,\n      height: config && config.height,\n    }\n\n    this.globalData = {\n      _mdf: false,\n      frameNum: -1,\n      defs: defs,\n      renderConfig: this.renderConfig,\n    }\n    this.elements = []\n    this.pendingElements = []\n    this.destroyed = false\n    this.rendererType = 'svg'\n  }\n\n  extendPrototype([SVGRendererBase], SVGRenderer)\n\n  SVGRenderer.prototype.createComp = function (data) {\n    return new SVGCompElement(data, this.globalData, this)\n  }\n\n  function CVContextData() {\n    this.saved = []\n    this.cArrPos = 0\n    this.cTr = new Matrix()\n    this.cO = 1\n    var i\n    var len = 15\n    this.savedOp = createTypedArray('float32', len)\n    for (i = 0; i < len; i += 1) {\n      this.saved[i] = createTypedArray('float32', 16)\n    }\n    this._length = len\n  }\n\n  CVContextData.prototype.duplicate = function () {\n    var newLength = this._length * 2\n    var currentSavedOp = this.savedOp\n    this.savedOp = createTypedArray('float32', newLength)\n    this.savedOp.set(currentSavedOp)\n    var i = 0\n    for (i = this._length; i < newLength; i += 1) {\n      this.saved[i] = createTypedArray('float32', 16)\n    }\n    this._length = newLength\n  }\n\n  CVContextData.prototype.reset = function () {\n    this.cArrPos = 0\n    this.cTr.reset()\n    this.cO = 1\n  }\n\n  function ShapeTransformManager() {\n    this.sequences = {}\n    this.sequenceList = []\n    this.transform_key_count = 0\n  }\n\n  ShapeTransformManager.prototype = {\n    addTransformSequence: function (transforms) {\n      var i\n      var len = transforms.length\n      var key = '_'\n      for (i = 0; i < len; i += 1) {\n        key += transforms[i].transform.key + '_'\n      }\n      var sequence = this.sequences[key]\n      if (!sequence) {\n        sequence = {\n          transforms: [].concat(transforms),\n          finalTransform: new Matrix(),\n          _mdf: false,\n        }\n        this.sequences[key] = sequence\n        this.sequenceList.push(sequence)\n      }\n      return sequence\n    },\n    processSequence: function (sequence, isFirstFrame) {\n      var i = 0\n      var len = sequence.transforms.length\n      var _mdf = isFirstFrame\n      while (i < len && !isFirstFrame) {\n        if (sequence.transforms[i].transform.mProps._mdf) {\n          _mdf = true\n          break\n        }\n        i += 1\n      }\n      if (_mdf) {\n        var props\n        sequence.finalTransform.reset()\n        for (i = len - 1; i >= 0; i -= 1) {\n          props = sequence.transforms[i].transform.mProps.v.props\n          sequence.finalTransform.transform(\n            props[0],\n            props[1],\n            props[2],\n            props[3],\n            props[4],\n            props[5],\n            props[6],\n            props[7],\n            props[8],\n            props[9],\n            props[10],\n            props[11],\n            props[12],\n            props[13],\n            props[14],\n            props[15],\n          )\n        }\n      }\n      sequence._mdf = _mdf\n    },\n    processSequences: function (isFirstFrame) {\n      var i\n      var len = this.sequenceList.length\n      for (i = 0; i < len; i += 1) {\n        this.processSequence(this.sequenceList[i], isFirstFrame)\n      }\n    },\n    getNewKey: function () {\n      this.transform_key_count += 1\n      return '_' + this.transform_key_count\n    },\n  }\n\n  function CVEffects() {}\n  CVEffects.prototype.renderFrame = function () {}\n\n  function CVMaskElement(data, element) {\n    this.data = data\n    this.element = element\n    this.masksProperties = this.data.masksProperties || []\n    this.viewData = createSizedArray(this.masksProperties.length)\n    var i\n    var len = this.masksProperties.length\n    var hasMasks = false\n    for (i = 0; i < len; i += 1) {\n      if (this.masksProperties[i].mode !== 'n') {\n        hasMasks = true\n      }\n      this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3)\n    }\n    this.hasMasks = hasMasks\n    if (hasMasks) {\n      this.element.addRenderableComponent(this)\n    }\n  }\n\n  CVMaskElement.prototype.renderFrame = function () {\n    if (!this.hasMasks) {\n      return\n    }\n    var transform = this.element.finalTransform.mat\n    var ctx = this.element.canvasContext\n    var i\n    var len = this.masksProperties.length\n    var pt\n    var pts\n    var data\n    ctx.beginPath()\n    for (i = 0; i < len; i += 1) {\n      if (this.masksProperties[i].mode !== 'n') {\n        if (this.masksProperties[i].inv) {\n          ctx.moveTo(0, 0)\n          ctx.lineTo(this.element.globalData.compSize.w, 0)\n          ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h)\n          ctx.lineTo(0, this.element.globalData.compSize.h)\n          ctx.lineTo(0, 0)\n        }\n        data = this.viewData[i].v\n        pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0)\n        ctx.moveTo(pt[0], pt[1])\n        var j\n        var jLen = data._length\n        for (j = 1; j < jLen; j += 1) {\n          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j])\n          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5])\n        }\n        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0])\n        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5])\n      }\n    }\n    this.element.globalData.renderer.save(true)\n    ctx.clip()\n  }\n\n  CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty\n\n  CVMaskElement.prototype.destroy = function () {\n    this.element = null\n  }\n\n  function CVBaseElement() {}\n\n  CVBaseElement.prototype = {\n    createElements: function () {},\n    initRendererElement: function () {},\n    createContainerElements: function () {\n      this.canvasContext = this.globalData.canvasContext\n      this.renderableEffectsManager = new CVEffects(this)\n    },\n    createContent: function () {},\n    setBlendMode: function () {\n      var globalData = this.globalData\n      if (globalData.blendMode !== this.data.bm) {\n        globalData.blendMode = this.data.bm\n        var blendModeValue = getBlendMode(this.data.bm)\n        globalData.canvasContext.globalCompositeOperation = blendModeValue\n      }\n    },\n    createRenderableComponents: function () {\n      this.maskManager = new CVMaskElement(this.data, this)\n    },\n    hideElement: function () {\n      if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n        this.hidden = true\n      }\n    },\n    showElement: function () {\n      if (this.isInRange && !this.isTransparent) {\n        this.hidden = false\n        this._isFirstFrame = true\n        this.maskManager._isFirstFrame = true\n      }\n    },\n    renderFrame: function () {\n      if (this.hidden || this.data.hd) {\n        return\n      }\n      this.renderTransform()\n      this.renderRenderable()\n      this.setBlendMode()\n      var forceRealStack = this.data.ty === 0\n      this.globalData.renderer.save(forceRealStack)\n      this.globalData.renderer.ctxTransform(this.finalTransform.mat.props)\n      this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v)\n      this.renderInnerContent()\n      this.globalData.renderer.restore(forceRealStack)\n      if (this.maskManager.hasMasks) {\n        this.globalData.renderer.restore(true)\n      }\n      if (this._isFirstFrame) {\n        this._isFirstFrame = false\n      }\n    },\n    destroy: function () {\n      this.canvasContext = null\n      this.data = null\n      this.globalData = null\n      this.maskManager.destroy()\n    },\n    mHelper: new Matrix(),\n  }\n  CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement\n  CVBaseElement.prototype.show = CVBaseElement.prototype.showElement\n\n  function CVShapeData(element, data, styles, transformsManager) {\n    this.styledShapes = []\n    this.tr = [0, 0, 0, 0, 0, 0]\n    var ty = 4\n    if (data.ty === 'rc') {\n      ty = 5\n    } else if (data.ty === 'el') {\n      ty = 6\n    } else if (data.ty === 'sr') {\n      ty = 7\n    }\n    this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element)\n    var i\n    var len = styles.length\n    var styledShape\n    for (i = 0; i < len; i += 1) {\n      if (!styles[i].closed) {\n        styledShape = {\n          transforms: transformsManager.addTransformSequence(styles[i].transforms),\n          trNodes: [],\n        }\n        this.styledShapes.push(styledShape)\n        styles[i].elements.push(styledShape)\n      }\n    }\n  }\n\n  CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated\n\n  function CVShapeElement(data, globalData, comp) {\n    this.shapes = []\n    this.shapesData = data.shapes\n    this.stylesList = []\n    this.itemsData = []\n    this.prevViewData = []\n    this.shapeModifiers = []\n    this.processedElements = []\n    this.transformsManager = new ShapeTransformManager()\n    this.initElement(data, globalData, comp)\n  }\n\n  extendPrototype(\n    [BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement],\n    CVShapeElement,\n  )\n\n  CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement\n\n  CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: false }\n\n  CVShapeElement.prototype.dashResetter = []\n\n  CVShapeElement.prototype.createContent = function () {\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, [])\n  }\n\n  CVShapeElement.prototype.createStyleElement = function (data, transforms) {\n    var styleElem = {\n      data: data,\n      type: data.ty,\n      preTransforms: this.transformsManager.addTransformSequence(transforms),\n      transforms: [],\n      elements: [],\n      closed: data.hd === true,\n    }\n    var elementData = {}\n    if (data.ty === 'fl' || data.ty === 'st') {\n      elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this)\n      if (!elementData.c.k) {\n        styleElem.co =\n          'rgb(' +\n          bmFloor(elementData.c.v[0]) +\n          ',' +\n          bmFloor(elementData.c.v[1]) +\n          ',' +\n          bmFloor(elementData.c.v[2]) +\n          ')'\n      }\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\n      elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this)\n      elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this)\n      elementData.h = PropertyFactory.getProp(this, data.h || { k: 0 }, 0, 0.01, this)\n      elementData.a = PropertyFactory.getProp(this, data.a || { k: 0 }, 0, degToRads, this)\n      elementData.g = new GradientProperty(this, data.g, this)\n    }\n    elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this)\n    if (data.ty === 'st' || data.ty === 'gs') {\n      styleElem.lc = lineCapEnum[data.lc || 2]\n      styleElem.lj = lineJoinEnum[data.lj || 2]\n      if (data.lj == 1) {\n        // eslint-disable-line eqeqeq\n        styleElem.ml = data.ml\n      }\n      elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this)\n      if (!elementData.w.k) {\n        styleElem.wi = elementData.w.v\n      }\n      if (data.d) {\n        var d = new DashProperty(this, data.d, 'canvas', this)\n        elementData.d = d\n        if (!elementData.d.k) {\n          styleElem.da = elementData.d.dashArray\n          styleElem.do = elementData.d.dashoffset[0]\n        }\n      }\n    } else {\n      styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero'\n    }\n    this.stylesList.push(styleElem)\n    elementData.style = styleElem\n    return elementData\n  }\n\n  CVShapeElement.prototype.createGroupElement = function () {\n    var elementData = {\n      it: [],\n      prevViewData: [],\n    }\n    return elementData\n  }\n\n  CVShapeElement.prototype.createTransformElement = function (data) {\n    var elementData = {\n      transform: {\n        opacity: 1,\n        _opMdf: false,\n        key: this.transformsManager.getNewKey(),\n        op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),\n        mProps: TransformPropertyFactory.getTransformProperty(this, data, this),\n      },\n    }\n    return elementData\n  }\n\n  CVShapeElement.prototype.createShapeElement = function (data) {\n    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager)\n\n    this.shapes.push(elementData)\n    this.addShapeToModifiers(elementData)\n    return elementData\n  }\n\n  CVShapeElement.prototype.reloadShapes = function () {\n    this._isFirstFrame = true\n    var i\n    var len = this.itemsData.length\n    for (i = 0; i < len; i += 1) {\n      this.prevViewData[i] = this.itemsData[i]\n    }\n    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, [])\n    len = this.dynamicProperties.length\n    for (i = 0; i < len; i += 1) {\n      this.dynamicProperties[i].getValue()\n    }\n    this.renderModifiers()\n    this.transformsManager.processSequences(this._isFirstFrame)\n  }\n\n  CVShapeElement.prototype.addTransformToStyleList = function (transform) {\n    var i\n    var len = this.stylesList.length\n    for (i = 0; i < len; i += 1) {\n      if (!this.stylesList[i].closed) {\n        this.stylesList[i].transforms.push(transform)\n      }\n    }\n  }\n\n  CVShapeElement.prototype.removeTransformFromStyleList = function () {\n    var i\n    var len = this.stylesList.length\n    for (i = 0; i < len; i += 1) {\n      if (!this.stylesList[i].closed) {\n        this.stylesList[i].transforms.pop()\n      }\n    }\n  }\n\n  CVShapeElement.prototype.closeStyles = function (styles) {\n    var i\n    var len = styles.length\n    for (i = 0; i < len; i += 1) {\n      styles[i].closed = true\n    }\n  }\n\n  CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {\n    var i\n    var len = arr.length - 1\n    var j\n    var jLen\n    var ownStyles = []\n    var ownModifiers = []\n    var processedPos\n    var modifier\n    var currentTransform\n    var ownTransforms = [].concat(transforms)\n    for (i = len; i >= 0; i -= 1) {\n      processedPos = this.searchProcessedElement(arr[i])\n      if (!processedPos) {\n        arr[i]._shouldRender = shouldRender\n      } else {\n        itemsData[i] = prevViewData[processedPos - 1]\n      }\n      if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {\n        if (!processedPos) {\n          itemsData[i] = this.createStyleElement(arr[i], ownTransforms)\n        } else {\n          itemsData[i].style.closed = false\n        }\n\n        ownStyles.push(itemsData[i].style)\n      } else if (arr[i].ty === 'gr') {\n        if (!processedPos) {\n          itemsData[i] = this.createGroupElement(arr[i])\n        } else {\n          jLen = itemsData[i].it.length\n          for (j = 0; j < jLen; j += 1) {\n            itemsData[i].prevViewData[j] = itemsData[i].it[j]\n          }\n        }\n        this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms)\n      } else if (arr[i].ty === 'tr') {\n        if (!processedPos) {\n          currentTransform = this.createTransformElement(arr[i])\n          itemsData[i] = currentTransform\n        }\n        ownTransforms.push(itemsData[i])\n        this.addTransformToStyleList(itemsData[i])\n      } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n        if (!processedPos) {\n          itemsData[i] = this.createShapeElement(arr[i])\n        }\n      } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty)\n          modifier.init(this, arr[i])\n          itemsData[i] = modifier\n          this.shapeModifiers.push(modifier)\n        } else {\n          modifier = itemsData[i]\n          modifier.closed = false\n        }\n        ownModifiers.push(modifier)\n      } else if (arr[i].ty === 'rp') {\n        if (!processedPos) {\n          modifier = ShapeModifiers.getModifier(arr[i].ty)\n          itemsData[i] = modifier\n          modifier.init(this, arr, i, itemsData)\n          this.shapeModifiers.push(modifier)\n          shouldRender = false\n        } else {\n          modifier = itemsData[i]\n          modifier.closed = true\n        }\n        ownModifiers.push(modifier)\n      }\n      this.addProcessedElement(arr[i], i + 1)\n    }\n    this.removeTransformFromStyleList()\n    this.closeStyles(ownStyles)\n    len = ownModifiers.length\n    for (i = 0; i < len; i += 1) {\n      ownModifiers[i].closed = true\n    }\n  }\n\n  CVShapeElement.prototype.renderInnerContent = function () {\n    this.transformHelper.opacity = 1\n    this.transformHelper._opMdf = false\n    this.renderModifiers()\n    this.transformsManager.processSequences(this._isFirstFrame)\n    this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true)\n  }\n\n  CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {\n    if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\n      groupTransform.opacity = parentTransform.opacity\n      groupTransform.opacity *= groupTransform.op.v\n      groupTransform._opMdf = true\n    }\n  }\n\n  CVShapeElement.prototype.drawLayer = function () {\n    var i\n    var len = this.stylesList.length\n    var j\n    var jLen\n    var k\n    var kLen\n    var elems\n    var nodes\n    var renderer = this.globalData.renderer\n    var ctx = this.globalData.canvasContext\n    var type\n    var currentStyle\n    for (i = 0; i < len; i += 1) {\n      currentStyle = this.stylesList[i]\n      type = currentStyle.type\n\n      // Skipping style when\n      // Stroke width equals 0\n      // style should not be rendered (extra unused repeaters)\n      // current opacity equals 0\n      // global opacity equals 0\n      if (\n        !(\n          ((type === 'st' || type === 'gs') && currentStyle.wi === 0) ||\n          !currentStyle.data._shouldRender ||\n          currentStyle.coOp === 0 ||\n          this.globalData.currentGlobalAlpha === 0\n        )\n      ) {\n        renderer.save()\n        elems = currentStyle.elements\n        if (type === 'st' || type === 'gs') {\n          ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd\n          ctx.lineWidth = currentStyle.wi\n          ctx.lineCap = currentStyle.lc\n          ctx.lineJoin = currentStyle.lj\n          ctx.miterLimit = currentStyle.ml || 0\n        } else {\n          ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd\n        }\n        renderer.ctxOpacity(currentStyle.coOp)\n        if (type !== 'st' && type !== 'gs') {\n          ctx.beginPath()\n        }\n        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props)\n        jLen = elems.length\n        for (j = 0; j < jLen; j += 1) {\n          if (type === 'st' || type === 'gs') {\n            ctx.beginPath()\n            if (currentStyle.da) {\n              ctx.setLineDash(currentStyle.da)\n              ctx.lineDashOffset = currentStyle.do\n            }\n          }\n          nodes = elems[j].trNodes\n          kLen = nodes.length\n\n          for (k = 0; k < kLen; k += 1) {\n            if (nodes[k].t === 'm') {\n              ctx.moveTo(nodes[k].p[0], nodes[k].p[1])\n            } else if (nodes[k].t === 'c') {\n              ctx.bezierCurveTo(\n                nodes[k].pts[0],\n                nodes[k].pts[1],\n                nodes[k].pts[2],\n                nodes[k].pts[3],\n                nodes[k].pts[4],\n                nodes[k].pts[5],\n              )\n            } else {\n              ctx.closePath()\n            }\n          }\n          if (type === 'st' || type === 'gs') {\n            ctx.stroke()\n            if (currentStyle.da) {\n              ctx.setLineDash(this.dashResetter)\n            }\n          }\n        }\n        if (type !== 'st' && type !== 'gs') {\n          ctx.fill(currentStyle.r)\n        }\n        renderer.restore()\n      }\n    }\n  }\n\n  CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {\n    var i\n    var len = items.length - 1\n    var groupTransform\n    groupTransform = parentTransform\n    for (i = len; i >= 0; i -= 1) {\n      if (items[i].ty === 'tr') {\n        groupTransform = data[i].transform\n        this.renderShapeTransform(parentTransform, groupTransform)\n      } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {\n        this.renderPath(items[i], data[i])\n      } else if (items[i].ty === 'fl') {\n        this.renderFill(items[i], data[i], groupTransform)\n      } else if (items[i].ty === 'st') {\n        this.renderStroke(items[i], data[i], groupTransform)\n      } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {\n        this.renderGradientFill(items[i], data[i], groupTransform)\n      } else if (items[i].ty === 'gr') {\n        this.renderShape(groupTransform, items[i].it, data[i].it)\n      } else if (items[i].ty === 'tm') {\n        //\n      }\n    }\n    if (isMain) {\n      this.drawLayer()\n    }\n  }\n\n  CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {\n    if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\n      var shapeNodes = styledShape.trNodes\n      var paths = shape.paths\n      var i\n      var len\n      var j\n      var jLen = paths._length\n      shapeNodes.length = 0\n      var groupTransformMat = styledShape.transforms.finalTransform\n      for (j = 0; j < jLen; j += 1) {\n        var pathNodes = paths.shapes[j]\n        if (pathNodes && pathNodes.v) {\n          len = pathNodes._length\n          for (i = 1; i < len; i += 1) {\n            if (i === 1) {\n              shapeNodes.push({\n                t: 'm',\n                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),\n              })\n            }\n            shapeNodes.push({\n              t: 'c',\n              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i]),\n            })\n          }\n          if (len === 1) {\n            shapeNodes.push({\n              t: 'm',\n              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),\n            })\n          }\n          if (pathNodes.c && len) {\n            shapeNodes.push({\n              t: 'c',\n              pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0]),\n            })\n            shapeNodes.push({\n              t: 'z',\n            })\n          }\n        }\n      }\n      styledShape.trNodes = shapeNodes\n    }\n  }\n\n  CVShapeElement.prototype.renderPath = function (pathData, itemData) {\n    if (pathData.hd !== true && pathData._shouldRender) {\n      var i\n      var len = itemData.styledShapes.length\n      for (i = 0; i < len; i += 1) {\n        this.renderStyledShape(itemData.styledShapes[i], itemData.sh)\n      }\n    }\n  }\n\n  CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style\n\n    if (itemData.c._mdf || this._isFirstFrame) {\n      styleElem.co =\n        'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')'\n    }\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n      styleElem.coOp = itemData.o.v * groupTransform.opacity\n    }\n  }\n\n  CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style\n    var grd\n    if (\n      !styleElem.grd ||\n      itemData.g._mdf ||\n      itemData.s._mdf ||\n      itemData.e._mdf ||\n      (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))\n    ) {\n      var ctx = this.globalData.canvasContext\n      var pt1 = itemData.s.v\n      var pt2 = itemData.e.v\n      if (styleData.t === 1) {\n        grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1])\n      } else {\n        var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2))\n        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0])\n\n        var percent = itemData.h.v\n        if (percent >= 1) {\n          percent = 0.99\n        } else if (percent <= -1) {\n          percent = -0.99\n        }\n        var dist = rad * percent\n        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0]\n        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1]\n        grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad)\n      }\n\n      var i\n      var len = styleData.g.p\n      var cValues = itemData.g.c\n      var opacity = 1\n\n      for (i = 0; i < len; i += 1) {\n        if (itemData.g._hasOpacity && itemData.g._collapsable) {\n          opacity = itemData.g.o[i * 2 + 1]\n        }\n        grd.addColorStop(\n          cValues[i * 4] / 100,\n          'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')',\n        )\n      }\n      styleElem.grd = grd\n    }\n    styleElem.coOp = itemData.o.v * groupTransform.opacity\n  }\n\n  CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {\n    var styleElem = itemData.style\n    var d = itemData.d\n    if (d && (d._mdf || this._isFirstFrame)) {\n      styleElem.da = d.dashArray\n      styleElem.do = d.dashoffset[0]\n    }\n    if (itemData.c._mdf || this._isFirstFrame) {\n      styleElem.co =\n        'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')'\n    }\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n      styleElem.coOp = itemData.o.v * groupTransform.opacity\n    }\n    if (itemData.w._mdf || this._isFirstFrame) {\n      styleElem.wi = itemData.w.v\n    }\n  }\n\n  CVShapeElement.prototype.destroy = function () {\n    this.shapesData = null\n    this.globalData = null\n    this.canvasContext = null\n    this.stylesList.length = 0\n    this.itemsData.length = 0\n  }\n\n  function CVTextElement(data, globalData, comp) {\n    this.textSpans = []\n    this.yOffset = 0\n    this.fillColorAnim = false\n    this.strokeColorAnim = false\n    this.strokeWidthAnim = false\n    this.stroke = false\n    this.fill = false\n    this.justifyOffset = 0\n    this.currentRender = null\n    this.renderType = 'canvas'\n    this.values = {\n      fill: 'rgba(0,0,0,0)',\n      stroke: 'rgba(0,0,0,0)',\n      sWidth: 0,\n      fValue: '',\n    }\n    this.initElement(data, globalData, comp)\n  }\n  extendPrototype(\n    [BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement],\n    CVTextElement,\n  )\n\n  CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d')\n\n  CVTextElement.prototype.buildNewText = function () {\n    var documentData = this.textProperty.currentData\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0)\n\n    var hasFill = false\n    if (documentData.fc) {\n      hasFill = true\n      this.values.fill = this.buildColor(documentData.fc)\n    } else {\n      this.values.fill = 'rgba(0,0,0,0)'\n    }\n    this.fill = hasFill\n    var hasStroke = false\n    if (documentData.sc) {\n      hasStroke = true\n      this.values.stroke = this.buildColor(documentData.sc)\n      this.values.sWidth = documentData.sw\n    }\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f)\n    var i\n    var len\n    var letters = documentData.l\n    var matrixHelper = this.mHelper\n    this.stroke = hasStroke\n    this.values.fValue =\n      documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily\n    len = documentData.finalText.length\n    // this.tHelper.font = this.values.fValue;\n    var charData\n    var shapeData\n    var k\n    var kLen\n    var shapes\n    var j\n    var jLen\n    var pathNodes\n    var commands\n    var pathArr\n    var singleShape = this.data.singleShape\n    var trackingOffset = documentData.tr * 0.001 * documentData.finalSize\n    var xPos = 0\n    var yPos = 0\n    var firstLine = true\n    var cnt = 0\n    for (i = 0; i < len; i += 1) {\n      charData = this.globalData.fontManager.getCharData(\n        documentData.finalText[i],\n        fontData.fStyle,\n        this.globalData.fontManager.getFontByName(documentData.f).fFamily,\n      )\n      shapeData = (charData && charData.data) || {}\n      matrixHelper.reset()\n      if (singleShape && letters[i].n) {\n        xPos = -trackingOffset\n        yPos += documentData.yOffset\n        yPos += firstLine ? 1 : 0\n        firstLine = false\n      }\n      shapes = shapeData.shapes ? shapeData.shapes[0].it : []\n      jLen = shapes.length\n      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100)\n      if (singleShape) {\n        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos)\n      }\n      commands = createSizedArray(jLen - 1)\n      var commandsCounter = 0\n      for (j = 0; j < jLen; j += 1) {\n        if (shapes[j].ty === 'sh') {\n          kLen = shapes[j].ks.k.i.length\n          pathNodes = shapes[j].ks.k\n          pathArr = []\n          for (k = 1; k < kLen; k += 1) {\n            if (k === 1) {\n              pathArr.push(\n                matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0),\n                matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0),\n              )\n            }\n            pathArr.push(\n              matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0),\n              matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0),\n              matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0),\n              matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0),\n              matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0),\n              matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0),\n            )\n          }\n          pathArr.push(\n            matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0),\n            matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0),\n            matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0),\n            matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0),\n            matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0),\n            matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0),\n          )\n          commands[commandsCounter] = pathArr\n          commandsCounter += 1\n        }\n      }\n      if (singleShape) {\n        xPos += letters[i].l\n        xPos += trackingOffset\n      }\n      if (this.textSpans[cnt]) {\n        this.textSpans[cnt].elem = commands\n      } else {\n        this.textSpans[cnt] = { elem: commands }\n      }\n      cnt += 1\n    }\n  }\n\n  CVTextElement.prototype.renderInnerContent = function () {\n    var ctx = this.canvasContext\n    ctx.font = this.values.fValue\n    ctx.lineCap = 'butt'\n    ctx.lineJoin = 'miter'\n    ctx.miterLimit = 4\n\n    if (!this.data.singleShape) {\n      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag)\n    }\n\n    var i\n    var len\n    var j\n    var jLen\n    var k\n    var kLen\n    var renderedLetters = this.textAnimator.renderedLetters\n\n    var letters = this.textProperty.currentData.l\n\n    len = letters.length\n    var renderedLetter\n    var lastFill = null\n    var lastStroke = null\n    var lastStrokeW = null\n    var commands\n    var pathArr\n    for (i = 0; i < len; i += 1) {\n      if (!letters[i].n) {\n        renderedLetter = renderedLetters[i]\n        if (renderedLetter) {\n          this.globalData.renderer.save()\n          this.globalData.renderer.ctxTransform(renderedLetter.p)\n          this.globalData.renderer.ctxOpacity(renderedLetter.o)\n        }\n        if (this.fill) {\n          if (renderedLetter && renderedLetter.fc) {\n            if (lastFill !== renderedLetter.fc) {\n              lastFill = renderedLetter.fc\n              ctx.fillStyle = renderedLetter.fc\n            }\n          } else if (lastFill !== this.values.fill) {\n            lastFill = this.values.fill\n            ctx.fillStyle = this.values.fill\n          }\n          commands = this.textSpans[i].elem\n          jLen = commands.length\n          this.globalData.canvasContext.beginPath()\n          for (j = 0; j < jLen; j += 1) {\n            pathArr = commands[j]\n            kLen = pathArr.length\n            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1])\n            for (k = 2; k < kLen; k += 6) {\n              this.globalData.canvasContext.bezierCurveTo(\n                pathArr[k],\n                pathArr[k + 1],\n                pathArr[k + 2],\n                pathArr[k + 3],\n                pathArr[k + 4],\n                pathArr[k + 5],\n              )\n            }\n          }\n          this.globalData.canvasContext.closePath()\n          this.globalData.canvasContext.fill()\n          /// ctx.fillText(this.textSpans[i].val,0,0);\n        }\n        if (this.stroke) {\n          if (renderedLetter && renderedLetter.sw) {\n            if (lastStrokeW !== renderedLetter.sw) {\n              lastStrokeW = renderedLetter.sw\n              ctx.lineWidth = renderedLetter.sw\n            }\n          } else if (lastStrokeW !== this.values.sWidth) {\n            lastStrokeW = this.values.sWidth\n            ctx.lineWidth = this.values.sWidth\n          }\n          if (renderedLetter && renderedLetter.sc) {\n            if (lastStroke !== renderedLetter.sc) {\n              lastStroke = renderedLetter.sc\n              ctx.strokeStyle = renderedLetter.sc\n            }\n          } else if (lastStroke !== this.values.stroke) {\n            lastStroke = this.values.stroke\n            ctx.strokeStyle = this.values.stroke\n          }\n          commands = this.textSpans[i].elem\n          jLen = commands.length\n          this.globalData.canvasContext.beginPath()\n          for (j = 0; j < jLen; j += 1) {\n            pathArr = commands[j]\n            kLen = pathArr.length\n            this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1])\n            for (k = 2; k < kLen; k += 6) {\n              this.globalData.canvasContext.bezierCurveTo(\n                pathArr[k],\n                pathArr[k + 1],\n                pathArr[k + 2],\n                pathArr[k + 3],\n                pathArr[k + 4],\n                pathArr[k + 5],\n              )\n            }\n          }\n          this.globalData.canvasContext.closePath()\n          this.globalData.canvasContext.stroke()\n          /// ctx.strokeText(letters[i].val,0,0);\n        }\n        if (renderedLetter) {\n          this.globalData.renderer.restore()\n        }\n      }\n    }\n  }\n\n  function CVImageElement(data, globalData, comp) {\n    this.assetData = globalData.getAssetData(data.refId)\n    this.img = globalData.imageLoader.getAsset(this.assetData)\n    this.initElement(data, globalData, comp)\n  }\n  extendPrototype(\n    [BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement],\n    CVImageElement,\n  )\n\n  CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement\n  CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame\n\n  CVImageElement.prototype.createContent = function () {\n    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\n      var canvas = createTag('canvas')\n      canvas.width = this.assetData.w\n      canvas.height = this.assetData.h\n      var ctx = canvas.getContext('2d')\n\n      var imgW = this.img.width\n      var imgH = this.img.height\n      var imgRel = imgW / imgH\n      var canvasRel = this.assetData.w / this.assetData.h\n      var widthCrop\n      var heightCrop\n      var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio\n      if ((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {\n        heightCrop = imgH\n        widthCrop = heightCrop * canvasRel\n      } else {\n        widthCrop = imgW\n        heightCrop = widthCrop / canvasRel\n      }\n      ctx.drawImage(\n        this.img,\n        (imgW - widthCrop) / 2,\n        (imgH - heightCrop) / 2,\n        widthCrop,\n        heightCrop,\n        0,\n        0,\n        this.assetData.w,\n        this.assetData.h,\n      )\n      this.img = canvas\n    }\n  }\n\n  CVImageElement.prototype.renderInnerContent = function () {\n    this.canvasContext.drawImage(this.img, 0, 0)\n  }\n\n  CVImageElement.prototype.destroy = function () {\n    this.img = null\n  }\n\n  function CVSolidElement(data, globalData, comp) {\n    this.initElement(data, globalData, comp)\n  }\n  extendPrototype(\n    [BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement],\n    CVSolidElement,\n  )\n\n  CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement\n  CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame\n\n  CVSolidElement.prototype.renderInnerContent = function () {\n    var ctx = this.canvasContext\n    ctx.fillStyle = this.data.sc\n    ctx.fillRect(0, 0, this.data.sw, this.data.sh)\n    //\n  }\n\n  function CanvasRendererBase(animationItem, config) {\n    this.animationItem = animationItem\n    this.renderConfig = {\n      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n      context: (config && config.context) || null,\n      progressiveLoad: (config && config.progressiveLoad) || false,\n      preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',\n      imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',\n      contentVisibility: (config && config.contentVisibility) || 'visible',\n      className: (config && config.className) || '',\n      id: (config && config.id) || '',\n    }\n    this.renderConfig.dpr = (config && config.dpr) || 1\n    if (this.animationItem.wrapper) {\n      this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1\n    }\n    this.renderedFrame = -1\n    this.globalData = {\n      frameNum: -1,\n      _mdf: false,\n      renderConfig: this.renderConfig,\n      currentGlobalAlpha: -1,\n    }\n    this.contextData = new CVContextData()\n    this.elements = []\n    this.pendingElements = []\n    this.transformMat = new Matrix()\n    this.completeLayers = false\n    this.rendererType = 'canvas'\n  }\n  extendPrototype([BaseRenderer], CanvasRendererBase)\n\n  CanvasRendererBase.prototype.createShape = function (data) {\n    return new CVShapeElement(data, this.globalData, this)\n  }\n\n  CanvasRendererBase.prototype.createText = function (data) {\n    return new CVTextElement(data, this.globalData, this)\n  }\n\n  CanvasRendererBase.prototype.createImage = function (data) {\n    return new CVImageElement(data, this.globalData, this)\n  }\n\n  CanvasRendererBase.prototype.createSolid = function (data) {\n    return new CVSolidElement(data, this.globalData, this)\n  }\n\n  CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull\n\n  CanvasRendererBase.prototype.ctxTransform = function (props) {\n    if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {\n      return\n    }\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13])\n      return\n    }\n    this.transformMat.cloneFromProps(props)\n    var cProps = this.contextData.cTr.props\n    this.transformMat.transform(\n      cProps[0],\n      cProps[1],\n      cProps[2],\n      cProps[3],\n      cProps[4],\n      cProps[5],\n      cProps[6],\n      cProps[7],\n      cProps[8],\n      cProps[9],\n      cProps[10],\n      cProps[11],\n      cProps[12],\n      cProps[13],\n      cProps[14],\n      cProps[15],\n    )\n    // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);\n    this.contextData.cTr.cloneFromProps(this.transformMat.props)\n    var trProps = this.contextData.cTr.props\n    this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13])\n  }\n\n  CanvasRendererBase.prototype.ctxOpacity = function (op) {\n    /* if(op === 1){\n        return;\n    } */\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.globalAlpha *= op < 0 ? 0 : op\n      this.globalData.currentGlobalAlpha = this.contextData.cO\n      return\n    }\n    this.contextData.cO *= op < 0 ? 0 : op\n    if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {\n      this.canvasContext.globalAlpha = this.contextData.cO\n      this.globalData.currentGlobalAlpha = this.contextData.cO\n    }\n  }\n\n  CanvasRendererBase.prototype.reset = function () {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.restore()\n      return\n    }\n    this.contextData.reset()\n  }\n\n  CanvasRendererBase.prototype.save = function (actionFlag) {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.save()\n      return\n    }\n    if (actionFlag) {\n      this.canvasContext.save()\n    }\n    var props = this.contextData.cTr.props\n    if (this.contextData._length <= this.contextData.cArrPos) {\n      this.contextData.duplicate()\n    }\n    var i\n    var arr = this.contextData.saved[this.contextData.cArrPos]\n    for (i = 0; i < 16; i += 1) {\n      arr[i] = props[i]\n    }\n    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO\n    this.contextData.cArrPos += 1\n  }\n\n  CanvasRendererBase.prototype.restore = function (actionFlag) {\n    if (!this.renderConfig.clearCanvas) {\n      this.canvasContext.restore()\n      return\n    }\n    if (actionFlag) {\n      this.canvasContext.restore()\n      this.globalData.blendMode = 'source-over'\n    }\n    this.contextData.cArrPos -= 1\n    var popped = this.contextData.saved[this.contextData.cArrPos]\n    var i\n    var arr = this.contextData.cTr.props\n    for (i = 0; i < 16; i += 1) {\n      arr[i] = popped[i]\n    }\n    this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13])\n    popped = this.contextData.savedOp[this.contextData.cArrPos]\n    this.contextData.cO = popped\n    if (this.globalData.currentGlobalAlpha !== popped) {\n      this.canvasContext.globalAlpha = popped\n      this.globalData.currentGlobalAlpha = popped\n    }\n  }\n\n  CanvasRendererBase.prototype.configAnimation = function (animData) {\n    if (this.animationItem.wrapper) {\n      this.animationItem.container = createTag('canvas')\n      var containerStyle = this.animationItem.container.style\n      containerStyle.width = '100%'\n      containerStyle.height = '100%'\n      var origin = '0px 0px 0px'\n      containerStyle.transformOrigin = origin\n      containerStyle.mozTransformOrigin = origin\n      containerStyle.webkitTransformOrigin = origin\n      containerStyle['-webkit-transform'] = origin\n      containerStyle.contentVisibility = this.renderConfig.contentVisibility\n      this.animationItem.wrapper.appendChild(this.animationItem.container)\n      this.canvasContext = this.animationItem.container.getContext('2d')\n      if (this.renderConfig.className) {\n        this.animationItem.container.setAttribute('class', this.renderConfig.className)\n      }\n      if (this.renderConfig.id) {\n        this.animationItem.container.setAttribute('id', this.renderConfig.id)\n      }\n    } else {\n      this.canvasContext = this.renderConfig.context\n    }\n    this.data = animData\n    this.layers = animData.layers\n    this.transformCanvas = {\n      w: animData.w,\n      h: animData.h,\n      sx: 0,\n      sy: 0,\n      tx: 0,\n      ty: 0,\n    }\n    this.setupGlobalData(animData, document.body)\n    this.globalData.canvasContext = this.canvasContext\n    this.globalData.renderer = this\n    this.globalData.isDashed = false\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad\n    this.globalData.transformCanvas = this.transformCanvas\n    this.elements = createSizedArray(animData.layers.length)\n\n    this.updateContainerSize()\n  }\n\n  CanvasRendererBase.prototype.updateContainerSize = function () {\n    this.reset()\n    var elementWidth\n    var elementHeight\n    if (this.animationItem.wrapper && this.animationItem.container) {\n      elementWidth = this.animationItem.wrapper.offsetWidth\n      elementHeight = this.animationItem.wrapper.offsetHeight\n      this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr)\n      this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr)\n    } else {\n      elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr\n      elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr\n    }\n    var elementRel\n    var animationRel\n    if (\n      this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 ||\n      this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1\n    ) {\n      var par = this.renderConfig.preserveAspectRatio.split(' ')\n      var fillType = par[1] || 'meet'\n      var pos = par[0] || 'xMidYMid'\n      var xPos = pos.substr(0, 4)\n      var yPos = pos.substr(4)\n      elementRel = elementWidth / elementHeight\n      animationRel = this.transformCanvas.w / this.transformCanvas.h\n      if ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice')) {\n        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)\n        this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)\n      } else {\n        this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)\n        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)\n      }\n\n      if (\n        xPos === 'xMid' &&\n        ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))\n      ) {\n        this.transformCanvas.tx =\n          ((elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2) *\n          this.renderConfig.dpr\n      } else if (\n        xPos === 'xMax' &&\n        ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))\n      ) {\n        this.transformCanvas.tx =\n          (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr\n      } else {\n        this.transformCanvas.tx = 0\n      }\n      if (\n        yPos === 'YMid' &&\n        ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))\n      ) {\n        this.transformCanvas.ty =\n          ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2) *\n          this.renderConfig.dpr\n      } else if (\n        yPos === 'YMax' &&\n        ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))\n      ) {\n        this.transformCanvas.ty =\n          (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr\n      } else {\n        this.transformCanvas.ty = 0\n      }\n    } else if (this.renderConfig.preserveAspectRatio === 'none') {\n      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)\n      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)\n      this.transformCanvas.tx = 0\n      this.transformCanvas.ty = 0\n    } else {\n      this.transformCanvas.sx = this.renderConfig.dpr\n      this.transformCanvas.sy = this.renderConfig.dpr\n      this.transformCanvas.tx = 0\n      this.transformCanvas.ty = 0\n    }\n    this.transformCanvas.props = [\n      this.transformCanvas.sx,\n      0,\n      0,\n      0,\n      0,\n      this.transformCanvas.sy,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      this.transformCanvas.tx,\n      this.transformCanvas.ty,\n      0,\n      1,\n    ]\n    /* var i, len = this.elements.length;\n    for(i=0;i<len;i+=1){\n        if(this.elements[i] && this.elements[i].data.ty === 0){\n            this.elements[i].resize(this.globalData.transformCanvas);\n        }\n    } */\n    this.ctxTransform(this.transformCanvas.props)\n    this.canvasContext.beginPath()\n    this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h)\n    this.canvasContext.closePath()\n    this.canvasContext.clip()\n\n    this.renderFrame(this.renderedFrame, true)\n  }\n\n  CanvasRendererBase.prototype.destroy = function () {\n    if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {\n      this.animationItem.wrapper.innerText = ''\n    }\n    var i\n    var len = this.layers ? this.layers.length : 0\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy()\n      }\n    }\n    this.elements.length = 0\n    this.globalData.canvasContext = null\n    this.animationItem.container = null\n    this.destroyed = true\n  }\n\n  CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {\n    if (\n      (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) ||\n      this.destroyed ||\n      num === -1\n    ) {\n      return\n    }\n    this.renderedFrame = num\n    this.globalData.frameNum = num - this.animationItem._isFirstFrame\n    this.globalData.frameId += 1\n    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender\n    this.globalData.projectInterface.currentFrame = num\n\n    // console.log('--------');\n    // console.log('NEW: ',num);\n    var i\n    var len = this.layers.length\n    if (!this.completeLayers) {\n      this.checkLayers(num)\n    }\n\n    for (i = 0; i < len; i += 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].prepareFrame(num - this.layers[i].st)\n      }\n    }\n    if (this.globalData._mdf) {\n      if (this.renderConfig.clearCanvas === true) {\n        this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h)\n      } else {\n        this.save()\n      }\n      for (i = len - 1; i >= 0; i -= 1) {\n        if (this.completeLayers || this.elements[i]) {\n          this.elements[i].renderFrame()\n        }\n      }\n      if (this.renderConfig.clearCanvas !== true) {\n        this.restore()\n      }\n    }\n  }\n\n  CanvasRendererBase.prototype.buildItem = function (pos) {\n    var elements = this.elements\n    if (elements[pos] || this.layers[pos].ty === 99) {\n      return\n    }\n    var element = this.createItem(this.layers[pos], this, this.globalData)\n    elements[pos] = element\n    element.initExpressions()\n    /* if(this.layers[pos].ty === 0){\n        element.resize(this.globalData.transformCanvas);\n    } */\n  }\n\n  CanvasRendererBase.prototype.checkPendingElements = function () {\n    while (this.pendingElements.length) {\n      var element = this.pendingElements.pop()\n      element.checkParenting()\n    }\n  }\n\n  CanvasRendererBase.prototype.hide = function () {\n    this.animationItem.container.style.display = 'none'\n  }\n\n  CanvasRendererBase.prototype.show = function () {\n    this.animationItem.container.style.display = 'block'\n  }\n\n  function CVCompElement(data, globalData, comp) {\n    this.completeLayers = false\n    this.layers = data.layers\n    this.pendingElements = []\n    this.elements = createSizedArray(this.layers.length)\n    this.initElement(data, globalData, comp)\n    this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true }\n  }\n\n  extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement)\n\n  CVCompElement.prototype.renderInnerContent = function () {\n    var ctx = this.canvasContext\n    ctx.beginPath()\n    ctx.moveTo(0, 0)\n    ctx.lineTo(this.data.w, 0)\n    ctx.lineTo(this.data.w, this.data.h)\n    ctx.lineTo(0, this.data.h)\n    ctx.lineTo(0, 0)\n    ctx.clip()\n    var i\n    var len = this.layers.length\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.completeLayers || this.elements[i]) {\n        this.elements[i].renderFrame()\n      }\n    }\n  }\n\n  CVCompElement.prototype.destroy = function () {\n    var i\n    var len = this.layers.length\n    for (i = len - 1; i >= 0; i -= 1) {\n      if (this.elements[i]) {\n        this.elements[i].destroy()\n      }\n    }\n    this.layers = null\n    this.elements = null\n  }\n\n  CVCompElement.prototype.createComp = function (data) {\n    return new CVCompElement(data, this.globalData, this)\n  }\n\n  function CanvasRenderer(animationItem, config) {\n    this.animationItem = animationItem\n    this.renderConfig = {\n      clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n      context: (config && config.context) || null,\n      progressiveLoad: (config && config.progressiveLoad) || false,\n      preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',\n      imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',\n      contentVisibility: (config && config.contentVisibility) || 'visible',\n      className: (config && config.className) || '',\n      id: (config && config.id) || '',\n    }\n    this.renderConfig.dpr = (config && config.dpr) || 1\n    if (this.animationItem.wrapper) {\n      this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1\n    }\n    this.renderedFrame = -1\n    this.globalData = {\n      frameNum: -1,\n      _mdf: false,\n      renderConfig: this.renderConfig,\n      currentGlobalAlpha: -1,\n    }\n    this.contextData = new CVContextData()\n    this.elements = []\n    this.pendingElements = []\n    this.transformMat = new Matrix()\n    this.completeLayers = false\n    this.rendererType = 'canvas'\n  }\n  extendPrototype([CanvasRendererBase], CanvasRenderer)\n\n  CanvasRenderer.prototype.createComp = function (data) {\n    return new CVCompElement(data, this.globalData, this)\n  }\n\n  // Registering renderers\n  registerRenderer('canvas', CanvasRenderer)\n\n  // Registering shape modifiers\n  ShapeModifiers.registerModifier('tm', TrimModifier)\n  ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier)\n  ShapeModifiers.registerModifier('rp', RepeaterModifier)\n  ShapeModifiers.registerModifier('rd', RoundCornersModifier)\n\n  const Expressions = (function () {\n    var ob = {}\n    ob.initExpressions = initExpressions\n\n    function initExpressions(animation) {\n      var stackCount = 0\n      var registers = []\n\n      function pushExpression() {\n        stackCount += 1\n      }\n\n      function popExpression() {\n        stackCount -= 1\n        if (stackCount === 0) {\n          releaseInstances()\n        }\n      }\n\n      function registerExpressionProperty(expression) {\n        if (registers.indexOf(expression) === -1) {\n          registers.push(expression)\n        }\n      }\n\n      function releaseInstances() {\n        var i\n        var len = registers.length\n        for (i = 0; i < len; i += 1) {\n          registers[i].release()\n        }\n        registers.length = 0\n      }\n\n      animation.renderer.compInterface = CompExpressionInterface(animation.renderer)\n      animation.renderer.globalData.projectInterface.registerComposition(animation.renderer)\n      animation.renderer.globalData.pushExpression = pushExpression\n      animation.renderer.globalData.popExpression = popExpression\n      animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty\n    }\n    return ob\n  })()\n\n  /* eslint-disable */\n  /*\n Copyright 2014 David Bau.\n\n Permission is hereby granted, free of charge, to any person obtaining\n a copy of this software and associated documentation files (the\n \"Software\"), to deal in the Software without restriction, including\n without limitation the rights to use, copy, modify, merge, publish,\n distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to\n the following conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n */\n\n  function seedRandom(pool, math) {\n    //\n    // The following constants are related to IEEE 754 limits.\n    //\n    var global = this,\n      width = 256, // each RC4 output is 0 <= x < 256\n      chunks = 6, // at least six RC4 outputs for each double\n      digits = 52, // there are 52 significant digits in a double\n      rngname = 'random', // rngname: name for Math.random and Math.seedrandom\n      startdenom = math.pow(width, chunks),\n      significance = math.pow(2, digits),\n      overflow = significance * 2,\n      mask = width - 1,\n      nodecrypto // node.js crypto module, initialized at the bottom.\n\n    //\n    // seedrandom()\n    // This is the seedrandom function described above.\n    //\n    function seedrandom(seed, options, callback) {\n      var key = []\n      options = options === true ? { entropy: true } : options || {}\n\n      // Flatten the seed string or build one from local entropy if needed.\n      var shortseed = mixkey(\n        flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3),\n        key,\n      )\n\n      // Use the seed to initialize an ARC4 generator.\n      var arc4 = new ARC4(key)\n\n      // This function returns a random double in [0, 1) that contains\n      // randomness in every bit of the mantissa of the IEEE 754 value.\n      var prng = function () {\n        var n = arc4.g(chunks), // Start with a numerator n < 2 ^ 48\n          d = startdenom, //   and denominator d = 2 ^ 48.\n          x = 0 //   and no 'extra last byte'.\n        while (n < significance) {\n          // Fill up all significant digits by\n          n = (n + x) * width //   shifting numerator and\n          d *= width //   denominator and generating a\n          x = arc4.g(1) //   new least-significant-byte.\n        }\n        while (n >= overflow) {\n          // To avoid rounding up, before adding\n          n /= 2 //   last byte, shift everything\n          d /= 2 //   right using integer math until\n          x >>>= 1 //   we have exactly the desired bits.\n        }\n        return (n + x) / d // Form the number within [0, 1).\n      }\n\n      prng.int32 = function () {\n        return arc4.g(4) | 0\n      }\n      prng.quick = function () {\n        return arc4.g(4) / 0x100000000\n      }\n      prng.double = prng\n\n      // Mix the randomness into accumulated entropy.\n      mixkey(tostring(arc4.S), pool)\n\n      // Calling convention: what to return as a function of prng, seed, is_math.\n      return (\n        options.pass ||\n        callback ||\n        function (prng, seed, is_math_call, state) {\n          if (state) {\n            // Load the arc4 state from the given state if it has an S array.\n            if (state.S) {\n              copy(state, arc4)\n            }\n            // Only provide the .state method if requested via options.state.\n            prng.state = function () {\n              return copy(arc4, {})\n            }\n          }\n\n          // If called as a method of Math (Math.seedrandom()), mutate\n          // Math.random because that is how seedrandom.js has worked since v1.0.\n          if (is_math_call) {\n            math[rngname] = prng\n            return seed\n          }\n\n          // Otherwise, it is a newer calling convention, so return the\n          // prng directly.\n          else return prng\n        }\n      )(prng, shortseed, 'global' in options ? options.global : this == math, options.state)\n    }\n    math['seed' + rngname] = seedrandom\n\n    //\n    // ARC4\n    //\n    // An ARC4 implementation.  The constructor takes a key in the form of\n    // an array of at most (width) integers that should be 0 <= x < (width).\n    //\n    // The g(count) method returns a pseudorandom integer that concatenates\n    // the next (count) outputs from ARC4.  Its return value is a number x\n    // that is in the range 0 <= x < (width ^ count).\n    //\n    function ARC4(key) {\n      var t,\n        keylen = key.length,\n        me = this,\n        i = 0,\n        j = (me.i = me.j = 0),\n        s = (me.S = [])\n\n      // The empty key [] is treated as [0].\n      if (!keylen) {\n        key = [keylen++]\n      }\n\n      // Set up S using the standard key scheduling algorithm.\n      while (i < width) {\n        s[i] = i++\n      }\n      for (i = 0; i < width; i++) {\n        s[i] = s[(j = mask & (j + key[i % keylen] + (t = s[i])))]\n        s[j] = t\n      }\n\n      // The \"g\" method returns the next (count) outputs as one number.\n      me.g = function (count) {\n        // Using instance members instead of closure state nearly doubles speed.\n        var t,\n          r = 0,\n          i = me.i,\n          j = me.j,\n          s = me.S\n        while (count--) {\n          t = s[(i = mask & (i + 1))]\n          r = r * width + s[mask & ((s[i] = s[(j = mask & (j + t))]) + (s[j] = t))]\n        }\n        me.i = i\n        me.j = j\n        return r\n        // For robust unpredictability, the function call below automatically\n        // discards an initial batch of values.  This is called RC4-drop[256].\n        // See http://google.com/search?q=rsa+fluhrer+response&btnI\n      }\n    }\n\n    //\n    // copy()\n    // Copies internal state of ARC4 to or from a plain object.\n    //\n    function copy(f, t) {\n      t.i = f.i\n      t.j = f.j\n      t.S = f.S.slice()\n      return t\n    }\n\n    //\n    // flatten()\n    // Converts an object tree to nested arrays of strings.\n    //\n    function flatten(obj, depth) {\n      var result = [],\n        typ = typeof obj,\n        prop\n      if (depth && typ == 'object') {\n        for (prop in obj) {\n          try {\n            result.push(flatten(obj[prop], depth - 1))\n          } catch (e) {}\n        }\n      }\n      return result.length ? result : typ == 'string' ? obj : obj + '\\0'\n    }\n\n    //\n    // mixkey()\n    // Mixes a string seed into a key that is an array of integers, and\n    // returns a shortened string seed that is equivalent to the result key.\n    //\n    function mixkey(seed, key) {\n      var stringseed = seed + '',\n        smear,\n        j = 0\n      while (j < stringseed.length) {\n        key[mask & j] = mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++))\n      }\n      return tostring(key)\n    }\n\n    //\n    // autoseed()\n    // Returns an object for autoseeding, using window.crypto and Node crypto\n    // module if available.\n    //\n    function autoseed() {\n      try {\n        if (nodecrypto) {\n          return tostring(nodecrypto.randomBytes(width))\n        }\n        var out = new Uint8Array(width)\n        ;(global.crypto || global.msCrypto).getRandomValues(out)\n        return tostring(out)\n      } catch (e) {\n        var browser = global.navigator,\n          plugins = browser && browser.plugins\n        return [+new Date(), global, plugins, global.screen, tostring(pool)]\n      }\n    }\n\n    //\n    // tostring()\n    // Converts an array of charcodes to a string\n    //\n    function tostring(a) {\n      return String.fromCharCode.apply(0, a)\n    }\n\n    //\n    // When seedrandom.js is loaded, we immediately mix a few bits\n    // from the built-in RNG into the entropy pool.  Because we do\n    // not want to interfere with deterministic PRNG state later,\n    // seedrandom will not call math.random on its own again after\n    // initialization.\n    //\n    mixkey(math.random(), pool)\n\n    //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n\n    // End anonymous scope, and pass initial values.\n  }\n\n  function initialize$2(BMMath) {\n    seedRandom([], BMMath)\n  }\n\n  var propTypes = {\n    SHAPE: 'shape',\n  }\n\n  /* eslint-disable camelcase */\n\n  const ExpressionManager = (function () {\n    'use strict'\n\n    var ob = {}\n    var Math = BMMath\n    var window = null\n    var document = null\n    var XMLHttpRequest = null\n    var fetch = null\n    var frames = null\n    initialize$2(BMMath)\n\n    function $bm_isInstanceOfArray(arr) {\n      return arr.constructor === Array || arr.constructor === Float32Array\n    }\n\n    function isNumerable(tOfV, v) {\n      return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number\n    }\n\n    function $bm_neg(a) {\n      var tOfA = typeof a\n      if (tOfA === 'number' || tOfA === 'boolean' || a instanceof Number) {\n        return -a\n      }\n      if ($bm_isInstanceOfArray(a)) {\n        var i\n        var lenA = a.length\n        var retArr = []\n        for (i = 0; i < lenA; i += 1) {\n          retArr[i] = -a[i]\n        }\n        return retArr\n      }\n      if (a.propType) {\n        return a.v\n      }\n      return -a\n    }\n\n    var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get\n    var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get\n    var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get\n\n    function sum(a, b) {\n      var tOfA = typeof a\n      var tOfB = typeof b\n      if (tOfA === 'string' || tOfB === 'string') {\n        return a + b\n      }\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a + b\n      }\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        a = a.slice(0)\n        a[0] += b\n        return a\n      }\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        b = b.slice(0)\n        b[0] = a + b[0]\n        return b\n      }\n      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n        var i = 0\n        var lenA = a.length\n        var lenB = b.length\n        var retArr = []\n        while (i < lenA || i < lenB) {\n          if (\n            (typeof a[i] === 'number' || a[i] instanceof Number) &&\n            (typeof b[i] === 'number' || b[i] instanceof Number)\n          ) {\n            retArr[i] = a[i] + b[i]\n          } else {\n            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i]\n          }\n          i += 1\n        }\n        return retArr\n      }\n      return 0\n    }\n    var add = sum\n\n    function sub(a, b) {\n      var tOfA = typeof a\n      var tOfB = typeof b\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        if (tOfA === 'string') {\n          a = parseInt(a, 10)\n        }\n        if (tOfB === 'string') {\n          b = parseInt(b, 10)\n        }\n        return a - b\n      }\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        a = a.slice(0)\n        a[0] -= b\n        return a\n      }\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        b = b.slice(0)\n        b[0] = a - b[0]\n        return b\n      }\n      if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n        var i = 0\n        var lenA = a.length\n        var lenB = b.length\n        var retArr = []\n        while (i < lenA || i < lenB) {\n          if (\n            (typeof a[i] === 'number' || a[i] instanceof Number) &&\n            (typeof b[i] === 'number' || b[i] instanceof Number)\n          ) {\n            retArr[i] = a[i] - b[i]\n          } else {\n            retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i]\n          }\n          i += 1\n        }\n        return retArr\n      }\n      return 0\n    }\n\n    function mul(a, b) {\n      var tOfA = typeof a\n      var tOfB = typeof b\n      var arr\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a * b\n      }\n\n      var i\n      var len\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        len = a.length\n        arr = createTypedArray('float32', len)\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a[i] * b\n        }\n        return arr\n      }\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        len = b.length\n        arr = createTypedArray('float32', len)\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a * b[i]\n        }\n        return arr\n      }\n      return 0\n    }\n\n    function div(a, b) {\n      var tOfA = typeof a\n      var tOfB = typeof b\n      var arr\n      if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n        return a / b\n      }\n      var i\n      var len\n      if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n        len = a.length\n        arr = createTypedArray('float32', len)\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a[i] / b\n        }\n        return arr\n      }\n      if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n        len = b.length\n        arr = createTypedArray('float32', len)\n        for (i = 0; i < len; i += 1) {\n          arr[i] = a / b[i]\n        }\n        return arr\n      }\n      return 0\n    }\n    function mod(a, b) {\n      if (typeof a === 'string') {\n        a = parseInt(a, 10)\n      }\n      if (typeof b === 'string') {\n        b = parseInt(b, 10)\n      }\n      return a % b\n    }\n    var $bm_sum = sum\n    var $bm_sub = sub\n    var $bm_mul = mul\n    var $bm_div = div\n    var $bm_mod = mod\n\n    function clamp(num, min, max) {\n      if (min > max) {\n        var mm = max\n        max = min\n        min = mm\n      }\n      return Math.min(Math.max(num, min), max)\n    }\n\n    function radiansToDegrees(val) {\n      return val / degToRads\n    }\n    var radians_to_degrees = radiansToDegrees\n\n    function degreesToRadians(val) {\n      return val * degToRads\n    }\n    var degrees_to_radians = radiansToDegrees\n\n    var helperLengthArray = [0, 0, 0, 0, 0, 0]\n\n    function length(arr1, arr2) {\n      if (typeof arr1 === 'number' || arr1 instanceof Number) {\n        arr2 = arr2 || 0\n        return Math.abs(arr1 - arr2)\n      }\n      if (!arr2) {\n        arr2 = helperLengthArray\n      }\n      var i\n      var len = Math.min(arr1.length, arr2.length)\n      var addedLength = 0\n      for (i = 0; i < len; i += 1) {\n        addedLength += Math.pow(arr2[i] - arr1[i], 2)\n      }\n      return Math.sqrt(addedLength)\n    }\n\n    function normalize(vec) {\n      return div(vec, length(vec))\n    }\n\n    function rgbToHsl(val) {\n      var r = val[0]\n      var g = val[1]\n      var b = val[2]\n      var max = Math.max(r, g, b)\n      var min = Math.min(r, g, b)\n      var h\n      var s\n      var l = (max + min) / 2\n\n      if (max === min) {\n        h = 0 // achromatic\n        s = 0 // achromatic\n      } else {\n        var d = max - min\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min)\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0)\n            break\n          case g:\n            h = (b - r) / d + 2\n            break\n          case b:\n            h = (r - g) / d + 4\n            break\n          default:\n            break\n        }\n        h /= 6\n      }\n\n      return [h, s, l, val[3]]\n    }\n\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1\n      if (t > 1) t -= 1\n      if (t < 1 / 6) return p + (q - p) * 6 * t\n      if (t < 1 / 2) return q\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6\n      return p\n    }\n\n    function hslToRgb(val) {\n      var h = val[0]\n      var s = val[1]\n      var l = val[2]\n\n      var r\n      var g\n      var b\n\n      if (s === 0) {\n        r = l // achromatic\n        b = l // achromatic\n        g = l // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s\n        var p = 2 * l - q\n        r = hue2rgb(p, q, h + 1 / 3)\n        g = hue2rgb(p, q, h)\n        b = hue2rgb(p, q, h - 1 / 3)\n      }\n\n      return [r, g, b, val[3]]\n    }\n\n    function linear(t, tMin, tMax, value1, value2) {\n      if (value1 === undefined || value2 === undefined) {\n        value1 = tMin\n        value2 = tMax\n        tMin = 0\n        tMax = 1\n      }\n      if (tMax < tMin) {\n        var _tMin = tMax\n        tMax = tMin\n        tMin = _tMin\n      }\n      if (t <= tMin) {\n        return value1\n      }\n      if (t >= tMax) {\n        return value2\n      }\n      var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin)\n      if (!value1.length) {\n        return value1 + (value2 - value1) * perc\n      }\n      var i\n      var len = value1.length\n      var arr = createTypedArray('float32', len)\n      for (i = 0; i < len; i += 1) {\n        arr[i] = value1[i] + (value2[i] - value1[i]) * perc\n      }\n      return arr\n    }\n    function random(min, max) {\n      if (max === undefined) {\n        if (min === undefined) {\n          min = 0\n          max = 1\n        } else {\n          max = min\n          min = undefined\n        }\n      }\n      if (max.length) {\n        var i\n        var len = max.length\n        if (!min) {\n          min = createTypedArray('float32', len)\n        }\n        var arr = createTypedArray('float32', len)\n        var rnd = BMMath.random()\n        for (i = 0; i < len; i += 1) {\n          arr[i] = min[i] + rnd * (max[i] - min[i])\n        }\n        return arr\n      }\n      if (min === undefined) {\n        min = 0\n      }\n      var rndm = BMMath.random()\n      return min + rndm * (max - min)\n    }\n\n    function createPath(points, inTangents, outTangents, closed) {\n      var i\n      var len = points.length\n      var path = shapePool.newElement()\n      path.setPathData(!!closed, len)\n      var arrPlaceholder = [0, 0]\n      var inVertexPoint\n      var outVertexPoint\n      for (i = 0; i < len; i += 1) {\n        inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder\n        outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder\n        path.setTripleAt(\n          points[i][0],\n          points[i][1],\n          outVertexPoint[0] + points[i][0],\n          outVertexPoint[1] + points[i][1],\n          inVertexPoint[0] + points[i][0],\n          inVertexPoint[1] + points[i][1],\n          i,\n          true,\n        )\n      }\n      return path\n    }\n\n    function initiateExpression(elem, data, property) {\n      var val = data.x\n      var needsVelocity = /velocity(?![\\w\\d])/.test(val)\n      var _needsRandom = val.indexOf('random') !== -1\n      var elemType = elem.data.ty\n      var transform\n      var $bm_transform\n      var content\n      var effect\n      var thisProperty = property\n      thisProperty.valueAtTime = thisProperty.getValueAtTime\n      Object.defineProperty(thisProperty, 'value', {\n        get: function () {\n          return thisProperty.v\n        },\n      })\n      elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate\n      elem.comp.displayStartTime = 0\n      var inPoint = elem.data.ip / elem.comp.globalData.frameRate\n      var outPoint = elem.data.op / elem.comp.globalData.frameRate\n      var width = elem.data.sw ? elem.data.sw : 0\n      var height = elem.data.sh ? elem.data.sh : 0\n      var name = elem.data.nm\n      var loopIn\n      var loop_in\n      var loopOut\n      var loop_out\n      var smooth\n      var toWorld\n      var fromWorld\n      var fromComp\n      var toComp\n      var fromCompToSurface\n      var position\n      var rotation\n      var anchorPoint\n      var scale\n      var thisLayer\n      var thisComp\n      var mask\n      var valueAtTime\n      var velocityAtTime\n\n      var scoped_bm_rt\n      // val = val.replace(/(\\\\?\"|')((http)(s)?(:\\/))?\\/.*?(\\\\?\"|')/g, \"\\\"\\\"\"); // deter potential network calls\n      var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0] // eslint-disable-line no-eval\n      var numKeys = property.kf ? data.k.length : 0\n\n      var active = !this.data || this.data.hd !== true\n\n      var wiggle = function wiggle(freq, amp) {\n        var iWiggle\n        var j\n        var lenWiggle = this.pv.length ? this.pv.length : 1\n        var addedAmps = createTypedArray('float32', lenWiggle)\n        freq = 5\n        var iterations = Math.floor(time * freq)\n        iWiggle = 0\n        j = 0\n        while (iWiggle < iterations) {\n          // var rnd = BMMath.random();\n          for (j = 0; j < lenWiggle; j += 1) {\n            addedAmps[j] += -amp + amp * 2 * BMMath.random()\n            // addedAmps[j] += -amp + amp*2*rnd;\n          }\n          iWiggle += 1\n        }\n        // var rnd2 = BMMath.random();\n        var periods = time * freq\n        var perc = periods - Math.floor(periods)\n        var arr = createTypedArray('float32', lenWiggle)\n        if (lenWiggle > 1) {\n          for (j = 0; j < lenWiggle; j += 1) {\n            arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc\n            // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\n            // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\n          }\n          return arr\n        }\n        return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc\n      }.bind(this)\n\n      if (thisProperty.loopIn) {\n        loopIn = thisProperty.loopIn.bind(thisProperty)\n        loop_in = loopIn\n      }\n\n      if (thisProperty.loopOut) {\n        loopOut = thisProperty.loopOut.bind(thisProperty)\n        loop_out = loopOut\n      }\n\n      if (thisProperty.smooth) {\n        smooth = thisProperty.smooth.bind(thisProperty)\n      }\n\n      function loopInDuration(type, duration) {\n        return loopIn(type, duration, true)\n      }\n\n      function loopOutDuration(type, duration) {\n        return loopOut(type, duration, true)\n      }\n\n      if (this.getValueAtTime) {\n        valueAtTime = this.getValueAtTime.bind(this)\n      }\n\n      if (this.getVelocityAtTime) {\n        velocityAtTime = this.getVelocityAtTime.bind(this)\n      }\n\n      var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface)\n\n      function lookAt(elem1, elem2) {\n        var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]]\n        var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads\n        var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads\n        return [yaw, pitch, 0]\n      }\n\n      function easeOut(t, tMin, tMax, val1, val2) {\n        return applyEase(easeOutBez, t, tMin, tMax, val1, val2)\n      }\n\n      function easeIn(t, tMin, tMax, val1, val2) {\n        return applyEase(easeInBez, t, tMin, tMax, val1, val2)\n      }\n\n      function ease(t, tMin, tMax, val1, val2) {\n        return applyEase(easeInOutBez, t, tMin, tMax, val1, val2)\n      }\n\n      function applyEase(fn, t, tMin, tMax, val1, val2) {\n        if (val1 === undefined) {\n          val1 = tMin\n          val2 = tMax\n        } else {\n          t = (t - tMin) / (tMax - tMin)\n        }\n        if (t > 1) {\n          t = 1\n        } else if (t < 0) {\n          t = 0\n        }\n        var mult = fn(t)\n        if ($bm_isInstanceOfArray(val1)) {\n          var iKey\n          var lenKey = val1.length\n          var arr = createTypedArray('float32', lenKey)\n          for (iKey = 0; iKey < lenKey; iKey += 1) {\n            arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey]\n          }\n          return arr\n        }\n        return (val2 - val1) * mult + val1\n      }\n\n      function nearestKey(time) {\n        var iKey\n        var lenKey = data.k.length\n        var index\n        var keyTime\n        if (!data.k.length || typeof data.k[0] === 'number') {\n          index = 0\n          keyTime = 0\n        } else {\n          index = -1\n          time *= elem.comp.globalData.frameRate\n          if (time < data.k[0].t) {\n            index = 1\n            keyTime = data.k[0].t\n          } else {\n            for (iKey = 0; iKey < lenKey - 1; iKey += 1) {\n              if (time === data.k[iKey].t) {\n                index = iKey + 1\n                keyTime = data.k[iKey].t\n                break\n              } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {\n                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {\n                  index = iKey + 2\n                  keyTime = data.k[iKey + 1].t\n                } else {\n                  index = iKey + 1\n                  keyTime = data.k[iKey].t\n                }\n                break\n              }\n            }\n            if (index === -1) {\n              index = iKey + 1\n              keyTime = data.k[iKey].t\n            }\n          }\n        }\n        var obKey = {}\n        obKey.index = index\n        obKey.time = keyTime / elem.comp.globalData.frameRate\n        return obKey\n      }\n\n      function key(ind) {\n        var obKey\n        var iKey\n        var lenKey\n        if (!data.k.length || typeof data.k[0] === 'number') {\n          throw new Error('The property has no keyframe at index ' + ind)\n        }\n        ind -= 1\n        obKey = {\n          time: data.k[ind].t / elem.comp.globalData.frameRate,\n          value: [],\n        }\n        var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e\n\n        lenKey = arr.length\n        for (iKey = 0; iKey < lenKey; iKey += 1) {\n          obKey[iKey] = arr[iKey]\n          obKey.value[iKey] = arr[iKey]\n        }\n        return obKey\n      }\n\n      function framesToTime(fr, fps) {\n        if (!fps) {\n          fps = elem.comp.globalData.frameRate\n        }\n        return fr / fps\n      }\n\n      function timeToFrames(t, fps) {\n        if (!t && t !== 0) {\n          t = time\n        }\n        if (!fps) {\n          fps = elem.comp.globalData.frameRate\n        }\n        return t * fps\n      }\n\n      function seedRandom(seed) {\n        BMMath.seedrandom(randSeed + seed)\n      }\n\n      function sourceRectAtTime() {\n        return elem.sourceRectAtTime()\n      }\n\n      function substring(init, end) {\n        if (typeof value === 'string') {\n          if (end === undefined) {\n            return value.substring(init)\n          }\n          return value.substring(init, end)\n        }\n        return ''\n      }\n\n      function substr(init, end) {\n        if (typeof value === 'string') {\n          if (end === undefined) {\n            return value.substr(init)\n          }\n          return value.substr(init, end)\n        }\n        return ''\n      }\n\n      function posterizeTime(framesPerSecond) {\n        time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond\n        value = valueAtTime(time)\n      }\n\n      var time\n      var velocity\n      var value\n      var text\n      var textIndex\n      var textTotal\n      var selectorValue\n      var index = elem.data.ind\n      var hasParent = !!(elem.hierarchy && elem.hierarchy.length)\n      var parent\n      var randSeed = Math.floor(Math.random() * 1000000)\n      var globalData = elem.globalData\n      function executeExpression(_value) {\n        // globalData.pushExpression();\n        value = _value\n        if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {\n          return value\n        }\n        if (this.propType === 'textSelector') {\n          textIndex = this.textIndex\n          textTotal = this.textTotal\n          selectorValue = this.selectorValue\n        }\n        if (!thisLayer) {\n          text = elem.layerInterface.text\n          thisLayer = elem.layerInterface\n          thisComp = elem.comp.compInterface\n          toWorld = thisLayer.toWorld.bind(thisLayer)\n          fromWorld = thisLayer.fromWorld.bind(thisLayer)\n          fromComp = thisLayer.fromComp.bind(thisLayer)\n          toComp = thisLayer.toComp.bind(thisLayer)\n          mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null\n          fromCompToSurface = fromComp\n        }\n        if (!transform) {\n          transform = elem.layerInterface('ADBE Transform Group')\n          $bm_transform = transform\n          if (transform) {\n            anchorPoint = transform.anchorPoint\n            /* position = transform.position;\n                    rotation = transform.rotation;\n                    scale = transform.scale; */\n          }\n        }\n\n        if (elemType === 4 && !content) {\n          content = thisLayer('ADBE Root Vectors Group')\n        }\n        if (!effect) {\n          effect = thisLayer(4)\n        }\n        hasParent = !!(elem.hierarchy && elem.hierarchy.length)\n        if (hasParent && !parent) {\n          parent = elem.hierarchy[0].layerInterface\n        }\n        time = this.comp.renderedFrame / this.comp.globalData.frameRate\n        if (_needsRandom) {\n          seedRandom(randSeed + time)\n        }\n        if (needsVelocity) {\n          velocity = velocityAtTime(time)\n        }\n        expression_function()\n        this.frameExpressionId = elem.globalData.frameId\n\n        // TODO: Check if it's possible to return on ShapeInterface the .v value\n        // Changed this to a ternary operation because Rollup failed compiling it correctly\n        scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt\n        return scoped_bm_rt\n      }\n      // Bundlers will see these as dead code and unless we reference them\n      executeExpression.__preventDeadCodeRemoval = [\n        $bm_transform,\n        anchorPoint,\n        time,\n        velocity,\n        inPoint,\n        outPoint,\n        width,\n        height,\n        name,\n        loop_in,\n        loop_out,\n        smooth,\n        toComp,\n        fromCompToSurface,\n        toWorld,\n        fromWorld,\n        mask,\n        position,\n        rotation,\n        scale,\n        thisComp,\n        numKeys,\n        active,\n        wiggle,\n        loopInDuration,\n        loopOutDuration,\n        comp,\n        lookAt,\n        easeOut,\n        easeIn,\n        ease,\n        nearestKey,\n        key,\n        text,\n        textIndex,\n        textTotal,\n        selectorValue,\n        framesToTime,\n        timeToFrames,\n        sourceRectAtTime,\n        substring,\n        substr,\n        posterizeTime,\n        index,\n        globalData,\n      ]\n      return executeExpression\n    }\n\n    ob.initiateExpression = initiateExpression\n    ob.__preventDeadCodeRemoval = [\n      window,\n      document,\n      XMLHttpRequest,\n      fetch,\n      frames,\n      $bm_neg,\n      add,\n      $bm_sum,\n      $bm_sub,\n      $bm_mul,\n      $bm_div,\n      $bm_mod,\n      clamp,\n      radians_to_degrees,\n      degreesToRadians,\n      degrees_to_radians,\n      normalize,\n      rgbToHsl,\n      hslToRgb,\n      linear,\n      random,\n      createPath,\n    ]\n    return ob\n  })()\n\n  const expressionHelpers = (function () {\n    function searchExpressions(elem, data, prop) {\n      if (data.x) {\n        prop.k = true\n        prop.x = true\n        prop.initiateExpression = ExpressionManager.initiateExpression\n        prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop))\n      }\n    }\n\n    function getValueAtTime(frameNum) {\n      frameNum *= this.elem.globalData.frameRate\n      frameNum -= this.offsetTime\n      if (frameNum !== this._cachingAtTime.lastFrame) {\n        this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0\n        this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime)\n        this._cachingAtTime.lastFrame = frameNum\n      }\n      return this._cachingAtTime.value\n    }\n\n    function getSpeedAtTime(frameNum) {\n      var delta = -0.01\n      var v1 = this.getValueAtTime(frameNum)\n      var v2 = this.getValueAtTime(frameNum + delta)\n      var speed = 0\n      if (v1.length) {\n        var i\n        for (i = 0; i < v1.length; i += 1) {\n          speed += Math.pow(v2[i] - v1[i], 2)\n        }\n        speed = Math.sqrt(speed) * 100\n      } else {\n        speed = 0\n      }\n      return speed\n    }\n\n    function getVelocityAtTime(frameNum) {\n      if (this.vel !== undefined) {\n        return this.vel\n      }\n      var delta = -0.001\n      // frameNum += this.elem.data.st;\n      var v1 = this.getValueAtTime(frameNum)\n      var v2 = this.getValueAtTime(frameNum + delta)\n      var velocity\n      if (v1.length) {\n        velocity = createTypedArray('float32', v1.length)\n        var i\n        for (i = 0; i < v1.length; i += 1) {\n          // removing frameRate\n          // if needed, don't add it here\n          // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\n          velocity[i] = (v2[i] - v1[i]) / delta\n        }\n      } else {\n        velocity = (v2 - v1) / delta\n      }\n      return velocity\n    }\n\n    function getStaticValueAtTime() {\n      return this.pv\n    }\n\n    function setGroupProperty(propertyGroup) {\n      this.propertyGroup = propertyGroup\n    }\n\n    return {\n      searchExpressions: searchExpressions,\n      getSpeedAtTime: getSpeedAtTime,\n      getVelocityAtTime: getVelocityAtTime,\n      getValueAtTime: getValueAtTime,\n      getStaticValueAtTime: getStaticValueAtTime,\n      setGroupProperty: setGroupProperty,\n    }\n  })()\n\n  function addPropertyDecorator() {\n    function loopOut(type, duration, durationFlag) {\n      if (!this.k || !this.keyframes) {\n        return this.pv\n      }\n      type = type ? type.toLowerCase() : ''\n      var currentFrame = this.comp.renderedFrame\n      var keyframes = this.keyframes\n      var lastKeyFrame = keyframes[keyframes.length - 1].t\n      if (currentFrame <= lastKeyFrame) {\n        return this.pv\n      }\n      var cycleDuration\n      var firstKeyFrame\n      if (!durationFlag) {\n        if (!duration || duration > keyframes.length - 1) {\n          duration = keyframes.length - 1\n        }\n        firstKeyFrame = keyframes[keyframes.length - 1 - duration].t\n        cycleDuration = lastKeyFrame - firstKeyFrame\n      } else {\n        if (!duration) {\n          cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip)\n        } else {\n          cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration)\n        }\n        firstKeyFrame = lastKeyFrame - cycleDuration\n      }\n      var i\n      var len\n      var ret\n      if (type === 'pingpong') {\n        var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration)\n        if (iterations % 2 !== 0) {\n          return this.getValueAtTime(\n            (cycleDuration - ((currentFrame - firstKeyFrame) % cycleDuration) + firstKeyFrame) /\n              this.comp.globalData.frameRate,\n            0,\n          ) // eslint-disable-line\n        }\n      } else if (type === 'offset') {\n        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0)\n        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0)\n        var current = this.getValueAtTime(\n          (((currentFrame - firstKeyFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate,\n          0,\n        ) // eslint-disable-line\n        var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration)\n        if (this.pv.length) {\n          ret = new Array(initV.length)\n          len = ret.length\n          for (i = 0; i < len; i += 1) {\n            ret[i] = (endV[i] - initV[i]) * repeats + current[i]\n          }\n          return ret\n        }\n        return (endV - initV) * repeats + current\n      } else if (type === 'continue') {\n        var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0)\n        var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0)\n        if (this.pv.length) {\n          ret = new Array(lastValue.length)\n          len = ret.length\n          for (i = 0; i < len; i += 1) {\n            ret[i] =\n              lastValue[i] +\n              ((lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate)) /\n                0.0005 // eslint-disable-line\n          }\n          return ret\n        }\n        return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001)\n      }\n      return this.getValueAtTime(\n        (((currentFrame - firstKeyFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate,\n        0,\n      ) // eslint-disable-line\n    }\n\n    function loopIn(type, duration, durationFlag) {\n      if (!this.k) {\n        return this.pv\n      }\n      type = type ? type.toLowerCase() : ''\n      var currentFrame = this.comp.renderedFrame\n      var keyframes = this.keyframes\n      var firstKeyFrame = keyframes[0].t\n      if (currentFrame >= firstKeyFrame) {\n        return this.pv\n      }\n      var cycleDuration\n      var lastKeyFrame\n      if (!durationFlag) {\n        if (!duration || duration > keyframes.length - 1) {\n          duration = keyframes.length - 1\n        }\n        lastKeyFrame = keyframes[duration].t\n        cycleDuration = lastKeyFrame - firstKeyFrame\n      } else {\n        if (!duration) {\n          cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame)\n        } else {\n          cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration)\n        }\n        lastKeyFrame = firstKeyFrame + cycleDuration\n      }\n      var i\n      var len\n      var ret\n      if (type === 'pingpong') {\n        var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration)\n        if (iterations % 2 === 0) {\n          return this.getValueAtTime(\n            (((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate,\n            0,\n          ) // eslint-disable-line\n        }\n      } else if (type === 'offset') {\n        var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0)\n        var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0)\n        var current = this.getValueAtTime(\n          (cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) /\n            this.comp.globalData.frameRate,\n          0,\n        )\n        var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1\n        if (this.pv.length) {\n          ret = new Array(initV.length)\n          len = ret.length\n          for (i = 0; i < len; i += 1) {\n            ret[i] = current[i] - (endV[i] - initV[i]) * repeats\n          }\n          return ret\n        }\n        return current - (endV - initV) * repeats\n      } else if (type === 'continue') {\n        var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0)\n        var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0)\n        if (this.pv.length) {\n          ret = new Array(firstValue.length)\n          len = ret.length\n          for (i = 0; i < len; i += 1) {\n            ret[i] = firstValue[i] + ((firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame)) / 0.001\n          }\n          return ret\n        }\n        return firstValue + ((firstValue - nextFirstValue) * (firstKeyFrame - currentFrame)) / 0.001\n      }\n      return this.getValueAtTime(\n        (cycleDuration - (((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame)) /\n          this.comp.globalData.frameRate,\n        0,\n      ) // eslint-disable-line\n    }\n\n    function smooth(width, samples) {\n      if (!this.k) {\n        return this.pv\n      }\n      width = (width || 0.4) * 0.5\n      samples = Math.floor(samples || 5)\n      if (samples <= 1) {\n        return this.pv\n      }\n      var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate\n      var initFrame = currentTime - width\n      var endFrame = currentTime + width\n      var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1\n      var i = 0\n      var j = 0\n      var value\n      if (this.pv.length) {\n        value = createTypedArray('float32', this.pv.length)\n      } else {\n        value = 0\n      }\n      var sampleValue\n      while (i < samples) {\n        sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency)\n        if (this.pv.length) {\n          for (j = 0; j < this.pv.length; j += 1) {\n            value[j] += sampleValue[j]\n          }\n        } else {\n          value += sampleValue\n        }\n        i += 1\n      }\n      if (this.pv.length) {\n        for (j = 0; j < this.pv.length; j += 1) {\n          value[j] /= samples\n        }\n      } else {\n        value /= samples\n      }\n      return value\n    }\n\n    function getTransformValueAtTime(time) {\n      if (!this._transformCachingAtTime) {\n        this._transformCachingAtTime = {\n          v: new Matrix(),\n        }\n      }\n      /// /\n      var matrix = this._transformCachingAtTime.v\n      matrix.cloneFromProps(this.pre.props)\n      if (this.appliedTransformations < 1) {\n        var anchor = this.a.getValueAtTime(time)\n        matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult)\n      }\n      if (this.appliedTransformations < 2) {\n        var scale = this.s.getValueAtTime(time)\n        matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult)\n      }\n      if (this.sk && this.appliedTransformations < 3) {\n        var skew = this.sk.getValueAtTime(time)\n        var skewAxis = this.sa.getValueAtTime(time)\n        matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult)\n      }\n      if (this.r && this.appliedTransformations < 4) {\n        var rotation = this.r.getValueAtTime(time)\n        matrix.rotate(-rotation * this.r.mult)\n      } else if (!this.r && this.appliedTransformations < 4) {\n        var rotationZ = this.rz.getValueAtTime(time)\n        var rotationY = this.ry.getValueAtTime(time)\n        var rotationX = this.rx.getValueAtTime(time)\n        var orientation = this.or.getValueAtTime(time)\n        matrix\n          .rotateZ(-rotationZ * this.rz.mult)\n          .rotateY(rotationY * this.ry.mult)\n          .rotateX(rotationX * this.rx.mult)\n          .rotateZ(-orientation[2] * this.or.mult)\n          .rotateY(orientation[1] * this.or.mult)\n          .rotateX(orientation[0] * this.or.mult)\n      }\n      if (this.data.p && this.data.p.s) {\n        var positionX = this.px.getValueAtTime(time)\n        var positionY = this.py.getValueAtTime(time)\n        if (this.data.p.z) {\n          var positionZ = this.pz.getValueAtTime(time)\n          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult)\n        } else {\n          matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0)\n        }\n      } else {\n        var position = this.p.getValueAtTime(time)\n        matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult)\n      }\n      return matrix\n      /// /\n    }\n\n    function getTransformStaticValueAtTime() {\n      return this.v.clone(new Matrix())\n    }\n\n    var getTransformProperty = TransformPropertyFactory.getTransformProperty\n    TransformPropertyFactory.getTransformProperty = function (elem, data, container) {\n      var prop = getTransformProperty(elem, data, container)\n      if (prop.dynamicProperties.length) {\n        prop.getValueAtTime = getTransformValueAtTime.bind(prop)\n      } else {\n        prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop)\n      }\n      prop.setGroupProperty = expressionHelpers.setGroupProperty\n      return prop\n    }\n\n    var propertyGetProp = PropertyFactory.getProp\n    PropertyFactory.getProp = function (elem, data, type, mult, container) {\n      var prop = propertyGetProp(elem, data, type, mult, container)\n      // prop.getVelocityAtTime = getVelocityAtTime;\n      // prop.loopOut = loopOut;\n      // prop.loopIn = loopIn;\n      if (prop.kf) {\n        prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop)\n      } else {\n        prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop)\n      }\n      prop.setGroupProperty = expressionHelpers.setGroupProperty\n      prop.loopOut = loopOut\n      prop.loopIn = loopIn\n      prop.smooth = smooth\n      prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop)\n      prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop)\n      prop.numKeys = data.a === 1 ? data.k.length : 0\n      prop.propertyIndex = data.ix\n      var value = 0\n      if (type !== 0) {\n        value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length)\n      }\n      prop._cachingAtTime = {\n        lastFrame: initialDefaultFrame,\n        lastIndex: 0,\n        value: value,\n      }\n      expressionHelpers.searchExpressions(elem, data, prop)\n      if (prop.k) {\n        container.addDynamicProperty(prop)\n      }\n\n      return prop\n    }\n\n    function getShapeValueAtTime(frameNum) {\n      // For now this caching object is created only when needed instead of creating it when the shape is initialized.\n      if (!this._cachingAtTime) {\n        this._cachingAtTime = {\n          shapeValue: shapePool.clone(this.pv),\n          lastIndex: 0,\n          lastTime: initialDefaultFrame,\n        }\n      }\n\n      frameNum *= this.elem.globalData.frameRate\n      frameNum -= this.offsetTime\n      if (frameNum !== this._cachingAtTime.lastTime) {\n        this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0\n        this._cachingAtTime.lastTime = frameNum\n        this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime)\n      }\n      return this._cachingAtTime.shapeValue\n    }\n\n    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction()\n    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction()\n\n    function ShapeExpressions() {}\n    ShapeExpressions.prototype = {\n      vertices: function (prop, time) {\n        if (this.k) {\n          this.getValue()\n        }\n        var shapePath = this.v\n        if (time !== undefined) {\n          shapePath = this.getValueAtTime(time, 0)\n        }\n        var i\n        var len = shapePath._length\n        var vertices = shapePath[prop]\n        var points = shapePath.v\n        var arr = createSizedArray(len)\n        for (i = 0; i < len; i += 1) {\n          if (prop === 'i' || prop === 'o') {\n            arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]]\n          } else {\n            arr[i] = [vertices[i][0], vertices[i][1]]\n          }\n        }\n        return arr\n      },\n      points: function (time) {\n        return this.vertices('v', time)\n      },\n      inTangents: function (time) {\n        return this.vertices('i', time)\n      },\n      outTangents: function (time) {\n        return this.vertices('o', time)\n      },\n      isClosed: function () {\n        return this.v.c\n      },\n      pointOnPath: function (perc, time) {\n        var shapePath = this.v\n        if (time !== undefined) {\n          shapePath = this.getValueAtTime(time, 0)\n        }\n        if (!this._segmentsLength) {\n          this._segmentsLength = bez.getSegmentsLength(shapePath)\n        }\n\n        var segmentsLength = this._segmentsLength\n        var lengths = segmentsLength.lengths\n        var lengthPos = segmentsLength.totalLength * perc\n        var i = 0\n        var len = lengths.length\n        var accumulatedLength = 0\n        var pt\n        while (i < len) {\n          if (accumulatedLength + lengths[i].addedLength > lengthPos) {\n            var initIndex = i\n            var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1\n            var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength\n            pt = bez.getPointInSegment(\n              shapePath.v[initIndex],\n              shapePath.v[endIndex],\n              shapePath.o[initIndex],\n              shapePath.i[endIndex],\n              segmentPerc,\n              lengths[i],\n            )\n            break\n          } else {\n            accumulatedLength += lengths[i].addedLength\n          }\n          i += 1\n        }\n        if (!pt) {\n          pt = shapePath.c\n            ? [shapePath.v[0][0], shapePath.v[0][1]]\n            : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]]\n        }\n        return pt\n      },\n      vectorOnPath: function (perc, time, vectorType) {\n        // perc doesn't use triple equality because it can be a Number object as well as a primitive.\n        if (perc == 1) {\n          // eslint-disable-line eqeqeq\n          perc = this.v.c\n        } else if (perc == 0) {\n          // eslint-disable-line eqeqeq\n          perc = 0.999\n        }\n        var pt1 = this.pointOnPath(perc, time)\n        var pt2 = this.pointOnPath(perc + 0.001, time)\n        var xLength = pt2[0] - pt1[0]\n        var yLength = pt2[1] - pt1[1]\n        var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2))\n        if (magnitude === 0) {\n          return [0, 0]\n        }\n        var unitVector =\n          vectorType === 'tangent'\n            ? [xLength / magnitude, yLength / magnitude]\n            : [-yLength / magnitude, xLength / magnitude]\n        return unitVector\n      },\n      tangentOnPath: function (perc, time) {\n        return this.vectorOnPath(perc, time, 'tangent')\n      },\n      normalOnPath: function (perc, time) {\n        return this.vectorOnPath(perc, time, 'normal')\n      },\n      setGroupProperty: expressionHelpers.setGroupProperty,\n      getValueAtTime: expressionHelpers.getStaticValueAtTime,\n    }\n    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction)\n    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction)\n    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime\n    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression\n\n    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp\n    ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {\n      var prop = propertyGetShapeProp(elem, data, type, arr, trims)\n      prop.propertyIndex = data.ix\n      prop.lock = false\n      if (type === 3) {\n        expressionHelpers.searchExpressions(elem, data.pt, prop)\n      } else if (type === 4) {\n        expressionHelpers.searchExpressions(elem, data.ks, prop)\n      }\n      if (prop.k) {\n        elem.addDynamicProperty(prop)\n      }\n      return prop\n    }\n  }\n\n  function initialize$1() {\n    addPropertyDecorator()\n  }\n\n  function addDecorator() {\n    function searchExpressions() {\n      if (this.data.d.x) {\n        this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this)\n        this.addEffect(this.getExpressionValue.bind(this))\n        return true\n      }\n      return null\n    }\n\n    TextProperty.prototype.getExpressionValue = function (currentValue, text) {\n      var newValue = this.calculateExpression(text)\n      if (currentValue.t !== newValue) {\n        var newData = {}\n        this.copyData(newData, currentValue)\n        newData.t = newValue.toString()\n        newData.__complete = false\n        return newData\n      }\n      return currentValue\n    }\n\n    TextProperty.prototype.searchProperty = function () {\n      var isKeyframed = this.searchKeyframes()\n      var hasExpressions = this.searchExpressions()\n      this.kf = isKeyframed || hasExpressions\n      return this.kf\n    }\n\n    TextProperty.prototype.searchExpressions = searchExpressions\n  }\n\n  function initialize() {\n    addDecorator()\n  }\n\n  // Registering expression plugin\n  setExpressionsPlugin(Expressions)\n  initialize$1()\n  initialize()\n\n  return lottie\n})()\n\nexport { lottie as default }\n", "const { parseBuffer } = (() => {\n  /**\n   * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n   */\n\n  var TINF_OK = 0\n  var TINF_DATA_ERROR = -3\n\n  function Tree() {\n    this.table = new Uint16Array(16) /* table of code length counts */\n    this.trans = new Uint16Array(288) /* code -> symbol translation table */\n  }\n\n  function Data(source, dest) {\n    this.source = source\n    this.sourceIndex = 0\n    this.tag = 0\n    this.bitcount = 0\n\n    this.dest = dest\n    this.destLen = 0\n\n    this.ltree = new Tree() /* dynamic length/symbol tree */\n    this.dtree = new Tree() /* dynamic distance tree */\n  }\n\n  /* --------------------------------------------------- *\n   * -- uninitialized global data (static structures) -- *\n   * --------------------------------------------------- */\n\n  var sltree = new Tree()\n  var sdtree = new Tree()\n\n  /* extra bits and base tables for length codes */\n  var length_bits = new Uint8Array(30)\n  var length_base = new Uint16Array(30)\n\n  /* extra bits and base tables for distance codes */\n  var dist_bits = new Uint8Array(30)\n  var dist_base = new Uint16Array(30)\n\n  /* special ordering of code length codes */\n  var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])\n\n  /* used by tinf_decode_trees, avoids allocations every call */\n  var code_tree = new Tree()\n  var lengths = new Uint8Array(288 + 32)\n\n  /* ----------------------- *\n   * -- utility functions -- *\n   * ----------------------- */\n\n  /* build extra bits and base tables */\n  function tinf_build_bits_base(bits, base, delta, first) {\n    var i, sum\n\n    /* build bits table */\n    for (i = 0; i < delta; ++i) {\n      bits[i] = 0\n    }\n    for (i = 0; i < 30 - delta; ++i) {\n      bits[i + delta] = (i / delta) | 0\n    }\n\n    /* build base table */\n    for (sum = first, i = 0; i < 30; ++i) {\n      base[i] = sum\n      sum += 1 << bits[i]\n    }\n  }\n\n  /* build the fixed huffman trees */\n  function tinf_build_fixed_trees(lt, dt) {\n    var i\n\n    /* build fixed length tree */\n    for (i = 0; i < 7; ++i) {\n      lt.table[i] = 0\n    }\n\n    lt.table[7] = 24\n    lt.table[8] = 152\n    lt.table[9] = 112\n\n    for (i = 0; i < 24; ++i) {\n      lt.trans[i] = 256 + i\n    }\n    for (i = 0; i < 144; ++i) {\n      lt.trans[24 + i] = i\n    }\n    for (i = 0; i < 8; ++i) {\n      lt.trans[24 + 144 + i] = 280 + i\n    }\n    for (i = 0; i < 112; ++i) {\n      lt.trans[24 + 144 + 8 + i] = 144 + i\n    }\n\n    /* build fixed distance tree */\n    for (i = 0; i < 5; ++i) {\n      dt.table[i] = 0\n    }\n\n    dt.table[5] = 32\n\n    for (i = 0; i < 32; ++i) {\n      dt.trans[i] = i\n    }\n  }\n\n  /* given an array of code lengths, build a tree */\n  var offs = new Uint16Array(16)\n\n  function tinf_build_tree(t, lengths, off, num) {\n    var i, sum\n\n    /* clear code length count table */\n    for (i = 0; i < 16; ++i) {\n      t.table[i] = 0\n    }\n\n    /* scan symbol lengths, and sum code length counts */\n    for (i = 0; i < num; ++i) {\n      t.table[lengths[off + i]]++\n    }\n\n    t.table[0] = 0\n\n    /* compute offset table for distribution sort */\n    for (sum = 0, i = 0; i < 16; ++i) {\n      offs[i] = sum\n      sum += t.table[i]\n    }\n\n    /* create code->symbol translation table (symbols sorted by code) */\n    for (i = 0; i < num; ++i) {\n      if (lengths[off + i]) {\n        t.trans[offs[lengths[off + i]]++] = i\n      }\n    }\n  }\n\n  /* ---------------------- *\n   * -- decode functions -- *\n   * ---------------------- */\n\n  /* get one bit from source stream */\n  function tinf_getbit(d) {\n    /* check if tag is empty */\n    if (!d.bitcount--) {\n      /* load next tag */\n      d.tag = d.source[d.sourceIndex++]\n      d.bitcount = 7\n    }\n\n    /* shift bit out of tag */\n    var bit = d.tag & 1\n    d.tag >>>= 1\n\n    return bit\n  }\n\n  /* read a num bit value from a stream and add base */\n  function tinf_read_bits(d, num, base) {\n    if (!num) {\n      return base\n    }\n\n    while (d.bitcount < 24) {\n      d.tag |= d.source[d.sourceIndex++] << d.bitcount\n      d.bitcount += 8\n    }\n\n    var val = d.tag & (0xffff >>> (16 - num))\n    d.tag >>>= num\n    d.bitcount -= num\n    return val + base\n  }\n\n  /* given a data stream and a tree, decode a symbol */\n  function tinf_decode_symbol(d, t) {\n    while (d.bitcount < 24) {\n      d.tag |= d.source[d.sourceIndex++] << d.bitcount\n      d.bitcount += 8\n    }\n\n    var sum = 0,\n      cur = 0,\n      len = 0\n    var tag = d.tag\n\n    /* get more bits while code value is above sum */\n    do {\n      cur = 2 * cur + (tag & 1)\n      tag >>>= 1\n      ++len\n\n      sum += t.table[len]\n      cur -= t.table[len]\n    } while (cur >= 0)\n\n    d.tag = tag\n    d.bitcount -= len\n\n    return t.trans[sum + cur]\n  }\n\n  /* given a data stream, decode dynamic trees from it */\n  function tinf_decode_trees(d, lt, dt) {\n    var hlit, hdist, hclen\n    var i, num, length\n\n    /* get 5 bits HLIT (257-286) */\n    hlit = tinf_read_bits(d, 5, 257)\n\n    /* get 5 bits HDIST (1-32) */\n    hdist = tinf_read_bits(d, 5, 1)\n\n    /* get 4 bits HCLEN (4-19) */\n    hclen = tinf_read_bits(d, 4, 4)\n\n    for (i = 0; i < 19; ++i) {\n      lengths[i] = 0\n    }\n\n    /* read code lengths for code length alphabet */\n    for (i = 0; i < hclen; ++i) {\n      /* get 3 bits code length (0-7) */\n      var clen = tinf_read_bits(d, 3, 0)\n      lengths[clcidx[i]] = clen\n    }\n\n    /* build code length tree */\n    tinf_build_tree(code_tree, lengths, 0, 19)\n\n    /* decode code lengths for the dynamic trees */\n    for (num = 0; num < hlit + hdist; ) {\n      var sym = tinf_decode_symbol(d, code_tree)\n\n      switch (sym) {\n        case 16:\n          /* copy previous code length 3-6 times (read 2 bits) */\n          var prev = lengths[num - 1]\n          for (length = tinf_read_bits(d, 2, 3); length; --length) {\n            lengths[num++] = prev\n          }\n          break\n        case 17:\n          /* repeat code length 0 for 3-10 times (read 3 bits) */\n          for (length = tinf_read_bits(d, 3, 3); length; --length) {\n            lengths[num++] = 0\n          }\n          break\n        case 18:\n          /* repeat code length 0 for 11-138 times (read 7 bits) */\n          for (length = tinf_read_bits(d, 7, 11); length; --length) {\n            lengths[num++] = 0\n          }\n          break\n        default:\n          /* values 0-15 represent the actual code lengths */\n          lengths[num++] = sym\n          break\n      }\n    }\n\n    /* build dynamic trees */\n    tinf_build_tree(lt, lengths, 0, hlit)\n    tinf_build_tree(dt, lengths, hlit, hdist)\n  }\n\n  /* ----------------------------- *\n   * -- block inflate functions -- *\n   * ----------------------------- */\n\n  /* given a stream and two trees, inflate a block of data */\n  function tinf_inflate_block_data(d, lt, dt) {\n    while (1) {\n      var sym = tinf_decode_symbol(d, lt)\n\n      /* check for end of block */\n      if (sym === 256) {\n        return TINF_OK\n      }\n\n      if (sym < 256) {\n        d.dest[d.destLen++] = sym\n      } else {\n        var length, dist, offs\n        var i\n\n        sym -= 257\n\n        /* possibly get more bits from length code */\n        length = tinf_read_bits(d, length_bits[sym], length_base[sym])\n\n        dist = tinf_decode_symbol(d, dt)\n\n        /* possibly get more bits from distance code */\n        offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist])\n\n        /* copy match */\n        for (i = offs; i < offs + length; ++i) {\n          d.dest[d.destLen++] = d.dest[i]\n        }\n      }\n    }\n  }\n\n  /* inflate an uncompressed block of data */\n  function tinf_inflate_uncompressed_block(d) {\n    var length, invlength\n    var i\n\n    /* unread from bitbuffer */\n    while (d.bitcount > 8) {\n      d.sourceIndex--\n      d.bitcount -= 8\n    }\n\n    /* get length */\n    length = d.source[d.sourceIndex + 1]\n    length = 256 * length + d.source[d.sourceIndex]\n\n    /* get one's complement of length */\n    invlength = d.source[d.sourceIndex + 3]\n    invlength = 256 * invlength + d.source[d.sourceIndex + 2]\n\n    /* check length */\n    if (length !== (~invlength & 0x0000ffff)) {\n      return TINF_DATA_ERROR\n    }\n\n    d.sourceIndex += 4\n\n    /* copy block */\n    for (i = length; i; --i) {\n      d.dest[d.destLen++] = d.source[d.sourceIndex++]\n    }\n\n    /* make sure we start next block on a byte boundary */\n    d.bitcount = 0\n\n    return TINF_OK\n  }\n\n  /* inflate stream from source to dest */\n  function tinf_uncompress(source, dest) {\n    var d = new Data(source, dest)\n    var bfinal, btype, res\n\n    do {\n      /* read final block flag */\n      bfinal = tinf_getbit(d)\n\n      /* read block type (2 bits) */\n      btype = tinf_read_bits(d, 2, 0)\n\n      /* decompress block */\n      switch (btype) {\n        case 0:\n          /* decompress uncompressed block */\n          res = tinf_inflate_uncompressed_block(d)\n          break\n        case 1:\n          /* decompress block with fixed huffman trees */\n          res = tinf_inflate_block_data(d, sltree, sdtree)\n          break\n        case 2:\n          /* decompress block with dynamic huffman trees */\n          tinf_decode_trees(d, d.ltree, d.dtree)\n          res = tinf_inflate_block_data(d, d.ltree, d.dtree)\n          break\n        default:\n          res = TINF_DATA_ERROR\n      }\n\n      if (res !== TINF_OK) {\n        throw new Error('Data error')\n      }\n    } while (!bfinal)\n\n    if (d.destLen < d.dest.length) {\n      if (typeof d.dest.slice === 'function') {\n        return d.dest.slice(0, d.destLen)\n      } else {\n        return d.dest.subarray(0, d.destLen)\n      }\n    }\n\n    return d.dest\n  }\n\n  /* -------------------- *\n   * -- initialization -- *\n   * -------------------- */\n\n  /* build fixed huffman trees */\n  tinf_build_fixed_trees(sltree, sdtree)\n\n  /* build extra bits and base tables */\n  tinf_build_bits_base(length_bits, length_base, 4, 3)\n  tinf_build_bits_base(dist_bits, dist_base, 2, 1)\n\n  /* fix a special case */\n  length_bits[28] = 0\n  length_base[28] = 258\n\n  var tinyInflate = tinf_uncompress\n\n  // The Bounding Box object\n\n  function derive(v0, v1, v2, v3, t) {\n    return (\n      Math.pow(1 - t, 3) * v0 +\n      3 * Math.pow(1 - t, 2) * t * v1 +\n      3 * (1 - t) * Math.pow(t, 2) * v2 +\n      Math.pow(t, 3) * v3\n    )\n  }\n  /**\n   * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n   * It is used to calculate the bounding box of a glyph or text path.\n   *\n   * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n   *\n   * @exports opentype.BoundingBox\n   * @class\n   * @constructor\n   */\n  function BoundingBox() {\n    this.x1 = Number.NaN\n    this.y1 = Number.NaN\n    this.x2 = Number.NaN\n    this.y2 = Number.NaN\n  }\n\n  /**\n   * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n   */\n  BoundingBox.prototype.isEmpty = function () {\n    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2)\n  }\n\n  /**\n   * Add the point to the bounding box.\n   * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n   * @param {number} x - The X coordinate of the point.\n   * @param {number} y - The Y coordinate of the point.\n   */\n  BoundingBox.prototype.addPoint = function (x, y) {\n    if (typeof x === 'number') {\n      if (isNaN(this.x1) || isNaN(this.x2)) {\n        this.x1 = x\n        this.x2 = x\n      }\n      if (x < this.x1) {\n        this.x1 = x\n      }\n      if (x > this.x2) {\n        this.x2 = x\n      }\n    }\n    if (typeof y === 'number') {\n      if (isNaN(this.y1) || isNaN(this.y2)) {\n        this.y1 = y\n        this.y2 = y\n      }\n      if (y < this.y1) {\n        this.y1 = y\n      }\n      if (y > this.y2) {\n        this.y2 = y\n      }\n    }\n  }\n\n  /**\n   * Add a X coordinate to the bounding box.\n   * This extends the bounding box to include the X coordinate.\n   * This function is used internally inside of addBezier.\n   * @param {number} x - The X coordinate of the point.\n   */\n  BoundingBox.prototype.addX = function (x) {\n    this.addPoint(x, null)\n  }\n\n  /**\n   * Add a Y coordinate to the bounding box.\n   * This extends the bounding box to include the Y coordinate.\n   * This function is used internally inside of addBezier.\n   * @param {number} y - The Y coordinate of the point.\n   */\n  BoundingBox.prototype.addY = function (y) {\n    this.addPoint(null, y)\n  }\n\n  /**\n   * Add a Bzier curve to the bounding box.\n   * This extends the bounding box to include the entire Bzier.\n   * @param {number} x0 - The starting X coordinate.\n   * @param {number} y0 - The starting Y coordinate.\n   * @param {number} x1 - The X coordinate of the first control point.\n   * @param {number} y1 - The Y coordinate of the first control point.\n   * @param {number} x2 - The X coordinate of the second control point.\n   * @param {number} y2 - The Y coordinate of the second control point.\n   * @param {number} x - The ending X coordinate.\n   * @param {number} y - The ending Y coordinate.\n   */\n  BoundingBox.prototype.addBezier = function (x0, y0, x1, y1, x2, y2, x, y) {\n    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // and https://github.com/icons8/svg-path-bounding-box\n\n    var p0 = [x0, y0]\n    var p1 = [x1, y1]\n    var p2 = [x2, y2]\n    var p3 = [x, y]\n\n    this.addPoint(x0, y0)\n    this.addPoint(x, y)\n\n    for (var i = 0; i <= 1; i++) {\n      var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i]\n      var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i]\n      var c = 3 * p1[i] - 3 * p0[i]\n\n      if (a === 0) {\n        if (b === 0) {\n          continue\n        }\n        var t = -c / b\n        if (0 < t && t < 1) {\n          if (i === 0) {\n            this.addX(derive(p0[i], p1[i], p2[i], p3[i], t))\n          }\n          if (i === 1) {\n            this.addY(derive(p0[i], p1[i], p2[i], p3[i], t))\n          }\n        }\n        continue\n      }\n\n      var b2ac = Math.pow(b, 2) - 4 * c * a\n      if (b2ac < 0) {\n        continue\n      }\n      var t1 = (-b + Math.sqrt(b2ac)) / (2 * a)\n      if (0 < t1 && t1 < 1) {\n        if (i === 0) {\n          this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1))\n        }\n        if (i === 1) {\n          this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1))\n        }\n      }\n      var t2 = (-b - Math.sqrt(b2ac)) / (2 * a)\n      if (0 < t2 && t2 < 1) {\n        if (i === 0) {\n          this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2))\n        }\n        if (i === 1) {\n          this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2))\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a quadratic curve to the bounding box.\n   * This extends the bounding box to include the entire quadratic curve.\n   * @param {number} x0 - The starting X coordinate.\n   * @param {number} y0 - The starting Y coordinate.\n   * @param {number} x1 - The X coordinate of the control point.\n   * @param {number} y1 - The Y coordinate of the control point.\n   * @param {number} x - The ending X coordinate.\n   * @param {number} y - The ending Y coordinate.\n   */\n  BoundingBox.prototype.addQuad = function (x0, y0, x1, y1, x, y) {\n    var cp1x = x0 + (2 / 3) * (x1 - x0)\n    var cp1y = y0 + (2 / 3) * (y1 - y0)\n    var cp2x = cp1x + (1 / 3) * (x - x0)\n    var cp2y = cp1y + (1 / 3) * (y - y0)\n    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y)\n  }\n\n  // Geometric objects\n\n  /**\n   * A bzier path containing a set of path commands similar to a SVG path.\n   * Paths can be drawn on a context using `draw`.\n   * @exports opentype.Path\n   * @class\n   * @constructor\n   */\n  function Path() {\n    this.commands = []\n    this.fill = 'black'\n    this.stroke = null\n    this.strokeWidth = 1\n  }\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   */\n  Path.prototype.moveTo = function (x, y) {\n    this.commands.push({\n      type: 'M',\n      x: x,\n      y: y,\n    })\n  }\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   */\n  Path.prototype.lineTo = function (x, y) {\n    this.commands.push({\n      type: 'L',\n      x: x,\n      y: y,\n    })\n  }\n\n  /**\n   * Draws cubic curve\n   * @function\n   * curveTo\n   * @memberof opentype.Path.prototype\n   * @param  {number} x1 - x of control 1\n   * @param  {number} y1 - y of control 1\n   * @param  {number} x2 - x of control 2\n   * @param  {number} y2 - y of control 2\n   * @param  {number} x - x of path point\n   * @param  {number} y - y of path point\n   */\n\n  /**\n   * Draws cubic curve\n   * @function\n   * bezierCurveTo\n   * @memberof opentype.Path.prototype\n   * @param  {number} x1 - x of control 1\n   * @param  {number} y1 - y of control 1\n   * @param  {number} x2 - x of control 2\n   * @param  {number} y2 - y of control 2\n   * @param  {number} x - x of path point\n   * @param  {number} y - y of path point\n   * @see curveTo\n   */\n  Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {\n    this.commands.push({\n      type: 'C',\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      x: x,\n      y: y,\n    })\n  }\n\n  /**\n   * Draws quadratic curve\n   * @function\n   * quadraticCurveTo\n   * @memberof opentype.Path.prototype\n   * @param  {number} x1 - x of control\n   * @param  {number} y1 - y of control\n   * @param  {number} x - x of path point\n   * @param  {number} y - y of path point\n   */\n\n  /**\n   * Draws quadratic curve\n   * @function\n   * quadTo\n   * @memberof opentype.Path.prototype\n   * @param  {number} x1 - x of control\n   * @param  {number} y1 - y of control\n   * @param  {number} x - x of path point\n   * @param  {number} y - y of path point\n   */\n  Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {\n    this.commands.push({\n      type: 'Q',\n      x1: x1,\n      y1: y1,\n      x: x,\n      y: y,\n    })\n  }\n\n  /**\n   * Closes the path\n   * @function closePath\n   * @memberof opentype.Path.prototype\n   */\n\n  /**\n   * Close the path\n   * @function close\n   * @memberof opentype.Path.prototype\n   */\n  Path.prototype.close = Path.prototype.closePath = function () {\n    this.commands.push({\n      type: 'Z',\n    })\n  }\n\n  /**\n   * Add the given path or list of commands to the commands of this path.\n   * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n   */\n  Path.prototype.extend = function (pathOrCommands) {\n    if (pathOrCommands.commands) {\n      pathOrCommands = pathOrCommands.commands\n    } else if (pathOrCommands instanceof BoundingBox) {\n      var box = pathOrCommands\n      this.moveTo(box.x1, box.y1)\n      this.lineTo(box.x2, box.y1)\n      this.lineTo(box.x2, box.y2)\n      this.lineTo(box.x1, box.y2)\n      this.close()\n      return\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands)\n  }\n\n  /**\n   * Calculate the bounding box of the path.\n   * @returns {opentype.BoundingBox}\n   */\n  Path.prototype.getBoundingBox = function () {\n    var box = new BoundingBox()\n\n    var startX = 0\n    var startY = 0\n    var prevX = 0\n    var prevY = 0\n    for (var i = 0; i < this.commands.length; i++) {\n      var cmd = this.commands[i]\n      switch (cmd.type) {\n        case 'M':\n          box.addPoint(cmd.x, cmd.y)\n          startX = prevX = cmd.x\n          startY = prevY = cmd.y\n          break\n        case 'L':\n          box.addPoint(cmd.x, cmd.y)\n          prevX = cmd.x\n          prevY = cmd.y\n          break\n        case 'Q':\n          box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y)\n          prevX = cmd.x\n          prevY = cmd.y\n          break\n        case 'C':\n          box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y)\n          prevX = cmd.x\n          prevY = cmd.y\n          break\n        case 'Z':\n          prevX = startX\n          prevY = startY\n          break\n        default:\n          throw new Error('Unexpected path command ' + cmd.type)\n      }\n    }\n    if (box.isEmpty()) {\n      box.addPoint(0, 0)\n    }\n    return box\n  }\n\n  /**\n   * Draw the path to a 2D context.\n   * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n   */\n  Path.prototype.draw = function (ctx) {\n    ctx.beginPath()\n    for (var i = 0; i < this.commands.length; i += 1) {\n      var cmd = this.commands[i]\n      if (cmd.type === 'M') {\n        ctx.moveTo(cmd.x, cmd.y)\n      } else if (cmd.type === 'L') {\n        ctx.lineTo(cmd.x, cmd.y)\n      } else if (cmd.type === 'C') {\n        ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y)\n      } else if (cmd.type === 'Q') {\n        ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y)\n      } else if (cmd.type === 'Z') {\n        ctx.closePath()\n      }\n    }\n\n    if (this.fill) {\n      ctx.fillStyle = this.fill\n      ctx.fill()\n    }\n\n    if (this.stroke) {\n      ctx.strokeStyle = this.stroke\n      ctx.lineWidth = this.strokeWidth\n      ctx.stroke()\n    }\n  }\n\n  /**\n   * Convert the Path to a string of path data instructions\n   * See http://www.w3.org/TR/SVG/paths.html#PathData\n   * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n   * @return {string}\n   */\n  Path.prototype.toPathData = function (decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2\n\n    function floatToString(v) {\n      if (Math.round(v) === v) {\n        return '' + Math.round(v)\n      } else {\n        return v.toFixed(decimalPlaces)\n      }\n    }\n\n    function packValues() {\n      var arguments$1 = arguments\n\n      var s = ''\n      for (var i = 0; i < arguments.length; i += 1) {\n        var v = arguments$1[i]\n        if (v >= 0 && i > 0) {\n          s += ' '\n        }\n\n        s += floatToString(v)\n      }\n\n      return s\n    }\n\n    var d = ''\n    for (var i = 0; i < this.commands.length; i += 1) {\n      var cmd = this.commands[i]\n      if (cmd.type === 'M') {\n        d += 'M' + packValues(cmd.x, cmd.y)\n      } else if (cmd.type === 'L') {\n        d += 'L' + packValues(cmd.x, cmd.y)\n      } else if (cmd.type === 'C') {\n        d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y)\n      } else if (cmd.type === 'Q') {\n        d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y)\n      } else if (cmd.type === 'Z') {\n        d += 'Z'\n      }\n    }\n\n    return d\n  }\n\n  /**\n   * Convert the path to an SVG <path> element, as a string.\n   * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n   * @return {string}\n   */\n  Path.prototype.toSVG = function (decimalPlaces) {\n    var svg = '<path d=\"'\n    svg += this.toPathData(decimalPlaces)\n    svg += '\"'\n    if (this.fill && this.fill !== 'black') {\n      if (this.fill === null) {\n        svg += ' fill=\"none\"'\n      } else {\n        svg += ' fill=\"' + this.fill + '\"'\n      }\n    }\n\n    if (this.stroke) {\n      svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"'\n    }\n\n    svg += '/>'\n    return svg\n  }\n\n  /**\n   * Convert the path to a DOM element.\n   * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n   * @return {SVGPathElement}\n   */\n  Path.prototype.toDOMElement = function (decimalPlaces) {\n    var temporaryPath = this.toPathData(decimalPlaces)\n    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\n    newPath.setAttribute('d', temporaryPath)\n\n    return newPath\n  }\n\n  // Run-time checking of preconditions.\n\n  function fail(message) {\n    throw new Error(message)\n  }\n\n  // Precondition function that checks if the given predicate is true.\n  // If not, it will throw an error.\n  function argument(predicate, message) {\n    if (!predicate) {\n      fail(message)\n    }\n  }\n  var check = { fail: fail, argument: argument, assert: argument }\n\n  // Data types used in the OpenType font file.\n\n  var LIMIT16 = 32768 // The limit at which a 16-bit number switches signs == 2^15\n  var LIMIT32 = 2147483648 // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n  /**\n   * @exports opentype.decode\n   * @class\n   */\n  var decode = {}\n  /**\n   * @exports opentype.encode\n   * @class\n   */\n  var encode = {}\n  /**\n   * @exports opentype.sizeOf\n   * @class\n   */\n  var sizeOf = {}\n\n  // Return a function that always returns the same value.\n  function constant(v) {\n    return function () {\n      return v\n    }\n  }\n\n  // OpenType data types //////////////////////////////////////////////////////\n\n  /**\n   * Convert an 8-bit unsigned integer to a list of 1 byte.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.BYTE = function (v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.')\n    return [v]\n  }\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.BYTE = constant(1)\n\n  /**\n   * Convert a 8-bit signed integer to a list of 1 byte.\n   * @param {string}\n   * @returns {Array}\n   */\n  encode.CHAR = function (v) {\n    return [v.charCodeAt(0)]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.CHAR = constant(1)\n\n  /**\n   * Convert an ASCII string to a list of bytes.\n   * @param {string}\n   * @returns {Array}\n   */\n  encode.CHARARRAY = function (v) {\n    if (typeof v === 'undefined') {\n      v = ''\n      console.warn(\n        'Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.',\n      )\n    }\n    var b = []\n    for (var i = 0; i < v.length; i += 1) {\n      b[i] = v.charCodeAt(i)\n    }\n\n    return b\n  }\n\n  /**\n   * @param {Array}\n   * @returns {number}\n   */\n  sizeOf.CHARARRAY = function (v) {\n    if (typeof v === 'undefined') {\n      return 0\n    }\n    return v.length\n  }\n\n  /**\n   * Convert a 16-bit unsigned integer to a list of 2 bytes.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.USHORT = function (v) {\n    return [(v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.USHORT = constant(2)\n\n  /**\n   * Convert a 16-bit signed integer to a list of 2 bytes.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.SHORT = function (v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n      v = -(2 * LIMIT16 - v)\n    }\n\n    return [(v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.SHORT = constant(2)\n\n  /**\n   * Convert a 24-bit unsigned integer to a list of 3 bytes.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.UINT24 = function (v) {\n    return [(v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.UINT24 = constant(3)\n\n  /**\n   * Convert a 32-bit unsigned integer to a list of 4 bytes.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.ULONG = function (v) {\n    return [(v >> 24) & 0xff, (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.ULONG = constant(4)\n\n  /**\n   * Convert a 32-bit unsigned integer to a list of 4 bytes.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.LONG = function (v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n      v = -(2 * LIMIT32 - v)\n    }\n\n    return [(v >> 24) & 0xff, (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.LONG = constant(4)\n\n  encode.FIXED = encode.ULONG\n  sizeOf.FIXED = sizeOf.ULONG\n\n  encode.FWORD = encode.SHORT\n  sizeOf.FWORD = sizeOf.SHORT\n\n  encode.UFWORD = encode.USHORT\n  sizeOf.UFWORD = sizeOf.USHORT\n\n  /**\n   * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.LONGDATETIME = function (v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xff, (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.LONGDATETIME = constant(8)\n\n  /**\n   * Convert a 4-char tag to a list of 4 bytes.\n   * @param {string}\n   * @returns {Array}\n   */\n  encode.TAG = function (v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.')\n    return [v.charCodeAt(0), v.charCodeAt(1), v.charCodeAt(2), v.charCodeAt(3)]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.TAG = constant(4)\n\n  // CFF data types ///////////////////////////////////////////////////////////\n\n  encode.Card8 = encode.BYTE\n  sizeOf.Card8 = sizeOf.BYTE\n\n  encode.Card16 = encode.USHORT\n  sizeOf.Card16 = sizeOf.USHORT\n\n  encode.OffSize = encode.BYTE\n  sizeOf.OffSize = sizeOf.BYTE\n\n  encode.SID = encode.USHORT\n  sizeOf.SID = sizeOf.USHORT\n\n  // Convert a numeric operand or charstring number to a variable-size list of bytes.\n  /**\n   * Convert a numeric operand or charstring number to a variable-size list of bytes.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.NUMBER = function (v) {\n    if (v >= -107 && v <= 107) {\n      return [v + 139]\n    } else if (v >= 108 && v <= 1131) {\n      v = v - 108\n      return [(v >> 8) + 247, v & 0xff]\n    } else if (v >= -1131 && v <= -108) {\n      v = -v - 108\n      return [(v >> 8) + 251, v & 0xff]\n    } else if (v >= -32768 && v <= 32767) {\n      return encode.NUMBER16(v)\n    } else {\n      return encode.NUMBER32(v)\n    }\n  }\n\n  /**\n   * @param {number}\n   * @returns {number}\n   */\n  sizeOf.NUMBER = function (v) {\n    return encode.NUMBER(v).length\n  }\n\n  /**\n   * Convert a signed number between -32768 and +32767 to a three-byte value.\n   * This ensures we always use three bytes, but is not the most compact format.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.NUMBER16 = function (v) {\n    return [28, (v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.NUMBER16 = constant(3)\n\n  /**\n   * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n   * This is useful if you want to be sure you always use four bytes,\n   * at the expense of wasting a few bytes for smaller numbers.\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.NUMBER32 = function (v) {\n    return [29, (v >> 24) & 0xff, (v >> 16) & 0xff, (v >> 8) & 0xff, v & 0xff]\n  }\n\n  /**\n   * @constant\n   * @type {number}\n   */\n  sizeOf.NUMBER32 = constant(5)\n\n  /**\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.REAL = function (v) {\n    var value = v.toString()\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value)\n    if (m) {\n      var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length))\n      value = (Math.round(v * epsilon) / epsilon).toString()\n    }\n\n    var nibbles = ''\n    for (var i = 0, ii = value.length; i < ii; i += 1) {\n      var c = value[i]\n      if (c === 'e') {\n        nibbles += value[++i] === '-' ? 'c' : 'b'\n      } else if (c === '.') {\n        nibbles += 'a'\n      } else if (c === '-') {\n        nibbles += 'e'\n      } else {\n        nibbles += c\n      }\n    }\n\n    nibbles += nibbles.length & 1 ? 'f' : 'ff'\n    var out = [30]\n    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n      out.push(parseInt(nibbles.substr(i$1, 2), 16))\n    }\n\n    return out\n  }\n\n  /**\n   * @param {number}\n   * @returns {number}\n   */\n  sizeOf.REAL = function (v) {\n    return encode.REAL(v).length\n  }\n\n  encode.NAME = encode.CHARARRAY\n  sizeOf.NAME = sizeOf.CHARARRAY\n\n  encode.STRING = encode.CHARARRAY\n  sizeOf.STRING = sizeOf.CHARARRAY\n\n  /**\n   * @param {DataView} data\n   * @param {number} offset\n   * @param {number} numBytes\n   * @returns {string}\n   */\n  decode.UTF8 = function (data, offset, numBytes) {\n    var codePoints = []\n    var numChars = numBytes\n    for (var j = 0; j < numChars; j++, offset += 1) {\n      codePoints[j] = data.getUint8(offset)\n    }\n\n    return String.fromCharCode.apply(null, codePoints)\n  }\n\n  /**\n   * @param {DataView} data\n   * @param {number} offset\n   * @param {number} numBytes\n   * @returns {string}\n   */\n  decode.UTF16 = function (data, offset, numBytes) {\n    var codePoints = []\n    var numChars = numBytes / 2\n    for (var j = 0; j < numChars; j++, offset += 2) {\n      codePoints[j] = data.getUint16(offset)\n    }\n\n    return String.fromCharCode.apply(null, codePoints)\n  }\n\n  /**\n   * Convert a JavaScript string to UTF16-BE.\n   * @param {string}\n   * @returns {Array}\n   */\n  encode.UTF16 = function (v) {\n    var b = []\n    for (var i = 0; i < v.length; i += 1) {\n      var codepoint = v.charCodeAt(i)\n      b[b.length] = (codepoint >> 8) & 0xff\n      b[b.length] = codepoint & 0xff\n    }\n\n    return b\n  }\n\n  /**\n   * @param {string}\n   * @returns {number}\n   */\n  sizeOf.UTF16 = function (v) {\n    return v.length * 2\n  }\n\n  // Data for converting old eight-bit Macintosh encodings to Unicode.\n  // This representation is optimized for decoding; encoding is slower\n  // and needs more memory. The assumption is that all opentype.js users\n  // want to open fonts, but saving a font will be comparatively rare\n  // so it can be more expensive. Keyed by IANA character set name.\n  //\n  // Python script for generating these strings:\n  //\n  //     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n  //     print(s.encode('utf-8'))\n  /**\n   * @private\n   */\n  var eightBitMacEncodings = {\n    // Python: 'mac_croatian'\n    'x-mac-croatian':\n      '' +\n      ' ',\n    // Python: 'mac_cyrillic'\n    'x-mac-cyrillic':\n      '' +\n      ' ',\n    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'x-mac-gaelic':\n      '' +\n      ' ',\n    // Python: 'mac_greek'\n    'x-mac-greek':\n      '' +\n      ' \\u00AD',\n    // Python: 'mac_iceland'\n    'x-mac-icelandic':\n      '' +\n      ' ',\n    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'x-mac-inuit':\n      '' +\n      ' ',\n    // Python: 'mac_latin2'\n    'x-mac-ce':\n      '' +\n      ' ',\n    // Python: 'mac_roman'\n    macintosh:\n      '' +\n      ' ',\n    // Python: 'mac_romanian'\n    'x-mac-romanian':\n      '' +\n      ' ',\n    // Python: 'mac_turkish'\n    'x-mac-turkish':\n      '' +\n      ' ',\n  }\n\n  /**\n   * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n   * string, or 'undefined' if the encoding is unsupported. For example, we do\n   * not support Chinese, Japanese or Korean because these would need large\n   * mapping tables.\n   * @param {DataView} dataView\n   * @param {number} offset\n   * @param {number} dataLength\n   * @param {string} encoding\n   * @returns {string}\n   */\n  decode.MACSTRING = function (dataView, offset, dataLength, encoding) {\n    var table = eightBitMacEncodings[encoding]\n    if (table === undefined) {\n      return undefined\n    }\n\n    var result = ''\n    for (var i = 0; i < dataLength; i++) {\n      var c = dataView.getUint8(offset + i)\n      // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n      // mapped to U+0000..U+007F; we only need to look up the others.\n      if (c <= 0x7f) {\n        result += String.fromCharCode(c)\n      } else {\n        result += table[c & 0x7f]\n      }\n    }\n\n    return result\n  }\n\n  // Helper function for encode.MACSTRING. Returns a dictionary for mapping\n  // Unicode character codes to their 8-bit MacOS equivalent. This table\n  // is not exactly a super cheap data structure, but we do not care because\n  // encoding Macintosh strings is only rarely needed in typical applications.\n  var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap()\n  var macEncodingCacheKeys\n  var getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n      macEncodingCacheKeys = {}\n      for (var e in eightBitMacEncodings) {\n        /*jshint -W053 */ // Suppress \"Do not use String as a constructor.\"\n        macEncodingCacheKeys[e] = new String(e)\n      }\n    }\n\n    var cacheKey = macEncodingCacheKeys[encoding]\n    if (cacheKey === undefined) {\n      return undefined\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n      var cachedTable = macEncodingTableCache.get(cacheKey)\n      if (cachedTable !== undefined) {\n        return cachedTable\n      }\n    }\n\n    var decodingTable = eightBitMacEncodings[encoding]\n    if (decodingTable === undefined) {\n      return undefined\n    }\n\n    var encodingTable = {}\n    for (var i = 0; i < decodingTable.length; i++) {\n      encodingTable[decodingTable.charCodeAt(i)] = i + 0x80\n    }\n\n    if (macEncodingTableCache) {\n      macEncodingTableCache.set(cacheKey, encodingTable)\n    }\n\n    return encodingTable\n  }\n\n  /**\n   * Encodes an old-style Macintosh string. Returns a byte array upon success.\n   * If the requested encoding is unsupported, or if the input string contains\n   * a character that cannot be expressed in the encoding, the function returns\n   * 'undefined'.\n   * @param {string} str\n   * @param {string} encoding\n   * @returns {Array}\n   */\n  encode.MACSTRING = function (str, encoding) {\n    var table = getMacEncodingTable(encoding)\n    if (table === undefined) {\n      return undefined\n    }\n\n    var result = []\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charCodeAt(i)\n\n      // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n      // mapped to U+0000..U+007F; we only need to look up the others.\n      if (c >= 0x80) {\n        c = table[c]\n        if (c === undefined) {\n          // str contains a Unicode character that cannot be encoded\n          // in the requested encoding.\n          return undefined\n        }\n      }\n      result[i] = c\n      // result.push(c);\n    }\n\n    return result\n  }\n\n  /**\n   * @param {string} str\n   * @param {string} encoding\n   * @returns {number}\n   */\n  sizeOf.MACSTRING = function (str, encoding) {\n    var b = encode.MACSTRING(str, encoding)\n    if (b !== undefined) {\n      return b.length\n    } else {\n      return 0\n    }\n  }\n\n  // Helper for encode.VARDELTAS\n  function isByteEncodable(value) {\n    return value >= -128 && value <= 127\n  }\n\n  // Helper for encode.VARDELTAS\n  function encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    var runLength = 0\n    var numDeltas = deltas.length\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n      ++pos\n      ++runLength\n    }\n    result.push(0x80 | (runLength - 1))\n    return pos\n  }\n\n  // Helper for encode.VARDELTAS\n  function encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    var runLength = 0\n    var numDeltas = deltas.length\n    var pos = offset\n    while (pos < numDeltas && runLength < 64) {\n      var value = deltas[pos]\n      if (!isByteEncodable(value)) {\n        break\n      }\n\n      // Within a byte-encoded run of deltas, a single zero is best\n      // stored literally as 0x00 value. However, if we have two or\n      // more zeroes in a sequence, it is better to start a new run.\n      // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n      // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n      // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n      // when starting a new run.\n      if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n        break\n      }\n\n      ++pos\n      ++runLength\n    }\n    result.push(runLength - 1)\n    for (var i = offset; i < pos; ++i) {\n      result.push((deltas[i] + 256) & 0xff)\n    }\n    return pos\n  }\n\n  // Helper for encode.VARDELTAS\n  function encodeVarDeltaRunAsWords(deltas, offset, result) {\n    var runLength = 0\n    var numDeltas = deltas.length\n    var pos = offset\n    while (pos < numDeltas && runLength < 64) {\n      var value = deltas[pos]\n\n      // Within a word-encoded run of deltas, it is easiest to start\n      // a new run (with a different encoding) whenever we encounter\n      // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n      // needs 7 bytes when storing the zero inside the current run\n      // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n      // new run (40 66 66 80 40 77 77).\n      if (value === 0) {\n        break\n      }\n\n      // Within a word-encoded run of deltas, a single value in the\n      // range (-128..127) should be encoded within the current run\n      // because it is more compact. For example, the sequence\n      // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n      // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n      // a new run (40 66 66 00 02 40 77 77).\n      if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n        break\n      }\n\n      ++pos\n      ++runLength\n    }\n    result.push(0x40 | (runLength - 1))\n    for (var i = offset; i < pos; ++i) {\n      var val = deltas[i]\n      result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff)\n    }\n    return pos\n  }\n\n  /**\n   * Encode a list of variation adjustment deltas.\n   *\n   * Variation adjustment deltas are used in gvar and cvar tables.\n   * They indicate how points (in gvar) or values (in cvar) get adjusted\n   * when generating instances of variation fonts.\n   *\n   * @see https://www.microsoft.com/typography/otspec/gvar.htm\n   * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n   * @param {Array}\n   * @return {Array}\n   */\n  encode.VARDELTAS = function (deltas) {\n    var pos = 0\n    var result = []\n    while (pos < deltas.length) {\n      var value = deltas[pos]\n      if (value === 0) {\n        pos = encodeVarDeltaRunAsZeroes(deltas, pos, result)\n      } else if (value >= -128 && value <= 127) {\n        pos = encodeVarDeltaRunAsBytes(deltas, pos, result)\n      } else {\n        pos = encodeVarDeltaRunAsWords(deltas, pos, result)\n      }\n    }\n    return result\n  }\n\n  // Convert a list of values to a CFF INDEX structure.\n  // The values should be objects containing name / type / value.\n  /**\n   * @param {Array} l\n   * @returns {Array}\n   */\n  encode.INDEX = function (l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    var offset = 1 // First offset is always 1.\n    var offsets = [offset]\n    var data = []\n    for (var i = 0; i < l.length; i += 1) {\n      var v = encode.OBJECT(l[i])\n      Array.prototype.push.apply(data, v)\n      offset += v.length\n      offsets.push(offset)\n    }\n\n    if (data.length === 0) {\n      return [0, 0]\n    }\n\n    var encodedOffsets = []\n    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0\n    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize]\n    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n      var encodedOffset = offsetEncoder(offsets[i$1])\n      Array.prototype.push.apply(encodedOffsets, encodedOffset)\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data)\n  }\n\n  /**\n   * @param {Array}\n   * @returns {number}\n   */\n  sizeOf.INDEX = function (v) {\n    return encode.INDEX(v).length\n  }\n\n  /**\n   * Convert an object to a CFF DICT structure.\n   * The keys should be numeric.\n   * The values should be objects containing name / type / value.\n   * @param {Object} m\n   * @returns {Array}\n   */\n  encode.DICT = function (m) {\n    var d = []\n    var keys = Object.keys(m)\n    var length = keys.length\n\n    for (var i = 0; i < length; i += 1) {\n      // Object.keys() return string keys, but our keys are always numeric.\n      var k = parseInt(keys[i], 0)\n      var v = m[k]\n      // Value comes before the key.\n      d = d.concat(encode.OPERAND(v.value, v.type))\n      d = d.concat(encode.OPERATOR(k))\n    }\n\n    return d\n  }\n\n  /**\n   * @param {Object}\n   * @returns {number}\n   */\n  sizeOf.DICT = function (m) {\n    return encode.DICT(m).length\n  }\n\n  /**\n   * @param {number}\n   * @returns {Array}\n   */\n  encode.OPERATOR = function (v) {\n    if (v < 1200) {\n      return [v]\n    } else {\n      return [12, v - 1200]\n    }\n  }\n\n  /**\n   * @param {Array} v\n   * @param {string}\n   * @returns {Array}\n   */\n  encode.OPERAND = function (v, type) {\n    var d = []\n    if (Array.isArray(type)) {\n      for (var i = 0; i < type.length; i += 1) {\n        check.argument(v.length === type.length, 'Not enough arguments given for type' + type)\n        d = d.concat(encode.OPERAND(v[i], type[i]))\n      }\n    } else {\n      if (type === 'SID') {\n        d = d.concat(encode.NUMBER(v))\n      } else if (type === 'offset') {\n        // We make it easy for ourselves and always encode offsets as\n        // 4 bytes. This makes offset calculation for the top dict easier.\n        d = d.concat(encode.NUMBER32(v))\n      } else if (type === 'number') {\n        d = d.concat(encode.NUMBER(v))\n      } else if (type === 'real') {\n        d = d.concat(encode.REAL(v))\n      } else {\n        throw new Error('Unknown operand type ' + type)\n        // FIXME Add support for booleans\n      }\n    }\n\n    return d\n  }\n\n  encode.OP = encode.BYTE\n  sizeOf.OP = sizeOf.BYTE\n\n  // memoize charstring encoding using WeakMap if available\n  var wmm = typeof WeakMap === 'function' && new WeakMap()\n\n  /**\n   * Convert a list of CharString operations to bytes.\n   * @param {Array}\n   * @returns {Array}\n   */\n  encode.CHARSTRING = function (ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n      var cachedValue = wmm.get(ops)\n      if (cachedValue !== undefined) {\n        return cachedValue\n      }\n    }\n\n    var d = []\n    var length = ops.length\n\n    for (var i = 0; i < length; i += 1) {\n      var op = ops[i]\n      d = d.concat(encode[op.type](op.value))\n    }\n\n    if (wmm) {\n      wmm.set(ops, d)\n    }\n\n    return d\n  }\n\n  /**\n   * @param {Array}\n   * @returns {number}\n   */\n  sizeOf.CHARSTRING = function (ops) {\n    return encode.CHARSTRING(ops).length\n  }\n\n  // Utility functions ////////////////////////////////////////////////////////\n\n  /**\n   * Convert an object containing name / type / value to bytes.\n   * @param {Object}\n   * @returns {Array}\n   */\n  encode.OBJECT = function (v) {\n    var encodingFunction = encode[v.type]\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type)\n    return encodingFunction(v.value)\n  }\n\n  /**\n   * @param {Object}\n   * @returns {number}\n   */\n  sizeOf.OBJECT = function (v) {\n    var sizeOfFunction = sizeOf[v.type]\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type)\n    return sizeOfFunction(v.value)\n  }\n\n  /**\n   * Convert a table object to bytes.\n   * A table contains a list of fields containing the metadata (name, type and default value).\n   * The table itself has the field values set as attributes.\n   * @param {opentype.Table}\n   * @returns {Array}\n   */\n  encode.TABLE = function (table) {\n    var d = []\n    var length = table.fields.length\n    var subtables = []\n    var subtableOffsets = []\n\n    for (var i = 0; i < length; i += 1) {\n      var field = table.fields[i]\n      var encodingFunction = encode[field.type]\n      check.argument(\n        encodingFunction !== undefined,\n        'No encoding function for field type ' + field.type + ' (' + field.name + ')',\n      )\n      var value = table[field.name]\n      if (value === undefined) {\n        value = field.value\n      }\n\n      var bytes = encodingFunction(value)\n\n      if (field.type === 'TABLE') {\n        subtableOffsets.push(d.length)\n        d = d.concat([0, 0])\n        subtables.push(bytes)\n      } else {\n        d = d.concat(bytes)\n      }\n    }\n\n    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n      var o = subtableOffsets[i$1]\n      var offset = d.length\n      check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.')\n      d[o] = offset >> 8\n      d[o + 1] = offset & 0xff\n      d = d.concat(subtables[i$1])\n    }\n\n    return d\n  }\n\n  /**\n   * @param {opentype.Table}\n   * @returns {number}\n   */\n  sizeOf.TABLE = function (table) {\n    var numBytes = 0\n    var length = table.fields.length\n\n    for (var i = 0; i < length; i += 1) {\n      var field = table.fields[i]\n      var sizeOfFunction = sizeOf[field.type]\n      check.argument(\n        sizeOfFunction !== undefined,\n        'No sizeOf function for field type ' + field.type + ' (' + field.name + ')',\n      )\n      var value = table[field.name]\n      if (value === undefined) {\n        value = field.value\n      }\n\n      numBytes += sizeOfFunction(value)\n\n      // Subtables take 2 more bytes for offsets.\n      if (field.type === 'TABLE') {\n        numBytes += 2\n      }\n    }\n\n    return numBytes\n  }\n\n  encode.RECORD = encode.TABLE\n  sizeOf.RECORD = sizeOf.TABLE\n\n  // Merge in a list of bytes.\n  encode.LITERAL = function (v) {\n    return v\n  }\n\n  sizeOf.LITERAL = function (v) {\n    return v.length\n  }\n\n  // Table metadata\n\n  /**\n   * @exports opentype.Table\n   * @class\n   * @param {string} tableName\n   * @param {Array} fields\n   * @param {Object} options\n   * @constructor\n   */\n  function Table(tableName, fields, options) {\n    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,\n    // as this will result in wrong encoding order of the coverage data on serialization to bytes.\n    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.\n    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {\n      for (var i = 0; i < fields.length; i += 1) {\n        var field = fields[i]\n        this[field.name] = field.value\n      }\n    }\n\n    this.tableName = tableName\n    this.fields = fields\n    if (options) {\n      var optionKeys = Object.keys(options)\n      for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n        var k = optionKeys[i$1]\n        var v = options[k]\n        if (this[k] !== undefined) {\n          this[k] = v\n        }\n      }\n    }\n  }\n\n  /**\n   * Encodes the table and returns an array of bytes\n   * @return {Array}\n   */\n  Table.prototype.encode = function () {\n    return encode.TABLE(this)\n  }\n\n  /**\n   * Get the size of the table.\n   * @return {number}\n   */\n  Table.prototype.sizeOf = function () {\n    return sizeOf.TABLE(this)\n  }\n\n  /**\n   * @private\n   */\n  function ushortList(itemName, list, count) {\n    if (count === undefined) {\n      count = list.length\n    }\n    var fields = new Array(list.length + 1)\n    fields[0] = { name: itemName + 'Count', type: 'USHORT', value: count }\n    for (var i = 0; i < list.length; i++) {\n      fields[i + 1] = { name: itemName + i, type: 'USHORT', value: list[i] }\n    }\n    return fields\n  }\n\n  /**\n   * @private\n   */\n  function tableList(itemName, records, itemCallback) {\n    var count = records.length\n    var fields = new Array(count + 1)\n    fields[0] = { name: itemName + 'Count', type: 'USHORT', value: count }\n    for (var i = 0; i < count; i++) {\n      fields[i + 1] = { name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i) }\n    }\n    return fields\n  }\n\n  /**\n   * @private\n   */\n  function recordList(itemName, records, itemCallback) {\n    var count = records.length\n    var fields = []\n    fields[0] = { name: itemName + 'Count', type: 'USHORT', value: count }\n    for (var i = 0; i < count; i++) {\n      fields = fields.concat(itemCallback(records[i], i))\n    }\n    return fields\n  }\n\n  // Common Layout Tables\n\n  /**\n   * @exports opentype.Coverage\n   * @class\n   * @param {opentype.Table}\n   * @constructor\n   * @extends opentype.Table\n   */\n  function Coverage(coverageTable) {\n    if (coverageTable.format === 1) {\n      Table.call(\n        this,\n        'coverageTable',\n        [{ name: 'coverageFormat', type: 'USHORT', value: 1 }].concat(ushortList('glyph', coverageTable.glyphs)),\n      )\n    } else if (coverageTable.format === 2) {\n      Table.call(\n        this,\n        'coverageTable',\n        [{ name: 'coverageFormat', type: 'USHORT', value: 2 }].concat(\n          recordList('rangeRecord', coverageTable.ranges, function (RangeRecord) {\n            return [\n              { name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start },\n              { name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end },\n              { name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index },\n            ]\n          }),\n        ),\n      )\n    } else {\n      check.assert(false, 'Coverage format must be 1 or 2.')\n    }\n  }\n  Coverage.prototype = Object.create(Table.prototype)\n  Coverage.prototype.constructor = Coverage\n\n  function ScriptList(scriptListTable) {\n    Table.call(\n      this,\n      'scriptListTable',\n      recordList('scriptRecord', scriptListTable, function (scriptRecord, i) {\n        var script = scriptRecord.script\n        var defaultLangSys = script.defaultLangSys\n        check.assert(\n          !!defaultLangSys,\n          'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.',\n        )\n        return [\n          { name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag },\n          {\n            name: 'script' + i,\n            type: 'TABLE',\n            value: new Table(\n              'scriptTable',\n              [\n                {\n                  name: 'defaultLangSys',\n                  type: 'TABLE',\n                  value: new Table(\n                    'defaultLangSys',\n                    [\n                      { name: 'lookupOrder', type: 'USHORT', value: 0 },\n                      { name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex },\n                    ].concat(ushortList('featureIndex', defaultLangSys.featureIndexes)),\n                  ),\n                },\n              ].concat(\n                recordList('langSys', script.langSysRecords, function (langSysRecord, i) {\n                  var langSys = langSysRecord.langSys\n                  return [\n                    { name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag },\n                    {\n                      name: 'langSys' + i,\n                      type: 'TABLE',\n                      value: new Table(\n                        'langSys',\n                        [\n                          { name: 'lookupOrder', type: 'USHORT', value: 0 },\n                          { name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex },\n                        ].concat(ushortList('featureIndex', langSys.featureIndexes)),\n                      ),\n                    },\n                  ]\n                }),\n              ),\n            ),\n          },\n        ]\n      }),\n    )\n  }\n  ScriptList.prototype = Object.create(Table.prototype)\n  ScriptList.prototype.constructor = ScriptList\n\n  /**\n   * @exports opentype.FeatureList\n   * @class\n   * @param {opentype.Table}\n   * @constructor\n   * @extends opentype.Table\n   */\n  function FeatureList(featureListTable) {\n    Table.call(\n      this,\n      'featureListTable',\n      recordList('featureRecord', featureListTable, function (featureRecord, i) {\n        var feature = featureRecord.feature\n        return [\n          { name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag },\n          {\n            name: 'feature' + i,\n            type: 'TABLE',\n            value: new Table(\n              'featureTable',\n              [{ name: 'featureParams', type: 'USHORT', value: feature.featureParams }].concat(\n                ushortList('lookupListIndex', feature.lookupListIndexes),\n              ),\n            ),\n          },\n        ]\n      }),\n    )\n  }\n  FeatureList.prototype = Object.create(Table.prototype)\n  FeatureList.prototype.constructor = FeatureList\n\n  /**\n   * @exports opentype.LookupList\n   * @class\n   * @param {opentype.Table}\n   * @param {Object}\n   * @constructor\n   * @extends opentype.Table\n   */\n  function LookupList(lookupListTable, subtableMakers) {\n    Table.call(\n      this,\n      'lookupListTable',\n      tableList('lookup', lookupListTable, function (lookupTable) {\n        var subtableCallback = subtableMakers[lookupTable.lookupType]\n        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.')\n        return new Table(\n          'lookupTable',\n          [\n            { name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType },\n            { name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag },\n          ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)),\n        )\n      }),\n    )\n  }\n  LookupList.prototype = Object.create(Table.prototype)\n  LookupList.prototype.constructor = LookupList\n\n  // Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n  // Don't use offsets inside Records (probable bug), only in Tables.\n  var table = {\n    Table: Table,\n    Record: Table,\n    Coverage: Coverage,\n    ScriptList: ScriptList,\n    FeatureList: FeatureList,\n    LookupList: LookupList,\n    ushortList: ushortList,\n    tableList: tableList,\n    recordList: recordList,\n  }\n\n  // Parsing utility functions\n\n  // Retrieve an unsigned byte from the DataView.\n  function getByte(dataView, offset) {\n    return dataView.getUint8(offset)\n  }\n\n  // Retrieve an unsigned 16-bit short from the DataView.\n  // The value is stored in big endian.\n  function getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false)\n  }\n\n  // Retrieve a signed 16-bit short from the DataView.\n  // The value is stored in big endian.\n  function getShort(dataView, offset) {\n    return dataView.getInt16(offset, false)\n  }\n\n  // Retrieve an unsigned 32-bit long from the DataView.\n  // The value is stored in big endian.\n  function getULong(dataView, offset) {\n    return dataView.getUint32(offset, false)\n  }\n\n  // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n  // The value is stored in big endian.\n  function getFixed(dataView, offset) {\n    var decimal = dataView.getInt16(offset, false)\n    var fraction = dataView.getUint16(offset + 2, false)\n    return decimal + fraction / 65535\n  }\n\n  // Retrieve a 4-character tag from the DataView.\n  // Tags are used to identify tables.\n  function getTag(dataView, offset) {\n    var tag = ''\n    for (var i = offset; i < offset + 4; i += 1) {\n      tag += String.fromCharCode(dataView.getInt8(i))\n    }\n\n    return tag\n  }\n\n  // Retrieve an offset from the DataView.\n  // Offsets are 1 to 4 bytes in length, depending on the offSize argument.\n  function getOffset(dataView, offset, offSize) {\n    var v = 0\n    for (var i = 0; i < offSize; i += 1) {\n      v <<= 8\n      v += dataView.getUint8(offset + i)\n    }\n\n    return v\n  }\n\n  // Retrieve a number of bytes from start offset to the end offset from the DataView.\n  function getBytes(dataView, startOffset, endOffset) {\n    var bytes = []\n    for (var i = startOffset; i < endOffset; i += 1) {\n      bytes.push(dataView.getUint8(i))\n    }\n\n    return bytes\n  }\n\n  // Convert the list of bytes to a string.\n  function bytesToString(bytes) {\n    var s = ''\n    for (var i = 0; i < bytes.length; i += 1) {\n      s += String.fromCharCode(bytes[i])\n    }\n\n    return s\n  }\n\n  var typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4,\n  }\n\n  // A stateful parser that changes the offset whenever a value is retrieved.\n  // The data is a DataView.\n  function Parser(data, offset) {\n    this.data = data\n    this.offset = offset\n    this.relativeOffset = 0\n  }\n\n  Parser.prototype.parseByte = function () {\n    var v = this.data.getUint8(this.offset + this.relativeOffset)\n    this.relativeOffset += 1\n    return v\n  }\n\n  Parser.prototype.parseChar = function () {\n    var v = this.data.getInt8(this.offset + this.relativeOffset)\n    this.relativeOffset += 1\n    return v\n  }\n\n  Parser.prototype.parseCard8 = Parser.prototype.parseByte\n\n  Parser.prototype.parseUShort = function () {\n    var v = this.data.getUint16(this.offset + this.relativeOffset)\n    this.relativeOffset += 2\n    return v\n  }\n\n  Parser.prototype.parseCard16 = Parser.prototype.parseUShort\n  Parser.prototype.parseSID = Parser.prototype.parseUShort\n  Parser.prototype.parseOffset16 = Parser.prototype.parseUShort\n\n  Parser.prototype.parseShort = function () {\n    var v = this.data.getInt16(this.offset + this.relativeOffset)\n    this.relativeOffset += 2\n    return v\n  }\n\n  Parser.prototype.parseF2Dot14 = function () {\n    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384\n    this.relativeOffset += 2\n    return v\n  }\n\n  Parser.prototype.parseULong = function () {\n    var v = getULong(this.data, this.offset + this.relativeOffset)\n    this.relativeOffset += 4\n    return v\n  }\n\n  Parser.prototype.parseOffset32 = Parser.prototype.parseULong\n\n  Parser.prototype.parseFixed = function () {\n    var v = getFixed(this.data, this.offset + this.relativeOffset)\n    this.relativeOffset += 4\n    return v\n  }\n\n  Parser.prototype.parseString = function (length) {\n    var dataView = this.data\n    var offset = this.offset + this.relativeOffset\n    var string = ''\n    this.relativeOffset += length\n    for (var i = 0; i < length; i++) {\n      string += String.fromCharCode(dataView.getUint8(offset + i))\n    }\n\n    return string\n  }\n\n  Parser.prototype.parseTag = function () {\n    return this.parseString(4)\n  }\n\n  // LONGDATETIME is a 64-bit integer.\n  // JavaScript and unix timestamps traditionally use 32 bits, so we\n  // only take the last 32 bits.\n  // + Since until 2038 those bits will be filled by zeros we can ignore them.\n  Parser.prototype.parseLongDateTime = function () {\n    var v = getULong(this.data, this.offset + this.relativeOffset + 4)\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800\n    this.relativeOffset += 8\n    return v\n  }\n\n  Parser.prototype.parseVersion = function (minorBase) {\n    var major = getUShort(this.data, this.offset + this.relativeOffset)\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // Default returns the correct number if minor = 0xN000 where N is 0-9\n    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2)\n    this.relativeOffset += 4\n    if (minorBase === undefined) {\n      minorBase = 0x1000\n    }\n    return major + minor / minorBase / 10\n  }\n\n  Parser.prototype.skip = function (type, amount) {\n    if (amount === undefined) {\n      amount = 1\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount\n  }\n\n  ///// Parsing lists and records ///////////////////////////////\n\n  // Parse a list of 32 bit unsigned integers.\n  Parser.prototype.parseULongList = function (count) {\n    if (count === undefined) {\n      count = this.parseULong()\n    }\n    var offsets = new Array(count)\n    var dataView = this.data\n    var offset = this.offset + this.relativeOffset\n    for (var i = 0; i < count; i++) {\n      offsets[i] = dataView.getUint32(offset)\n      offset += 4\n    }\n\n    this.relativeOffset += count * 4\n    return offsets\n  }\n\n  // Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n  // or provided as an argument.\n  Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function (count) {\n    if (count === undefined) {\n      count = this.parseUShort()\n    }\n    var offsets = new Array(count)\n    var dataView = this.data\n    var offset = this.offset + this.relativeOffset\n    for (var i = 0; i < count; i++) {\n      offsets[i] = dataView.getUint16(offset)\n      offset += 2\n    }\n\n    this.relativeOffset += count * 2\n    return offsets\n  }\n\n  // Parses a list of 16 bit signed integers.\n  Parser.prototype.parseShortList = function (count) {\n    var list = new Array(count)\n    var dataView = this.data\n    var offset = this.offset + this.relativeOffset\n    for (var i = 0; i < count; i++) {\n      list[i] = dataView.getInt16(offset)\n      offset += 2\n    }\n\n    this.relativeOffset += count * 2\n    return list\n  }\n\n  // Parses a list of bytes.\n  Parser.prototype.parseByteList = function (count) {\n    var list = new Array(count)\n    var dataView = this.data\n    var offset = this.offset + this.relativeOffset\n    for (var i = 0; i < count; i++) {\n      list[i] = dataView.getUint8(offset++)\n    }\n\n    this.relativeOffset += count\n    return list\n  }\n\n  /**\n   * Parse a list of items.\n   * Record count is optional, if omitted it is read from the stream.\n   * itemCallback is one of the Parser methods.\n   */\n  Parser.prototype.parseList = function (count, itemCallback) {\n    if (!itemCallback) {\n      itemCallback = count\n      count = this.parseUShort()\n    }\n    var list = new Array(count)\n    for (var i = 0; i < count; i++) {\n      list[i] = itemCallback.call(this)\n    }\n    return list\n  }\n\n  Parser.prototype.parseList32 = function (count, itemCallback) {\n    if (!itemCallback) {\n      itemCallback = count\n      count = this.parseULong()\n    }\n    var list = new Array(count)\n    for (var i = 0; i < count; i++) {\n      list[i] = itemCallback.call(this)\n    }\n    return list\n  }\n\n  /**\n   * Parse a list of records.\n   * Record count is optional, if omitted it is read from the stream.\n   * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n   */\n  Parser.prototype.parseRecordList = function (count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n      recordDescription = count\n      count = this.parseUShort()\n    }\n    var records = new Array(count)\n    var fields = Object.keys(recordDescription)\n    for (var i = 0; i < count; i++) {\n      var rec = {}\n      for (var j = 0; j < fields.length; j++) {\n        var fieldName = fields[j]\n        var fieldType = recordDescription[fieldName]\n        rec[fieldName] = fieldType.call(this)\n      }\n      records[i] = rec\n    }\n    return records\n  }\n\n  Parser.prototype.parseRecordList32 = function (count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n      recordDescription = count\n      count = this.parseULong()\n    }\n    var records = new Array(count)\n    var fields = Object.keys(recordDescription)\n    for (var i = 0; i < count; i++) {\n      var rec = {}\n      for (var j = 0; j < fields.length; j++) {\n        var fieldName = fields[j]\n        var fieldType = recordDescription[fieldName]\n        rec[fieldName] = fieldType.call(this)\n      }\n      records[i] = rec\n    }\n    return records\n  }\n\n  // Parse a data structure into an object\n  // Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n  Parser.prototype.parseStruct = function (description) {\n    if (typeof description === 'function') {\n      return description.call(this)\n    } else {\n      var fields = Object.keys(description)\n      var struct = {}\n      for (var j = 0; j < fields.length; j++) {\n        var fieldName = fields[j]\n        var fieldType = description[fieldName]\n        struct[fieldName] = fieldType.call(this)\n      }\n      return struct\n    }\n  }\n\n  /**\n   * Parse a GPOS valueRecord\n   * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n   * valueFormat is optional, if omitted it is read from the stream.\n   */\n  Parser.prototype.parseValueRecord = function (valueFormat) {\n    if (valueFormat === undefined) {\n      valueFormat = this.parseUShort()\n    }\n    if (valueFormat === 0) {\n      // valueFormat2 in kerning pairs is most often 0\n      // in this case return undefined instead of an empty object, to save space\n      return\n    }\n    var valueRecord = {}\n\n    if (valueFormat & 0x0001) {\n      valueRecord.xPlacement = this.parseShort()\n    }\n    if (valueFormat & 0x0002) {\n      valueRecord.yPlacement = this.parseShort()\n    }\n    if (valueFormat & 0x0004) {\n      valueRecord.xAdvance = this.parseShort()\n    }\n    if (valueFormat & 0x0008) {\n      valueRecord.yAdvance = this.parseShort()\n    }\n\n    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n    if (valueFormat & 0x0010) {\n      valueRecord.xPlaDevice = undefined\n      this.parseShort()\n    }\n    if (valueFormat & 0x0020) {\n      valueRecord.yPlaDevice = undefined\n      this.parseShort()\n    }\n    if (valueFormat & 0x0040) {\n      valueRecord.xAdvDevice = undefined\n      this.parseShort()\n    }\n    if (valueFormat & 0x0080) {\n      valueRecord.yAdvDevice = undefined\n      this.parseShort()\n    }\n\n    return valueRecord\n  }\n\n  /**\n   * Parse a list of GPOS valueRecords\n   * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n   * valueFormat and valueCount are read from the stream.\n   */\n  Parser.prototype.parseValueRecordList = function () {\n    var valueFormat = this.parseUShort()\n    var valueCount = this.parseUShort()\n    var values = new Array(valueCount)\n    for (var i = 0; i < valueCount; i++) {\n      values[i] = this.parseValueRecord(valueFormat)\n    }\n    return values\n  }\n\n  Parser.prototype.parsePointer = function (description) {\n    var structOffset = this.parseOffset16()\n    if (structOffset > 0) {\n      // NULL offset => return undefined\n      return new Parser(this.data, this.offset + structOffset).parseStruct(description)\n    }\n    return undefined\n  }\n\n  Parser.prototype.parsePointer32 = function (description) {\n    var structOffset = this.parseOffset32()\n    if (structOffset > 0) {\n      // NULL offset => return undefined\n      return new Parser(this.data, this.offset + structOffset).parseStruct(description)\n    }\n    return undefined\n  }\n\n  /**\n   * Parse a list of offsets to lists of 16-bit integers,\n   * or a list of offsets to lists of offsets to any kind of items.\n   * If itemCallback is not provided, a list of list of UShort is assumed.\n   * If provided, itemCallback is called on each item and must parse the item.\n   * See examples in tables/gsub.js\n   */\n  Parser.prototype.parseListOfLists = function (itemCallback) {\n    var offsets = this.parseOffset16List()\n    var count = offsets.length\n    var relativeOffset = this.relativeOffset\n    var list = new Array(count)\n    for (var i = 0; i < count; i++) {\n      var start = offsets[i]\n      if (start === 0) {\n        // NULL offset\n        // Add i as owned property to list. Convenient with assert.\n        list[i] = undefined\n        continue\n      }\n      this.relativeOffset = start\n      if (itemCallback) {\n        var subOffsets = this.parseOffset16List()\n        var subList = new Array(subOffsets.length)\n        for (var j = 0; j < subOffsets.length; j++) {\n          this.relativeOffset = start + subOffsets[j]\n          subList[j] = itemCallback.call(this)\n        }\n        list[i] = subList\n      } else {\n        list[i] = this.parseUShortList()\n      }\n    }\n    this.relativeOffset = relativeOffset\n    return list\n  }\n\n  ///// Complex tables parsing //////////////////////////////////\n\n  // Parse a coverage table in a GSUB, GPOS or GDEF table.\n  // https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n  // parser.offset must point to the start of the table containing the coverage.\n  Parser.prototype.parseCoverage = function () {\n    var startOffset = this.offset + this.relativeOffset\n    var format = this.parseUShort()\n    var count = this.parseUShort()\n    if (format === 1) {\n      return {\n        format: 1,\n        glyphs: this.parseUShortList(count),\n      }\n    } else if (format === 2) {\n      var ranges = new Array(count)\n      for (var i = 0; i < count; i++) {\n        ranges[i] = {\n          start: this.parseUShort(),\n          end: this.parseUShort(),\n          index: this.parseUShort(),\n        }\n      }\n      return {\n        format: 2,\n        ranges: ranges,\n      }\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.')\n  }\n\n  // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n  // https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n  Parser.prototype.parseClassDef = function () {\n    var startOffset = this.offset + this.relativeOffset\n    var format = this.parseUShort()\n    if (format === 1) {\n      return {\n        format: 1,\n        startGlyph: this.parseUShort(),\n        classes: this.parseUShortList(),\n      }\n    } else if (format === 2) {\n      return {\n        format: 2,\n        ranges: this.parseRecordList({\n          start: Parser.uShort,\n          end: Parser.uShort,\n          classId: Parser.uShort,\n        }),\n      }\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.')\n  }\n\n  ///// Static methods ///////////////////////////////////\n  // These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\n  Parser.list = function (count, itemCallback) {\n    return function () {\n      return this.parseList(count, itemCallback)\n    }\n  }\n\n  Parser.list32 = function (count, itemCallback) {\n    return function () {\n      return this.parseList32(count, itemCallback)\n    }\n  }\n\n  Parser.recordList = function (count, recordDescription) {\n    return function () {\n      return this.parseRecordList(count, recordDescription)\n    }\n  }\n\n  Parser.recordList32 = function (count, recordDescription) {\n    return function () {\n      return this.parseRecordList32(count, recordDescription)\n    }\n  }\n\n  Parser.pointer = function (description) {\n    return function () {\n      return this.parsePointer(description)\n    }\n  }\n\n  Parser.pointer32 = function (description) {\n    return function () {\n      return this.parsePointer32(description)\n    }\n  }\n\n  Parser.tag = Parser.prototype.parseTag\n  Parser.byte = Parser.prototype.parseByte\n  Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort\n  Parser.uShortList = Parser.prototype.parseUShortList\n  Parser.uLong = Parser.offset32 = Parser.prototype.parseULong\n  Parser.uLongList = Parser.prototype.parseULongList\n  Parser.struct = Parser.prototype.parseStruct\n  Parser.coverage = Parser.prototype.parseCoverage\n  Parser.classDef = Parser.prototype.parseClassDef\n\n  ///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n  // https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\n  var langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList,\n  }\n\n  Parser.prototype.parseScriptList = function () {\n    return (\n      this.parsePointer(\n        Parser.recordList({\n          tag: Parser.tag,\n          script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n              tag: Parser.tag,\n              langSys: Parser.pointer(langSysTable),\n            }),\n          }),\n        }),\n      ) || []\n    )\n  }\n\n  Parser.prototype.parseFeatureList = function () {\n    return (\n      this.parsePointer(\n        Parser.recordList({\n          tag: Parser.tag,\n          feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList,\n          }),\n        }),\n      ) || []\n    )\n  }\n\n  Parser.prototype.parseLookupList = function (lookupTableParsers) {\n    return (\n      this.parsePointer(\n        Parser.list(\n          Parser.pointer(function () {\n            var lookupType = this.parseUShort()\n            check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.')\n            var lookupFlag = this.parseUShort()\n            var useMarkFilteringSet = lookupFlag & 0x10\n            return {\n              lookupType: lookupType,\n              lookupFlag: lookupFlag,\n              subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n              markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined,\n            }\n          }),\n        ),\n      ) || []\n    )\n  }\n\n  Parser.prototype.parseFeatureVariationsList = function () {\n    return (\n      this.parsePointer32(function () {\n        var majorVersion = this.parseUShort()\n        var minorVersion = this.parseUShort()\n        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.')\n        var featureVariations = this.parseRecordList32({\n          conditionSetOffset: Parser.offset32,\n          featureTableSubstitutionOffset: Parser.offset32,\n        })\n        return featureVariations\n      }) || []\n    )\n  }\n\n  var parse = {\n    getByte: getByte,\n    getCard8: getByte,\n    getUShort: getUShort,\n    getCard16: getUShort,\n    getShort: getShort,\n    getULong: getULong,\n    getFixed: getFixed,\n    getTag: getTag,\n    getOffset: getOffset,\n    getBytes: getBytes,\n    bytesToString: bytesToString,\n    Parser: Parser,\n  }\n\n  // The `cmap` table stores the mappings from characters to glyphs.\n\n  function parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort()\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong()\n    cmap.language = p.parseULong()\n\n    var groupCount\n    cmap.groupCount = groupCount = p.parseULong()\n    cmap.glyphIndexMap = {}\n\n    for (var i = 0; i < groupCount; i += 1) {\n      var startCharCode = p.parseULong()\n      var endCharCode = p.parseULong()\n      var startGlyphId = p.parseULong()\n\n      for (var c = startCharCode; c <= endCharCode; c += 1) {\n        cmap.glyphIndexMap[c] = startGlyphId\n        startGlyphId++\n      }\n    }\n  }\n\n  function parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort()\n    cmap.language = p.parseUShort()\n\n    // segCount is stored x 2.\n    var segCount\n    cmap.segCount = segCount = p.parseUShort() >> 1\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3)\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {}\n    var endCountParser = new parse.Parser(data, start + offset + 14)\n    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2)\n    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4)\n    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6)\n    var glyphIndexOffset = start + offset + 16 + segCount * 8\n    for (var i = 0; i < segCount - 1; i += 1) {\n      var glyphIndex = void 0\n      var endCount = endCountParser.parseUShort()\n      var startCount = startCountParser.parseUShort()\n      var idDelta = idDeltaParser.parseShort()\n      var idRangeOffset = idRangeOffsetParser.parseUShort()\n      for (var c = startCount; c <= endCount; c += 1) {\n        if (idRangeOffset !== 0) {\n          // The idRangeOffset is relative to the current position in the idRangeOffset array.\n          // Take the current offset in the idRangeOffset array.\n          glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2\n\n          // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n          glyphIndexOffset += idRangeOffset\n\n          // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n          glyphIndexOffset += (c - startCount) * 2\n          glyphIndex = parse.getUShort(data, glyphIndexOffset)\n          if (glyphIndex !== 0) {\n            glyphIndex = (glyphIndex + idDelta) & 0xffff\n          }\n        } else {\n          glyphIndex = (c + idDelta) & 0xffff\n        }\n\n        cmap.glyphIndexMap[c] = glyphIndex\n      }\n    }\n  }\n\n  // Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n  // There are many available formats, but we only support the Windows format 4 and 12.\n  // This function returns a `CmapEncoding` object or null if no supported format could be found.\n  function parseCmapTable(data, start) {\n    var cmap = {}\n    cmap.version = parse.getUShort(data, start)\n    check.argument(cmap.version === 0, 'cmap table version should be 0.')\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n    cmap.numTables = parse.getUShort(data, start + 2)\n    var offset = -1\n    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n      var platformId = parse.getUShort(data, start + 4 + i * 8)\n      var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2)\n      if (\n        (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n        (platformId === 0 &&\n          (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))\n      ) {\n        offset = parse.getULong(data, start + 4 + i * 8 + 4)\n        break\n      }\n    }\n\n    if (offset === -1) {\n      // There is no cmap table in the font that we support.\n      throw new Error('No valid cmap sub-tables found.')\n    }\n\n    var p = new parse.Parser(data, start + offset)\n    cmap.format = p.parseUShort()\n\n    if (cmap.format === 12) {\n      parseCmapTableFormat12(cmap, p)\n    } else if (cmap.format === 4) {\n      parseCmapTableFormat4(cmap, p, data, start, offset)\n    } else {\n      throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').')\n    }\n\n    return cmap\n  }\n\n  function addSegment(t, code, glyphIndex) {\n    t.segments.push({\n      end: code,\n      start: code,\n      delta: -(code - glyphIndex),\n      offset: 0,\n      glyphIndex: glyphIndex,\n    })\n  }\n\n  function addTerminatorSegment(t) {\n    t.segments.push({\n      end: 0xffff,\n      start: 0xffff,\n      delta: 1,\n      offset: 0,\n    })\n  }\n\n  // Make cmap table, format 4 by default, 12 if needed only\n  function makeCmapTable(glyphs) {\n    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n    var isPlan0Only = true\n    var i\n\n    // Check if we need to add cmap format 12 or if format 4 only is fine\n    for (i = glyphs.length - 1; i > 0; i -= 1) {\n      var g = glyphs.get(i)\n      if (g.unicode > 65535) {\n        console.log('Adding CMAP format 12 (needed!)')\n        isPlan0Only = false\n        break\n      }\n    }\n\n    var cmapTable = [\n      { name: 'version', type: 'USHORT', value: 0 },\n      { name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2 },\n\n      // CMAP 4 header\n      { name: 'platformID', type: 'USHORT', value: 3 },\n      { name: 'encodingID', type: 'USHORT', value: 1 },\n      { name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : 12 + 8 },\n    ]\n\n    if (!isPlan0Only) {\n      cmapTable = cmapTable.concat([\n        // CMAP 12 header\n        { name: 'cmap12PlatformID', type: 'USHORT', value: 3 }, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n        { name: 'cmap12EncodingID', type: 'USHORT', value: 10 },\n        { name: 'cmap12Offset', type: 'ULONG', value: 0 },\n      ])\n    }\n\n    cmapTable = cmapTable.concat([\n      // CMAP 4 Subtable\n      { name: 'format', type: 'USHORT', value: 4 },\n      { name: 'cmap4Length', type: 'USHORT', value: 0 },\n      { name: 'language', type: 'USHORT', value: 0 },\n      { name: 'segCountX2', type: 'USHORT', value: 0 },\n      { name: 'searchRange', type: 'USHORT', value: 0 },\n      { name: 'entrySelector', type: 'USHORT', value: 0 },\n      { name: 'rangeShift', type: 'USHORT', value: 0 },\n    ])\n\n    var t = new table.Table('cmap', cmapTable)\n\n    t.segments = []\n    for (i = 0; i < glyphs.length; i += 1) {\n      var glyph = glyphs.get(i)\n      for (var j = 0; j < glyph.unicodes.length; j += 1) {\n        addSegment(t, glyph.unicodes[j], i)\n      }\n\n      t.segments = t.segments.sort(function (a, b) {\n        return a.start - b.start\n      })\n    }\n\n    addTerminatorSegment(t)\n\n    var segCount = t.segments.length\n    var segCountToRemove = 0\n\n    // CMAP 4\n    // Set up parallel segment arrays.\n    var endCounts = []\n    var startCounts = []\n    var idDeltas = []\n    var idRangeOffsets = []\n    var glyphIds = []\n\n    // CMAP 12\n    var cmap12Groups = []\n\n    // Reminder this loop is not following the specification at 100%\n    // The specification -> find suites of characters and make a group\n    // Here we're doing one group for each letter\n    // Doing as the spec can save 8 times (or more) space\n    for (i = 0; i < segCount; i += 1) {\n      var segment = t.segments[i]\n\n      // CMAP 4\n      if (segment.end <= 65535 && segment.start <= 65535) {\n        endCounts = endCounts.concat({ name: 'end_' + i, type: 'USHORT', value: segment.end })\n        startCounts = startCounts.concat({ name: 'start_' + i, type: 'USHORT', value: segment.start })\n        idDeltas = idDeltas.concat({ name: 'idDelta_' + i, type: 'SHORT', value: segment.delta })\n        idRangeOffsets = idRangeOffsets.concat({ name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset })\n        if (segment.glyphId !== undefined) {\n          glyphIds = glyphIds.concat({ name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId })\n        }\n      } else {\n        // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n        segCountToRemove += 1\n      }\n\n      // CMAP 12\n      // Skip Terminator Segment\n      if (!isPlan0Only && segment.glyphIndex !== undefined) {\n        cmap12Groups = cmap12Groups.concat({ name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start })\n        cmap12Groups = cmap12Groups.concat({ name: 'cmap12End_' + i, type: 'ULONG', value: segment.end })\n        cmap12Groups = cmap12Groups.concat({ name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex })\n      }\n    }\n\n    // CMAP 4 Subtable\n    t.segCountX2 = (segCount - segCountToRemove) * 2\n    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2)\n    t.rangeShift = t.segCountX2 - t.searchRange\n\n    t.fields = t.fields.concat(endCounts)\n    t.fields.push({ name: 'reservedPad', type: 'USHORT', value: 0 })\n    t.fields = t.fields.concat(startCounts)\n    t.fields = t.fields.concat(idDeltas)\n    t.fields = t.fields.concat(idRangeOffsets)\n    t.fields = t.fields.concat(glyphIds)\n\n    t.cmap4Length =\n      14 + // Subtable header\n      endCounts.length * 2 +\n      2 + // reservedPad\n      startCounts.length * 2 +\n      idDeltas.length * 2 +\n      idRangeOffsets.length * 2 +\n      glyphIds.length * 2\n\n    if (!isPlan0Only) {\n      // CMAP 12 Subtable\n      var cmap12Length =\n        16 + // Subtable header\n        cmap12Groups.length * 4\n\n      t.cmap12Offset = 12 + 2 * 2 + 4 + t.cmap4Length\n      t.fields = t.fields.concat([\n        { name: 'cmap12Format', type: 'USHORT', value: 12 },\n        { name: 'cmap12Reserved', type: 'USHORT', value: 0 },\n        { name: 'cmap12Length', type: 'ULONG', value: cmap12Length },\n        { name: 'cmap12Language', type: 'ULONG', value: 0 },\n        { name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3 },\n      ])\n\n      t.fields = t.fields.concat(cmap12Groups)\n    }\n\n    return t\n  }\n\n  var cmap = { parse: parseCmapTable, make: makeCmapTable }\n\n  // Glyph encoding\n\n  var cffStandardStrings = [\n    '.notdef',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quoteright',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'quoteleft',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    'exclamdown',\n    'cent',\n    'sterling',\n    'fraction',\n    'yen',\n    'florin',\n    'section',\n    'currency',\n    'quotesingle',\n    'quotedblleft',\n    'guillemotleft',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    'endash',\n    'dagger',\n    'daggerdbl',\n    'periodcentered',\n    'paragraph',\n    'bullet',\n    'quotesinglbase',\n    'quotedblbase',\n    'quotedblright',\n    'guillemotright',\n    'ellipsis',\n    'perthousand',\n    'questiondown',\n    'grave',\n    'acute',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'dieresis',\n    'ring',\n    'cedilla',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'emdash',\n    'AE',\n    'ordfeminine',\n    'Lslash',\n    'Oslash',\n    'OE',\n    'ordmasculine',\n    'ae',\n    'dotlessi',\n    'lslash',\n    'oslash',\n    'oe',\n    'germandbls',\n    'onesuperior',\n    'logicalnot',\n    'mu',\n    'trademark',\n    'Eth',\n    'onehalf',\n    'plusminus',\n    'Thorn',\n    'onequarter',\n    'divide',\n    'brokenbar',\n    'degree',\n    'thorn',\n    'threequarters',\n    'twosuperior',\n    'registered',\n    'minus',\n    'eth',\n    'multiply',\n    'threesuperior',\n    'copyright',\n    'Aacute',\n    'Acircumflex',\n    'Adieresis',\n    'Agrave',\n    'Aring',\n    'Atilde',\n    'Ccedilla',\n    'Eacute',\n    'Ecircumflex',\n    'Edieresis',\n    'Egrave',\n    'Iacute',\n    'Icircumflex',\n    'Idieresis',\n    'Igrave',\n    'Ntilde',\n    'Oacute',\n    'Ocircumflex',\n    'Odieresis',\n    'Ograve',\n    'Otilde',\n    'Scaron',\n    'Uacute',\n    'Ucircumflex',\n    'Udieresis',\n    'Ugrave',\n    'Yacute',\n    'Ydieresis',\n    'Zcaron',\n    'aacute',\n    'acircumflex',\n    'adieresis',\n    'agrave',\n    'aring',\n    'atilde',\n    'ccedilla',\n    'eacute',\n    'ecircumflex',\n    'edieresis',\n    'egrave',\n    'iacute',\n    'icircumflex',\n    'idieresis',\n    'igrave',\n    'ntilde',\n    'oacute',\n    'ocircumflex',\n    'odieresis',\n    'ograve',\n    'otilde',\n    'scaron',\n    'uacute',\n    'ucircumflex',\n    'udieresis',\n    'ugrave',\n    'yacute',\n    'ydieresis',\n    'zcaron',\n    'exclamsmall',\n    'Hungarumlautsmall',\n    'dollaroldstyle',\n    'dollarsuperior',\n    'ampersandsmall',\n    'Acutesmall',\n    'parenleftsuperior',\n    'parenrightsuperior',\n    '266 ff',\n    'onedotenleader',\n    'zerooldstyle',\n    'oneoldstyle',\n    'twooldstyle',\n    'threeoldstyle',\n    'fouroldstyle',\n    'fiveoldstyle',\n    'sixoldstyle',\n    'sevenoldstyle',\n    'eightoldstyle',\n    'nineoldstyle',\n    'commasuperior',\n    'threequartersemdash',\n    'periodsuperior',\n    'questionsmall',\n    'asuperior',\n    'bsuperior',\n    'centsuperior',\n    'dsuperior',\n    'esuperior',\n    'isuperior',\n    'lsuperior',\n    'msuperior',\n    'nsuperior',\n    'osuperior',\n    'rsuperior',\n    'ssuperior',\n    'tsuperior',\n    'ff',\n    'ffi',\n    'ffl',\n    'parenleftinferior',\n    'parenrightinferior',\n    'Circumflexsmall',\n    'hyphensuperior',\n    'Gravesmall',\n    'Asmall',\n    'Bsmall',\n    'Csmall',\n    'Dsmall',\n    'Esmall',\n    'Fsmall',\n    'Gsmall',\n    'Hsmall',\n    'Ismall',\n    'Jsmall',\n    'Ksmall',\n    'Lsmall',\n    'Msmall',\n    'Nsmall',\n    'Osmall',\n    'Psmall',\n    'Qsmall',\n    'Rsmall',\n    'Ssmall',\n    'Tsmall',\n    'Usmall',\n    'Vsmall',\n    'Wsmall',\n    'Xsmall',\n    'Ysmall',\n    'Zsmall',\n    'colonmonetary',\n    'onefitted',\n    'rupiah',\n    'Tildesmall',\n    'exclamdownsmall',\n    'centoldstyle',\n    'Lslashsmall',\n    'Scaronsmall',\n    'Zcaronsmall',\n    'Dieresissmall',\n    'Brevesmall',\n    'Caronsmall',\n    'Dotaccentsmall',\n    'Macronsmall',\n    'figuredash',\n    'hypheninferior',\n    'Ogoneksmall',\n    'Ringsmall',\n    'Cedillasmall',\n    'questiondownsmall',\n    'oneeighth',\n    'threeeighths',\n    'fiveeighths',\n    'seveneighths',\n    'onethird',\n    'twothirds',\n    'zerosuperior',\n    'foursuperior',\n    'fivesuperior',\n    'sixsuperior',\n    'sevensuperior',\n    'eightsuperior',\n    'ninesuperior',\n    'zeroinferior',\n    'oneinferior',\n    'twoinferior',\n    'threeinferior',\n    'fourinferior',\n    'fiveinferior',\n    'sixinferior',\n    'seveninferior',\n    'eightinferior',\n    'nineinferior',\n    'centinferior',\n    'dollarinferior',\n    'periodinferior',\n    'commainferior',\n    'Agravesmall',\n    'Aacutesmall',\n    'Acircumflexsmall',\n    'Atildesmall',\n    'Adieresissmall',\n    'Aringsmall',\n    'AEsmall',\n    'Ccedillasmall',\n    'Egravesmall',\n    'Eacutesmall',\n    'Ecircumflexsmall',\n    'Edieresissmall',\n    'Igravesmall',\n    'Iacutesmall',\n    'Icircumflexsmall',\n    'Idieresissmall',\n    'Ethsmall',\n    'Ntildesmall',\n    'Ogravesmall',\n    'Oacutesmall',\n    'Ocircumflexsmall',\n    'Otildesmall',\n    'Odieresissmall',\n    'OEsmall',\n    'Oslashsmall',\n    'Ugravesmall',\n    'Uacutesmall',\n    'Ucircumflexsmall',\n    'Udieresissmall',\n    'Yacutesmall',\n    'Thornsmall',\n    'Ydieresissmall',\n    '001.000',\n    '001.001',\n    '001.002',\n    '001.003',\n    'Black',\n    'Bold',\n    'Book',\n    'Light',\n    'Medium',\n    'Regular',\n    'Roman',\n    'Semibold',\n  ]\n\n  var cffStandardEncoding = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quoteright',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'quoteleft',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'exclamdown',\n    'cent',\n    'sterling',\n    'fraction',\n    'yen',\n    'florin',\n    'section',\n    'currency',\n    'quotesingle',\n    'quotedblleft',\n    'guillemotleft',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    '',\n    'endash',\n    'dagger',\n    'daggerdbl',\n    'periodcentered',\n    '',\n    'paragraph',\n    'bullet',\n    'quotesinglbase',\n    'quotedblbase',\n    'quotedblright',\n    'guillemotright',\n    'ellipsis',\n    'perthousand',\n    '',\n    'questiondown',\n    '',\n    'grave',\n    'acute',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'dieresis',\n    '',\n    'ring',\n    'cedilla',\n    '',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'emdash',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'AE',\n    '',\n    'ordfeminine',\n    '',\n    '',\n    '',\n    '',\n    'Lslash',\n    'Oslash',\n    'OE',\n    'ordmasculine',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'ae',\n    '',\n    '',\n    '',\n    'dotlessi',\n    '',\n    '',\n    'lslash',\n    'oslash',\n    'oe',\n    'germandbls',\n  ]\n\n  var cffExpertEncoding = [\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'space',\n    'exclamsmall',\n    'Hungarumlautsmall',\n    '',\n    'dollaroldstyle',\n    'dollarsuperior',\n    'ampersandsmall',\n    'Acutesmall',\n    'parenleftsuperior',\n    'parenrightsuperior',\n    'twodotenleader',\n    'onedotenleader',\n    'comma',\n    'hyphen',\n    'period',\n    'fraction',\n    'zerooldstyle',\n    'oneoldstyle',\n    'twooldstyle',\n    'threeoldstyle',\n    'fouroldstyle',\n    'fiveoldstyle',\n    'sixoldstyle',\n    'sevenoldstyle',\n    'eightoldstyle',\n    'nineoldstyle',\n    'colon',\n    'semicolon',\n    'commasuperior',\n    'threequartersemdash',\n    'periodsuperior',\n    'questionsmall',\n    '',\n    'asuperior',\n    'bsuperior',\n    'centsuperior',\n    'dsuperior',\n    'esuperior',\n    '',\n    '',\n    'isuperior',\n    '',\n    '',\n    'lsuperior',\n    'msuperior',\n    'nsuperior',\n    'osuperior',\n    '',\n    '',\n    'rsuperior',\n    'ssuperior',\n    'tsuperior',\n    '',\n    'ff',\n    'fi',\n    'fl',\n    'ffi',\n    'ffl',\n    'parenleftinferior',\n    '',\n    'parenrightinferior',\n    'Circumflexsmall',\n    'hyphensuperior',\n    'Gravesmall',\n    'Asmall',\n    'Bsmall',\n    'Csmall',\n    'Dsmall',\n    'Esmall',\n    'Fsmall',\n    'Gsmall',\n    'Hsmall',\n    'Ismall',\n    'Jsmall',\n    'Ksmall',\n    'Lsmall',\n    'Msmall',\n    'Nsmall',\n    'Osmall',\n    'Psmall',\n    'Qsmall',\n    'Rsmall',\n    'Ssmall',\n    'Tsmall',\n    'Usmall',\n    'Vsmall',\n    'Wsmall',\n    'Xsmall',\n    'Ysmall',\n    'Zsmall',\n    'colonmonetary',\n    'onefitted',\n    'rupiah',\n    'Tildesmall',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    '',\n    'exclamdownsmall',\n    'centoldstyle',\n    'Lslashsmall',\n    '',\n    '',\n    'Scaronsmall',\n    'Zcaronsmall',\n    'Dieresissmall',\n    'Brevesmall',\n    'Caronsmall',\n    '',\n    'Dotaccentsmall',\n    '',\n    '',\n    'Macronsmall',\n    '',\n    '',\n    'figuredash',\n    'hypheninferior',\n    '',\n    '',\n    'Ogoneksmall',\n    'Ringsmall',\n    'Cedillasmall',\n    '',\n    '',\n    '',\n    'onequarter',\n    'onehalf',\n    'threequarters',\n    'questiondownsmall',\n    'oneeighth',\n    'threeeighths',\n    'fiveeighths',\n    'seveneighths',\n    'onethird',\n    'twothirds',\n    '',\n    '',\n    'zerosuperior',\n    'onesuperior',\n    'twosuperior',\n    'threesuperior',\n    'foursuperior',\n    'fivesuperior',\n    'sixsuperior',\n    'sevensuperior',\n    'eightsuperior',\n    'ninesuperior',\n    'zeroinferior',\n    'oneinferior',\n    'twoinferior',\n    'threeinferior',\n    'fourinferior',\n    'fiveinferior',\n    'sixinferior',\n    'seveninferior',\n    'eightinferior',\n    'nineinferior',\n    'centinferior',\n    'dollarinferior',\n    'periodinferior',\n    'commainferior',\n    'Agravesmall',\n    'Aacutesmall',\n    'Acircumflexsmall',\n    'Atildesmall',\n    'Adieresissmall',\n    'Aringsmall',\n    'AEsmall',\n    'Ccedillasmall',\n    'Egravesmall',\n    'Eacutesmall',\n    'Ecircumflexsmall',\n    'Edieresissmall',\n    'Igravesmall',\n    'Iacutesmall',\n    'Icircumflexsmall',\n    'Idieresissmall',\n    'Ethsmall',\n    'Ntildesmall',\n    'Ogravesmall',\n    'Oacutesmall',\n    'Ocircumflexsmall',\n    'Otildesmall',\n    'Odieresissmall',\n    'OEsmall',\n    'Oslashsmall',\n    'Ugravesmall',\n    'Uacutesmall',\n    'Ucircumflexsmall',\n    'Udieresissmall',\n    'Yacutesmall',\n    'Thornsmall',\n    'Ydieresissmall',\n  ]\n\n  var standardNames = [\n    '.notdef',\n    '.null',\n    'nonmarkingreturn',\n    'space',\n    'exclam',\n    'quotedbl',\n    'numbersign',\n    'dollar',\n    'percent',\n    'ampersand',\n    'quotesingle',\n    'parenleft',\n    'parenright',\n    'asterisk',\n    'plus',\n    'comma',\n    'hyphen',\n    'period',\n    'slash',\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n    'colon',\n    'semicolon',\n    'less',\n    'equal',\n    'greater',\n    'question',\n    'at',\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n    'bracketleft',\n    'backslash',\n    'bracketright',\n    'asciicircum',\n    'underscore',\n    'grave',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    'braceleft',\n    'bar',\n    'braceright',\n    'asciitilde',\n    'Adieresis',\n    'Aring',\n    'Ccedilla',\n    'Eacute',\n    'Ntilde',\n    'Odieresis',\n    'Udieresis',\n    'aacute',\n    'agrave',\n    'acircumflex',\n    'adieresis',\n    'atilde',\n    'aring',\n    'ccedilla',\n    'eacute',\n    'egrave',\n    'ecircumflex',\n    'edieresis',\n    'iacute',\n    'igrave',\n    'icircumflex',\n    'idieresis',\n    'ntilde',\n    'oacute',\n    'ograve',\n    'ocircumflex',\n    'odieresis',\n    'otilde',\n    'uacute',\n    'ugrave',\n    'ucircumflex',\n    'udieresis',\n    'dagger',\n    'degree',\n    'cent',\n    'sterling',\n    'section',\n    'bullet',\n    'paragraph',\n    'germandbls',\n    'registered',\n    'copyright',\n    'trademark',\n    'acute',\n    'dieresis',\n    'notequal',\n    'AE',\n    'Oslash',\n    'infinity',\n    'plusminus',\n    'lessequal',\n    'greaterequal',\n    'yen',\n    'mu',\n    'partialdiff',\n    'summation',\n    'product',\n    'pi',\n    'integral',\n    'ordfeminine',\n    'ordmasculine',\n    'Omega',\n    'ae',\n    'oslash',\n    'questiondown',\n    'exclamdown',\n    'logicalnot',\n    'radical',\n    'florin',\n    'approxequal',\n    'Delta',\n    'guillemotleft',\n    'guillemotright',\n    'ellipsis',\n    'nonbreakingspace',\n    'Agrave',\n    'Atilde',\n    'Otilde',\n    'OE',\n    'oe',\n    'endash',\n    'emdash',\n    'quotedblleft',\n    'quotedblright',\n    'quoteleft',\n    'quoteright',\n    'divide',\n    'lozenge',\n    'ydieresis',\n    'Ydieresis',\n    'fraction',\n    'currency',\n    'guilsinglleft',\n    'guilsinglright',\n    'fi',\n    'fl',\n    'daggerdbl',\n    'periodcentered',\n    'quotesinglbase',\n    'quotedblbase',\n    'perthousand',\n    'Acircumflex',\n    'Ecircumflex',\n    'Aacute',\n    'Edieresis',\n    'Egrave',\n    'Iacute',\n    'Icircumflex',\n    'Idieresis',\n    'Igrave',\n    'Oacute',\n    'Ocircumflex',\n    'apple',\n    'Ograve',\n    'Uacute',\n    'Ucircumflex',\n    'Ugrave',\n    'dotlessi',\n    'circumflex',\n    'tilde',\n    'macron',\n    'breve',\n    'dotaccent',\n    'ring',\n    'cedilla',\n    'hungarumlaut',\n    'ogonek',\n    'caron',\n    'Lslash',\n    'lslash',\n    'Scaron',\n    'scaron',\n    'Zcaron',\n    'zcaron',\n    'brokenbar',\n    'Eth',\n    'eth',\n    'Yacute',\n    'yacute',\n    'Thorn',\n    'thorn',\n    'minus',\n    'multiply',\n    'onesuperior',\n    'twosuperior',\n    'threesuperior',\n    'onehalf',\n    'onequarter',\n    'threequarters',\n    'franc',\n    'Gbreve',\n    'gbreve',\n    'Idotaccent',\n    'Scedilla',\n    'scedilla',\n    'Cacute',\n    'cacute',\n    'Ccaron',\n    'ccaron',\n    'dcroat',\n  ]\n\n  /**\n   * This is the encoding used for fonts created from scratch.\n   * It loops through all glyphs and finds the appropriate unicode value.\n   * Since it's linear time, other encodings will be faster.\n   * @exports opentype.DefaultEncoding\n   * @class\n   * @constructor\n   * @param {opentype.Font}\n   */\n  function DefaultEncoding(font) {\n    this.font = font\n  }\n\n  DefaultEncoding.prototype.charToGlyphIndex = function (c) {\n    var code = c.codePointAt(0)\n    var glyphs = this.font.glyphs\n    if (glyphs) {\n      for (var i = 0; i < glyphs.length; i += 1) {\n        var glyph = glyphs.get(i)\n        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n          if (glyph.unicodes[j] === code) {\n            return i\n          }\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * @exports opentype.CmapEncoding\n   * @class\n   * @constructor\n   * @param {Object} cmap - a object with the cmap encoded data\n   */\n  function CmapEncoding(cmap) {\n    this.cmap = cmap\n  }\n\n  /**\n   * @param  {string} c - the character\n   * @return {number} The glyph index.\n   */\n  CmapEncoding.prototype.charToGlyphIndex = function (c) {\n    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0\n  }\n\n  /**\n   * @exports opentype.CffEncoding\n   * @class\n   * @constructor\n   * @param {string} encoding - The encoding\n   * @param {Array} charset - The character set.\n   */\n  function CffEncoding(encoding, charset) {\n    this.encoding = encoding\n    this.charset = charset\n  }\n\n  /**\n   * @param  {string} s - The character\n   * @return {number} The index.\n   */\n  CffEncoding.prototype.charToGlyphIndex = function (s) {\n    var code = s.codePointAt(0)\n    var charName = this.encoding[code]\n    return this.charset.indexOf(charName)\n  }\n\n  /**\n   * @exports opentype.GlyphNames\n   * @class\n   * @constructor\n   * @param {Object} post\n   */\n  function GlyphNames(post) {\n    switch (post.version) {\n      case 1:\n        this.names = standardNames.slice()\n        break\n      case 2:\n        this.names = new Array(post.numberOfGlyphs)\n        for (var i = 0; i < post.numberOfGlyphs; i++) {\n          if (post.glyphNameIndex[i] < standardNames.length) {\n            this.names[i] = standardNames[post.glyphNameIndex[i]]\n          } else {\n            this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length]\n          }\n        }\n\n        break\n      case 2.5:\n        this.names = new Array(post.numberOfGlyphs)\n        for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n          this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]]\n        }\n\n        break\n      case 3:\n        this.names = []\n        break\n      default:\n        this.names = []\n        break\n    }\n  }\n\n  /**\n   * Gets the index of a glyph by name.\n   * @param  {string} name - The glyph name\n   * @return {number} The index\n   */\n  GlyphNames.prototype.nameToGlyphIndex = function (name) {\n    return this.names.indexOf(name)\n  }\n\n  /**\n   * @param  {number} gid\n   * @return {string}\n   */\n  GlyphNames.prototype.glyphIndexToName = function (gid) {\n    return this.names[gid]\n  }\n\n  function addGlyphNamesAll(font) {\n    var glyph\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap\n    var charCodes = Object.keys(glyphIndexMap)\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n      var c = charCodes[i]\n      var glyphIndex = glyphIndexMap[c]\n      glyph = font.glyphs.get(glyphIndex)\n      glyph.addUnicode(parseInt(c))\n    }\n\n    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n      glyph = font.glyphs.get(i$1)\n      if (font.cffEncoding) {\n        if (font.isCIDFont) {\n          glyph.name = 'gid' + i$1\n        } else {\n          glyph.name = font.cffEncoding.charset[i$1]\n        }\n      } else if (font.glyphNames.names) {\n        glyph.name = font.glyphNames.glyphIndexToName(i$1)\n      }\n    }\n  }\n\n  function addGlyphNamesToUnicodeMap(font) {\n    font._IndexToUnicodeMap = {}\n\n    var glyphIndexMap = font.tables.cmap.glyphIndexMap\n    var charCodes = Object.keys(glyphIndexMap)\n\n    for (var i = 0; i < charCodes.length; i += 1) {\n      var c = charCodes[i]\n      var glyphIndex = glyphIndexMap[c]\n      if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n        font._IndexToUnicodeMap[glyphIndex] = {\n          unicodes: [parseInt(c)],\n        }\n      } else {\n        font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c))\n      }\n    }\n  }\n\n  /**\n   * @alias opentype.addGlyphNames\n   * @param {opentype.Font}\n   * @param {Object}\n   */\n  function addGlyphNames(font, opt) {\n    if (opt.lowMemory) {\n      addGlyphNamesToUnicodeMap(font)\n    } else {\n      addGlyphNamesAll(font)\n    }\n  }\n\n  // Drawing utility functions.\n\n  // Draw a line on the given context from point `x1,y1` to point `x2,y2`.\n  function line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath()\n    ctx.moveTo(x1, y1)\n    ctx.lineTo(x2, y2)\n    ctx.stroke()\n  }\n\n  var draw = { line: line }\n\n  // The Glyph object\n  // import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\n  function getPathDefinition(glyph, path) {\n    var _path = path || new Path()\n    return {\n      configurable: true,\n\n      get: function () {\n        if (typeof _path === 'function') {\n          _path = _path()\n        }\n\n        return _path\n      },\n\n      set: function (p) {\n        _path = p\n      },\n    }\n  }\n  /**\n   * @typedef GlyphOptions\n   * @type Object\n   * @property {string} [name] - The glyph name\n   * @property {number} [unicode]\n   * @property {Array} [unicodes]\n   * @property {number} [xMin]\n   * @property {number} [yMin]\n   * @property {number} [xMax]\n   * @property {number} [yMax]\n   * @property {number} [advanceWidth]\n   */\n\n  // A Glyph is an individual mark that often corresponds to a character.\n  // Some glyphs, such as ligatures, are a combination of many characters.\n  // Glyphs are the basic building blocks of a font.\n  //\n  // The `Glyph` class contains utility methods for drawing the path and its points.\n  /**\n   * @exports opentype.Glyph\n   * @class\n   * @param {GlyphOptions}\n   * @constructor\n   */\n  function Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options)\n  }\n\n  /**\n   * @param  {GlyphOptions}\n   */\n  Glyph.prototype.bindConstructorValues = function (options) {\n    this.index = options.index || 0\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null\n    this.unicode = options.unicode || undefined\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : []\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if ('xMin' in options) {\n      this.xMin = options.xMin\n    }\n\n    if ('yMin' in options) {\n      this.yMin = options.yMin\n    }\n\n    if ('xMax' in options) {\n      this.xMax = options.xMax\n    }\n\n    if ('yMax' in options) {\n      this.yMax = options.yMax\n    }\n\n    if ('advanceWidth' in options) {\n      this.advanceWidth = options.advanceWidth\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path))\n  }\n\n  /**\n   * @param {number}\n   */\n  Glyph.prototype.addUnicode = function (unicode) {\n    if (this.unicodes.length === 0) {\n      this.unicode = unicode\n    }\n\n    this.unicodes.push(unicode)\n  }\n\n  /**\n   * Calculate the minimum bounding box for this glyph.\n   * @return {opentype.BoundingBox}\n   */\n  Glyph.prototype.getBoundingBox = function () {\n    return this.path.getBoundingBox()\n  }\n\n  /**\n   * Convert the glyph to a Path we can draw on a drawing context.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {Object=} options - xScale, yScale to stretch the glyph.\n   * @param  {opentype.Font} if hinting is to be used, the font\n   * @return {opentype.Path}\n   */\n  Glyph.prototype.getPath = function (x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0\n    y = y !== undefined ? y : 0\n    fontSize = fontSize !== undefined ? fontSize : 72\n    var commands\n    var hPoints\n    if (!options) {\n      options = {}\n    }\n    var xScale = options.xScale\n    var yScale = options.yScale\n\n    if (options.hinting && font && font.hinting) {\n      // in case of hinting, the hinting engine takes care\n      // of scaling the points (not the path) before hinting.\n      hPoints = this.path && font.hinting.exec(this, fontSize)\n      // in case the hinting engine failed hPoints is undefined\n      // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n      // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n      commands = font.hinting.getCommands(hPoints)\n      x = Math.round(x)\n      y = Math.round(y)\n      // TODO in case of hinting xyScaling is not yet supported\n      xScale = yScale = 1\n    } else {\n      commands = this.path.commands\n      var scale = (1 / (this.path.unitsPerEm || 1000)) * fontSize\n      if (xScale === undefined) {\n        xScale = scale\n      }\n      if (yScale === undefined) {\n        yScale = scale\n      }\n    }\n\n    var p = new Path()\n    for (var i = 0; i < commands.length; i += 1) {\n      var cmd = commands[i]\n      if (cmd.type === 'M') {\n        p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale)\n      } else if (cmd.type === 'L') {\n        p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale)\n      } else if (cmd.type === 'Q') {\n        p.quadraticCurveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale)\n      } else if (cmd.type === 'C') {\n        p.curveTo(\n          x + cmd.x1 * xScale,\n          y + -cmd.y1 * yScale,\n          x + cmd.x2 * xScale,\n          y + -cmd.y2 * yScale,\n          x + cmd.x * xScale,\n          y + -cmd.y * yScale,\n        )\n      } else if (cmd.type === 'Z') {\n        p.closePath()\n      }\n    }\n\n    return p\n  }\n\n  /**\n   * Split the glyph into contours.\n   * This function is here for backwards compatibility, and to\n   * provide raw access to the TrueType glyph outlines.\n   * @return {Array}\n   */\n  Glyph.prototype.getContours = function () {\n    if (this.points === undefined) {\n      return []\n    }\n\n    var contours = []\n    var currentContour = []\n    for (var i = 0; i < this.points.length; i += 1) {\n      var pt = this.points[i]\n      currentContour.push(pt)\n      if (pt.lastPointOfContour) {\n        contours.push(currentContour)\n        currentContour = []\n      }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.')\n    return contours\n  }\n\n  /**\n   * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n   * @return {Object}\n   */\n  Glyph.prototype.getMetrics = function () {\n    var commands = this.path.commands\n    var xCoords = []\n    var yCoords = []\n    for (var i = 0; i < commands.length; i += 1) {\n      var cmd = commands[i]\n      if (cmd.type !== 'Z') {\n        xCoords.push(cmd.x)\n        yCoords.push(cmd.y)\n      }\n\n      if (cmd.type === 'Q' || cmd.type === 'C') {\n        xCoords.push(cmd.x1)\n        yCoords.push(cmd.y1)\n      }\n\n      if (cmd.type === 'C') {\n        xCoords.push(cmd.x2)\n        yCoords.push(cmd.y2)\n      }\n    }\n\n    var metrics = {\n      xMin: Math.min.apply(null, xCoords),\n      yMin: Math.min.apply(null, yCoords),\n      xMax: Math.max.apply(null, xCoords),\n      yMax: Math.max.apply(null, yCoords),\n      leftSideBearing: this.leftSideBearing,\n    }\n\n    if (!isFinite(metrics.xMin)) {\n      metrics.xMin = 0\n    }\n\n    if (!isFinite(metrics.xMax)) {\n      metrics.xMax = this.advanceWidth\n    }\n\n    if (!isFinite(metrics.yMin)) {\n      metrics.yMin = 0\n    }\n\n    if (!isFinite(metrics.yMax)) {\n      metrics.yMax = 0\n    }\n\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin)\n    return metrics\n  }\n\n  /**\n   * Draw the glyph on the given context.\n   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {Object=} options - xScale, yScale to stretch the glyph.\n   */\n  Glyph.prototype.draw = function (ctx, x, y, fontSize, options) {\n    this.getPath(x, y, fontSize, options).draw(ctx)\n  }\n\n  /**\n   * Draw the points of the glyph.\n   * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   */\n  Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {\n    function drawCircles(l, x, y, scale) {\n      ctx.beginPath()\n      for (var j = 0; j < l.length; j += 1) {\n        ctx.moveTo(x + l[j].x * scale, y + l[j].y * scale)\n        ctx.arc(x + l[j].x * scale, y + l[j].y * scale, 2, 0, Math.PI * 2, false)\n      }\n\n      ctx.closePath()\n      ctx.fill()\n    }\n\n    x = x !== undefined ? x : 0\n    y = y !== undefined ? y : 0\n    fontSize = fontSize !== undefined ? fontSize : 24\n    var scale = (1 / this.path.unitsPerEm) * fontSize\n\n    var blueCircles = []\n    var redCircles = []\n    var path = this.path\n    for (var i = 0; i < path.commands.length; i += 1) {\n      var cmd = path.commands[i]\n      if (cmd.x !== undefined) {\n        blueCircles.push({ x: cmd.x, y: -cmd.y })\n      }\n\n      if (cmd.x1 !== undefined) {\n        redCircles.push({ x: cmd.x1, y: -cmd.y1 })\n      }\n\n      if (cmd.x2 !== undefined) {\n        redCircles.push({ x: cmd.x2, y: -cmd.y2 })\n      }\n    }\n\n    ctx.fillStyle = 'blue'\n    drawCircles(blueCircles, x, y, scale)\n    ctx.fillStyle = 'red'\n    drawCircles(redCircles, x, y, scale)\n  }\n\n  /**\n   * Draw lines indicating important font measurements.\n   * Black lines indicate the origin of the coordinate system (point 0,0).\n   * Blue lines indicate the glyph bounding box.\n   * Green line indicates the advance width of the glyph.\n   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   */\n  Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {\n    var scale\n    x = x !== undefined ? x : 0\n    y = y !== undefined ? y : 0\n    fontSize = fontSize !== undefined ? fontSize : 24\n    scale = (1 / this.path.unitsPerEm) * fontSize\n    ctx.lineWidth = 1\n\n    // Draw the origin\n    ctx.strokeStyle = 'black'\n    draw.line(ctx, x, -10000, x, 10000)\n    draw.line(ctx, -10000, y, 10000, y)\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    var xMin = this.xMin || 0\n    var yMin = this.yMin || 0\n    var xMax = this.xMax || 0\n    var yMax = this.yMax || 0\n    var advanceWidth = this.advanceWidth || 0\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue'\n    draw.line(ctx, x + xMin * scale, -10000, x + xMin * scale, 10000)\n    draw.line(ctx, x + xMax * scale, -10000, x + xMax * scale, 10000)\n    draw.line(ctx, -10000, y + -yMin * scale, 10000, y + -yMin * scale)\n    draw.line(ctx, -10000, y + -yMax * scale, 10000, y + -yMax * scale)\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green'\n    draw.line(ctx, x + advanceWidth * scale, -10000, x + advanceWidth * scale, 10000)\n  }\n\n  // The GlyphSet object\n\n  // Define a property on the glyph that depends on the path being loaded.\n  function defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n      get: function () {\n        // Request the path property to make sure the path is loaded.\n        glyph.path // jshint ignore:line\n        return glyph[internalName]\n      },\n      set: function (newValue) {\n        glyph[internalName] = newValue\n      },\n      enumerable: true,\n      configurable: true,\n    })\n  }\n\n  /**\n   * A GlyphSet represents all glyphs available in the font, but modelled using\n   * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n   * necessary, to keep the memory footprint down.\n   * @exports opentype.GlyphSet\n   * @class\n   * @param {opentype.Font}\n   * @param {Array}\n   */\n  function GlyphSet(font, glyphs) {\n    this.font = font\n    this.glyphs = {}\n    if (Array.isArray(glyphs)) {\n      for (var i = 0; i < glyphs.length; i++) {\n        var glyph = glyphs[i]\n        glyph.path.unitsPerEm = font.unitsPerEm\n        this.glyphs[i] = glyph\n      }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0\n  }\n\n  /**\n   * @param  {number} index\n   * @return {opentype.Glyph}\n   */\n  GlyphSet.prototype.get = function (index) {\n    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n    if (this.glyphs[index] === undefined) {\n      this.font._push(index)\n      if (typeof this.glyphs[index] === 'function') {\n        this.glyphs[index] = this.glyphs[index]()\n      }\n\n      var glyph = this.glyphs[index]\n      var unicodeObj = this.font._IndexToUnicodeMap[index]\n\n      if (unicodeObj) {\n        for (var j = 0; j < unicodeObj.unicodes.length; j++) {\n          glyph.addUnicode(unicodeObj.unicodes[j])\n        }\n      }\n\n      if (this.font.cffEncoding) {\n        if (this.font.isCIDFont) {\n          glyph.name = 'gid' + index\n        } else {\n          glyph.name = this.font.cffEncoding.charset[index]\n        }\n      } else if (this.font.glyphNames.names) {\n        glyph.name = this.font.glyphNames.glyphIndexToName(index)\n      }\n\n      this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth\n      this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing\n    } else {\n      if (typeof this.glyphs[index] === 'function') {\n        this.glyphs[index] = this.glyphs[index]()\n      }\n    }\n\n    return this.glyphs[index]\n  }\n\n  /**\n   * @param  {number} index\n   * @param  {Object}\n   */\n  GlyphSet.prototype.push = function (index, loader) {\n    this.glyphs[index] = loader\n    this.length++\n  }\n\n  /**\n   * @alias opentype.glyphLoader\n   * @param  {opentype.Font} font\n   * @param  {number} index\n   * @return {opentype.Glyph}\n   */\n  function glyphLoader(font, index) {\n    return new Glyph({ index: index, font: font })\n  }\n\n  /**\n   * Generate a stub glyph that can be filled with all metadata *except*\n   * the \"points\" and \"path\" properties, which must be loaded only once\n   * the glyph's path is actually requested for text shaping.\n   * @alias opentype.ttfGlyphLoader\n   * @param  {opentype.Font} font\n   * @param  {number} index\n   * @param  {Function} parseGlyph\n   * @param  {Object} data\n   * @param  {number} position\n   * @param  {Function} buildPath\n   * @return {opentype.Glyph}\n   */\n  function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function () {\n      var glyph = new Glyph({ index: index, font: font })\n\n      glyph.path = function () {\n        parseGlyph(glyph, data, position)\n        var path = buildPath(font.glyphs, glyph)\n        path.unitsPerEm = font.unitsPerEm\n        return path\n      }\n\n      defineDependentProperty(glyph, 'xMin', '_xMin')\n      defineDependentProperty(glyph, 'xMax', '_xMax')\n      defineDependentProperty(glyph, 'yMin', '_yMin')\n      defineDependentProperty(glyph, 'yMax', '_yMax')\n\n      return glyph\n    }\n  }\n  /**\n   * @alias opentype.cffGlyphLoader\n   * @param  {opentype.Font} font\n   * @param  {number} index\n   * @param  {Function} parseCFFCharstring\n   * @param  {string} charstring\n   * @return {opentype.Glyph}\n   */\n  function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function () {\n      var glyph = new Glyph({ index: index, font: font })\n\n      glyph.path = function () {\n        var path = parseCFFCharstring(font, glyph, charstring)\n        path.unitsPerEm = font.unitsPerEm\n        return path\n      }\n\n      return glyph\n    }\n  }\n\n  var glyphset = {\n    GlyphSet: GlyphSet,\n    glyphLoader: glyphLoader,\n    ttfGlyphLoader: ttfGlyphLoader,\n    cffGlyphLoader: cffGlyphLoader,\n  }\n\n  // The `CFF` table contains the glyph outlines in PostScript format.\n\n  // Custom equals function that can also check lists.\n  function equals(a, b) {\n    if (a === b) {\n      return true\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) {\n        return false\n      }\n\n      for (var i = 0; i < a.length; i += 1) {\n        if (!equals(a[i], b[i])) {\n          return false\n        }\n      }\n\n      return true\n    } else {\n      return false\n    }\n  }\n\n  // Subroutines are encoded using the negative half of the number space.\n  // See type 2 chapter 4.7 \"Subroutine operators\".\n  function calcCFFSubroutineBias(subrs) {\n    var bias\n    if (subrs.length < 1240) {\n      bias = 107\n    } else if (subrs.length < 33900) {\n      bias = 1131\n    } else {\n      bias = 32768\n    }\n\n    return bias\n  }\n\n  // Parse a `CFF` INDEX array.\n  // An index array consists of a list of offsets, then a list of objects at those offsets.\n  function parseCFFIndex(data, start, conversionFn) {\n    var offsets = []\n    var objects = []\n    var count = parse.getCard16(data, start)\n    var objectOffset\n    var endOffset\n    if (count !== 0) {\n      var offsetSize = parse.getByte(data, start + 2)\n      objectOffset = start + (count + 1) * offsetSize + 2\n      var pos = start + 3\n      for (var i = 0; i < count + 1; i += 1) {\n        offsets.push(parse.getOffset(data, pos, offsetSize))\n        pos += offsetSize\n      }\n\n      // The total size of the index array is 4 header bytes + the value of the last offset.\n      endOffset = objectOffset + offsets[count]\n    } else {\n      endOffset = start + 2\n    }\n\n    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n      var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1])\n      if (conversionFn) {\n        value = conversionFn(value)\n      }\n\n      objects.push(value)\n    }\n\n    return { objects: objects, startOffset: start, endOffset: endOffset }\n  }\n\n  function parseCFFIndexLowMemory(data, start) {\n    var offsets = []\n    var count = parse.getCard16(data, start)\n    var objectOffset\n    var endOffset\n    if (count !== 0) {\n      var offsetSize = parse.getByte(data, start + 2)\n      objectOffset = start + (count + 1) * offsetSize + 2\n      var pos = start + 3\n      for (var i = 0; i < count + 1; i += 1) {\n        offsets.push(parse.getOffset(data, pos, offsetSize))\n        pos += offsetSize\n      }\n\n      // The total size of the index array is 4 header bytes + the value of the last offset.\n      endOffset = objectOffset + offsets[count]\n    } else {\n      endOffset = start + 2\n    }\n\n    return { offsets: offsets, startOffset: start, endOffset: endOffset }\n  }\n  function getCffIndexObject(i, offsets, data, start, conversionFn) {\n    var count = parse.getCard16(data, start)\n    var objectOffset = 0\n    if (count !== 0) {\n      var offsetSize = parse.getByte(data, start + 2)\n      objectOffset = start + (count + 1) * offsetSize + 2\n    }\n\n    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1])\n    if (conversionFn) {\n      value = conversionFn(value)\n    }\n    return value\n  }\n\n  // Parse a `CFF` DICT real value.\n  function parseFloatOperand(parser) {\n    var s = ''\n    var eof = 15\n    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-']\n    while (true) {\n      var b = parser.parseByte()\n      var n1 = b >> 4\n      var n2 = b & 15\n\n      if (n1 === eof) {\n        break\n      }\n\n      s += lookup[n1]\n\n      if (n2 === eof) {\n        break\n      }\n\n      s += lookup[n2]\n    }\n\n    return parseFloat(s)\n  }\n\n  // Parse a `CFF` DICT operand.\n  function parseOperand(parser, b0) {\n    var b1\n    var b2\n    var b3\n    var b4\n    if (b0 === 28) {\n      b1 = parser.parseByte()\n      b2 = parser.parseByte()\n      return (b1 << 8) | b2\n    }\n\n    if (b0 === 29) {\n      b1 = parser.parseByte()\n      b2 = parser.parseByte()\n      b3 = parser.parseByte()\n      b4 = parser.parseByte()\n      return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4\n    }\n\n    if (b0 === 30) {\n      return parseFloatOperand(parser)\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n      return b0 - 139\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n      b1 = parser.parseByte()\n      return (b0 - 247) * 256 + b1 + 108\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n      b1 = parser.parseByte()\n      return -(b0 - 251) * 256 - b1 - 108\n    }\n\n    throw new Error('Invalid b0 ' + b0)\n  }\n\n  // Convert the entries returned by `parseDict` to a proper dictionary.\n  // If a value is a list of one, it is unpacked.\n  function entriesToObject(entries) {\n    var o = {}\n    for (var i = 0; i < entries.length; i += 1) {\n      var key = entries[i][0]\n      var values = entries[i][1]\n      var value = void 0\n      if (values.length === 1) {\n        value = values[0]\n      } else {\n        value = values\n      }\n\n      if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n        throw new Error('Object ' + o + ' already has key ' + key)\n      }\n\n      o[key] = value\n    }\n\n    return o\n  }\n\n  // Parse a `CFF` DICT object.\n  // A dictionary contains key-value pairs in a compact tokenized format.\n  function parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0\n    var parser = new parse.Parser(data, start)\n    var entries = []\n    var operands = []\n    size = size !== undefined ? size : data.length\n\n    while (parser.relativeOffset < size) {\n      var op = parser.parseByte()\n\n      // The first byte for each dict item distinguishes between operator (key) and operand (value).\n      // Values <= 21 are operators.\n      if (op <= 21) {\n        // Two-byte operators have an initial escape byte of 12.\n        if (op === 12) {\n          op = 1200 + parser.parseByte()\n        }\n\n        entries.push([op, operands])\n        operands = []\n      } else {\n        // Since the operands (values) come before the operators (keys), we store all operands in a list\n        // until we encounter an operator.\n        operands.push(parseOperand(parser, op))\n      }\n    }\n\n    return entriesToObject(entries)\n  }\n\n  // Given a String Index (SID), return the value of the string.\n  // Strings below index 392 are standard CFF strings and are not encoded in the font.\n  function getCFFString(strings, index) {\n    if (index <= 390) {\n      index = cffStandardStrings[index]\n    } else {\n      index = strings[index - 391]\n    }\n\n    return index\n  }\n\n  // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n  // This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\n  function interpretDict(dict, meta, strings) {\n    var newDict = {}\n    var value\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (var i = 0; i < meta.length; i += 1) {\n      var m = meta[i]\n\n      if (Array.isArray(m.type)) {\n        var values = []\n        values.length = m.type.length\n        for (var j = 0; j < m.type.length; j++) {\n          value = dict[m.op] !== undefined ? dict[m.op][j] : undefined\n          if (value === undefined) {\n            value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null\n          }\n          if (m.type[j] === 'SID') {\n            value = getCFFString(strings, value)\n          }\n          values[j] = value\n        }\n        newDict[m.name] = values\n      } else {\n        value = dict[m.op]\n        if (value === undefined) {\n          value = m.value !== undefined ? m.value : null\n        }\n\n        if (m.type === 'SID') {\n          value = getCFFString(strings, value)\n        }\n        newDict[m.name] = value\n      }\n    }\n\n    return newDict\n  }\n\n  // Parse the CFF header.\n  function parseCFFHeader(data, start) {\n    var header = {}\n    header.formatMajor = parse.getCard8(data, start)\n    header.formatMinor = parse.getCard8(data, start + 1)\n    header.size = parse.getCard8(data, start + 2)\n    header.offsetSize = parse.getCard8(data, start + 3)\n    header.startOffset = start\n    header.endOffset = start + 4\n    return header\n  }\n\n  var TOP_DICT_META = [\n    { name: 'version', op: 0, type: 'SID' },\n    { name: 'notice', op: 1, type: 'SID' },\n    { name: 'copyright', op: 1200, type: 'SID' },\n    { name: 'fullName', op: 2, type: 'SID' },\n    { name: 'familyName', op: 3, type: 'SID' },\n    { name: 'weight', op: 4, type: 'SID' },\n    { name: 'isFixedPitch', op: 1201, type: 'number', value: 0 },\n    { name: 'italicAngle', op: 1202, type: 'number', value: 0 },\n    { name: 'underlinePosition', op: 1203, type: 'number', value: -100 },\n    { name: 'underlineThickness', op: 1204, type: 'number', value: 50 },\n    { name: 'paintType', op: 1205, type: 'number', value: 0 },\n    { name: 'charstringType', op: 1206, type: 'number', value: 2 },\n    {\n      name: 'fontMatrix',\n      op: 1207,\n      type: ['real', 'real', 'real', 'real', 'real', 'real'],\n      value: [0.001, 0, 0, 0.001, 0, 0],\n    },\n    { name: 'uniqueId', op: 13, type: 'number' },\n    { name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0] },\n    { name: 'strokeWidth', op: 1208, type: 'number', value: 0 },\n    { name: 'xuid', op: 14, type: [], value: null },\n    { name: 'charset', op: 15, type: 'offset', value: 0 },\n    { name: 'encoding', op: 16, type: 'offset', value: 0 },\n    { name: 'charStrings', op: 17, type: 'offset', value: 0 },\n    { name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0] },\n    { name: 'ros', op: 1230, type: ['SID', 'SID', 'number'] },\n    { name: 'cidFontVersion', op: 1231, type: 'number', value: 0 },\n    { name: 'cidFontRevision', op: 1232, type: 'number', value: 0 },\n    { name: 'cidFontType', op: 1233, type: 'number', value: 0 },\n    { name: 'cidCount', op: 1234, type: 'number', value: 8720 },\n    { name: 'uidBase', op: 1235, type: 'number' },\n    { name: 'fdArray', op: 1236, type: 'offset' },\n    { name: 'fdSelect', op: 1237, type: 'offset' },\n    { name: 'fontName', op: 1238, type: 'SID' },\n  ]\n\n  var PRIVATE_DICT_META = [\n    { name: 'subrs', op: 19, type: 'offset', value: 0 },\n    { name: 'defaultWidthX', op: 20, type: 'number', value: 0 },\n    { name: 'nominalWidthX', op: 21, type: 'number', value: 0 },\n  ]\n\n  // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n  // The top dictionary contains the essential metadata for the font, together with the private dictionary.\n  function parseCFFTopDict(data, strings) {\n    var dict = parseCFFDict(data, 0, data.byteLength)\n    return interpretDict(dict, TOP_DICT_META, strings)\n  }\n\n  // Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\n  function parseCFFPrivateDict(data, start, size, strings) {\n    var dict = parseCFFDict(data, start, size)\n    return interpretDict(dict, PRIVATE_DICT_META, strings)\n  }\n\n  // Returns a list of \"Top DICT\"s found using an INDEX list.\n  // Used to read both the usual high-level Top DICTs and also the FDArray\n  // discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n  // a Private DICT that is read and saved into the Top DICT.\n  //\n  // In addition to the expected/optional values as outlined in TOP_DICT_META\n  // the following values might be saved into the Top DICT.\n  //\n  //    _subrs []        array of local CFF subroutines from Private DICT\n  //    _subrsBias       bias value computed from number of subroutines\n  //                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n  //    _defaultWidthX   default widths for CFF characters\n  //    _nominalWidthX   bias added to width embedded within glyph description\n  //\n  //    _privateDict     saved copy of parsed Private DICT from Top DICT\n  function gatherCFFTopDicts(data, start, cffIndex, strings) {\n    var topDictArray = []\n    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n      var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer)\n      var topDict = parseCFFTopDict(topDictData, strings)\n      topDict._subrs = []\n      topDict._subrsBias = 0\n      topDict._defaultWidthX = 0\n      topDict._nominalWidthX = 0\n      var privateSize = topDict.private[0]\n      var privateOffset = topDict.private[1]\n      if (privateSize !== 0 && privateOffset !== 0) {\n        var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings)\n        topDict._defaultWidthX = privateDict.defaultWidthX\n        topDict._nominalWidthX = privateDict.nominalWidthX\n        if (privateDict.subrs !== 0) {\n          var subrOffset = privateOffset + privateDict.subrs\n          var subrIndex = parseCFFIndex(data, subrOffset + start)\n          topDict._subrs = subrIndex.objects\n          topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs)\n        }\n        topDict._privateDict = privateDict\n      }\n      topDictArray.push(topDict)\n    }\n    return topDictArray\n  }\n\n  // Parse the CFF charset table, which contains internal names for all the glyphs.\n  // This function will return a list of glyph names.\n  // See Adobe TN #5176 chapter 13, \"Charsets\".\n  function parseCFFCharset(data, start, nGlyphs, strings) {\n    var sid\n    var count\n    var parser = new parse.Parser(data, start)\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1\n    var charset = ['.notdef']\n\n    var format = parser.parseCard8()\n    if (format === 0) {\n      for (var i = 0; i < nGlyphs; i += 1) {\n        sid = parser.parseSID()\n        charset.push(getCFFString(strings, sid))\n      }\n    } else if (format === 1) {\n      while (charset.length <= nGlyphs) {\n        sid = parser.parseSID()\n        count = parser.parseCard8()\n        for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n          charset.push(getCFFString(strings, sid))\n          sid += 1\n        }\n      }\n    } else if (format === 2) {\n      while (charset.length <= nGlyphs) {\n        sid = parser.parseSID()\n        count = parser.parseCard16()\n        for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n          charset.push(getCFFString(strings, sid))\n          sid += 1\n        }\n      }\n    } else {\n      throw new Error('Unknown charset format ' + format)\n    }\n\n    return charset\n  }\n\n  // Parse the CFF encoding data. Only one encoding can be specified per font.\n  // See Adobe TN #5176 chapter 12, \"Encodings\".\n  function parseCFFEncoding(data, start, charset) {\n    var code\n    var enc = {}\n    var parser = new parse.Parser(data, start)\n    var format = parser.parseCard8()\n    if (format === 0) {\n      var nCodes = parser.parseCard8()\n      for (var i = 0; i < nCodes; i += 1) {\n        code = parser.parseCard8()\n        enc[code] = i\n      }\n    } else if (format === 1) {\n      var nRanges = parser.parseCard8()\n      code = 1\n      for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n        var first = parser.parseCard8()\n        var nLeft = parser.parseCard8()\n        for (var j = first; j <= first + nLeft; j += 1) {\n          enc[j] = code\n          code += 1\n        }\n      }\n    } else {\n      throw new Error('Unknown encoding format ' + format)\n    }\n\n    return new CffEncoding(enc, charset)\n  }\n\n  // Take in charstring code and return a Glyph object.\n  // The encoding is described in the Type 2 Charstring Format\n  // https://www.microsoft.com/typography/OTSPEC/charstr2.htm\n  function parseCFFCharstring(font, glyph, code) {\n    var c1x\n    var c1y\n    var c2x\n    var c2y\n    var p = new Path()\n    var stack = []\n    var nStems = 0\n    var haveWidth = false\n    var open = false\n    var x = 0\n    var y = 0\n    var subrs\n    var subrsBias\n    var defaultWidthX\n    var nominalWidthX\n    if (font.isCIDFont) {\n      var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index]\n      var fdDict = font.tables.cff.topDict._fdArray[fdIndex]\n      subrs = fdDict._subrs\n      subrsBias = fdDict._subrsBias\n      defaultWidthX = fdDict._defaultWidthX\n      nominalWidthX = fdDict._nominalWidthX\n    } else {\n      subrs = font.tables.cff.topDict._subrs\n      subrsBias = font.tables.cff.topDict._subrsBias\n      defaultWidthX = font.tables.cff.topDict._defaultWidthX\n      nominalWidthX = font.tables.cff.topDict._nominalWidthX\n    }\n    var width = defaultWidthX\n\n    function newContour(x, y) {\n      if (open) {\n        p.closePath()\n      }\n\n      p.moveTo(x, y)\n      open = true\n    }\n\n    function parseStems() {\n      var hasWidthArg\n\n      // The number of stem operators on the stack is always even.\n      // If the value is uneven, that means a width is specified.\n      hasWidthArg = stack.length % 2 !== 0\n      if (hasWidthArg && !haveWidth) {\n        width = stack.shift() + nominalWidthX\n      }\n\n      nStems += stack.length >> 1\n      stack.length = 0\n      haveWidth = true\n    }\n\n    function parse(code) {\n      var b1\n      var b2\n      var b3\n      var b4\n      var codeIndex\n      var subrCode\n      var jpx\n      var jpy\n      var c3x\n      var c3y\n      var c4x\n      var c4y\n\n      var i = 0\n      while (i < code.length) {\n        var v = code[i]\n        i += 1\n        switch (v) {\n          case 1: // hstem\n            parseStems()\n            break\n          case 3: // vstem\n            parseStems()\n            break\n          case 4: // vmoveto\n            if (stack.length > 1 && !haveWidth) {\n              width = stack.shift() + nominalWidthX\n              haveWidth = true\n            }\n\n            y += stack.pop()\n            newContour(x, y)\n            break\n          case 5: // rlineto\n            while (stack.length > 0) {\n              x += stack.shift()\n              y += stack.shift()\n              p.lineTo(x, y)\n            }\n\n            break\n          case 6: // hlineto\n            while (stack.length > 0) {\n              x += stack.shift()\n              p.lineTo(x, y)\n              if (stack.length === 0) {\n                break\n              }\n\n              y += stack.shift()\n              p.lineTo(x, y)\n            }\n\n            break\n          case 7: // vlineto\n            while (stack.length > 0) {\n              y += stack.shift()\n              p.lineTo(x, y)\n              if (stack.length === 0) {\n                break\n              }\n\n              x += stack.shift()\n              p.lineTo(x, y)\n            }\n\n            break\n          case 8: // rrcurveto\n            while (stack.length > 0) {\n              c1x = x + stack.shift()\n              c1y = y + stack.shift()\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              x = c2x + stack.shift()\n              y = c2y + stack.shift()\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            }\n\n            break\n          case 10: // callsubr\n            codeIndex = stack.pop() + subrsBias\n            subrCode = subrs[codeIndex]\n            if (subrCode) {\n              parse(subrCode)\n            }\n\n            break\n          case 11: // return\n            return\n          case 12: // flex operators\n            v = code[i]\n            i += 1\n            switch (v) {\n              case 35: // flex\n                // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                c1x = x + stack.shift() // dx1\n                c1y = y + stack.shift() // dy1\n                c2x = c1x + stack.shift() // dx2\n                c2y = c1y + stack.shift() // dy2\n                jpx = c2x + stack.shift() // dx3\n                jpy = c2y + stack.shift() // dy3\n                c3x = jpx + stack.shift() // dx4\n                c3y = jpy + stack.shift() // dy4\n                c4x = c3x + stack.shift() // dx5\n                c4y = c3y + stack.shift() // dy5\n                x = c4x + stack.shift() // dx6\n                y = c4y + stack.shift() // dy6\n                stack.shift() // flex depth\n                p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy)\n                p.curveTo(c3x, c3y, c4x, c4y, x, y)\n                break\n              case 34: // hflex\n                // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                c1x = x + stack.shift() // dx1\n                c1y = y // dy1\n                c2x = c1x + stack.shift() // dx2\n                c2y = c1y + stack.shift() // dy2\n                jpx = c2x + stack.shift() // dx3\n                jpy = c2y // dy3\n                c3x = jpx + stack.shift() // dx4\n                c3y = c2y // dy4\n                c4x = c3x + stack.shift() // dx5\n                c4y = y // dy5\n                x = c4x + stack.shift() // dx6\n                p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy)\n                p.curveTo(c3x, c3y, c4x, c4y, x, y)\n                break\n              case 36: // hflex1\n                // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                c1x = x + stack.shift() // dx1\n                c1y = y + stack.shift() // dy1\n                c2x = c1x + stack.shift() // dx2\n                c2y = c1y + stack.shift() // dy2\n                jpx = c2x + stack.shift() // dx3\n                jpy = c2y // dy3\n                c3x = jpx + stack.shift() // dx4\n                c3y = c2y // dy4\n                c4x = c3x + stack.shift() // dx5\n                c4y = c3y + stack.shift() // dy5\n                x = c4x + stack.shift() // dx6\n                p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy)\n                p.curveTo(c3x, c3y, c4x, c4y, x, y)\n                break\n              case 37: // flex1\n                // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                c1x = x + stack.shift() // dx1\n                c1y = y + stack.shift() // dy1\n                c2x = c1x + stack.shift() // dx2\n                c2y = c1y + stack.shift() // dy2\n                jpx = c2x + stack.shift() // dx3\n                jpy = c2y + stack.shift() // dy3\n                c3x = jpx + stack.shift() // dx4\n                c3y = jpy + stack.shift() // dy4\n                c4x = c3x + stack.shift() // dx5\n                c4y = c3y + stack.shift() // dy5\n                if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                  x = c4x + stack.shift()\n                } else {\n                  y = c4y + stack.shift()\n                }\n\n                p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy)\n                p.curveTo(c3x, c3y, c4x, c4y, x, y)\n                break\n              default:\n                console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v)\n                stack.length = 0\n            }\n            break\n          case 14: // endchar\n            if (stack.length > 0 && !haveWidth) {\n              width = stack.shift() + nominalWidthX\n              haveWidth = true\n            }\n\n            if (open) {\n              p.closePath()\n              open = false\n            }\n\n            break\n          case 18: // hstemhm\n            parseStems()\n            break\n          case 19: // hintmask\n          case 20: // cntrmask\n            parseStems()\n            i += (nStems + 7) >> 3\n            break\n          case 21: // rmoveto\n            if (stack.length > 2 && !haveWidth) {\n              width = stack.shift() + nominalWidthX\n              haveWidth = true\n            }\n\n            y += stack.pop()\n            x += stack.pop()\n            newContour(x, y)\n            break\n          case 22: // hmoveto\n            if (stack.length > 1 && !haveWidth) {\n              width = stack.shift() + nominalWidthX\n              haveWidth = true\n            }\n\n            x += stack.pop()\n            newContour(x, y)\n            break\n          case 23: // vstemhm\n            parseStems()\n            break\n          case 24: // rcurveline\n            while (stack.length > 2) {\n              c1x = x + stack.shift()\n              c1y = y + stack.shift()\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              x = c2x + stack.shift()\n              y = c2y + stack.shift()\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            }\n\n            x += stack.shift()\n            y += stack.shift()\n            p.lineTo(x, y)\n            break\n          case 25: // rlinecurve\n            while (stack.length > 6) {\n              x += stack.shift()\n              y += stack.shift()\n              p.lineTo(x, y)\n            }\n\n            c1x = x + stack.shift()\n            c1y = y + stack.shift()\n            c2x = c1x + stack.shift()\n            c2y = c1y + stack.shift()\n            x = c2x + stack.shift()\n            y = c2y + stack.shift()\n            p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            break\n          case 26: // vvcurveto\n            if (stack.length % 2) {\n              x += stack.shift()\n            }\n\n            while (stack.length > 0) {\n              c1x = x\n              c1y = y + stack.shift()\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              x = c2x\n              y = c2y + stack.shift()\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            }\n\n            break\n          case 27: // hhcurveto\n            if (stack.length % 2) {\n              y += stack.shift()\n            }\n\n            while (stack.length > 0) {\n              c1x = x + stack.shift()\n              c1y = y\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              x = c2x + stack.shift()\n              y = c2y\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            }\n\n            break\n          case 28: // shortint\n            b1 = code[i]\n            b2 = code[i + 1]\n            stack.push(((b1 << 24) | (b2 << 16)) >> 16)\n            i += 2\n            break\n          case 29: // callgsubr\n            codeIndex = stack.pop() + font.gsubrsBias\n            subrCode = font.gsubrs[codeIndex]\n            if (subrCode) {\n              parse(subrCode)\n            }\n\n            break\n          case 30: // vhcurveto\n            while (stack.length > 0) {\n              c1x = x\n              c1y = y + stack.shift()\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              x = c2x + stack.shift()\n              y = c2y + (stack.length === 1 ? stack.shift() : 0)\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n              if (stack.length === 0) {\n                break\n              }\n\n              c1x = x + stack.shift()\n              c1y = y\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              y = c2y + stack.shift()\n              x = c2x + (stack.length === 1 ? stack.shift() : 0)\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            }\n\n            break\n          case 31: // hvcurveto\n            while (stack.length > 0) {\n              c1x = x + stack.shift()\n              c1y = y\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              y = c2y + stack.shift()\n              x = c2x + (stack.length === 1 ? stack.shift() : 0)\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n              if (stack.length === 0) {\n                break\n              }\n\n              c1x = x\n              c1y = y + stack.shift()\n              c2x = c1x + stack.shift()\n              c2y = c1y + stack.shift()\n              x = c2x + stack.shift()\n              y = c2y + (stack.length === 1 ? stack.shift() : 0)\n              p.curveTo(c1x, c1y, c2x, c2y, x, y)\n            }\n\n            break\n          default:\n            if (v < 32) {\n              console.log('Glyph ' + glyph.index + ': unknown operator ' + v)\n            } else if (v < 247) {\n              stack.push(v - 139)\n            } else if (v < 251) {\n              b1 = code[i]\n              i += 1\n              stack.push((v - 247) * 256 + b1 + 108)\n            } else if (v < 255) {\n              b1 = code[i]\n              i += 1\n              stack.push(-(v - 251) * 256 - b1 - 108)\n            } else {\n              b1 = code[i]\n              b2 = code[i + 1]\n              b3 = code[i + 2]\n              b4 = code[i + 3]\n              i += 4\n              stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536)\n            }\n        }\n      }\n    }\n\n    parse(code)\n\n    glyph.advanceWidth = width\n    return p\n  }\n\n  function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    var fdSelect = []\n    var fdIndex\n    var parser = new parse.Parser(data, start)\n    var format = parser.parseCard8()\n    if (format === 0) {\n      // Simple list of nGlyphs elements\n      for (var iGid = 0; iGid < nGlyphs; iGid++) {\n        fdIndex = parser.parseCard8()\n        if (fdIndex >= fdArrayCount) {\n          throw new Error(\n            'CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')',\n          )\n        }\n        fdSelect.push(fdIndex)\n      }\n    } else if (format === 3) {\n      // Ranges\n      var nRanges = parser.parseCard16()\n      var first = parser.parseCard16()\n      if (first !== 0) {\n        throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first)\n      }\n      var next\n      for (var iRange = 0; iRange < nRanges; iRange++) {\n        fdIndex = parser.parseCard8()\n        next = parser.parseCard16()\n        if (fdIndex >= fdArrayCount) {\n          throw new Error(\n            'CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')',\n          )\n        }\n        if (next > nGlyphs) {\n          throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next)\n        }\n        for (; first < next; first++) {\n          fdSelect.push(fdIndex)\n        }\n        first = next\n      }\n      if (next !== nGlyphs) {\n        throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next)\n      }\n    } else {\n      throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format)\n    }\n    return fdSelect\n  }\n\n  // Parse the `CFF` table, which contains the glyph outlines in PostScript format.\n  function parseCFFTable(data, start, font, opt) {\n    font.tables.cff = {}\n    var header = parseCFFHeader(data, start)\n    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString)\n    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset)\n    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString)\n    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset)\n    font.gsubrs = globalSubrIndex.objects\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs)\n\n    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects)\n    if (topDictArray.length !== 1) {\n      throw new Error(\n        \"CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = \" + topDictArray.length,\n      )\n    }\n\n    var topDict = topDictArray[0]\n    font.tables.cff.topDict = topDict\n\n    if (topDict._privateDict) {\n      font.defaultWidthX = topDict._privateDict.defaultWidthX\n      font.nominalWidthX = topDict._privateDict.nominalWidthX\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n      font.isCIDFont = true\n    }\n\n    if (font.isCIDFont) {\n      var fdArrayOffset = topDict.fdArray\n      var fdSelectOffset = topDict.fdSelect\n      if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n        throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing')\n      }\n      fdArrayOffset += start\n      var fdArrayIndex = parseCFFIndex(data, fdArrayOffset)\n      var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects)\n      topDict._fdArray = fdArray\n      fdSelectOffset += start\n      topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length)\n    }\n\n    var privateDictOffset = start + topDict.private[1]\n    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects)\n    font.defaultWidthX = privateDict.defaultWidthX\n    font.nominalWidthX = privateDict.nominalWidthX\n\n    if (privateDict.subrs !== 0) {\n      var subrOffset = privateDictOffset + privateDict.subrs\n      var subrIndex = parseCFFIndex(data, subrOffset)\n      font.subrs = subrIndex.objects\n      font.subrsBias = calcCFFSubroutineBias(font.subrs)\n    } else {\n      font.subrs = []\n      font.subrsBias = 0\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    var charStringsIndex\n    if (opt.lowMemory) {\n      charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings)\n      font.nGlyphs = charStringsIndex.offsets.length\n    } else {\n      charStringsIndex = parseCFFIndex(data, start + topDict.charStrings)\n      font.nGlyphs = charStringsIndex.objects.length\n    }\n\n    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects)\n    if (topDict.encoding === 0) {\n      // Standard encoding\n      font.cffEncoding = new CffEncoding(cffStandardEncoding, charset)\n    } else if (topDict.encoding === 1) {\n      // Expert encoding\n      font.cffEncoding = new CffEncoding(cffExpertEncoding, charset)\n    } else {\n      font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset)\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding\n\n    font.glyphs = new glyphset.GlyphSet(font)\n    if (opt.lowMemory) {\n      font._push = function (i) {\n        var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings)\n        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString))\n      }\n    } else {\n      for (var i = 0; i < font.nGlyphs; i += 1) {\n        var charString = charStringsIndex.objects[i]\n        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString))\n      }\n    }\n  }\n\n  // Convert a string to a String ID (SID).\n  // The list of strings is modified in place.\n  function encodeString(s, strings) {\n    var sid\n\n    // Is the string in the CFF standard strings?\n    var i = cffStandardStrings.indexOf(s)\n    if (i >= 0) {\n      sid = i\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s)\n    if (i >= 0) {\n      sid = i + cffStandardStrings.length\n    } else {\n      sid = cffStandardStrings.length + strings.length\n      strings.push(s)\n    }\n\n    return sid\n  }\n\n  function makeHeader() {\n    return new table.Record('Header', [\n      { name: 'major', type: 'Card8', value: 1 },\n      { name: 'minor', type: 'Card8', value: 0 },\n      { name: 'hdrSize', type: 'Card8', value: 4 },\n      { name: 'major', type: 'Card8', value: 1 },\n    ])\n  }\n\n  function makeNameIndex(fontNames) {\n    var t = new table.Record('Name INDEX', [{ name: 'names', type: 'INDEX', value: [] }])\n    t.names = []\n    for (var i = 0; i < fontNames.length; i += 1) {\n      t.names.push({ name: 'name_' + i, type: 'NAME', value: fontNames[i] })\n    }\n\n    return t\n  }\n\n  // Given a dictionary's metadata, create a DICT structure.\n  function makeDict(meta, attrs, strings) {\n    var m = {}\n    for (var i = 0; i < meta.length; i += 1) {\n      var entry = meta[i]\n      var value = attrs[entry.name]\n      if (value !== undefined && !equals(value, entry.value)) {\n        if (entry.type === 'SID') {\n          value = encodeString(value, strings)\n        }\n\n        m[entry.op] = { name: entry.name, type: entry.type, value: value }\n      }\n    }\n\n    return m\n  }\n\n  // The Top DICT houses the global font attributes.\n  function makeTopDict(attrs, strings) {\n    var t = new table.Record('Top DICT', [{ name: 'dict', type: 'DICT', value: {} }])\n    t.dict = makeDict(TOP_DICT_META, attrs, strings)\n    return t\n  }\n\n  function makeTopDictIndex(topDict) {\n    var t = new table.Record('Top DICT INDEX', [{ name: 'topDicts', type: 'INDEX', value: [] }])\n    t.topDicts = [{ name: 'topDict_0', type: 'TABLE', value: topDict }]\n    return t\n  }\n\n  function makeStringIndex(strings) {\n    var t = new table.Record('String INDEX', [{ name: 'strings', type: 'INDEX', value: [] }])\n    t.strings = []\n    for (var i = 0; i < strings.length; i += 1) {\n      t.strings.push({ name: 'string_' + i, type: 'STRING', value: strings[i] })\n    }\n\n    return t\n  }\n\n  function makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new table.Record('Global Subr INDEX', [{ name: 'subrs', type: 'INDEX', value: [] }])\n  }\n\n  function makeCharsets(glyphNames, strings) {\n    var t = new table.Record('Charsets', [{ name: 'format', type: 'Card8', value: 0 }])\n    for (var i = 0; i < glyphNames.length; i += 1) {\n      var glyphName = glyphNames[i]\n      var glyphSID = encodeString(glyphName, strings)\n      t.fields.push({ name: 'glyph_' + i, type: 'SID', value: glyphSID })\n    }\n\n    return t\n  }\n\n  function glyphToOps(glyph) {\n    var ops = []\n    var path = glyph.path\n    ops.push({ name: 'width', type: 'NUMBER', value: glyph.advanceWidth })\n    var x = 0\n    var y = 0\n    for (var i = 0; i < path.commands.length; i += 1) {\n      var dx = void 0\n      var dy = void 0\n      var cmd = path.commands[i]\n      if (cmd.type === 'Q') {\n        // CFF only supports bzier curves, so convert the quad to a bzier.\n        var _13 = 1 / 3\n        var _23 = 2 / 3\n\n        // We're going to create a new command so we don't change the original path.\n        // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.\n        cmd = {\n          type: 'C',\n          x: cmd.x,\n          y: cmd.y,\n          x1: Math.round(_13 * x + _23 * cmd.x1),\n          y1: Math.round(_13 * y + _23 * cmd.y1),\n          x2: Math.round(_13 * cmd.x + _23 * cmd.x1),\n          y2: Math.round(_13 * cmd.y + _23 * cmd.y1),\n        }\n      }\n\n      if (cmd.type === 'M') {\n        dx = Math.round(cmd.x - x)\n        dy = Math.round(cmd.y - y)\n        ops.push({ name: 'dx', type: 'NUMBER', value: dx })\n        ops.push({ name: 'dy', type: 'NUMBER', value: dy })\n        ops.push({ name: 'rmoveto', type: 'OP', value: 21 })\n        x = Math.round(cmd.x)\n        y = Math.round(cmd.y)\n      } else if (cmd.type === 'L') {\n        dx = Math.round(cmd.x - x)\n        dy = Math.round(cmd.y - y)\n        ops.push({ name: 'dx', type: 'NUMBER', value: dx })\n        ops.push({ name: 'dy', type: 'NUMBER', value: dy })\n        ops.push({ name: 'rlineto', type: 'OP', value: 5 })\n        x = Math.round(cmd.x)\n        y = Math.round(cmd.y)\n      } else if (cmd.type === 'C') {\n        var dx1 = Math.round(cmd.x1 - x)\n        var dy1 = Math.round(cmd.y1 - y)\n        var dx2 = Math.round(cmd.x2 - cmd.x1)\n        var dy2 = Math.round(cmd.y2 - cmd.y1)\n        dx = Math.round(cmd.x - cmd.x2)\n        dy = Math.round(cmd.y - cmd.y2)\n        ops.push({ name: 'dx1', type: 'NUMBER', value: dx1 })\n        ops.push({ name: 'dy1', type: 'NUMBER', value: dy1 })\n        ops.push({ name: 'dx2', type: 'NUMBER', value: dx2 })\n        ops.push({ name: 'dy2', type: 'NUMBER', value: dy2 })\n        ops.push({ name: 'dx', type: 'NUMBER', value: dx })\n        ops.push({ name: 'dy', type: 'NUMBER', value: dy })\n        ops.push({ name: 'rrcurveto', type: 'OP', value: 8 })\n        x = Math.round(cmd.x)\n        y = Math.round(cmd.y)\n      }\n\n      // Contours are closed automatically.\n    }\n\n    ops.push({ name: 'endchar', type: 'OP', value: 14 })\n    return ops\n  }\n\n  function makeCharStringsIndex(glyphs) {\n    var t = new table.Record('CharStrings INDEX', [{ name: 'charStrings', type: 'INDEX', value: [] }])\n\n    for (var i = 0; i < glyphs.length; i += 1) {\n      var glyph = glyphs.get(i)\n      var ops = glyphToOps(glyph)\n      t.charStrings.push({ name: glyph.name, type: 'CHARSTRING', value: ops })\n    }\n\n    return t\n  }\n\n  function makePrivateDict(attrs, strings) {\n    var t = new table.Record('Private DICT', [{ name: 'dict', type: 'DICT', value: {} }])\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings)\n    return t\n  }\n\n  function makeCFFTable(glyphs, options) {\n    var t = new table.Table('CFF ', [\n      { name: 'header', type: 'RECORD' },\n      { name: 'nameIndex', type: 'RECORD' },\n      { name: 'topDictIndex', type: 'RECORD' },\n      { name: 'stringIndex', type: 'RECORD' },\n      { name: 'globalSubrIndex', type: 'RECORD' },\n      { name: 'charsets', type: 'RECORD' },\n      { name: 'charStringsIndex', type: 'RECORD' },\n      { name: 'privateDict', type: 'RECORD' },\n    ])\n\n    var fontScale = 1 / options.unitsPerEm\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    var attrs = {\n      version: options.version,\n      fullName: options.fullName,\n      familyName: options.familyName,\n      weight: options.weightName,\n      fontBBox: options.fontBBox || [0, 0, 0, 0],\n      fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n      charset: 999,\n      encoding: 0,\n      charStrings: 999,\n      private: [0, 999],\n    }\n\n    var privateAttrs = {}\n\n    var glyphNames = []\n    var glyph\n\n    // Skip first glyph (.notdef)\n    for (var i = 1; i < glyphs.length; i += 1) {\n      glyph = glyphs.get(i)\n      glyphNames.push(glyph.name)\n    }\n\n    var strings = []\n\n    t.header = makeHeader()\n    t.nameIndex = makeNameIndex([options.postScriptName])\n    var topDict = makeTopDict(attrs, strings)\n    t.topDictIndex = makeTopDictIndex(topDict)\n    t.globalSubrIndex = makeGlobalSubrIndex()\n    t.charsets = makeCharsets(glyphNames, strings)\n    t.charStringsIndex = makeCharStringsIndex(glyphs)\n    t.privateDict = makePrivateDict(privateAttrs, strings)\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings)\n\n    var startOffset =\n      t.header.sizeOf() +\n      t.nameIndex.sizeOf() +\n      t.topDictIndex.sizeOf() +\n      t.stringIndex.sizeOf() +\n      t.globalSubrIndex.sizeOf()\n    attrs.charset = startOffset\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf()\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf()\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings)\n    t.topDictIndex = makeTopDictIndex(topDict)\n\n    return t\n  }\n\n  var cff = { parse: parseCFFTable, make: makeCFFTable }\n\n  // The `head` table contains global information about the font.\n\n  // Parse the header `head` table\n  function parseHeadTable(data, start) {\n    var head = {}\n    var p = new parse.Parser(data, start)\n    head.version = p.parseVersion()\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000\n    head.checkSumAdjustment = p.parseULong()\n    head.magicNumber = p.parseULong()\n    check.argument(head.magicNumber === 0x5f0f3cf5, 'Font header has wrong magic number.')\n    head.flags = p.parseUShort()\n    head.unitsPerEm = p.parseUShort()\n    head.created = p.parseLongDateTime()\n    head.modified = p.parseLongDateTime()\n    head.xMin = p.parseShort()\n    head.yMin = p.parseShort()\n    head.xMax = p.parseShort()\n    head.yMax = p.parseShort()\n    head.macStyle = p.parseUShort()\n    head.lowestRecPPEM = p.parseUShort()\n    head.fontDirectionHint = p.parseShort()\n    head.indexToLocFormat = p.parseShort()\n    head.glyphDataFormat = p.parseShort()\n    return head\n  }\n\n  function makeHeadTable(options) {\n    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800\n    var createdTimestamp = timestamp\n\n    if (options.createdTimestamp) {\n      createdTimestamp = options.createdTimestamp + 2082844800\n    }\n\n    return new table.Table(\n      'head',\n      [\n        { name: 'version', type: 'FIXED', value: 0x00010000 },\n        { name: 'fontRevision', type: 'FIXED', value: 0x00010000 },\n        { name: 'checkSumAdjustment', type: 'ULONG', value: 0 },\n        { name: 'magicNumber', type: 'ULONG', value: 0x5f0f3cf5 },\n        { name: 'flags', type: 'USHORT', value: 0 },\n        { name: 'unitsPerEm', type: 'USHORT', value: 1000 },\n        { name: 'created', type: 'LONGDATETIME', value: createdTimestamp },\n        { name: 'modified', type: 'LONGDATETIME', value: timestamp },\n        { name: 'xMin', type: 'SHORT', value: 0 },\n        { name: 'yMin', type: 'SHORT', value: 0 },\n        { name: 'xMax', type: 'SHORT', value: 0 },\n        { name: 'yMax', type: 'SHORT', value: 0 },\n        { name: 'macStyle', type: 'USHORT', value: 0 },\n        { name: 'lowestRecPPEM', type: 'USHORT', value: 0 },\n        { name: 'fontDirectionHint', type: 'SHORT', value: 2 },\n        { name: 'indexToLocFormat', type: 'SHORT', value: 0 },\n        { name: 'glyphDataFormat', type: 'SHORT', value: 0 },\n      ],\n      options,\n    )\n  }\n\n  var head = { parse: parseHeadTable, make: makeHeadTable }\n\n  // The `hhea` table contains information for horizontal layout.\n\n  // Parse the horizontal header `hhea` table\n  function parseHheaTable(data, start) {\n    var hhea = {}\n    var p = new parse.Parser(data, start)\n    hhea.version = p.parseVersion()\n    hhea.ascender = p.parseShort()\n    hhea.descender = p.parseShort()\n    hhea.lineGap = p.parseShort()\n    hhea.advanceWidthMax = p.parseUShort()\n    hhea.minLeftSideBearing = p.parseShort()\n    hhea.minRightSideBearing = p.parseShort()\n    hhea.xMaxExtent = p.parseShort()\n    hhea.caretSlopeRise = p.parseShort()\n    hhea.caretSlopeRun = p.parseShort()\n    hhea.caretOffset = p.parseShort()\n    p.relativeOffset += 8\n    hhea.metricDataFormat = p.parseShort()\n    hhea.numberOfHMetrics = p.parseUShort()\n    return hhea\n  }\n\n  function makeHheaTable(options) {\n    return new table.Table(\n      'hhea',\n      [\n        { name: 'version', type: 'FIXED', value: 0x00010000 },\n        { name: 'ascender', type: 'FWORD', value: 0 },\n        { name: 'descender', type: 'FWORD', value: 0 },\n        { name: 'lineGap', type: 'FWORD', value: 0 },\n        { name: 'advanceWidthMax', type: 'UFWORD', value: 0 },\n        { name: 'minLeftSideBearing', type: 'FWORD', value: 0 },\n        { name: 'minRightSideBearing', type: 'FWORD', value: 0 },\n        { name: 'xMaxExtent', type: 'FWORD', value: 0 },\n        { name: 'caretSlopeRise', type: 'SHORT', value: 1 },\n        { name: 'caretSlopeRun', type: 'SHORT', value: 0 },\n        { name: 'caretOffset', type: 'SHORT', value: 0 },\n        { name: 'reserved1', type: 'SHORT', value: 0 },\n        { name: 'reserved2', type: 'SHORT', value: 0 },\n        { name: 'reserved3', type: 'SHORT', value: 0 },\n        { name: 'reserved4', type: 'SHORT', value: 0 },\n        { name: 'metricDataFormat', type: 'SHORT', value: 0 },\n        { name: 'numberOfHMetrics', type: 'USHORT', value: 0 },\n      ],\n      options,\n    )\n  }\n\n  var hhea = { parse: parseHheaTable, make: makeHheaTable }\n\n  // The `hmtx` table contains the horizontal metrics for all glyphs.\n\n  function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n    var advanceWidth\n    var leftSideBearing\n    var p = new parse.Parser(data, start)\n    for (var i = 0; i < numGlyphs; i += 1) {\n      // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n      if (i < numMetrics) {\n        advanceWidth = p.parseUShort()\n        leftSideBearing = p.parseShort()\n      }\n\n      var glyph = glyphs.get(i)\n      glyph.advanceWidth = advanceWidth\n      glyph.leftSideBearing = leftSideBearing\n    }\n  }\n\n  function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n    font._hmtxTableData = {}\n\n    var advanceWidth\n    var leftSideBearing\n    var p = new parse.Parser(data, start)\n    for (var i = 0; i < numGlyphs; i += 1) {\n      // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n      if (i < numMetrics) {\n        advanceWidth = p.parseUShort()\n        leftSideBearing = p.parseShort()\n      }\n\n      font._hmtxTableData[i] = {\n        advanceWidth: advanceWidth,\n        leftSideBearing: leftSideBearing,\n      }\n    }\n  }\n\n  // Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n  // This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\n  function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n    if (opt.lowMemory) {\n      parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs)\n    } else {\n      parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs)\n    }\n  }\n\n  function makeHmtxTable(glyphs) {\n    var t = new table.Table('hmtx', [])\n    for (var i = 0; i < glyphs.length; i += 1) {\n      var glyph = glyphs.get(i)\n      var advanceWidth = glyph.advanceWidth || 0\n      var leftSideBearing = glyph.leftSideBearing || 0\n      t.fields.push({ name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth })\n      t.fields.push({ name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing })\n    }\n\n    return t\n  }\n\n  var hmtx = { parse: parseHmtxTable, make: makeHmtxTable }\n\n  // The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\n  function makeLtagTable(tags) {\n    var result = new table.Table('ltag', [\n      { name: 'version', type: 'ULONG', value: 1 },\n      { name: 'flags', type: 'ULONG', value: 0 },\n      { name: 'numTags', type: 'ULONG', value: tags.length },\n    ])\n\n    var stringPool = ''\n    var stringPoolOffset = 12 + tags.length * 4\n    for (var i = 0; i < tags.length; ++i) {\n      var pos = stringPool.indexOf(tags[i])\n      if (pos < 0) {\n        pos = stringPool.length\n        stringPool += tags[i]\n      }\n\n      result.fields.push({ name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos })\n      result.fields.push({ name: 'length ' + i, type: 'USHORT', value: tags[i].length })\n    }\n\n    result.fields.push({ name: 'stringPool', type: 'CHARARRAY', value: stringPool })\n    return result\n  }\n\n  function parseLtagTable(data, start) {\n    var p = new parse.Parser(data, start)\n    var tableVersion = p.parseULong()\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.')\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1)\n    var numTags = p.parseULong()\n\n    var tags = []\n    for (var i = 0; i < numTags; i++) {\n      var tag = ''\n      var offset = start + p.parseUShort()\n      var length = p.parseUShort()\n      for (var j = offset; j < offset + length; ++j) {\n        tag += String.fromCharCode(data.getInt8(j))\n      }\n\n      tags.push(tag)\n    }\n\n    return tags\n  }\n\n  var ltag = { make: makeLtagTable, parse: parseLtagTable }\n\n  // The `maxp` table establishes the memory requirements for the font.\n\n  // Parse the maximum profile `maxp` table.\n  function parseMaxpTable(data, start) {\n    var maxp = {}\n    var p = new parse.Parser(data, start)\n    maxp.version = p.parseVersion()\n    maxp.numGlyphs = p.parseUShort()\n    if (maxp.version === 1.0) {\n      maxp.maxPoints = p.parseUShort()\n      maxp.maxContours = p.parseUShort()\n      maxp.maxCompositePoints = p.parseUShort()\n      maxp.maxCompositeContours = p.parseUShort()\n      maxp.maxZones = p.parseUShort()\n      maxp.maxTwilightPoints = p.parseUShort()\n      maxp.maxStorage = p.parseUShort()\n      maxp.maxFunctionDefs = p.parseUShort()\n      maxp.maxInstructionDefs = p.parseUShort()\n      maxp.maxStackElements = p.parseUShort()\n      maxp.maxSizeOfInstructions = p.parseUShort()\n      maxp.maxComponentElements = p.parseUShort()\n      maxp.maxComponentDepth = p.parseUShort()\n    }\n\n    return maxp\n  }\n\n  function makeMaxpTable(numGlyphs) {\n    return new table.Table('maxp', [\n      { name: 'version', type: 'FIXED', value: 0x00005000 },\n      { name: 'numGlyphs', type: 'USHORT', value: numGlyphs },\n    ])\n  }\n\n  var maxp = { parse: parseMaxpTable, make: makeMaxpTable }\n\n  // The `name` naming table.\n\n  // NameIDs for the name table.\n  var nameTableNames = [\n    'copyright', // 0\n    'fontFamily', // 1\n    'fontSubfamily', // 2\n    'uniqueID', // 3\n    'fullName', // 4\n    'version', // 5\n    'postScriptName', // 6\n    'trademark', // 7\n    'manufacturer', // 8\n    'designer', // 9\n    'description', // 10\n    'manufacturerURL', // 11\n    'designerURL', // 12\n    'license', // 13\n    'licenseURL', // 14\n    'reserved', // 15\n    'preferredFamily', // 16\n    'preferredSubfamily', // 17\n    'compatibleFullName', // 18\n    'sampleText', // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily', // 21\n    'wwsSubfamily', // 22\n  ]\n\n  var macLanguages = {\n    0: 'en',\n    1: 'fr',\n    2: 'de',\n    3: 'it',\n    4: 'nl',\n    5: 'sv',\n    6: 'es',\n    7: 'da',\n    8: 'pt',\n    9: 'no',\n    10: 'he',\n    11: 'ja',\n    12: 'ar',\n    13: 'fi',\n    14: 'el',\n    15: 'is',\n    16: 'mt',\n    17: 'tr',\n    18: 'hr',\n    19: 'zh-Hant',\n    20: 'ur',\n    21: 'hi',\n    22: 'th',\n    23: 'ko',\n    24: 'lt',\n    25: 'pl',\n    26: 'hu',\n    27: 'es',\n    28: 'lv',\n    29: 'se',\n    30: 'fo',\n    31: 'fa',\n    32: 'ru',\n    33: 'zh',\n    34: 'nl-BE',\n    35: 'ga',\n    36: 'sq',\n    37: 'ro',\n    38: 'cz',\n    39: 'sk',\n    40: 'si',\n    41: 'yi',\n    42: 'sr',\n    43: 'mk',\n    44: 'bg',\n    45: 'uk',\n    46: 'be',\n    47: 'uz',\n    48: 'kk',\n    49: 'az-Cyrl',\n    50: 'az-Arab',\n    51: 'hy',\n    52: 'ka',\n    53: 'mo',\n    54: 'ky',\n    55: 'tg',\n    56: 'tk',\n    57: 'mn-CN',\n    58: 'mn',\n    59: 'ps',\n    60: 'ks',\n    61: 'ku',\n    62: 'sd',\n    63: 'bo',\n    64: 'ne',\n    65: 'sa',\n    66: 'mr',\n    67: 'bn',\n    68: 'as',\n    69: 'gu',\n    70: 'pa',\n    71: 'or',\n    72: 'ml',\n    73: 'kn',\n    74: 'ta',\n    75: 'te',\n    76: 'si',\n    77: 'my',\n    78: 'km',\n    79: 'lo',\n    80: 'vi',\n    81: 'id',\n    82: 'tl',\n    83: 'ms',\n    84: 'ms-Arab',\n    85: 'am',\n    86: 'ti',\n    87: 'om',\n    88: 'so',\n    89: 'sw',\n    90: 'rw',\n    91: 'rn',\n    92: 'ny',\n    93: 'mg',\n    94: 'eo',\n    128: 'cy',\n    129: 'eu',\n    130: 'ca',\n    131: 'la',\n    132: 'qu',\n    133: 'gn',\n    134: 'ay',\n    135: 'tt',\n    136: 'ug',\n    137: 'dz',\n    138: 'jv',\n    139: 'su',\n    140: 'gl',\n    141: 'af',\n    142: 'br',\n    143: 'iu',\n    144: 'gd',\n    145: 'gv',\n    146: 'ga',\n    147: 'to',\n    148: 'el-polyton',\n    149: 'kl',\n    150: 'az',\n    151: 'nn',\n  }\n\n  // MacOS language ID  MacOS script ID\n  //\n  // Note that the script ID is not sufficient to determine what encoding\n  // to use in TrueType files. For some languages, MacOS used a modification\n  // of a mainstream script. For example, an Icelandic name would be stored\n  // with smRoman in the TrueType naming table, but the actual encoding\n  // is a special Icelandic version of the normal Macintosh Roman encoding.\n  // As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n  // Syllables but MacOS had run out of available script codes, so this was\n  // done as a (pretty radical) \"modification\" of Ethiopic.\n  //\n  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n  var macLanguageToScript = {\n    0: 0, // langEnglish  smRoman\n    1: 0, // langFrench  smRoman\n    2: 0, // langGerman  smRoman\n    3: 0, // langItalian  smRoman\n    4: 0, // langDutch  smRoman\n    5: 0, // langSwedish  smRoman\n    6: 0, // langSpanish  smRoman\n    7: 0, // langDanish  smRoman\n    8: 0, // langPortuguese  smRoman\n    9: 0, // langNorwegian  smRoman\n    10: 5, // langHebrew  smHebrew\n    11: 1, // langJapanese  smJapanese\n    12: 4, // langArabic  smArabic\n    13: 0, // langFinnish  smRoman\n    14: 6, // langGreek  smGreek\n    15: 0, // langIcelandic  smRoman (modified)\n    16: 0, // langMaltese  smRoman\n    17: 0, // langTurkish  smRoman (modified)\n    18: 0, // langCroatian  smRoman (modified)\n    19: 2, // langTradChinese  smTradChinese\n    20: 4, // langUrdu  smArabic\n    21: 9, // langHindi  smDevanagari\n    22: 21, // langThai  smThai\n    23: 3, // langKorean  smKorean\n    24: 29, // langLithuanian  smCentralEuroRoman\n    25: 29, // langPolish  smCentralEuroRoman\n    26: 29, // langHungarian  smCentralEuroRoman\n    27: 29, // langEstonian  smCentralEuroRoman\n    28: 29, // langLatvian  smCentralEuroRoman\n    29: 0, // langSami  smRoman\n    30: 0, // langFaroese  smRoman (modified)\n    31: 4, // langFarsi  smArabic (modified)\n    32: 7, // langRussian  smCyrillic\n    33: 25, // langSimpChinese  smSimpChinese\n    34: 0, // langFlemish  smRoman\n    35: 0, // langIrishGaelic  smRoman (modified)\n    36: 0, // langAlbanian  smRoman\n    37: 0, // langRomanian  smRoman (modified)\n    38: 29, // langCzech  smCentralEuroRoman\n    39: 29, // langSlovak  smCentralEuroRoman\n    40: 0, // langSlovenian  smRoman (modified)\n    41: 5, // langYiddish  smHebrew\n    42: 7, // langSerbian  smCyrillic\n    43: 7, // langMacedonian  smCyrillic\n    44: 7, // langBulgarian  smCyrillic\n    45: 7, // langUkrainian  smCyrillic (modified)\n    46: 7, // langByelorussian  smCyrillic\n    47: 7, // langUzbek  smCyrillic\n    48: 7, // langKazakh  smCyrillic\n    49: 7, // langAzerbaijani  smCyrillic\n    50: 4, // langAzerbaijanAr  smArabic\n    51: 24, // langArmenian  smArmenian\n    52: 23, // langGeorgian  smGeorgian\n    53: 7, // langMoldavian  smCyrillic\n    54: 7, // langKirghiz  smCyrillic\n    55: 7, // langTajiki  smCyrillic\n    56: 7, // langTurkmen  smCyrillic\n    57: 27, // langMongolian  smMongolian\n    58: 7, // langMongolianCyr  smCyrillic\n    59: 4, // langPashto  smArabic\n    60: 4, // langKurdish  smArabic\n    61: 4, // langKashmiri  smArabic\n    62: 4, // langSindhi  smArabic\n    63: 26, // langTibetan  smTibetan\n    64: 9, // langNepali  smDevanagari\n    65: 9, // langSanskrit  smDevanagari\n    66: 9, // langMarathi  smDevanagari\n    67: 13, // langBengali  smBengali\n    68: 13, // langAssamese  smBengali\n    69: 11, // langGujarati  smGujarati\n    70: 10, // langPunjabi  smGurmukhi\n    71: 12, // langOriya  smOriya\n    72: 17, // langMalayalam  smMalayalam\n    73: 16, // langKannada  smKannada\n    74: 14, // langTamil  smTamil\n    75: 15, // langTelugu  smTelugu\n    76: 18, // langSinhalese  smSinhalese\n    77: 19, // langBurmese  smBurmese\n    78: 20, // langKhmer  smKhmer\n    79: 22, // langLao  smLao\n    80: 30, // langVietnamese  smVietnamese\n    81: 0, // langIndonesian  smRoman\n    82: 0, // langTagalog  smRoman\n    83: 0, // langMalayRoman  smRoman\n    84: 4, // langMalayArabic  smArabic\n    85: 28, // langAmharic  smEthiopic\n    86: 28, // langTigrinya  smEthiopic\n    87: 28, // langOromo  smEthiopic\n    88: 0, // langSomali  smRoman\n    89: 0, // langSwahili  smRoman\n    90: 0, // langKinyarwanda  smRoman\n    91: 0, // langRundi  smRoman\n    92: 0, // langNyanja  smRoman\n    93: 0, // langMalagasy  smRoman\n    94: 0, // langEsperanto  smRoman\n    128: 0, // langWelsh  smRoman (modified)\n    129: 0, // langBasque  smRoman\n    130: 0, // langCatalan  smRoman\n    131: 0, // langLatin  smRoman\n    132: 0, // langQuechua  smRoman\n    133: 0, // langGuarani  smRoman\n    134: 0, // langAymara  smRoman\n    135: 7, // langTatar  smCyrillic\n    136: 4, // langUighur  smArabic\n    137: 26, // langDzongkha  smTibetan\n    138: 0, // langJavaneseRom  smRoman\n    139: 0, // langSundaneseRom  smRoman\n    140: 0, // langGalician  smRoman\n    141: 0, // langAfrikaans  smRoman\n    142: 0, // langBreton  smRoman (modified)\n    143: 28, // langInuktitut  smEthiopic (modified)\n    144: 0, // langScottishGaelic  smRoman (modified)\n    145: 0, // langManxGaelic  smRoman (modified)\n    146: 0, // langIrishGaelicScript  smRoman (modified)\n    147: 0, // langTongan  smRoman\n    148: 6, // langGreekAncient  smRoman\n    149: 0, // langGreenlandic  smRoman\n    150: 0, // langAzerbaijanRoman  smRoman\n    151: 0, // langNynorsk  smRoman\n  }\n\n  // While Microsoft indicates a region/country for all its language\n  // IDs, we omit the region code if it's equal to the \"most likely\n  // region subtag\" according to Unicode CLDR. For scripts, we omit\n  // the subtag if it is equal to the Suppress-Script entry in the\n  // IANA language subtag registry for IETF BCP 47.\n  //\n  // For example, Microsoft states that its language code 0x041A is\n  // Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n  // and not 'hr-HR' because Croatia is the default country for Croatian,\n  // according to Unicode CLDR. As another example, Microsoft states\n  // that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n  // this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n  // for the Croatian language, according to IANA.\n  //\n  // http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n  // http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n  var windowsLanguages = {\n    0x0436: 'af',\n    0x041c: 'sq',\n    0x0484: 'gsw',\n    0x045e: 'am',\n    0x1401: 'ar-DZ',\n    0x3c01: 'ar-BH',\n    0x0c01: 'ar',\n    0x0801: 'ar-IQ',\n    0x2c01: 'ar-JO',\n    0x3401: 'ar-KW',\n    0x3001: 'ar-LB',\n    0x1001: 'ar-LY',\n    0x1801: 'ary',\n    0x2001: 'ar-OM',\n    0x4001: 'ar-QA',\n    0x0401: 'ar-SA',\n    0x2801: 'ar-SY',\n    0x1c01: 'aeb',\n    0x3801: 'ar-AE',\n    0x2401: 'ar-YE',\n    0x042b: 'hy',\n    0x044d: 'as',\n    0x082c: 'az-Cyrl',\n    0x042c: 'az',\n    0x046d: 'ba',\n    0x042d: 'eu',\n    0x0423: 'be',\n    0x0845: 'bn',\n    0x0445: 'bn-IN',\n    0x201a: 'bs-Cyrl',\n    0x141a: 'bs',\n    0x047e: 'br',\n    0x0402: 'bg',\n    0x0403: 'ca',\n    0x0c04: 'zh-HK',\n    0x1404: 'zh-MO',\n    0x0804: 'zh',\n    0x1004: 'zh-SG',\n    0x0404: 'zh-TW',\n    0x0483: 'co',\n    0x041a: 'hr',\n    0x101a: 'hr-BA',\n    0x0405: 'cs',\n    0x0406: 'da',\n    0x048c: 'prs',\n    0x0465: 'dv',\n    0x0813: 'nl-BE',\n    0x0413: 'nl',\n    0x0c09: 'en-AU',\n    0x2809: 'en-BZ',\n    0x1009: 'en-CA',\n    0x2409: 'en-029',\n    0x4009: 'en-IN',\n    0x1809: 'en-IE',\n    0x2009: 'en-JM',\n    0x4409: 'en-MY',\n    0x1409: 'en-NZ',\n    0x3409: 'en-PH',\n    0x4809: 'en-SG',\n    0x1c09: 'en-ZA',\n    0x2c09: 'en-TT',\n    0x0809: 'en-GB',\n    0x0409: 'en',\n    0x3009: 'en-ZW',\n    0x0425: 'et',\n    0x0438: 'fo',\n    0x0464: 'fil',\n    0x040b: 'fi',\n    0x080c: 'fr-BE',\n    0x0c0c: 'fr-CA',\n    0x040c: 'fr',\n    0x140c: 'fr-LU',\n    0x180c: 'fr-MC',\n    0x100c: 'fr-CH',\n    0x0462: 'fy',\n    0x0456: 'gl',\n    0x0437: 'ka',\n    0x0c07: 'de-AT',\n    0x0407: 'de',\n    0x1407: 'de-LI',\n    0x1007: 'de-LU',\n    0x0807: 'de-CH',\n    0x0408: 'el',\n    0x046f: 'kl',\n    0x0447: 'gu',\n    0x0468: 'ha',\n    0x040d: 'he',\n    0x0439: 'hi',\n    0x040e: 'hu',\n    0x040f: 'is',\n    0x0470: 'ig',\n    0x0421: 'id',\n    0x045d: 'iu',\n    0x085d: 'iu-Latn',\n    0x083c: 'ga',\n    0x0434: 'xh',\n    0x0435: 'zu',\n    0x0410: 'it',\n    0x0810: 'it-CH',\n    0x0411: 'ja',\n    0x044b: 'kn',\n    0x043f: 'kk',\n    0x0453: 'km',\n    0x0486: 'quc',\n    0x0487: 'rw',\n    0x0441: 'sw',\n    0x0457: 'kok',\n    0x0412: 'ko',\n    0x0440: 'ky',\n    0x0454: 'lo',\n    0x0426: 'lv',\n    0x0427: 'lt',\n    0x082e: 'dsb',\n    0x046e: 'lb',\n    0x042f: 'mk',\n    0x083e: 'ms-BN',\n    0x043e: 'ms',\n    0x044c: 'ml',\n    0x043a: 'mt',\n    0x0481: 'mi',\n    0x047a: 'arn',\n    0x044e: 'mr',\n    0x047c: 'moh',\n    0x0450: 'mn',\n    0x0850: 'mn-CN',\n    0x0461: 'ne',\n    0x0414: 'nb',\n    0x0814: 'nn',\n    0x0482: 'oc',\n    0x0448: 'or',\n    0x0463: 'ps',\n    0x0415: 'pl',\n    0x0416: 'pt',\n    0x0816: 'pt-PT',\n    0x0446: 'pa',\n    0x046b: 'qu-BO',\n    0x086b: 'qu-EC',\n    0x0c6b: 'qu',\n    0x0418: 'ro',\n    0x0417: 'rm',\n    0x0419: 'ru',\n    0x243b: 'smn',\n    0x103b: 'smj-NO',\n    0x143b: 'smj',\n    0x0c3b: 'se-FI',\n    0x043b: 'se',\n    0x083b: 'se-SE',\n    0x203b: 'sms',\n    0x183b: 'sma-NO',\n    0x1c3b: 'sms',\n    0x044f: 'sa',\n    0x1c1a: 'sr-Cyrl-BA',\n    0x0c1a: 'sr',\n    0x181a: 'sr-Latn-BA',\n    0x081a: 'sr-Latn',\n    0x046c: 'nso',\n    0x0432: 'tn',\n    0x045b: 'si',\n    0x041b: 'sk',\n    0x0424: 'sl',\n    0x2c0a: 'es-AR',\n    0x400a: 'es-BO',\n    0x340a: 'es-CL',\n    0x240a: 'es-CO',\n    0x140a: 'es-CR',\n    0x1c0a: 'es-DO',\n    0x300a: 'es-EC',\n    0x440a: 'es-SV',\n    0x100a: 'es-GT',\n    0x480a: 'es-HN',\n    0x080a: 'es-MX',\n    0x4c0a: 'es-NI',\n    0x180a: 'es-PA',\n    0x3c0a: 'es-PY',\n    0x280a: 'es-PE',\n    0x500a: 'es-PR',\n\n    // Microsoft has defined two different language codes for\n    // Spanish with modern sorting and Spanish with traditional\n    // sorting. This makes sense for collation APIs, and it would be\n    // possible to express this in BCP 47 language tags via Unicode\n    // extensions (eg., es-u-co-trad is Spanish with traditional\n    // sorting). However, for storing names in fonts, the distinction\n    // does not make sense, so we give es in both cases.\n    0x0c0a: 'es',\n    0x040a: 'es',\n\n    0x540a: 'es-US',\n    0x380a: 'es-UY',\n    0x200a: 'es-VE',\n    0x081d: 'sv-FI',\n    0x041d: 'sv',\n    0x045a: 'syr',\n    0x0428: 'tg',\n    0x085f: 'tzm',\n    0x0449: 'ta',\n    0x0444: 'tt',\n    0x044a: 'te',\n    0x041e: 'th',\n    0x0451: 'bo',\n    0x041f: 'tr',\n    0x0442: 'tk',\n    0x0480: 'ug',\n    0x0422: 'uk',\n    0x042e: 'hsb',\n    0x0420: 'ur',\n    0x0843: 'uz-Cyrl',\n    0x0443: 'uz',\n    0x042a: 'vi',\n    0x0452: 'cy',\n    0x0488: 'wo',\n    0x0485: 'sah',\n    0x0478: 'ii',\n    0x046a: 'yo',\n  }\n\n  // Returns a IETF BCP 47 language code, for example 'zh-Hant'\n  // for 'Chinese in the traditional script'.\n  function getLanguageCode(platformID, languageID, ltag) {\n    switch (platformID) {\n      case 0: // Unicode\n        if (languageID === 0xffff) {\n          return 'und'\n        } else if (ltag) {\n          return ltag[languageID]\n        }\n\n        break\n\n      case 1: // Macintosh\n        return macLanguages[languageID]\n\n      case 3: // Windows\n        return windowsLanguages[languageID]\n    }\n\n    return undefined\n  }\n\n  var utf16 = 'utf-16'\n\n  // MacOS script ID  encoding. This table stores the default case,\n  // which can be overridden by macLanguageEncodings.\n  var macScriptEncodings = {\n    0: 'macintosh', // smRoman\n    1: 'x-mac-japanese', // smJapanese\n    2: 'x-mac-chinesetrad', // smTradChinese\n    3: 'x-mac-korean', // smKorean\n    6: 'x-mac-greek', // smGreek\n    7: 'x-mac-cyrillic', // smCyrillic\n    9: 'x-mac-devanagai', // smDevanagari\n    10: 'x-mac-gurmukhi', // smGurmukhi\n    11: 'x-mac-gujarati', // smGujarati\n    12: 'x-mac-oriya', // smOriya\n    13: 'x-mac-bengali', // smBengali\n    14: 'x-mac-tamil', // smTamil\n    15: 'x-mac-telugu', // smTelugu\n    16: 'x-mac-kannada', // smKannada\n    17: 'x-mac-malayalam', // smMalayalam\n    18: 'x-mac-sinhalese', // smSinhalese\n    19: 'x-mac-burmese', // smBurmese\n    20: 'x-mac-khmer', // smKhmer\n    21: 'x-mac-thai', // smThai\n    22: 'x-mac-lao', // smLao\n    23: 'x-mac-georgian', // smGeorgian\n    24: 'x-mac-armenian', // smArmenian\n    25: 'x-mac-chinesesimp', // smSimpChinese\n    26: 'x-mac-tibetan', // smTibetan\n    27: 'x-mac-mongolian', // smMongolian\n    28: 'x-mac-ethiopic', // smEthiopic\n    29: 'x-mac-ce', // smCentralEuroRoman\n    30: 'x-mac-vietnamese', // smVietnamese\n    31: 'x-mac-extarabic', // smExtArabic\n  }\n\n  // MacOS language ID  encoding. This table stores the exceptional\n  // cases, which override macScriptEncodings. For writing MacOS naming\n  // tables, we need to emit a MacOS script ID. Therefore, we cannot\n  // merge macScriptEncodings into macLanguageEncodings.\n  //\n  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n  var macLanguageEncodings = {\n    15: 'x-mac-icelandic', // langIcelandic\n    17: 'x-mac-turkish', // langTurkish\n    18: 'x-mac-croatian', // langCroatian\n    24: 'x-mac-ce', // langLithuanian\n    25: 'x-mac-ce', // langPolish\n    26: 'x-mac-ce', // langHungarian\n    27: 'x-mac-ce', // langEstonian\n    28: 'x-mac-ce', // langLatvian\n    30: 'x-mac-icelandic', // langFaroese\n    37: 'x-mac-romanian', // langRomanian\n    38: 'x-mac-ce', // langCzech\n    39: 'x-mac-ce', // langSlovak\n    40: 'x-mac-ce', // langSlovenian\n    143: 'x-mac-inuit', // langInuktitut\n    146: 'x-mac-gaelic', // langIrishGaelicScript\n  }\n\n  function getEncoding(platformID, encodingID, languageID) {\n    switch (platformID) {\n      case 0: // Unicode\n        return utf16\n\n      case 1: // Apple Macintosh\n        return macLanguageEncodings[languageID] || macScriptEncodings[encodingID]\n\n      case 3: // Microsoft Windows\n        if (encodingID === 1 || encodingID === 10) {\n          return utf16\n        }\n\n        break\n    }\n\n    return undefined\n  }\n\n  // Parse the naming `name` table.\n  // FIXME: Format 1 additional fields are not supported yet.\n  // ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\n  function parseNameTable(data, start, ltag) {\n    var name = {}\n    var p = new parse.Parser(data, start)\n    var format = p.parseUShort()\n    var count = p.parseUShort()\n    var stringOffset = p.offset + p.parseUShort()\n    for (var i = 0; i < count; i++) {\n      var platformID = p.parseUShort()\n      var encodingID = p.parseUShort()\n      var languageID = p.parseUShort()\n      var nameID = p.parseUShort()\n      var property = nameTableNames[nameID] || nameID\n      var byteLength = p.parseUShort()\n      var offset = p.parseUShort()\n      var language = getLanguageCode(platformID, languageID, ltag)\n      var encoding = getEncoding(platformID, encodingID, languageID)\n      if (encoding !== undefined && language !== undefined) {\n        var text = void 0\n        if (encoding === utf16) {\n          text = decode.UTF16(data, stringOffset + offset, byteLength)\n        } else {\n          text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding)\n        }\n\n        if (text) {\n          var translations = name[property]\n          if (translations === undefined) {\n            translations = name[property] = {}\n          }\n\n          translations[language] = text\n        }\n      }\n    }\n\n    var langTagCount = 0\n    if (format === 1) {\n      // FIXME: Also handle Microsoft's 'name' table 1.\n      langTagCount = p.parseUShort()\n    }\n\n    return name\n  }\n\n  // {23: 'foo'}  {'foo': 23}\n  // ['bar', 'baz']  {'bar': 0, 'baz': 1}\n  function reverseDict(dict) {\n    var result = {}\n    for (var key in dict) {\n      result[dict[key]] = parseInt(key)\n    }\n\n    return result\n  }\n\n  function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new table.Record('NameRecord', [\n      { name: 'platformID', type: 'USHORT', value: platformID },\n      { name: 'encodingID', type: 'USHORT', value: encodingID },\n      { name: 'languageID', type: 'USHORT', value: languageID },\n      { name: 'nameID', type: 'USHORT', value: nameID },\n      { name: 'length', type: 'USHORT', value: length },\n      { name: 'offset', type: 'USHORT', value: offset },\n    ])\n  }\n\n  // Finds the position of needle in haystack, or -1 if not there.\n  // Like String.indexOf(), but for arrays.\n  function findSubArray(needle, haystack) {\n    var needleLength = needle.length\n    var limit = haystack.length - needleLength + 1\n\n    loop: for (var pos = 0; pos < limit; pos++) {\n      for (; pos < limit; pos++) {\n        for (var k = 0; k < needleLength; k++) {\n          if (haystack[pos + k] !== needle[k]) {\n            continue loop\n          }\n        }\n\n        return pos\n      }\n    }\n\n    return -1\n  }\n\n  function addStringToPool(s, pool) {\n    var offset = findSubArray(s, pool)\n    if (offset < 0) {\n      offset = pool.length\n      var i = 0\n      var len = s.length\n      for (; i < len; ++i) {\n        pool.push(s[i])\n      }\n    }\n\n    return offset\n  }\n\n  function makeNameTable(names, ltag) {\n    var nameID\n    var nameIDs = []\n\n    var namesWithNumericKeys = {}\n    var nameTableIds = reverseDict(nameTableNames)\n    for (var key in names) {\n      var id = nameTableIds[key]\n      if (id === undefined) {\n        id = key\n      }\n\n      nameID = parseInt(id)\n\n      if (isNaN(nameID)) {\n        throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.')\n      }\n\n      namesWithNumericKeys[nameID] = names[key]\n      nameIDs.push(nameID)\n    }\n\n    var macLanguageIds = reverseDict(macLanguages)\n    var windowsLanguageIds = reverseDict(windowsLanguages)\n\n    var nameRecords = []\n    var stringPool = []\n\n    for (var i = 0; i < nameIDs.length; i++) {\n      nameID = nameIDs[i]\n      var translations = namesWithNumericKeys[nameID]\n      for (var lang in translations) {\n        var text = translations[lang]\n\n        // For MacOS, we try to emit the name in the form that was introduced\n        // in the initial version of the TrueType spec (in the late 1980s).\n        // However, this can fail for various reasons: the requested BCP 47\n        // language code might not have an old-style Mac equivalent;\n        // we might not have a codec for the needed character encoding;\n        // or the name might contain characters that cannot be expressed\n        // in the old-style Macintosh encoding. In case of failure, we emit\n        // the name in a more modern fashion (Unicode encoding with BCP 47\n        // language tags) that is recognized by MacOS 10.5, released in 2009.\n        // If fonts were only read by operating systems, we could simply\n        // emit all names in the modern form; this would be much easier.\n        // However, there are many applications and libraries that read\n        // 'name' tables directly, and these will usually only recognize\n        // the ancient form (silently skipping the unrecognized names).\n        var macPlatform = 1 // Macintosh\n        var macLanguage = macLanguageIds[lang]\n        var macScript = macLanguageToScript[macLanguage]\n        var macEncoding = getEncoding(macPlatform, macScript, macLanguage)\n        var macName = encode.MACSTRING(text, macEncoding)\n        if (macName === undefined) {\n          macPlatform = 0 // Unicode\n          macLanguage = ltag.indexOf(lang)\n          if (macLanguage < 0) {\n            macLanguage = ltag.length\n            ltag.push(lang)\n          }\n\n          macScript = 4 // Unicode 2.0 and later\n          macName = encode.UTF16(text)\n        }\n\n        var macNameOffset = addStringToPool(macName, stringPool)\n        nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage, nameID, macName.length, macNameOffset))\n\n        var winLanguage = windowsLanguageIds[lang]\n        if (winLanguage !== undefined) {\n          var winName = encode.UTF16(text)\n          var winNameOffset = addStringToPool(winName, stringPool)\n          nameRecords.push(makeNameRecord(3, 1, winLanguage, nameID, winName.length, winNameOffset))\n        }\n      }\n    }\n\n    nameRecords.sort(function (a, b) {\n      return (\n        a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID\n      )\n    })\n\n    var t = new table.Table('name', [\n      { name: 'format', type: 'USHORT', value: 0 },\n      { name: 'count', type: 'USHORT', value: nameRecords.length },\n      { name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12 },\n    ])\n\n    for (var r = 0; r < nameRecords.length; r++) {\n      t.fields.push({ name: 'record_' + r, type: 'RECORD', value: nameRecords[r] })\n    }\n\n    t.fields.push({ name: 'strings', type: 'LITERAL', value: stringPool })\n    return t\n  }\n\n  var _name = { parse: parseNameTable, make: makeNameTable }\n\n  // The `OS/2` table contains metrics required in OpenType fonts.\n\n  var unicodeRanges = [\n    { begin: 0x0000, end: 0x007f }, // Basic Latin\n    { begin: 0x0080, end: 0x00ff }, // Latin-1 Supplement\n    { begin: 0x0100, end: 0x017f }, // Latin Extended-A\n    { begin: 0x0180, end: 0x024f }, // Latin Extended-B\n    { begin: 0x0250, end: 0x02af }, // IPA Extensions\n    { begin: 0x02b0, end: 0x02ff }, // Spacing Modifier Letters\n    { begin: 0x0300, end: 0x036f }, // Combining Diacritical Marks\n    { begin: 0x0370, end: 0x03ff }, // Greek and Coptic\n    { begin: 0x2c80, end: 0x2cff }, // Coptic\n    { begin: 0x0400, end: 0x04ff }, // Cyrillic\n    { begin: 0x0530, end: 0x058f }, // Armenian\n    { begin: 0x0590, end: 0x05ff }, // Hebrew\n    { begin: 0xa500, end: 0xa63f }, // Vai\n    { begin: 0x0600, end: 0x06ff }, // Arabic\n    { begin: 0x07c0, end: 0x07ff }, // NKo\n    { begin: 0x0900, end: 0x097f }, // Devanagari\n    { begin: 0x0980, end: 0x09ff }, // Bengali\n    { begin: 0x0a00, end: 0x0a7f }, // Gurmukhi\n    { begin: 0x0a80, end: 0x0aff }, // Gujarati\n    { begin: 0x0b00, end: 0x0b7f }, // Oriya\n    { begin: 0x0b80, end: 0x0bff }, // Tamil\n    { begin: 0x0c00, end: 0x0c7f }, // Telugu\n    { begin: 0x0c80, end: 0x0cff }, // Kannada\n    { begin: 0x0d00, end: 0x0d7f }, // Malayalam\n    { begin: 0x0e00, end: 0x0e7f }, // Thai\n    { begin: 0x0e80, end: 0x0eff }, // Lao\n    { begin: 0x10a0, end: 0x10ff }, // Georgian\n    { begin: 0x1b00, end: 0x1b7f }, // Balinese\n    { begin: 0x1100, end: 0x11ff }, // Hangul Jamo\n    { begin: 0x1e00, end: 0x1eff }, // Latin Extended Additional\n    { begin: 0x1f00, end: 0x1fff }, // Greek Extended\n    { begin: 0x2000, end: 0x206f }, // General Punctuation\n    { begin: 0x2070, end: 0x209f }, // Superscripts And Subscripts\n    { begin: 0x20a0, end: 0x20cf }, // Currency Symbol\n    { begin: 0x20d0, end: 0x20ff }, // Combining Diacritical Marks For Symbols\n    { begin: 0x2100, end: 0x214f }, // Letterlike Symbols\n    { begin: 0x2150, end: 0x218f }, // Number Forms\n    { begin: 0x2190, end: 0x21ff }, // Arrows\n    { begin: 0x2200, end: 0x22ff }, // Mathematical Operators\n    { begin: 0x2300, end: 0x23ff }, // Miscellaneous Technical\n    { begin: 0x2400, end: 0x243f }, // Control Pictures\n    { begin: 0x2440, end: 0x245f }, // Optical Character Recognition\n    { begin: 0x2460, end: 0x24ff }, // Enclosed Alphanumerics\n    { begin: 0x2500, end: 0x257f }, // Box Drawing\n    { begin: 0x2580, end: 0x259f }, // Block Elements\n    { begin: 0x25a0, end: 0x25ff }, // Geometric Shapes\n    { begin: 0x2600, end: 0x26ff }, // Miscellaneous Symbols\n    { begin: 0x2700, end: 0x27bf }, // Dingbats\n    { begin: 0x3000, end: 0x303f }, // CJK Symbols And Punctuation\n    { begin: 0x3040, end: 0x309f }, // Hiragana\n    { begin: 0x30a0, end: 0x30ff }, // Katakana\n    { begin: 0x3100, end: 0x312f }, // Bopomofo\n    { begin: 0x3130, end: 0x318f }, // Hangul Compatibility Jamo\n    { begin: 0xa840, end: 0xa87f }, // Phags-pa\n    { begin: 0x3200, end: 0x32ff }, // Enclosed CJK Letters And Months\n    { begin: 0x3300, end: 0x33ff }, // CJK Compatibility\n    { begin: 0xac00, end: 0xd7af }, // Hangul Syllables\n    { begin: 0xd800, end: 0xdfff }, // Non-Plane 0 *\n    { begin: 0x10900, end: 0x1091f }, // Phoenicia\n    { begin: 0x4e00, end: 0x9fff }, // CJK Unified Ideographs\n    { begin: 0xe000, end: 0xf8ff }, // Private Use Area (plane 0)\n    { begin: 0x31c0, end: 0x31ef }, // CJK Strokes\n    { begin: 0xfb00, end: 0xfb4f }, // Alphabetic Presentation Forms\n    { begin: 0xfb50, end: 0xfdff }, // Arabic Presentation Forms-A\n    { begin: 0xfe20, end: 0xfe2f }, // Combining Half Marks\n    { begin: 0xfe10, end: 0xfe1f }, // Vertical Forms\n    { begin: 0xfe50, end: 0xfe6f }, // Small Form Variants\n    { begin: 0xfe70, end: 0xfeff }, // Arabic Presentation Forms-B\n    { begin: 0xff00, end: 0xffef }, // Halfwidth And Fullwidth Forms\n    { begin: 0xfff0, end: 0xffff }, // Specials\n    { begin: 0x0f00, end: 0x0fff }, // Tibetan\n    { begin: 0x0700, end: 0x074f }, // Syriac\n    { begin: 0x0780, end: 0x07bf }, // Thaana\n    { begin: 0x0d80, end: 0x0dff }, // Sinhala\n    { begin: 0x1000, end: 0x109f }, // Myanmar\n    { begin: 0x1200, end: 0x137f }, // Ethiopic\n    { begin: 0x13a0, end: 0x13ff }, // Cherokee\n    { begin: 0x1400, end: 0x167f }, // Unified Canadian Aboriginal Syllabics\n    { begin: 0x1680, end: 0x169f }, // Ogham\n    { begin: 0x16a0, end: 0x16ff }, // Runic\n    { begin: 0x1780, end: 0x17ff }, // Khmer\n    { begin: 0x1800, end: 0x18af }, // Mongolian\n    { begin: 0x2800, end: 0x28ff }, // Braille Patterns\n    { begin: 0xa000, end: 0xa48f }, // Yi Syllables\n    { begin: 0x1700, end: 0x171f }, // Tagalog\n    { begin: 0x10300, end: 0x1032f }, // Old Italic\n    { begin: 0x10330, end: 0x1034f }, // Gothic\n    { begin: 0x10400, end: 0x1044f }, // Deseret\n    { begin: 0x1d000, end: 0x1d0ff }, // Byzantine Musical Symbols\n    { begin: 0x1d400, end: 0x1d7ff }, // Mathematical Alphanumeric Symbols\n    { begin: 0xff000, end: 0xffffd }, // Private Use (plane 15)\n    { begin: 0xfe00, end: 0xfe0f }, // Variation Selectors\n    { begin: 0xe0000, end: 0xe007f }, // Tags\n    { begin: 0x1900, end: 0x194f }, // Limbu\n    { begin: 0x1950, end: 0x197f }, // Tai Le\n    { begin: 0x1980, end: 0x19df }, // New Tai Lue\n    { begin: 0x1a00, end: 0x1a1f }, // Buginese\n    { begin: 0x2c00, end: 0x2c5f }, // Glagolitic\n    { begin: 0x2d30, end: 0x2d7f }, // Tifinagh\n    { begin: 0x4dc0, end: 0x4dff }, // Yijing Hexagram Symbols\n    { begin: 0xa800, end: 0xa82f }, // Syloti Nagri\n    { begin: 0x10000, end: 0x1007f }, // Linear B Syllabary\n    { begin: 0x10140, end: 0x1018f }, // Ancient Greek Numbers\n    { begin: 0x10380, end: 0x1039f }, // Ugaritic\n    { begin: 0x103a0, end: 0x103df }, // Old Persian\n    { begin: 0x10450, end: 0x1047f }, // Shavian\n    { begin: 0x10480, end: 0x104af }, // Osmanya\n    { begin: 0x10800, end: 0x1083f }, // Cypriot Syllabary\n    { begin: 0x10a00, end: 0x10a5f }, // Kharoshthi\n    { begin: 0x1d300, end: 0x1d35f }, // Tai Xuan Jing Symbols\n    { begin: 0x12000, end: 0x123ff }, // Cuneiform\n    { begin: 0x1d360, end: 0x1d37f }, // Counting Rod Numerals\n    { begin: 0x1b80, end: 0x1bbf }, // Sundanese\n    { begin: 0x1c00, end: 0x1c4f }, // Lepcha\n    { begin: 0x1c50, end: 0x1c7f }, // Ol Chiki\n    { begin: 0xa880, end: 0xa8df }, // Saurashtra\n    { begin: 0xa900, end: 0xa92f }, // Kayah Li\n    { begin: 0xa930, end: 0xa95f }, // Rejang\n    { begin: 0xaa00, end: 0xaa5f }, // Cham\n    { begin: 0x10190, end: 0x101cf }, // Ancient Symbols\n    { begin: 0x101d0, end: 0x101ff }, // Phaistos Disc\n    { begin: 0x102a0, end: 0x102df }, // Carian\n    { begin: 0x1f030, end: 0x1f09f }, // Domino Tiles\n  ]\n\n  function getUnicodeRange(unicode) {\n    for (var i = 0; i < unicodeRanges.length; i += 1) {\n      var range = unicodeRanges[i]\n      if (unicode >= range.begin && unicode < range.end) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  // Parse the OS/2 and Windows metrics `OS/2` table\n  function parseOS2Table(data, start) {\n    var os2 = {}\n    var p = new parse.Parser(data, start)\n    os2.version = p.parseUShort()\n    os2.xAvgCharWidth = p.parseShort()\n    os2.usWeightClass = p.parseUShort()\n    os2.usWidthClass = p.parseUShort()\n    os2.fsType = p.parseUShort()\n    os2.ySubscriptXSize = p.parseShort()\n    os2.ySubscriptYSize = p.parseShort()\n    os2.ySubscriptXOffset = p.parseShort()\n    os2.ySubscriptYOffset = p.parseShort()\n    os2.ySuperscriptXSize = p.parseShort()\n    os2.ySuperscriptYSize = p.parseShort()\n    os2.ySuperscriptXOffset = p.parseShort()\n    os2.ySuperscriptYOffset = p.parseShort()\n    os2.yStrikeoutSize = p.parseShort()\n    os2.yStrikeoutPosition = p.parseShort()\n    os2.sFamilyClass = p.parseShort()\n    os2.panose = []\n    for (var i = 0; i < 10; i++) {\n      os2.panose[i] = p.parseByte()\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong()\n    os2.ulUnicodeRange2 = p.parseULong()\n    os2.ulUnicodeRange3 = p.parseULong()\n    os2.ulUnicodeRange4 = p.parseULong()\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte())\n    os2.fsSelection = p.parseUShort()\n    os2.usFirstCharIndex = p.parseUShort()\n    os2.usLastCharIndex = p.parseUShort()\n    os2.sTypoAscender = p.parseShort()\n    os2.sTypoDescender = p.parseShort()\n    os2.sTypoLineGap = p.parseShort()\n    os2.usWinAscent = p.parseUShort()\n    os2.usWinDescent = p.parseUShort()\n    if (os2.version >= 1) {\n      os2.ulCodePageRange1 = p.parseULong()\n      os2.ulCodePageRange2 = p.parseULong()\n    }\n\n    if (os2.version >= 2) {\n      os2.sxHeight = p.parseShort()\n      os2.sCapHeight = p.parseShort()\n      os2.usDefaultChar = p.parseUShort()\n      os2.usBreakChar = p.parseUShort()\n      os2.usMaxContent = p.parseUShort()\n    }\n\n    return os2\n  }\n\n  function makeOS2Table(options) {\n    return new table.Table(\n      'OS/2',\n      [\n        { name: 'version', type: 'USHORT', value: 0x0003 },\n        { name: 'xAvgCharWidth', type: 'SHORT', value: 0 },\n        { name: 'usWeightClass', type: 'USHORT', value: 0 },\n        { name: 'usWidthClass', type: 'USHORT', value: 0 },\n        { name: 'fsType', type: 'USHORT', value: 0 },\n        { name: 'ySubscriptXSize', type: 'SHORT', value: 650 },\n        { name: 'ySubscriptYSize', type: 'SHORT', value: 699 },\n        { name: 'ySubscriptXOffset', type: 'SHORT', value: 0 },\n        { name: 'ySubscriptYOffset', type: 'SHORT', value: 140 },\n        { name: 'ySuperscriptXSize', type: 'SHORT', value: 650 },\n        { name: 'ySuperscriptYSize', type: 'SHORT', value: 699 },\n        { name: 'ySuperscriptXOffset', type: 'SHORT', value: 0 },\n        { name: 'ySuperscriptYOffset', type: 'SHORT', value: 479 },\n        { name: 'yStrikeoutSize', type: 'SHORT', value: 49 },\n        { name: 'yStrikeoutPosition', type: 'SHORT', value: 258 },\n        { name: 'sFamilyClass', type: 'SHORT', value: 0 },\n        { name: 'bFamilyType', type: 'BYTE', value: 0 },\n        { name: 'bSerifStyle', type: 'BYTE', value: 0 },\n        { name: 'bWeight', type: 'BYTE', value: 0 },\n        { name: 'bProportion', type: 'BYTE', value: 0 },\n        { name: 'bContrast', type: 'BYTE', value: 0 },\n        { name: 'bStrokeVariation', type: 'BYTE', value: 0 },\n        { name: 'bArmStyle', type: 'BYTE', value: 0 },\n        { name: 'bLetterform', type: 'BYTE', value: 0 },\n        { name: 'bMidline', type: 'BYTE', value: 0 },\n        { name: 'bXHeight', type: 'BYTE', value: 0 },\n        { name: 'ulUnicodeRange1', type: 'ULONG', value: 0 },\n        { name: 'ulUnicodeRange2', type: 'ULONG', value: 0 },\n        { name: 'ulUnicodeRange3', type: 'ULONG', value: 0 },\n        { name: 'ulUnicodeRange4', type: 'ULONG', value: 0 },\n        { name: 'achVendID', type: 'CHARARRAY', value: 'XXXX' },\n        { name: 'fsSelection', type: 'USHORT', value: 0 },\n        { name: 'usFirstCharIndex', type: 'USHORT', value: 0 },\n        { name: 'usLastCharIndex', type: 'USHORT', value: 0 },\n        { name: 'sTypoAscender', type: 'SHORT', value: 0 },\n        { name: 'sTypoDescender', type: 'SHORT', value: 0 },\n        { name: 'sTypoLineGap', type: 'SHORT', value: 0 },\n        { name: 'usWinAscent', type: 'USHORT', value: 0 },\n        { name: 'usWinDescent', type: 'USHORT', value: 0 },\n        { name: 'ulCodePageRange1', type: 'ULONG', value: 0 },\n        { name: 'ulCodePageRange2', type: 'ULONG', value: 0 },\n        { name: 'sxHeight', type: 'SHORT', value: 0 },\n        { name: 'sCapHeight', type: 'SHORT', value: 0 },\n        { name: 'usDefaultChar', type: 'USHORT', value: 0 },\n        { name: 'usBreakChar', type: 'USHORT', value: 0 },\n        { name: 'usMaxContext', type: 'USHORT', value: 0 },\n      ],\n      options,\n    )\n  }\n\n  var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange }\n\n  // The `post` table stores additional PostScript information, such as glyph names.\n\n  // Parse the PostScript `post` table\n  function parsePostTable(data, start) {\n    var post = {}\n    var p = new parse.Parser(data, start)\n    post.version = p.parseVersion()\n    post.italicAngle = p.parseFixed()\n    post.underlinePosition = p.parseShort()\n    post.underlineThickness = p.parseShort()\n    post.isFixedPitch = p.parseULong()\n    post.minMemType42 = p.parseULong()\n    post.maxMemType42 = p.parseULong()\n    post.minMemType1 = p.parseULong()\n    post.maxMemType1 = p.parseULong()\n    switch (post.version) {\n      case 1:\n        post.names = standardNames.slice()\n        break\n      case 2:\n        post.numberOfGlyphs = p.parseUShort()\n        post.glyphNameIndex = new Array(post.numberOfGlyphs)\n        for (var i = 0; i < post.numberOfGlyphs; i++) {\n          post.glyphNameIndex[i] = p.parseUShort()\n        }\n\n        post.names = []\n        for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n          if (post.glyphNameIndex[i$1] >= standardNames.length) {\n            var nameLength = p.parseChar()\n            post.names.push(p.parseString(nameLength))\n          }\n        }\n\n        break\n      case 2.5:\n        post.numberOfGlyphs = p.parseUShort()\n        post.offset = new Array(post.numberOfGlyphs)\n        for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n          post.offset[i$2] = p.parseChar()\n        }\n\n        break\n    }\n    return post\n  }\n\n  function makePostTable() {\n    return new table.Table('post', [\n      { name: 'version', type: 'FIXED', value: 0x00030000 },\n      { name: 'italicAngle', type: 'FIXED', value: 0 },\n      { name: 'underlinePosition', type: 'FWORD', value: 0 },\n      { name: 'underlineThickness', type: 'FWORD', value: 0 },\n      { name: 'isFixedPitch', type: 'ULONG', value: 0 },\n      { name: 'minMemType42', type: 'ULONG', value: 0 },\n      { name: 'maxMemType42', type: 'ULONG', value: 0 },\n      { name: 'minMemType1', type: 'ULONG', value: 0 },\n      { name: 'maxMemType1', type: 'ULONG', value: 0 },\n    ])\n  }\n\n  var post = { parse: parsePostTable, make: makePostTable }\n\n  // The `GSUB` table contains ligatures, among other things.\n\n  var subtableParsers = new Array(9) // subtableParsers[0] is unused\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\n  subtableParsers[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset\n    var substFormat = this.parseUShort()\n    if (substFormat === 1) {\n      return {\n        substFormat: 1,\n        coverage: this.parsePointer(Parser.coverage),\n        deltaGlyphId: this.parseUShort(),\n      }\n    } else if (substFormat === 2) {\n      return {\n        substFormat: 2,\n        coverage: this.parsePointer(Parser.coverage),\n        substitute: this.parseOffset16List(),\n      }\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.')\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\n  subtableParsers[2] = function parseLookup2() {\n    var substFormat = this.parseUShort()\n    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1')\n    return {\n      substFormat: substFormat,\n      coverage: this.parsePointer(Parser.coverage),\n      sequences: this.parseListOfLists(),\n    }\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\n  subtableParsers[3] = function parseLookup3() {\n    var substFormat = this.parseUShort()\n    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1')\n    return {\n      substFormat: substFormat,\n      coverage: this.parsePointer(Parser.coverage),\n      alternateSets: this.parseListOfLists(),\n    }\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\n  subtableParsers[4] = function parseLookup4() {\n    var substFormat = this.parseUShort()\n    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1')\n    return {\n      substFormat: substFormat,\n      coverage: this.parsePointer(Parser.coverage),\n      ligatureSets: this.parseListOfLists(function () {\n        return {\n          ligGlyph: this.parseUShort(),\n          components: this.parseUShortList(this.parseUShort() - 1),\n        }\n      }),\n    }\n  }\n\n  var lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort,\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\n  subtableParsers[5] = function parseLookup5() {\n    var start = this.offset + this.relativeOffset\n    var substFormat = this.parseUShort()\n\n    if (substFormat === 1) {\n      return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ruleSets: this.parseListOfLists(function () {\n          var glyphCount = this.parseUShort()\n          var substCount = this.parseUShort()\n          return {\n            input: this.parseUShortList(glyphCount - 1),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc),\n          }\n        }),\n      }\n    } else if (substFormat === 2) {\n      return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        classDef: this.parsePointer(Parser.classDef),\n        classSets: this.parseListOfLists(function () {\n          var glyphCount = this.parseUShort()\n          var substCount = this.parseUShort()\n          return {\n            classes: this.parseUShortList(glyphCount - 1),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc),\n          }\n        }),\n      }\n    } else if (substFormat === 3) {\n      var glyphCount = this.parseUShort()\n      var substCount = this.parseUShort()\n      return {\n        substFormat: substFormat,\n        coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n        lookupRecords: this.parseRecordList(substCount, lookupRecordDesc),\n      }\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.')\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\n  subtableParsers[6] = function parseLookup6() {\n    var start = this.offset + this.relativeOffset\n    var substFormat = this.parseUShort()\n    if (substFormat === 1) {\n      return {\n        substFormat: 1,\n        coverage: this.parsePointer(Parser.coverage),\n        chainRuleSets: this.parseListOfLists(function () {\n          return {\n            backtrack: this.parseUShortList(),\n            input: this.parseUShortList(this.parseShort() - 1),\n            lookahead: this.parseUShortList(),\n            lookupRecords: this.parseRecordList(lookupRecordDesc),\n          }\n        }),\n      }\n    } else if (substFormat === 2) {\n      return {\n        substFormat: 2,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackClassDef: this.parsePointer(Parser.classDef),\n        inputClassDef: this.parsePointer(Parser.classDef),\n        lookaheadClassDef: this.parsePointer(Parser.classDef),\n        chainClassSet: this.parseListOfLists(function () {\n          return {\n            backtrack: this.parseUShortList(),\n            input: this.parseUShortList(this.parseShort() - 1),\n            lookahead: this.parseUShortList(),\n            lookupRecords: this.parseRecordList(lookupRecordDesc),\n          }\n        }),\n      }\n    } else if (substFormat === 3) {\n      return {\n        substFormat: 3,\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookupRecords: this.parseRecordList(lookupRecordDesc),\n      }\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.')\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\n  subtableParsers[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    var substFormat = this.parseUShort()\n    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1')\n    var extensionLookupType = this.parseUShort()\n    var extensionParser = new Parser(this.data, this.offset + this.parseULong())\n    return {\n      substFormat: 1,\n      lookupType: extensionLookupType,\n      extension: subtableParsers[extensionLookupType].call(extensionParser),\n    }\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\n  subtableParsers[8] = function parseLookup8() {\n    var substFormat = this.parseUShort()\n    check.argument(\n      substFormat === 1,\n      'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1',\n    )\n    return {\n      substFormat: substFormat,\n      coverage: this.parsePointer(Parser.coverage),\n      backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n      lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n      substitutes: this.parseUShortList(),\n    }\n  }\n\n  // https://www.microsoft.com/typography/OTSPEC/gsub.htm\n  function parseGsubTable(data, start) {\n    start = start || 0\n    var p = new Parser(data, start)\n    var tableVersion = p.parseVersion(1)\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.')\n    if (tableVersion === 1) {\n      return {\n        version: tableVersion,\n        scripts: p.parseScriptList(),\n        features: p.parseFeatureList(),\n        lookups: p.parseLookupList(subtableParsers),\n      }\n    } else {\n      return {\n        version: tableVersion,\n        scripts: p.parseScriptList(),\n        features: p.parseFeatureList(),\n        lookups: p.parseLookupList(subtableParsers),\n        variations: p.parseFeatureVariationsList(),\n      }\n    }\n  }\n\n  // GSUB Writing //////////////////////////////////////////////\n  var subtableMakers = new Array(9)\n\n  subtableMakers[1] = function makeLookup1(subtable) {\n    if (subtable.substFormat === 1) {\n      return new table.Table('substitutionTable', [\n        { name: 'substFormat', type: 'USHORT', value: 1 },\n        { name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage) },\n        { name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId },\n      ])\n    } else {\n      return new table.Table(\n        'substitutionTable',\n        [\n          { name: 'substFormat', type: 'USHORT', value: 2 },\n          { name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage) },\n        ].concat(table.ushortList('substitute', subtable.substitute)),\n      )\n    }\n  }\n\n  subtableMakers[2] = function makeLookup2(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.')\n    return new table.Table(\n      'substitutionTable',\n      [\n        { name: 'substFormat', type: 'USHORT', value: 1 },\n        { name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage) },\n      ].concat(\n        table.tableList('seqSet', subtable.sequences, function (sequenceSet) {\n          return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet))\n        }),\n      ),\n    )\n  }\n\n  subtableMakers[3] = function makeLookup3(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.')\n    return new table.Table(\n      'substitutionTable',\n      [\n        { name: 'substFormat', type: 'USHORT', value: 1 },\n        { name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage) },\n      ].concat(\n        table.tableList('altSet', subtable.alternateSets, function (alternateSet) {\n          return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet))\n        }),\n      ),\n    )\n  }\n\n  subtableMakers[4] = function makeLookup4(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.')\n    return new table.Table(\n      'substitutionTable',\n      [\n        { name: 'substFormat', type: 'USHORT', value: 1 },\n        { name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage) },\n      ].concat(\n        table.tableList('ligSet', subtable.ligatureSets, function (ligatureSet) {\n          return new table.Table(\n            'ligatureSetTable',\n            table.tableList('ligature', ligatureSet, function (ligature) {\n              return new table.Table(\n                'ligatureTable',\n                [{ name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph }].concat(\n                  table.ushortList('component', ligature.components, ligature.components.length + 1),\n                ),\n              )\n            }),\n          )\n        }),\n      ),\n    )\n  }\n\n  subtableMakers[6] = function makeLookup6(subtable) {\n    if (subtable.substFormat === 1) {\n      var returnTable = new table.Table(\n        'chainContextTable',\n        [\n          { name: 'substFormat', type: 'USHORT', value: subtable.substFormat },\n          { name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage) },\n        ].concat(\n          table.tableList('chainRuleSet', subtable.chainRuleSets, function (chainRuleSet) {\n            return new table.Table(\n              'chainRuleSetTable',\n              table.tableList('chainRule', chainRuleSet, function (chainRule) {\n                var tableData = table\n                  .ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)\n                  .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))\n                  .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))\n                  .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length))\n\n                chainRule.lookupRecords.forEach(function (record, i) {\n                  tableData = tableData\n                    .concat({ name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex })\n                    .concat({ name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex })\n                })\n                return new table.Table('chainRuleTable', tableData)\n              }),\n            )\n          }),\n        ),\n      )\n      return returnTable\n    } else if (subtable.substFormat === 2) {\n      check.assert(false, 'lookup type 6 format 2 is not yet supported.')\n    } else if (subtable.substFormat === 3) {\n      var tableData = [{ name: 'substFormat', type: 'USHORT', value: subtable.substFormat }]\n\n      tableData.push({ name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length })\n      subtable.backtrackCoverage.forEach(function (coverage, i) {\n        tableData.push({ name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage) })\n      })\n      tableData.push({ name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length })\n      subtable.inputCoverage.forEach(function (coverage, i) {\n        tableData.push({ name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage) })\n      })\n      tableData.push({ name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length })\n      subtable.lookaheadCoverage.forEach(function (coverage, i) {\n        tableData.push({ name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage) })\n      })\n\n      tableData.push({ name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length })\n      subtable.lookupRecords.forEach(function (record, i) {\n        tableData = tableData\n          .concat({ name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex })\n          .concat({ name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex })\n      })\n\n      var returnTable$1 = new table.Table('chainContextTable', tableData)\n\n      return returnTable$1\n    }\n\n    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.')\n  }\n\n  function makeGsubTable(gsub) {\n    return new table.Table('GSUB', [\n      { name: 'version', type: 'ULONG', value: 0x10000 },\n      { name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts) },\n      { name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features) },\n      { name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers) },\n    ])\n  }\n\n  var gsub = { parse: parseGsubTable, make: makeGsubTable }\n\n  // The `GPOS` table contains kerning pairs, among other things.\n\n  // Parse the metadata `meta` table.\n  // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\n  function parseMetaTable(data, start) {\n    var p = new parse.Parser(data, start)\n    var tableVersion = p.parseULong()\n    check.argument(tableVersion === 1, 'Unsupported META table version.')\n    p.parseULong() // flags - currently unused and set to 0\n    p.parseULong() // tableOffset\n    var numDataMaps = p.parseULong()\n\n    var tags = {}\n    for (var i = 0; i < numDataMaps; i++) {\n      var tag = p.parseTag()\n      var dataOffset = p.parseULong()\n      var dataLength = p.parseULong()\n      var text = decode.UTF8(data, start + dataOffset, dataLength)\n\n      tags[tag] = text\n    }\n    return tags\n  }\n\n  function makeMetaTable(tags) {\n    var numTags = Object.keys(tags).length\n    var stringPool = ''\n    var stringPoolOffset = 16 + numTags * 12\n\n    var result = new table.Table('meta', [\n      { name: 'version', type: 'ULONG', value: 1 },\n      { name: 'flags', type: 'ULONG', value: 0 },\n      { name: 'offset', type: 'ULONG', value: stringPoolOffset },\n      { name: 'numTags', type: 'ULONG', value: numTags },\n    ])\n\n    for (var tag in tags) {\n      var pos = stringPool.length\n      stringPool += tags[tag]\n\n      result.fields.push({ name: 'tag ' + tag, type: 'TAG', value: tag })\n      result.fields.push({ name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos })\n      result.fields.push({ name: 'length ' + tag, type: 'ULONG', value: tags[tag].length })\n    }\n\n    result.fields.push({ name: 'stringPool', type: 'CHARARRAY', value: stringPool })\n\n    return result\n  }\n\n  var meta = { parse: parseMetaTable, make: makeMetaTable }\n\n  // The `sfnt` wrapper provides organization for the tables in the font.\n\n  function log2(v) {\n    return (Math.log(v) / Math.log(2)) | 0\n  }\n\n  function computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n      bytes.push(0)\n    }\n\n    var sum = 0\n    for (var i = 0; i < bytes.length; i += 4) {\n      sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3]\n    }\n\n    sum %= Math.pow(2, 32)\n    return sum\n  }\n\n  function makeTableRecord(tag, checkSum, offset, length) {\n    return new table.Record('Table Record', [\n      { name: 'tag', type: 'TAG', value: tag !== undefined ? tag : '' },\n      { name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0 },\n      { name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0 },\n      { name: 'length', type: 'ULONG', value: length !== undefined ? length : 0 },\n    ])\n  }\n\n  function makeSfntTable(tables) {\n    var sfnt = new table.Table('sfnt', [\n      { name: 'version', type: 'TAG', value: 'OTTO' },\n      { name: 'numTables', type: 'USHORT', value: 0 },\n      { name: 'searchRange', type: 'USHORT', value: 0 },\n      { name: 'entrySelector', type: 'USHORT', value: 0 },\n      { name: 'rangeShift', type: 'USHORT', value: 0 },\n    ])\n    sfnt.tables = tables\n    sfnt.numTables = tables.length\n    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables))\n    sfnt.searchRange = 16 * highestPowerOf2\n    sfnt.entrySelector = log2(highestPowerOf2)\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange\n\n    var recordFields = []\n    var tableFields = []\n\n    var offset = sfnt.sizeOf() + makeTableRecord().sizeOf() * sfnt.numTables\n    while (offset % 4 !== 0) {\n      offset += 1\n      tableFields.push({ name: 'padding', type: 'BYTE', value: 0 })\n    }\n\n    for (var i = 0; i < tables.length; i += 1) {\n      var t = tables[i]\n      check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.')\n      var tableLength = t.sizeOf()\n      var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength)\n      recordFields.push({ name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord })\n      tableFields.push({ name: t.tableName + ' table', type: 'RECORD', value: t })\n      offset += tableLength\n      check.argument(!isNaN(offset), 'Something went wrong calculating the offset.')\n      while (offset % 4 !== 0) {\n        offset += 1\n        tableFields.push({ name: 'padding', type: 'BYTE', value: 0 })\n      }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function (r1, r2) {\n      if (r1.value.tag > r2.value.tag) {\n        return 1\n      } else {\n        return -1\n      }\n    })\n\n    sfnt.fields = sfnt.fields.concat(recordFields)\n    sfnt.fields = sfnt.fields.concat(tableFields)\n    return sfnt\n  }\n\n  // Get the metrics for a character. If the string has more than one character\n  // this function returns metrics for the first available character.\n  // You can provide optional fallback metrics if no characters are available.\n  function metricsForChar(font, chars, notFoundMetrics) {\n    for (var i = 0; i < chars.length; i += 1) {\n      var glyphIndex = font.charToGlyphIndex(chars[i])\n      if (glyphIndex > 0) {\n        var glyph = font.glyphs.get(glyphIndex)\n        return glyph.getMetrics()\n      }\n    }\n\n    return notFoundMetrics\n  }\n\n  function average(vs) {\n    var sum = 0\n    for (var i = 0; i < vs.length; i += 1) {\n      sum += vs[i]\n    }\n\n    return sum / vs.length\n  }\n\n  // Convert the font object to a SFNT data structure.\n  // This structure contains all the necessary tables and metadata to create a binary OTF file.\n  function fontToSfntTable(font) {\n    var xMins = []\n    var yMins = []\n    var xMaxs = []\n    var yMaxs = []\n    var advanceWidths = []\n    var leftSideBearings = []\n    var rightSideBearings = []\n    var firstCharIndex\n    var lastCharIndex = 0\n    var ulUnicodeRange1 = 0\n    var ulUnicodeRange2 = 0\n    var ulUnicodeRange3 = 0\n    var ulUnicodeRange4 = 0\n\n    for (var i = 0; i < font.glyphs.length; i += 1) {\n      var glyph = font.glyphs.get(i)\n      var unicode = glyph.unicode | 0\n\n      if (isNaN(glyph.advanceWidth)) {\n        throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.')\n      }\n\n      if (firstCharIndex > unicode || firstCharIndex === undefined) {\n        // ignore .notdef char\n        if (unicode > 0) {\n          firstCharIndex = unicode\n        }\n      }\n\n      if (lastCharIndex < unicode) {\n        lastCharIndex = unicode\n      }\n\n      var position = os2.getUnicodeRange(unicode)\n      if (position < 32) {\n        ulUnicodeRange1 |= 1 << position\n      } else if (position < 64) {\n        ulUnicodeRange2 |= 1 << (position - 32)\n      } else if (position < 96) {\n        ulUnicodeRange3 |= 1 << (position - 64)\n      } else if (position < 123) {\n        ulUnicodeRange4 |= 1 << (position - 96)\n      } else {\n        throw new Error('Unicode ranges bits > 123 are reserved for internal usage')\n      }\n      // Skip non-important characters.\n      if (glyph.name === '.notdef') {\n        continue\n      }\n      var metrics = glyph.getMetrics()\n      xMins.push(metrics.xMin)\n      yMins.push(metrics.yMin)\n      xMaxs.push(metrics.xMax)\n      yMaxs.push(metrics.yMax)\n      leftSideBearings.push(metrics.leftSideBearing)\n      rightSideBearings.push(metrics.rightSideBearing)\n      advanceWidths.push(glyph.advanceWidth)\n    }\n\n    var globals = {\n      xMin: Math.min.apply(null, xMins),\n      yMin: Math.min.apply(null, yMins),\n      xMax: Math.max.apply(null, xMaxs),\n      yMax: Math.max.apply(null, yMaxs),\n      advanceWidthMax: Math.max.apply(null, advanceWidths),\n      advanceWidthAvg: average(advanceWidths),\n      minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n      maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n      minRightSideBearing: Math.min.apply(null, rightSideBearings),\n    }\n    globals.ascender = font.ascender\n    globals.descender = font.descender\n\n    var headTable = head.make({\n      flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n      unitsPerEm: font.unitsPerEm,\n      xMin: globals.xMin,\n      yMin: globals.yMin,\n      xMax: globals.xMax,\n      yMax: globals.yMax,\n      lowestRecPPEM: 3,\n      createdTimestamp: font.createdTimestamp,\n    })\n\n    var hheaTable = hhea.make({\n      ascender: globals.ascender,\n      descender: globals.descender,\n      advanceWidthMax: globals.advanceWidthMax,\n      minLeftSideBearing: globals.minLeftSideBearing,\n      minRightSideBearing: globals.minRightSideBearing,\n      xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n      numberOfHMetrics: font.glyphs.length,\n    })\n\n    var maxpTable = maxp.make(font.glyphs.length)\n\n    var os2Table = os2.make(\n      Object.assign(\n        {\n          xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n          usFirstCharIndex: firstCharIndex,\n          usLastCharIndex: lastCharIndex,\n          ulUnicodeRange1: ulUnicodeRange1,\n          ulUnicodeRange2: ulUnicodeRange2,\n          ulUnicodeRange3: ulUnicodeRange3,\n          ulUnicodeRange4: ulUnicodeRange4,\n          // See http://typophile.com/node/13081 for more info on vertical metrics.\n          // We get metrics for typical characters (such as \"x\" for xHeight).\n          // We provide some fallback characters if characters are unavailable: their\n          // ordering was chosen experimentally.\n          sTypoAscender: globals.ascender,\n          sTypoDescender: globals.descender,\n          sTypoLineGap: 0,\n          usWinAscent: globals.yMax,\n          usWinDescent: Math.abs(globals.yMin),\n          ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n          sxHeight: metricsForChar(font, 'xyvw', { yMax: Math.round(globals.ascender / 2) }).yMax,\n          sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n          usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n          usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.\n        },\n        font.tables.os2,\n      ),\n    )\n\n    var hmtxTable = hmtx.make(font.glyphs)\n    var cmapTable = cmap.make(font.glyphs)\n\n    var englishFamilyName = font.getEnglishName('fontFamily')\n    var englishStyleName = font.getEnglishName('fontSubfamily')\n    var englishFullName = englishFamilyName + ' ' + englishStyleName\n    var postScriptName = font.getEnglishName('postScriptName')\n    if (!postScriptName) {\n      postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName\n    }\n\n    var names = {}\n    for (var n in font.names) {\n      names[n] = font.names[n]\n    }\n\n    if (!names.uniqueID) {\n      names.uniqueID = { en: font.getEnglishName('manufacturer') + ':' + englishFullName }\n    }\n\n    if (!names.postScriptName) {\n      names.postScriptName = { en: postScriptName }\n    }\n\n    if (!names.preferredFamily) {\n      names.preferredFamily = font.names.fontFamily\n    }\n\n    if (!names.preferredSubfamily) {\n      names.preferredSubfamily = font.names.fontSubfamily\n    }\n\n    var languageTags = []\n    var nameTable = _name.make(names, languageTags)\n    var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : undefined\n\n    var postTable = post.make()\n    var cffTable = cff.make(font.glyphs, {\n      version: font.getEnglishName('version'),\n      fullName: englishFullName,\n      familyName: englishFamilyName,\n      weightName: englishStyleName,\n      postScriptName: postScriptName,\n      unitsPerEm: font.unitsPerEm,\n      fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax],\n    })\n\n    var metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : undefined\n\n    // The order does not matter because makeSfntTable() will sort them.\n    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable]\n    if (ltagTable) {\n      tables.push(ltagTable)\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n      tables.push(gsub.make(font.tables.gsub))\n    }\n    if (metaTable) {\n      tables.push(metaTable)\n    }\n\n    var sfntTable = makeSfntTable(tables)\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    var bytes = sfntTable.encode()\n    var checkSum = computeCheckSum(bytes)\n    var tableFields = sfntTable.fields\n    var checkSumAdjusted = false\n    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n      if (tableFields[i$1].name === 'head table') {\n        tableFields[i$1].value.checkSumAdjustment = 0xb1b0afba - checkSum\n        checkSumAdjusted = true\n        break\n      }\n    }\n\n    if (!checkSumAdjusted) {\n      throw new Error('Could not find head table with checkSum to adjust.')\n    }\n\n    return sfntTable\n  }\n\n  var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum }\n\n  // The Layout object is the prototype of Substitution objects, and provides\n\n  function searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    var imin = 0\n    var imax = arr.length - 1\n    while (imin <= imax) {\n      var imid = (imin + imax) >>> 1\n      var val = arr[imid].tag\n      if (val === tag) {\n        return imid\n      } else if (val < tag) {\n        imin = imid + 1\n      } else {\n        imax = imid - 1\n      }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1\n  }\n\n  function binSearch(arr, value) {\n    /* jshint bitwise: false */\n    var imin = 0\n    var imax = arr.length - 1\n    while (imin <= imax) {\n      var imid = (imin + imax) >>> 1\n      var val = arr[imid]\n      if (val === value) {\n        return imid\n      } else if (val < value) {\n        imin = imid + 1\n      } else {\n        imax = imid - 1\n      }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1\n  }\n\n  // binary search in a list of ranges (coverage, class definition)\n  function searchRange(ranges, value) {\n    // jshint bitwise: false\n    var range\n    var imin = 0\n    var imax = ranges.length - 1\n    while (imin <= imax) {\n      var imid = (imin + imax) >>> 1\n      range = ranges[imid]\n      var start = range.start\n      if (start === value) {\n        return range\n      } else if (start < value) {\n        imin = imid + 1\n      } else {\n        imax = imid - 1\n      }\n    }\n    if (imin > 0) {\n      range = ranges[imin - 1]\n      if (value > range.end) {\n        return 0\n      }\n      return range\n    }\n  }\n\n  /**\n   * @exports opentype.Layout\n   * @class\n   */\n  function Layout(font, tableName) {\n    this.font = font\n    this.tableName = tableName\n  }\n\n  Layout.prototype = {\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function (create) {\n      var layout = this.font.tables[this.tableName]\n      if (!layout && create) {\n        layout = this.font.tables[this.tableName] = this.createDefaultTable()\n      }\n      return layout\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function () {\n      var layout = this.getTable()\n      if (!layout) {\n        return []\n      }\n      return layout.scripts.map(function (script) {\n        return script.tag\n      })\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function () {\n      var layout = this.getTable()\n      if (!layout) {\n        return\n      }\n      var hasLatn = false\n      for (var i = 0; i < layout.scripts.length; i++) {\n        var name = layout.scripts[i].tag\n        if (name === 'DFLT') {\n          return name\n        }\n        if (name === 'latn') {\n          hasLatn = true\n        }\n      }\n      if (hasLatn) {\n        return 'latn'\n      }\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function (script, create) {\n      var layout = this.getTable(create)\n      if (layout) {\n        script = script || 'DFLT'\n        var scripts = layout.scripts\n        var pos = searchTag(layout.scripts, script)\n        if (pos >= 0) {\n          return scripts[pos].script\n        } else if (create) {\n          var scr = {\n            tag: script,\n            script: {\n              defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n              langSysRecords: [],\n            },\n          }\n          scripts.splice(-1 - pos, 0, scr)\n          return scr.script\n        }\n      }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function (script, language, create) {\n      var scriptTable = this.getScriptTable(script, create)\n      if (scriptTable) {\n        if (!language || language === 'dflt' || language === 'DFLT') {\n          return scriptTable.defaultLangSys\n        }\n        var pos = searchTag(scriptTable.langSysRecords, language)\n        if (pos >= 0) {\n          return scriptTable.langSysRecords[pos].langSys\n        } else if (create) {\n          var langSysRecord = {\n            tag: language,\n            langSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n          }\n          scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord)\n          return langSysRecord.langSys\n        }\n      }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function (script, language, feature, create) {\n      var langSysTable = this.getLangSysTable(script, language, create)\n      if (langSysTable) {\n        var featureRecord\n        var featIndexes = langSysTable.featureIndexes\n        var allFeatures = this.font.tables[this.tableName].features\n        // The FeatureIndex array of indices is in arbitrary order,\n        // even if allFeatures is sorted alphabetically by feature tag.\n        for (var i = 0; i < featIndexes.length; i++) {\n          featureRecord = allFeatures[featIndexes[i]]\n          if (featureRecord.tag === feature) {\n            return featureRecord.feature\n          }\n        }\n        if (create) {\n          var index = allFeatures.length\n          // Automatic ordering of features would require to shift feature indexes in the script list.\n          check.assert(\n            index === 0 || feature >= allFeatures[index - 1].tag,\n            'Features must be added in alphabetical order.',\n          )\n          featureRecord = {\n            tag: feature,\n            feature: { params: 0, lookupListIndexes: [] },\n          }\n          allFeatures.push(featureRecord)\n          featIndexes.push(index)\n          return featureRecord.feature\n        }\n      }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 9\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function (script, language, feature, lookupType, create) {\n      var featureTable = this.getFeatureTable(script, language, feature, create)\n      var tables = []\n      if (featureTable) {\n        var lookupTable\n        var lookupListIndexes = featureTable.lookupListIndexes\n        var allLookups = this.font.tables[this.tableName].lookups\n        // lookupListIndexes are in no particular order, so use naive search.\n        for (var i = 0; i < lookupListIndexes.length; i++) {\n          lookupTable = allLookups[lookupListIndexes[i]]\n          if (lookupTable.lookupType === lookupType) {\n            tables.push(lookupTable)\n          }\n        }\n        if (tables.length === 0 && create) {\n          lookupTable = {\n            lookupType: lookupType,\n            lookupFlag: 0,\n            subtables: [],\n            markFilteringSet: undefined,\n          }\n          var index = allLookups.length\n          allLookups.push(lookupTable)\n          lookupListIndexes.push(index)\n          return [lookupTable]\n        }\n      }\n      return tables\n    },\n\n    /**\n     * Find a glyph in a class definition table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n     * @param {object} classDefTable - an OpenType Layout class definition table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getGlyphClass: function (classDefTable, glyphIndex) {\n      switch (classDefTable.format) {\n        case 1:\n          if (\n            classDefTable.startGlyph <= glyphIndex &&\n            glyphIndex < classDefTable.startGlyph + classDefTable.classes.length\n          ) {\n            return classDefTable.classes[glyphIndex - classDefTable.startGlyph]\n          }\n          return 0\n        case 2:\n          var range = searchRange(classDefTable.ranges, glyphIndex)\n          return range ? range.classId : 0\n      }\n    },\n\n    /**\n     * Find a glyph in a coverage table\n     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n     * @param {object} coverageTable - an OpenType Layout coverage table\n     * @param {number} glyphIndex - the index of the glyph to find\n     * @returns {number} -1 if not found\n     */\n    getCoverageIndex: function (coverageTable, glyphIndex) {\n      switch (coverageTable.format) {\n        case 1:\n          var index = binSearch(coverageTable.glyphs, glyphIndex)\n          return index >= 0 ? index : -1\n        case 2:\n          var range = searchRange(coverageTable.ranges, glyphIndex)\n          return range ? range.index + glyphIndex - range.start : -1\n      }\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function (coverageTable) {\n      if (coverageTable.format === 1) {\n        return coverageTable.glyphs\n      } else {\n        var glyphs = []\n        var ranges = coverageTable.ranges\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i]\n          var start = range.start\n          var end = range.end\n          for (var j = start; j <= end; j++) {\n            glyphs.push(j)\n          }\n        }\n        return glyphs\n      }\n    },\n  }\n\n  // The Position object provides utility methods to manipulate\n\n  /**\n   * @exports opentype.Position\n   * @class\n   * @extends opentype.Layout\n   * @param {opentype.Font}\n   * @constructor\n   */\n  function Position(font) {\n    Layout.call(this, font, 'gpos')\n  }\n\n  Position.prototype = Layout.prototype\n\n  /**\n   * Init some data for faster and easier access later.\n   */\n  Position.prototype.init = function () {\n    var script = this.getDefaultScriptName()\n    this.defaultKerningTables = this.getKerningTables(script)\n  }\n\n  /**\n   * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n   *\n   * @param {integer} leftIndex - left glyph index\n   * @param {integer} rightIndex - right glyph index\n   * @returns {integer}\n   */\n  Position.prototype.getKerningValue = function (kerningLookups, leftIndex, rightIndex) {\n    for (var i = 0; i < kerningLookups.length; i++) {\n      var subtables = kerningLookups[i].subtables\n      for (var j = 0; j < subtables.length; j++) {\n        var subtable = subtables[j]\n        var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex)\n        if (covIndex < 0) {\n          continue\n        }\n        switch (subtable.posFormat) {\n          case 1:\n            // Search Pair Adjustment Positioning Format 1\n            var pairSet = subtable.pairSets[covIndex]\n            for (var k = 0; k < pairSet.length; k++) {\n              var pair = pairSet[k]\n              if (pair.secondGlyph === rightIndex) {\n                return (pair.value1 && pair.value1.xAdvance) || 0\n              }\n            }\n            break // left glyph found, not right glyph - try next subtable\n          case 2:\n            // Search Pair Adjustment Positioning Format 2\n            var class1 = this.getGlyphClass(subtable.classDef1, leftIndex)\n            var class2 = this.getGlyphClass(subtable.classDef2, rightIndex)\n            var pair$1 = subtable.classRecords[class1][class2]\n            return (pair$1.value1 && pair$1.value1.xAdvance) || 0\n        }\n      }\n    }\n    return 0\n  }\n\n  /**\n   * List all kerning lookup tables.\n   *\n   * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n   * @param {string} [language='dflt']\n   * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n   */\n  Position.prototype.getKerningTables = function (script, language) {\n    if (this.font.tables.gpos) {\n      return this.getLookupTables(script, language, 'kern', 2)\n    }\n  }\n\n  // The Substitution object provides utility methods to manipulate\n\n  /**\n   * @exports opentype.Substitution\n   * @class\n   * @extends opentype.Layout\n   * @param {opentype.Font}\n   * @constructor\n   */\n  function Substitution(font) {\n    Layout.call(this, font, 'gsub')\n  }\n\n  // Check if 2 arrays of primitives are equal.\n  function arraysEqual(ar1, ar2) {\n    var n = ar1.length\n    if (n !== ar2.length) {\n      return false\n    }\n    for (var i = 0; i < n; i++) {\n      if (ar1[i] !== ar2[i]) {\n        return false\n      }\n    }\n    return true\n  }\n\n  // Find the first subtable of a lookup table in a particular format.\n  function getSubstFormat(lookupTable, format, defaultSubtable) {\n    var subtables = lookupTable.subtables\n    for (var i = 0; i < subtables.length; i++) {\n      var subtable = subtables[i]\n      if (subtable.substFormat === format) {\n        return subtable\n      }\n    }\n    if (defaultSubtable) {\n      subtables.push(defaultSubtable)\n      return defaultSubtable\n    }\n    return undefined\n  }\n\n  Substitution.prototype = Layout.prototype\n\n  /**\n   * Create a default GSUB table.\n   * @return {Object} gsub - The GSUB table.\n   */\n  Substitution.prototype.createDefaultTable = function () {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n      version: 1,\n      scripts: [\n        {\n          tag: 'DFLT',\n          script: {\n            defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n            langSysRecords: [],\n          },\n        },\n      ],\n      features: [],\n      lookups: [],\n    }\n  }\n\n  /**\n   * List all single substitutions (lookup type 1) for a given script, language, and feature.\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n   * @return {Array} substitutions - The list of substitutions.\n   */\n  Substitution.prototype.getSingle = function (feature, script, language) {\n    var substitutions = []\n    var lookupTables = this.getLookupTables(script, language, feature, 1)\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n      var subtables = lookupTables[idx].subtables\n      for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i]\n        var glyphs = this.expandCoverage(subtable.coverage)\n        var j = void 0\n        if (subtable.substFormat === 1) {\n          var delta = subtable.deltaGlyphId\n          for (j = 0; j < glyphs.length; j++) {\n            var glyph = glyphs[j]\n            substitutions.push({ sub: glyph, by: glyph + delta })\n          }\n        } else {\n          var substitute = subtable.substitute\n          for (j = 0; j < glyphs.length; j++) {\n            substitutions.push({ sub: glyphs[j], by: substitute[j] })\n          }\n        }\n      }\n    }\n    return substitutions\n  }\n\n  /**\n   * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n   * @return {Array} substitutions - The list of substitutions.\n   */\n  Substitution.prototype.getMultiple = function (feature, script, language) {\n    var substitutions = []\n    var lookupTables = this.getLookupTables(script, language, feature, 2)\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n      var subtables = lookupTables[idx].subtables\n      for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i]\n        var glyphs = this.expandCoverage(subtable.coverage)\n        var j = void 0\n\n        for (j = 0; j < glyphs.length; j++) {\n          var glyph = glyphs[j]\n          var replacements = subtable.sequences[j]\n          substitutions.push({ sub: glyph, by: replacements })\n        }\n      }\n    }\n    return substitutions\n  }\n\n  /**\n   * List all alternates (lookup type 3) for a given script, language, and feature.\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n   * @return {Array} alternates - The list of alternates\n   */\n  Substitution.prototype.getAlternates = function (feature, script, language) {\n    var alternates = []\n    var lookupTables = this.getLookupTables(script, language, feature, 3)\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n      var subtables = lookupTables[idx].subtables\n      for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i]\n        var glyphs = this.expandCoverage(subtable.coverage)\n        var alternateSets = subtable.alternateSets\n        for (var j = 0; j < glyphs.length; j++) {\n          alternates.push({ sub: glyphs[j], by: alternateSets[j] })\n        }\n      }\n    }\n    return alternates\n  }\n\n  /**\n   * List all ligatures (lookup type 4) for a given script, language, and feature.\n   * The result is an array of ligature objects like { sub: [ids], by: id }\n   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   * @return {Array} ligatures - The list of ligatures.\n   */\n  Substitution.prototype.getLigatures = function (feature, script, language) {\n    var ligatures = []\n    var lookupTables = this.getLookupTables(script, language, feature, 4)\n    for (var idx = 0; idx < lookupTables.length; idx++) {\n      var subtables = lookupTables[idx].subtables\n      for (var i = 0; i < subtables.length; i++) {\n        var subtable = subtables[i]\n        var glyphs = this.expandCoverage(subtable.coverage)\n        var ligatureSets = subtable.ligatureSets\n        for (var j = 0; j < glyphs.length; j++) {\n          var startGlyph = glyphs[j]\n          var ligSet = ligatureSets[j]\n          for (var k = 0; k < ligSet.length; k++) {\n            var lig = ligSet[k]\n            ligatures.push({\n              sub: [startGlyph].concat(lig.components),\n              by: lig.ligGlyph,\n            })\n          }\n        }\n      }\n    }\n    return ligatures\n  }\n\n  /**\n   * Add or modify a single substitution (lookup type 1)\n   * Format 2, more flexible, is always used.\n   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n   * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   */\n  Substitution.prototype.addSingle = function (feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0]\n    var subtable = getSubstFormat(lookupTable, 2, {\n      // lookup type 1 subtable, format 2, coverage format 1\n      substFormat: 2,\n      coverage: { format: 1, glyphs: [] },\n      substitute: [],\n    })\n    check.assert(\n      subtable.coverage.format === 1,\n      'Single: unable to modify coverage table format ' + subtable.coverage.format,\n    )\n    var coverageGlyph = substitution.sub\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph)\n    if (pos < 0) {\n      pos = -1 - pos\n      subtable.coverage.glyphs.splice(pos, 0, coverageGlyph)\n      subtable.substitute.splice(pos, 0, 0)\n    }\n    subtable.substitute[pos] = substitution.by\n  }\n\n  /**\n   * Add or modify a multiple substitution (lookup type 2)\n   * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n   * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   */\n  Substitution.prototype.addMultiple = function (feature, substitution, script, language) {\n    check.assert(\n      substitution.by instanceof Array && substitution.by.length > 1,\n      'Multiple: \"by\" must be an array of two or more ids',\n    )\n    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0]\n    var subtable = getSubstFormat(lookupTable, 1, {\n      // lookup type 2 subtable, format 1, coverage format 1\n      substFormat: 1,\n      coverage: { format: 1, glyphs: [] },\n      sequences: [],\n    })\n    check.assert(\n      subtable.coverage.format === 1,\n      'Multiple: unable to modify coverage table format ' + subtable.coverage.format,\n    )\n    var coverageGlyph = substitution.sub\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph)\n    if (pos < 0) {\n      pos = -1 - pos\n      subtable.coverage.glyphs.splice(pos, 0, coverageGlyph)\n      subtable.sequences.splice(pos, 0, 0)\n    }\n    subtable.sequences[pos] = substitution.by\n  }\n\n  /**\n   * Add or modify an alternate substitution (lookup type 3)\n   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n   * @param {Object} substitution - { sub: id, by: [ids] }\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   */\n  Substitution.prototype.addAlternate = function (feature, substitution, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0]\n    var subtable = getSubstFormat(lookupTable, 1, {\n      // lookup type 3 subtable, format 1, coverage format 1\n      substFormat: 1,\n      coverage: { format: 1, glyphs: [] },\n      alternateSets: [],\n    })\n    check.assert(\n      subtable.coverage.format === 1,\n      'Alternate: unable to modify coverage table format ' + subtable.coverage.format,\n    )\n    var coverageGlyph = substitution.sub\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph)\n    if (pos < 0) {\n      pos = -1 - pos\n      subtable.coverage.glyphs.splice(pos, 0, coverageGlyph)\n      subtable.alternateSets.splice(pos, 0, 0)\n    }\n    subtable.alternateSets[pos] = substitution.by\n  }\n\n  /**\n   * Add a ligature (lookup type 4)\n   * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n   * @param {Object} ligature - { sub: [ids], by: id }\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   */\n  Substitution.prototype.addLigature = function (feature, ligature, script, language) {\n    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0]\n    var subtable = lookupTable.subtables[0]\n    if (!subtable) {\n      subtable = {\n        // lookup type 4 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: { format: 1, glyphs: [] },\n        ligatureSets: [],\n      }\n      lookupTable.subtables[0] = subtable\n    }\n    check.assert(\n      subtable.coverage.format === 1,\n      'Ligature: unable to modify coverage table format ' + subtable.coverage.format,\n    )\n    var coverageGlyph = ligature.sub[0]\n    var ligComponents = ligature.sub.slice(1)\n    var ligatureTable = {\n      ligGlyph: ligature.by,\n      components: ligComponents,\n    }\n    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph)\n    if (pos >= 0) {\n      // ligatureSet already exists\n      var ligatureSet = subtable.ligatureSets[pos]\n      for (var i = 0; i < ligatureSet.length; i++) {\n        // If ligature already exists, return.\n        if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n          return\n        }\n      }\n      // ligature does not exist: add it.\n      ligatureSet.push(ligatureTable)\n    } else {\n      // Create a new ligatureSet and add coverage for the first glyph.\n      pos = -1 - pos\n      subtable.coverage.glyphs.splice(pos, 0, coverageGlyph)\n      subtable.ligatureSets.splice(pos, 0, [ligatureTable])\n    }\n  }\n\n  /**\n   * List all feature data for a given script and language.\n   * @param {string} feature - 4-letter feature name\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   * @return {Array} substitutions - The list of substitutions.\n   */\n  Substitution.prototype.getFeature = function (feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n      // ss01 - ss20\n      return this.getSingle(feature, script, language)\n    }\n    switch (feature) {\n      case 'aalt':\n      case 'salt':\n        return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language))\n      case 'dlig':\n      case 'liga':\n      case 'rlig':\n        return this.getLigatures(feature, script, language)\n      case 'ccmp':\n        return this.getMultiple(feature, script, language).concat(this.getLigatures(feature, script, language))\n      case 'stch':\n        return this.getMultiple(feature, script, language)\n    }\n    return undefined\n  }\n\n  /**\n   * Add a substitution to a feature for a given script and language.\n   * @param {string} feature - 4-letter feature name\n   * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n   * @param {string} [script='DFLT']\n   * @param {string} [language='dflt']\n   */\n  Substitution.prototype.add = function (feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {\n      // ss01 - ss20\n      return this.addSingle(feature, sub, script, language)\n    }\n    switch (feature) {\n      case 'aalt':\n      case 'salt':\n        if (typeof sub.by === 'number') {\n          return this.addSingle(feature, sub, script, language)\n        }\n        return this.addAlternate(feature, sub, script, language)\n      case 'dlig':\n      case 'liga':\n      case 'rlig':\n        return this.addLigature(feature, sub, script, language)\n      case 'ccmp':\n        if (sub.by instanceof Array) {\n          return this.addMultiple(feature, sub, script, language)\n        }\n        return this.addLigature(feature, sub, script, language)\n    }\n    return undefined\n  }\n\n  function checkArgument(expression, message) {\n    if (!expression) {\n      throw message\n    }\n  }\n\n  // The `glyf` table describes the glyphs in TrueType outline format.\n\n  // Parse the coordinate data for a glyph.\n  function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    var v\n    if ((flag & shortVectorBitMask) > 0) {\n      // The coordinate is 1 byte long.\n      v = p.parseByte()\n      // The `same` bit is re-used for short values to signify the sign of the value.\n      if ((flag & sameBitMask) === 0) {\n        v = -v\n      }\n\n      v = previousValue + v\n    } else {\n      //  The coordinate is 2 bytes long.\n      // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n      if ((flag & sameBitMask) > 0) {\n        v = previousValue\n      } else {\n        // Parse the coordinate as a signed 16-bit delta value.\n        v = previousValue + p.parseShort()\n      }\n    }\n\n    return v\n  }\n\n  // Parse a TrueType glyph.\n  function parseGlyph(glyph, data, start) {\n    var p = new parse.Parser(data, start)\n    glyph.numberOfContours = p.parseShort()\n    glyph._xMin = p.parseShort()\n    glyph._yMin = p.parseShort()\n    glyph._xMax = p.parseShort()\n    glyph._yMax = p.parseShort()\n    var flags\n    var flag\n\n    if (glyph.numberOfContours > 0) {\n      // This glyph is not a composite.\n      var endPointIndices = (glyph.endPointIndices = [])\n      for (var i = 0; i < glyph.numberOfContours; i += 1) {\n        endPointIndices.push(p.parseUShort())\n      }\n\n      glyph.instructionLength = p.parseUShort()\n      glyph.instructions = []\n      for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n        glyph.instructions.push(p.parseByte())\n      }\n\n      var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1\n      flags = []\n      for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n        flag = p.parseByte()\n        flags.push(flag)\n        // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n        if ((flag & 8) > 0) {\n          var repeatCount = p.parseByte()\n          for (var j = 0; j < repeatCount; j += 1) {\n            flags.push(flag)\n            i$2 += 1\n          }\n        }\n      }\n\n      check.argument(flags.length === numberOfCoordinates, 'Bad flags.')\n\n      if (endPointIndices.length > 0) {\n        var points = []\n        var point\n        // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n        if (numberOfCoordinates > 0) {\n          for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n            flag = flags[i$3]\n            point = {}\n            point.onCurve = !!(flag & 1)\n            point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0\n            points.push(point)\n          }\n\n          var px = 0\n          for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n            flag = flags[i$4]\n            point = points[i$4]\n            point.x = parseGlyphCoordinate(p, flag, px, 2, 16)\n            px = point.x\n          }\n\n          var py = 0\n          for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n            flag = flags[i$5]\n            point = points[i$5]\n            point.y = parseGlyphCoordinate(p, flag, py, 4, 32)\n            py = point.y\n          }\n        }\n\n        glyph.points = points\n      } else {\n        glyph.points = []\n      }\n    } else if (glyph.numberOfContours === 0) {\n      glyph.points = []\n    } else {\n      glyph.isComposite = true\n      glyph.points = []\n      glyph.components = []\n      var moreComponents = true\n      while (moreComponents) {\n        flags = p.parseUShort()\n        var component = {\n          glyphIndex: p.parseUShort(),\n          xScale: 1,\n          scale01: 0,\n          scale10: 0,\n          yScale: 1,\n          dx: 0,\n          dy: 0,\n        }\n        if ((flags & 1) > 0) {\n          // The arguments are words\n          if ((flags & 2) > 0) {\n            // values are offset\n            component.dx = p.parseShort()\n            component.dy = p.parseShort()\n          } else {\n            // values are matched points\n            component.matchedPoints = [p.parseUShort(), p.parseUShort()]\n          }\n        } else {\n          // The arguments are bytes\n          if ((flags & 2) > 0) {\n            // values are offset\n            component.dx = p.parseChar()\n            component.dy = p.parseChar()\n          } else {\n            // values are matched points\n            component.matchedPoints = [p.parseByte(), p.parseByte()]\n          }\n        }\n\n        if ((flags & 8) > 0) {\n          // We have a scale\n          component.xScale = component.yScale = p.parseF2Dot14()\n        } else if ((flags & 64) > 0) {\n          // We have an X / Y scale\n          component.xScale = p.parseF2Dot14()\n          component.yScale = p.parseF2Dot14()\n        } else if ((flags & 128) > 0) {\n          // We have a 2x2 transformation\n          component.xScale = p.parseF2Dot14()\n          component.scale01 = p.parseF2Dot14()\n          component.scale10 = p.parseF2Dot14()\n          component.yScale = p.parseF2Dot14()\n        }\n\n        glyph.components.push(component)\n        moreComponents = !!(flags & 32)\n      }\n      if (flags & 0x100) {\n        // We have instructions\n        glyph.instructionLength = p.parseUShort()\n        glyph.instructions = []\n        for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n          glyph.instructions.push(p.parseByte())\n        }\n      }\n    }\n  }\n\n  // Transform an array of points and return a new array.\n  function transformPoints(points, transform) {\n    var newPoints = []\n    for (var i = 0; i < points.length; i += 1) {\n      var pt = points[i]\n      var newPt = {\n        x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n        y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n        onCurve: pt.onCurve,\n        lastPointOfContour: pt.lastPointOfContour,\n      }\n      newPoints.push(newPt)\n    }\n\n    return newPoints\n  }\n\n  function getContours(points) {\n    var contours = []\n    var currentContour = []\n    for (var i = 0; i < points.length; i += 1) {\n      var pt = points[i]\n      currentContour.push(pt)\n      if (pt.lastPointOfContour) {\n        contours.push(currentContour)\n        currentContour = []\n      }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.')\n    return contours\n  }\n\n  // Convert the TrueType glyph outline to a Path.\n  function getPath(points) {\n    var p = new Path()\n    if (!points) {\n      return p\n    }\n\n    var contours = getContours(points)\n\n    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n      var contour = contours[contourIndex]\n\n      var prev = null\n      var curr = contour[contour.length - 1]\n      var next = contour[0]\n\n      if (curr.onCurve) {\n        p.moveTo(curr.x, curr.y)\n      } else {\n        if (next.onCurve) {\n          p.moveTo(next.x, next.y)\n        } else {\n          // If both first and last points are off-curve, start at their middle.\n          var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 }\n          p.moveTo(start.x, start.y)\n        }\n      }\n\n      for (var i = 0; i < contour.length; ++i) {\n        prev = curr\n        curr = next\n        next = contour[(i + 1) % contour.length]\n\n        if (curr.onCurve) {\n          // This is a straight line.\n          p.lineTo(curr.x, curr.y)\n        } else {\n          var prev2 = prev\n          var next2 = next\n\n          if (!prev.onCurve) {\n            prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 }\n          }\n\n          if (!next.onCurve) {\n            next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 }\n          }\n\n          p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y)\n        }\n      }\n\n      p.closePath()\n    }\n    return p\n  }\n\n  function buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n      for (var j = 0; j < glyph.components.length; j += 1) {\n        var component = glyph.components[j]\n        var componentGlyph = glyphs.get(component.glyphIndex)\n        // Force the ttfGlyphLoader to parse the glyph.\n        componentGlyph.getPath()\n        if (componentGlyph.points) {\n          var transformedPoints = void 0\n          if (component.matchedPoints === undefined) {\n            // component positioned by offset\n            transformedPoints = transformPoints(componentGlyph.points, component)\n          } else {\n            // component positioned by matched points\n            if (\n              component.matchedPoints[0] > glyph.points.length - 1 ||\n              component.matchedPoints[1] > componentGlyph.points.length - 1\n            ) {\n              throw Error('Matched points out of range in ' + glyph.name)\n            }\n            var firstPt = glyph.points[component.matchedPoints[0]]\n            var secondPt = componentGlyph.points[component.matchedPoints[1]]\n            var transform = {\n              xScale: component.xScale,\n              scale01: component.scale01,\n              scale10: component.scale10,\n              yScale: component.yScale,\n              dx: 0,\n              dy: 0,\n            }\n            secondPt = transformPoints([secondPt], transform)[0]\n            transform.dx = firstPt.x - secondPt.x\n            transform.dy = firstPt.y - secondPt.y\n            transformedPoints = transformPoints(componentGlyph.points, transform)\n          }\n          glyph.points = glyph.points.concat(transformedPoints)\n        }\n      }\n    }\n\n    return getPath(glyph.points)\n  }\n\n  function parseGlyfTableAll(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font)\n\n    // The last element of the loca table is invalid.\n    for (var i = 0; i < loca.length - 1; i += 1) {\n      var offset = loca[i]\n      var nextOffset = loca[i + 1]\n      if (offset !== nextOffset) {\n        glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath))\n      } else {\n        glyphs.push(i, glyphset.glyphLoader(font, i))\n      }\n    }\n\n    return glyphs\n  }\n\n  function parseGlyfTableOnLowMemory(data, start, loca, font) {\n    var glyphs = new glyphset.GlyphSet(font)\n\n    font._push = function (i) {\n      var offset = loca[i]\n      var nextOffset = loca[i + 1]\n      if (offset !== nextOffset) {\n        glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath))\n      } else {\n        glyphs.push(i, glyphset.glyphLoader(font, i))\n      }\n    }\n\n    return glyphs\n  }\n\n  // Parse all the glyphs according to the offsets from the `loca` table.\n  function parseGlyfTable(data, start, loca, font, opt) {\n    if (opt.lowMemory) {\n      return parseGlyfTableOnLowMemory(data, start, loca, font)\n    } else {\n      return parseGlyfTableAll(data, start, loca, font)\n    }\n  }\n\n  var glyf = { getPath: getPath, parse: parseGlyfTable }\n\n  /* A TrueType font hinting interpreter.\n   *\n   * (c) 2017 Axel Kittenberger\n   *\n   * This interpreter has been implemented according to this documentation:\n   * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n   *\n   * According to the documentation F24DOT6 values are used for pixels.\n   * That means calculation is 1/64 pixel accurate and uses integer operations.\n   * However, Javascript has floating point operations by default and only\n   * those are available. One could make a case to simulate the 1/64 accuracy\n   * exactly by truncating after every division operation\n   * (for example with << 0) to get pixel exactly results as other TrueType\n   * implementations. It may make sense since some fonts are pixel optimized\n   * by hand using DELTAP instructions. The current implementation doesn't\n   * and rather uses full floating point precision.\n   *\n   * xScale, yScale and rotation is currently ignored.\n   *\n   * A few non-trivial instructions are missing as I didn't encounter yet\n   * a font that used them to test a possible implementation.\n   *\n   * Some fonts seem to use undocumented features regarding the twilight zone.\n   * Only some of them are implemented as they were encountered.\n   *\n   * The exports.DEBUG statements are removed on the minified distribution file.\n   */\n\n  var instructionTable\n  var exec\n  var execGlyph\n  var execComponent\n\n  /*\n   * Creates a hinting object.\n   *\n   * There ought to be exactly one\n   * for each truetype font that is used for hinting.\n   */\n  function Hinting(font) {\n    // the font this hinting object is for\n    this.font = font\n\n    this.getCommands = function (hPoints) {\n      return glyf.getPath(hPoints).commands\n    }\n\n    // cached states\n    this._fpgmState = this._prepState = undefined\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0\n  }\n\n  /*\n   * Not rounding.\n   */\n  function roundOff(v) {\n    return v\n  }\n\n  /*\n   * Rounding to grid.\n   */\n  function roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v))\n  }\n\n  /*\n   * Rounding to double grid.\n   */\n  function roundToDoubleGrid(v) {\n    return (Math.sign(v) * Math.round(Math.abs(v * 2))) / 2\n  }\n\n  /*\n   * Rounding to half grid.\n   */\n  function roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5)\n  }\n\n  /*\n   * Rounding to up to grid.\n   */\n  function roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v))\n  }\n\n  /*\n   * Rounding to down to grid.\n   */\n  function roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v))\n  }\n\n  /*\n   * Super rounding.\n   */\n  var roundSuper = function (v) {\n    var period = this.srPeriod\n    var phase = this.srPhase\n    var threshold = this.srThreshold\n    var sign = 1\n\n    if (v < 0) {\n      v = -v\n      sign = -1\n    }\n\n    v += threshold - phase\n\n    v = Math.trunc(v / period) * period\n\n    v += phase\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (v < 0) {\n      return phase * sign\n    }\n\n    return v * sign\n  }\n\n  /*\n   * Unit vector of x-axis.\n   */\n  var xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n      return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x)\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n      var do1\n      var do2\n      var doa1\n      var doa2\n      var dm1\n      var dm2\n      var dt\n\n      if (!pv || pv === this) {\n        do1 = p.xo - rp1.xo\n        do2 = p.xo - rp2.xo\n        dm1 = rp1.x - rp1.xo\n        dm2 = rp2.x - rp2.xo\n        doa1 = Math.abs(do1)\n        doa2 = Math.abs(do2)\n        dt = doa1 + doa2\n\n        if (dt === 0) {\n          p.x = p.xo + (dm1 + dm2) / 2\n          return\n        }\n\n        p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt\n        return\n      }\n\n      do1 = pv.distance(p, rp1, true, true)\n      do2 = pv.distance(p, rp2, true, true)\n      dm1 = pv.distance(rp1, rp1, false, true)\n      dm2 = pv.distance(rp2, rp2, false, true)\n      doa1 = Math.abs(do1)\n      doa2 = Math.abs(do2)\n      dt = doa1 + doa2\n\n      if (dt === 0) {\n        xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true)\n        return\n      }\n\n      xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true)\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n      if (!pv || pv === this) {\n        p.x = (org ? rp.xo : rp.x) + d\n        return\n      }\n\n      var rpx = org ? rp.xo : rp.x\n      var rpy = org ? rp.yo : rp.y\n      var rpdx = rpx + d * pv.x\n      var rpdy = rpy + d * pv.y\n\n      p.x = rpdx + (p.y - rpdy) / pv.normalSlope\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n      p.xTouched = true\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n      return p.xTouched\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n      p.xTouched = false\n    },\n  }\n\n  /*\n   * Unit vector of y-axis.\n   */\n  var yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n      return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y)\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n      var do1\n      var do2\n      var doa1\n      var doa2\n      var dm1\n      var dm2\n      var dt\n\n      if (!pv || pv === this) {\n        do1 = p.yo - rp1.yo\n        do2 = p.yo - rp2.yo\n        dm1 = rp1.y - rp1.yo\n        dm2 = rp2.y - rp2.yo\n        doa1 = Math.abs(do1)\n        doa2 = Math.abs(do2)\n        dt = doa1 + doa2\n\n        if (dt === 0) {\n          p.y = p.yo + (dm1 + dm2) / 2\n          return\n        }\n\n        p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt\n        return\n      }\n\n      do1 = pv.distance(p, rp1, true, true)\n      do2 = pv.distance(p, rp2, true, true)\n      dm1 = pv.distance(rp1, rp1, false, true)\n      dm2 = pv.distance(rp2, rp2, false, true)\n      doa1 = Math.abs(do1)\n      doa2 = Math.abs(do2)\n      dt = doa1 + doa2\n\n      if (dt === 0) {\n        yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true)\n        return\n      }\n\n      yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true)\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n      if (!pv || pv === this) {\n        p.y = (org ? rp.yo : rp.y) + d\n        return\n      }\n\n      var rpx = org ? rp.xo : rp.x\n      var rpy = org ? rp.yo : rp.y\n      var rpdx = rpx + d * pv.x\n      var rpdy = rpy + d * pv.y\n\n      p.y = rpdy + pv.normalSlope * (p.x - rpdx)\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n      p.yTouched = true\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n      return p.yTouched\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n      p.yTouched = false\n    },\n  }\n\n  Object.freeze(xUnitVector)\n  Object.freeze(yUnitVector)\n\n  /*\n   * Creates a unit vector that is not x- or y-axis.\n   */\n  function UnitVector(x, y) {\n    this.x = x\n    this.y = y\n    this.axis = undefined\n    this.slope = y / x\n    this.normalSlope = -x / y\n    Object.freeze(this)\n  }\n\n  /*\n   * Gets the projected distance between two points.\n   * o1/o2 ... if true, respective original position is used.\n   */\n  UnitVector.prototype.distance = function (p1, p2, o1, o2) {\n    return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2)\n  }\n\n  /*\n   * Moves point p so the moved position has the same relative\n   * position to the moved positions of rp1 and rp2 than the\n   * original positions had.\n   *\n   * See APPENDIX on INTERPOLATE at the bottom of this file.\n   */\n  UnitVector.prototype.interpolate = function (p, rp1, rp2, pv) {\n    var dm1\n    var dm2\n    var do1\n    var do2\n    var doa1\n    var doa2\n    var dt\n\n    do1 = pv.distance(p, rp1, true, true)\n    do2 = pv.distance(p, rp2, true, true)\n    dm1 = pv.distance(rp1, rp1, false, true)\n    dm2 = pv.distance(rp2, rp2, false, true)\n    doa1 = Math.abs(do1)\n    doa2 = Math.abs(do2)\n    dt = doa1 + doa2\n\n    if (dt === 0) {\n      this.setRelative(p, p, (dm1 + dm2) / 2, pv, true)\n      return\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true)\n  }\n\n  /*\n   * Sets the point 'p' relative to point 'rp'\n   * by the distance 'd'\n   *\n   * See APPENDIX on SETRELATIVE at the bottom of this file.\n   *\n   * p   ...  point to set\n   * rp  ... reference point\n   * d   ... distance on projection vector\n   * pv  ... projection vector (undefined = this)\n   * org ... if true, uses the original position of rp as reference.\n   */\n  UnitVector.prototype.setRelative = function (p, rp, d, pv, org) {\n    pv = pv || this\n\n    var rpx = org ? rp.xo : rp.x\n    var rpy = org ? rp.yo : rp.y\n    var rpdx = rpx + d * pv.x\n    var rpdy = rpy + d * pv.y\n\n    var pvns = pv.normalSlope\n    var fvs = this.slope\n\n    var px = p.x\n    var py = p.y\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns)\n    p.y = fvs * (p.x - px) + py\n  }\n\n  /*\n   * Touches the point p.\n   */\n  UnitVector.prototype.touch = function (p) {\n    p.xTouched = true\n    p.yTouched = true\n  }\n\n  /*\n   * Returns a unit vector with x/y coordinates.\n   */\n  function getUnitVector(x, y) {\n    var d = Math.sqrt(x * x + y * y)\n\n    x /= d\n    y /= d\n\n    if (x === 1 && y === 0) {\n      return xUnitVector\n    } else if (x === 0 && y === 1) {\n      return yUnitVector\n    } else {\n      return new UnitVector(x, y)\n    }\n  }\n\n  /*\n   * Creates a point in the hinting engine.\n   */\n  function HPoint(x, y, lastPointOfContour, onCurve) {\n    this.x = this.xo = Math.round(x * 64) / 64 // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64 // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour\n    this.onCurve = onCurve\n    this.prevPointOnContour = undefined\n    this.nextPointOnContour = undefined\n    this.xTouched = false\n    this.yTouched = false\n\n    Object.preventExtensions(this)\n  }\n\n  /*\n   * Returns the next touched point on the contour.\n   *\n   * v  ... unit vector to test touch axis.\n   */\n  HPoint.prototype.nextTouched = function (v) {\n    var p = this.nextPointOnContour\n\n    while (!v.touched(p) && p !== this) {\n      p = p.nextPointOnContour\n    }\n\n    return p\n  }\n\n  /*\n   * Returns the previous touched point on the contour\n   *\n   * v  ... unit vector to test touch axis.\n   */\n  HPoint.prototype.prevTouched = function (v) {\n    var p = this.prevPointOnContour\n\n    while (!v.touched(p) && p !== this) {\n      p = p.prevPointOnContour\n    }\n\n    return p\n  }\n\n  /*\n   * The zero point.\n   */\n  var HPZero = Object.freeze(new HPoint(0, 0))\n\n  /*\n   * The default state of the interpreter.\n   *\n   * Note: Freezing the defaultState and then deriving from it\n   * makes the V8 Javascript engine going awkward,\n   * so this is avoided, albeit the defaultState shouldn't\n   * ever change.\n   */\n  var defaultState = {\n    cvCutIn: 17 / 16, // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1, // loops some instructions\n    minDis: 1, // minimum distance\n    autoFlip: true,\n  }\n\n  /*\n   * The current state of the interpreter.\n   *\n   * env  ... 'fpgm' or 'prep' or 'glyf'\n   * prog ... the program\n   */\n  function State(env, prog) {\n    this.env = env\n    this.stack = []\n    this.prog = prog\n\n    switch (env) {\n      case 'glyf':\n        this.zp0 = this.zp1 = this.zp2 = 1\n        this.rp0 = this.rp1 = this.rp2 = 0\n      /* fall through */\n      case 'prep':\n        this.fv = this.pv = this.dpv = xUnitVector\n        this.round = roundToGrid\n    }\n  }\n\n  /*\n   * Executes a glyph program.\n   *\n   * This does the hinting for each glyph.\n   *\n   * Returns an array of moved points.\n   *\n   * glyph: the glyph to hint\n   * ppem: the size the glyph is rendered for\n   */\n  Hinting.prototype.exec = function (glyph, ppem) {\n    if (typeof ppem !== 'number') {\n      throw new Error('Point size is not a number!')\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) {\n      return\n    }\n\n    var font = this.font\n    var prepState = this._prepState\n\n    if (!prepState || prepState.ppem !== ppem) {\n      var fpgmState = this._fpgmState\n\n      if (!fpgmState) {\n        // Executes the fpgm state.\n        // This is used by fonts to define functions.\n        State.prototype = defaultState\n\n        fpgmState = this._fpgmState = new State('fpgm', font.tables.fpgm)\n\n        fpgmState.funcs = []\n        fpgmState.font = font\n\n        if (exports.DEBUG) {\n          console.log('---EXEC FPGM---')\n          fpgmState.step = -1\n        }\n\n        try {\n          exec(fpgmState)\n        } catch (e) {\n          console.log('Hinting error in FPGM:' + e)\n          this._errorState = 3\n          return\n        }\n      }\n\n      // Executes the prep program for this ppem setting.\n      // This is used by fonts to set cvt values\n      // depending on to be rendered font size.\n\n      State.prototype = fpgmState\n      prepState = this._prepState = new State('prep', font.tables.prep)\n\n      prepState.ppem = ppem\n\n      // Creates a copy of the cvt table\n      // and scales it to the current ppem setting.\n      var oCvt = font.tables.cvt\n      if (oCvt) {\n        var cvt = (prepState.cvt = new Array(oCvt.length))\n        var scale = ppem / font.unitsPerEm\n        for (var c = 0; c < oCvt.length; c++) {\n          cvt[c] = oCvt[c] * scale\n        }\n      } else {\n        prepState.cvt = []\n      }\n\n      if (exports.DEBUG) {\n        console.log('---EXEC PREP---')\n        prepState.step = -1\n      }\n\n      try {\n        exec(prepState)\n      } catch (e) {\n        if (this._errorState < 2) {\n          console.log('Hinting error in PREP:' + e)\n        }\n        this._errorState = 2\n      }\n    }\n\n    if (this._errorState > 1) {\n      return\n    }\n\n    try {\n      return execGlyph(glyph, prepState)\n    } catch (e) {\n      if (this._errorState < 1) {\n        console.log('Hinting error:' + e)\n        console.log('Note: further hinting errors are silenced')\n      }\n      this._errorState = 1\n      return undefined\n    }\n  }\n\n  /*\n   * Executes the hinting program for a glyph.\n   */\n  execGlyph = function (glyph, prepState) {\n    // original point positions\n    var xScale = prepState.ppem / prepState.font.unitsPerEm\n    var yScale = xScale\n    var components = glyph.components\n    var contours\n    var gZone\n    var state\n\n    State.prototype = prepState\n    if (!components) {\n      state = new State('glyf', glyph.instructions)\n      if (exports.DEBUG) {\n        console.log('---EXEC GLYPH---')\n        state.step = -1\n      }\n      execComponent(glyph, state, xScale, yScale)\n      gZone = state.gZone\n    } else {\n      var font = prepState.font\n      gZone = []\n      contours = []\n      for (var i = 0; i < components.length; i++) {\n        var c = components[i]\n        var cg = font.glyphs.get(c.glyphIndex)\n\n        state = new State('glyf', cg.instructions)\n\n        if (exports.DEBUG) {\n          console.log('---EXEC COMP ' + i + '---')\n          state.step = -1\n        }\n\n        execComponent(cg, state, xScale, yScale)\n        // appends the computed points to the result array\n        // post processes the component points\n        var dx = Math.round(c.dx * xScale)\n        var dy = Math.round(c.dy * yScale)\n        var gz = state.gZone\n        var cc = state.contours\n        for (var pi = 0; pi < gz.length; pi++) {\n          var p = gz[pi]\n          p.xTouched = p.yTouched = false\n          p.xo = p.x = p.x + dx\n          p.yo = p.y = p.y + dy\n        }\n\n        var gLen = gZone.length\n        gZone.push.apply(gZone, gz)\n        for (var j = 0; j < cc.length; j++) {\n          contours.push(cc[j] + gLen)\n        }\n      }\n\n      if (glyph.instructions && !state.inhibitGridFit) {\n        // the composite has instructions on its own\n        state = new State('glyf', glyph.instructions)\n\n        state.gZone = state.z0 = state.z1 = state.z2 = gZone\n\n        state.contours = contours\n\n        // note: HPZero cannot be used here, since\n        //       the point might be modified\n        gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0))\n\n        if (exports.DEBUG) {\n          console.log('---EXEC COMPOSITE---')\n          state.step = -1\n        }\n\n        exec(state)\n\n        gZone.length -= 2\n      }\n    }\n\n    return gZone\n  }\n\n  /*\n   * Executes the hinting program for a component of a multi-component glyph\n   * or of the glyph itself for a non-component glyph.\n   */\n  execComponent = function (glyph, state, xScale, yScale) {\n    var points = glyph.points || []\n    var pLen = points.length\n    var gZone = (state.gZone = state.z0 = state.z1 = state.z2 = [])\n    var contours = (state.contours = [])\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    var cp // current point\n    for (var i = 0; i < pLen; i++) {\n      cp = points[i]\n\n      gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve)\n    }\n\n    // Chain links the contours.\n    var sp // start point\n    var np // next point\n\n    for (var i$1 = 0; i$1 < pLen; i$1++) {\n      cp = gZone[i$1]\n\n      if (!sp) {\n        sp = cp\n        contours.push(i$1)\n      }\n\n      if (cp.lastPointOfContour) {\n        cp.nextPointOnContour = sp\n        sp.prevPointOnContour = cp\n        sp = undefined\n      } else {\n        np = gZone[i$1 + 1]\n        cp.nextPointOnContour = np\n        np.prevPointOnContour = cp\n      }\n    }\n\n    if (state.inhibitGridFit) {\n      return\n    }\n\n    if (exports.DEBUG) {\n      console.log('PROCESSING GLYPH', state.stack)\n      for (var i$2 = 0; i$2 < pLen; i$2++) {\n        console.log(i$2, gZone[i$2].x, gZone[i$2].y)\n      }\n    }\n\n    gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0))\n\n    exec(state)\n\n    // Removes the extra points.\n    gZone.length -= 2\n\n    if (exports.DEBUG) {\n      console.log('FINISHED GLYPH', state.stack)\n      for (var i$3 = 0; i$3 < pLen; i$3++) {\n        console.log(i$3, gZone[i$3].x, gZone[i$3].y)\n      }\n    }\n  }\n\n  /*\n   * Executes the program loaded in state.\n   */\n  exec = function (state) {\n    var prog = state.prog\n\n    if (!prog) {\n      return\n    }\n\n    var pLen = prog.length\n    var ins\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n      if (exports.DEBUG) {\n        state.step++\n      }\n      ins = instructionTable[prog[state.ip]]\n\n      if (!ins) {\n        throw new Error('unknown instruction: 0x' + Number(prog[state.ip]).toString(16))\n      }\n\n      ins(state)\n\n      // very extensive debugging for each step\n      /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n  }\n\n  /*\n   * Initializes the twilight zone.\n   *\n   * This is only done if a SZPx instruction\n   * refers to the twilight zone.\n   */\n  function initTZone(state) {\n    var tZone = (state.tZone = new Array(state.gZone.length))\n\n    // no idea if this is actually correct...\n    for (var i = 0; i < tZone.length; i++) {\n      tZone[i] = new HPoint(0, 0)\n    }\n  }\n\n  /*\n   * Skips the instruction pointer ahead over an IF/ELSE block.\n   * handleElse .. if true breaks on matching ELSE\n   */\n  function skip(state, handleElse) {\n    var prog = state.prog\n    var ip = state.ip\n    var nesting = 1\n    var ins\n\n    do {\n      ins = prog[++ip]\n      if (ins === 0x58) {\n        // IF\n        nesting++\n      } else if (ins === 0x59) {\n        // EIF\n        nesting--\n      } else if (ins === 0x40) {\n        // NPUSHB\n        ip += prog[ip + 1] + 1\n      } else if (ins === 0x41) {\n        // NPUSHW\n        ip += 2 * prog[ip + 1] + 1\n      } else if (ins >= 0xb0 && ins <= 0xb7) {\n        // PUSHB\n        ip += ins - 0xb0 + 1\n      } else if (ins >= 0xb8 && ins <= 0xbf) {\n        // PUSHW\n        ip += (ins - 0xb8 + 1) * 2\n      } else if (handleElse && nesting === 1 && ins === 0x1b) {\n        // ELSE\n        break\n      }\n    } while (nesting > 0)\n\n    state.ip = ip\n  }\n\n  /*----------------------------------------------------------*\n   *          And then a lot of instructions...                *\n   *----------------------------------------------------------*/\n\n  // SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n  // 0x00-0x01\n  function SVTCA(v, state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'SVTCA[' + v.axis + ']')\n    }\n\n    state.fv = state.pv = state.dpv = v\n  }\n\n  // SPVTCA[a] Set Projection Vector to Coordinate Axis\n  // 0x02-0x03\n  function SPVTCA(v, state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'SPVTCA[' + v.axis + ']')\n    }\n\n    state.pv = state.dpv = v\n  }\n\n  // SFVTCA[a] Set Freedom Vector to Coordinate Axis\n  // 0x04-0x05\n  function SFVTCA(v, state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'SFVTCA[' + v.axis + ']')\n    }\n\n    state.fv = v\n  }\n\n  // SPVTL[a] Set Projection Vector To Line\n  // 0x06-0x07\n  function SPVTL(a, state) {\n    var stack = state.stack\n    var p2i = stack.pop()\n    var p1i = stack.pop()\n    var p2 = state.z2[p2i]\n    var p1 = state.z1[p1i]\n\n    if (exports.DEBUG) {\n      console.log('SPVTL[' + a + ']', p2i, p1i)\n    }\n\n    var dx\n    var dy\n\n    if (!a) {\n      dx = p1.x - p2.x\n      dy = p1.y - p2.y\n    } else {\n      dx = p2.y - p1.y\n      dy = p1.x - p2.x\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy)\n  }\n\n  // SFVTL[a] Set Freedom Vector To Line\n  // 0x08-0x09\n  function SFVTL(a, state) {\n    var stack = state.stack\n    var p2i = stack.pop()\n    var p1i = stack.pop()\n    var p2 = state.z2[p2i]\n    var p1 = state.z1[p1i]\n\n    if (exports.DEBUG) {\n      console.log('SFVTL[' + a + ']', p2i, p1i)\n    }\n\n    var dx\n    var dy\n\n    if (!a) {\n      dx = p1.x - p2.x\n      dy = p1.y - p2.y\n    } else {\n      dx = p2.y - p1.y\n      dy = p1.x - p2.x\n    }\n\n    state.fv = getUnitVector(dx, dy)\n  }\n\n  // SPVFS[] Set Projection Vector From Stack\n  // 0x0A\n  function SPVFS(state) {\n    var stack = state.stack\n    var y = stack.pop()\n    var x = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SPVFS[]', y, x)\n    }\n\n    state.pv = state.dpv = getUnitVector(x, y)\n  }\n\n  // SFVFS[] Set Freedom Vector From Stack\n  // 0x0B\n  function SFVFS(state) {\n    var stack = state.stack\n    var y = stack.pop()\n    var x = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SPVFS[]', y, x)\n    }\n\n    state.fv = getUnitVector(x, y)\n  }\n\n  // GPV[] Get Projection Vector\n  // 0x0C\n  function GPV(state) {\n    var stack = state.stack\n    var pv = state.pv\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'GPV[]')\n    }\n\n    stack.push(pv.x * 0x4000)\n    stack.push(pv.y * 0x4000)\n  }\n\n  // GFV[] Get Freedom Vector\n  // 0x0C\n  function GFV(state) {\n    var stack = state.stack\n    var fv = state.fv\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'GFV[]')\n    }\n\n    stack.push(fv.x * 0x4000)\n    stack.push(fv.y * 0x4000)\n  }\n\n  // SFVTPV[] Set Freedom Vector To Projection Vector\n  // 0x0E\n  function SFVTPV(state) {\n    state.fv = state.pv\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SFVTPV[]')\n    }\n  }\n\n  // ISECT[] moves point p to the InterSECTion of two lines\n  // 0x0F\n  function ISECT(state) {\n    var stack = state.stack\n    var pa0i = stack.pop()\n    var pa1i = stack.pop()\n    var pb0i = stack.pop()\n    var pb1i = stack.pop()\n    var pi = stack.pop()\n    var z0 = state.z0\n    var z1 = state.z1\n    var pa0 = z0[pa0i]\n    var pa1 = z0[pa1i]\n    var pb0 = z1[pb0i]\n    var pb1 = z1[pb1i]\n    var p = state.z2[pi]\n\n    if (exports.DEBUG) {\n      console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi)\n    }\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    var x1 = pa0.x\n    var y1 = pa0.y\n    var x2 = pa1.x\n    var y2 = pa1.y\n    var x3 = pb0.x\n    var y3 = pb0.y\n    var x4 = pb1.x\n    var y4 = pb1.y\n\n    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    var f1 = x1 * y2 - y1 * x2\n    var f2 = x3 * y4 - y3 * x4\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div\n  }\n\n  // SRP0[] Set Reference Point 0\n  // 0x10\n  function SRP0(state) {\n    state.rp0 = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SRP0[]', state.rp0)\n    }\n  }\n\n  // SRP1[] Set Reference Point 1\n  // 0x11\n  function SRP1(state) {\n    state.rp1 = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SRP1[]', state.rp1)\n    }\n  }\n\n  // SRP1[] Set Reference Point 2\n  // 0x12\n  function SRP2(state) {\n    state.rp2 = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SRP2[]', state.rp2)\n    }\n  }\n\n  // SZP0[] Set Zone Pointer 0\n  // 0x13\n  function SZP0(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SZP0[]', n)\n    }\n\n    state.zp0 = n\n\n    switch (n) {\n      case 0:\n        if (!state.tZone) {\n          initTZone(state)\n        }\n        state.z0 = state.tZone\n        break\n      case 1:\n        state.z0 = state.gZone\n        break\n      default:\n        throw new Error('Invalid zone pointer')\n    }\n  }\n\n  // SZP1[] Set Zone Pointer 1\n  // 0x14\n  function SZP1(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SZP1[]', n)\n    }\n\n    state.zp1 = n\n\n    switch (n) {\n      case 0:\n        if (!state.tZone) {\n          initTZone(state)\n        }\n        state.z1 = state.tZone\n        break\n      case 1:\n        state.z1 = state.gZone\n        break\n      default:\n        throw new Error('Invalid zone pointer')\n    }\n  }\n\n  // SZP2[] Set Zone Pointer 2\n  // 0x15\n  function SZP2(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SZP2[]', n)\n    }\n\n    state.zp2 = n\n\n    switch (n) {\n      case 0:\n        if (!state.tZone) {\n          initTZone(state)\n        }\n        state.z2 = state.tZone\n        break\n      case 1:\n        state.z2 = state.gZone\n        break\n      default:\n        throw new Error('Invalid zone pointer')\n    }\n  }\n\n  // SZPS[] Set Zone PointerS\n  // 0x16\n  function SZPS(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SZPS[]', n)\n    }\n\n    state.zp0 = state.zp1 = state.zp2 = n\n\n    switch (n) {\n      case 0:\n        if (!state.tZone) {\n          initTZone(state)\n        }\n        state.z0 = state.z1 = state.z2 = state.tZone\n        break\n      case 1:\n        state.z0 = state.z1 = state.z2 = state.gZone\n        break\n      default:\n        throw new Error('Invalid zone pointer')\n    }\n  }\n\n  // SLOOP[] Set LOOP variable\n  // 0x17\n  function SLOOP(state) {\n    state.loop = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SLOOP[]', state.loop)\n    }\n  }\n\n  // RTG[] Round To Grid\n  // 0x18\n  function RTG(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'RTG[]')\n    }\n\n    state.round = roundToGrid\n  }\n\n  // RTHG[] Round To Half Grid\n  // 0x19\n  function RTHG(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'RTHG[]')\n    }\n\n    state.round = roundToHalfGrid\n  }\n\n  // SMD[] Set Minimum Distance\n  // 0x1A\n  function SMD(state) {\n    var d = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SMD[]', d)\n    }\n\n    state.minDis = d / 0x40\n  }\n\n  // ELSE[] ELSE clause\n  // 0x1B\n  function ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'ELSE[]')\n    }\n\n    skip(state, false)\n  }\n\n  // JMPR[] JuMP Relative\n  // 0x1C\n  function JMPR(state) {\n    var o = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'JMPR[]', o)\n    }\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1\n  }\n\n  // SCVTCI[] Set Control Value Table Cut-In\n  // 0x1D\n  function SCVTCI(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SCVTCI[]', n)\n    }\n\n    state.cvCutIn = n / 0x40\n  }\n\n  // DUP[] DUPlicate top stack element\n  // 0x20\n  function DUP(state) {\n    var stack = state.stack\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'DUP[]')\n    }\n\n    stack.push(stack[stack.length - 1])\n  }\n\n  // POP[] POP top stack element\n  // 0x21\n  function POP(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'POP[]')\n    }\n\n    state.stack.pop()\n  }\n\n  // CLEAR[] CLEAR the stack\n  // 0x22\n  function CLEAR(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'CLEAR[]')\n    }\n\n    state.stack.length = 0\n  }\n\n  // SWAP[] SWAP the top two elements on the stack\n  // 0x23\n  function SWAP(state) {\n    var stack = state.stack\n\n    var a = stack.pop()\n    var b = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SWAP[]')\n    }\n\n    stack.push(a)\n    stack.push(b)\n  }\n\n  // DEPTH[] DEPTH of the stack\n  // 0x24\n  function DEPTH(state) {\n    var stack = state.stack\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'DEPTH[]')\n    }\n\n    stack.push(stack.length)\n  }\n\n  // LOOPCALL[] LOOPCALL function\n  // 0x2A\n  function LOOPCALL(state) {\n    var stack = state.stack\n    var fn = stack.pop()\n    var c = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'LOOPCALL[]', fn, c)\n    }\n\n    // saves callers program\n    var cip = state.ip\n    var cprog = state.prog\n\n    state.prog = state.funcs[fn]\n\n    // executes the function\n    for (var i = 0; i < c; i++) {\n      exec(state)\n\n      if (exports.DEBUG) {\n        console.log(++state.step, i + 1 < c ? 'next loopcall' : 'done loopcall', i)\n      }\n    }\n\n    // restores the callers program\n    state.ip = cip\n    state.prog = cprog\n  }\n\n  // CALL[] CALL function\n  // 0x2B\n  function CALL(state) {\n    var fn = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'CALL[]', fn)\n    }\n\n    // saves callers program\n    var cip = state.ip\n    var cprog = state.prog\n\n    state.prog = state.funcs[fn]\n\n    // executes the function\n    exec(state)\n\n    // restores the callers program\n    state.ip = cip\n    state.prog = cprog\n\n    if (exports.DEBUG) {\n      console.log(++state.step, 'returning from', fn)\n    }\n  }\n\n  // CINDEX[] Copy the INDEXed element to the top of the stack\n  // 0x25\n  function CINDEX(state) {\n    var stack = state.stack\n    var k = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'CINDEX[]', k)\n    }\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k])\n  }\n\n  // MINDEX[] Move the INDEXed element to the top of the stack\n  // 0x26\n  function MINDEX(state) {\n    var stack = state.stack\n    var k = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MINDEX[]', k)\n    }\n\n    stack.push(stack.splice(stack.length - k, 1)[0])\n  }\n\n  // FDEF[] Function DEFinition\n  // 0x2C\n  function FDEF(state) {\n    if (state.env !== 'fpgm') {\n      throw new Error('FDEF not allowed here')\n    }\n    var stack = state.stack\n    var prog = state.prog\n    var ip = state.ip\n\n    var fn = stack.pop()\n    var ipBegin = ip\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'FDEF[]', fn)\n    }\n\n    while (prog[++ip] !== 0x2d) {}\n\n    state.ip = ip\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip)\n  }\n\n  // MDAP[a] Move Direct Absolute Point\n  // 0x2E-0x2F\n  function MDAP(round, state) {\n    var pi = state.stack.pop()\n    var p = state.z0[pi]\n    var fv = state.fv\n    var pv = state.pv\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MDAP[' + round + ']', pi)\n    }\n\n    var d = pv.distance(p, HPZero)\n\n    if (round) {\n      d = state.round(d)\n    }\n\n    fv.setRelative(p, HPZero, d, pv)\n    fv.touch(p)\n\n    state.rp0 = state.rp1 = pi\n  }\n\n  // IUP[a] Interpolate Untouched Points through the outline\n  // 0x30\n  function IUP(v, state) {\n    var z2 = state.z2\n    var pLen = z2.length - 2\n    var cp\n    var pp\n    var np\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'IUP[' + v.axis + ']')\n    }\n\n    for (var i = 0; i < pLen; i++) {\n      cp = z2[i] // current point\n\n      // if this point has been touched go on\n      if (v.touched(cp)) {\n        continue\n      }\n\n      pp = cp.prevTouched(v)\n\n      // no point on the contour has been touched?\n      if (pp === cp) {\n        continue\n      }\n\n      np = cp.nextTouched(v)\n\n      if (pp === np) {\n        // only one point on the contour has been touched\n        // so simply moves the point like that\n\n        v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true)\n      }\n\n      v.interpolate(cp, pp, np, v)\n    }\n  }\n\n  // SHP[] SHift Point using reference point\n  // 0x32-0x33\n  function SHP(a, state) {\n    var stack = state.stack\n    var rpi = a ? state.rp1 : state.rp2\n    var rp = (a ? state.z0 : state.z1)[rpi]\n    var fv = state.fv\n    var pv = state.pv\n    var loop = state.loop\n    var z2 = state.z2\n\n    while (loop--) {\n      var pi = stack.pop()\n      var p = z2[pi]\n\n      var d = pv.distance(rp, rp, false, true)\n      fv.setRelative(p, p, d, pv)\n      fv.touch(p)\n\n      if (exports.DEBUG) {\n        console.log(\n          state.step,\n          (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHP[' + (a ? 'rp1' : 'rp2') + ']',\n          pi,\n        )\n      }\n    }\n\n    state.loop = 1\n  }\n\n  // SHC[] SHift Contour using reference point\n  // 0x36-0x37\n  function SHC(a, state) {\n    var stack = state.stack\n    var rpi = a ? state.rp1 : state.rp2\n    var rp = (a ? state.z0 : state.z1)[rpi]\n    var fv = state.fv\n    var pv = state.pv\n    var ci = stack.pop()\n    var sp = state.z2[state.contours[ci]]\n    var p = sp\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SHC[' + a + ']', ci)\n    }\n\n    var d = pv.distance(rp, rp, false, true)\n\n    do {\n      if (p !== rp) {\n        fv.setRelative(p, p, d, pv)\n      }\n      p = p.nextPointOnContour\n    } while (p !== sp)\n  }\n\n  // SHZ[] SHift Zone using reference point\n  // 0x36-0x37\n  function SHZ(a, state) {\n    var stack = state.stack\n    var rpi = a ? state.rp1 : state.rp2\n    var rp = (a ? state.z0 : state.z1)[rpi]\n    var fv = state.fv\n    var pv = state.pv\n\n    var e = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SHZ[' + a + ']', e)\n    }\n\n    var z\n    switch (e) {\n      case 0:\n        z = state.tZone\n        break\n      case 1:\n        z = state.gZone\n        break\n      default:\n        throw new Error('Invalid zone')\n    }\n\n    var p\n    var d = pv.distance(rp, rp, false, true)\n    var pLen = z.length - 2\n    for (var i = 0; i < pLen; i++) {\n      p = z[i]\n      fv.setRelative(p, p, d, pv)\n      //if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n  }\n\n  // SHPIX[] SHift point by a PIXel amount\n  // 0x38\n  function SHPIX(state) {\n    var stack = state.stack\n    var loop = state.loop\n    var fv = state.fv\n    var d = stack.pop() / 0x40\n    var z2 = state.z2\n\n    while (loop--) {\n      var pi = stack.pop()\n      var p = z2[pi]\n\n      if (exports.DEBUG) {\n        console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHPIX[]', pi, d)\n      }\n\n      fv.setRelative(p, p, d)\n      fv.touch(p)\n    }\n\n    state.loop = 1\n  }\n\n  // IP[] Interpolate Point\n  // 0x39\n  function IP(state) {\n    var stack = state.stack\n    var rp1i = state.rp1\n    var rp2i = state.rp2\n    var loop = state.loop\n    var rp1 = state.z0[rp1i]\n    var rp2 = state.z1[rp2i]\n    var fv = state.fv\n    var pv = state.dpv\n    var z2 = state.z2\n\n    while (loop--) {\n      var pi = stack.pop()\n      var p = z2[pi]\n\n      if (exports.DEBUG) {\n        console.log(\n          state.step,\n          (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'IP[]',\n          pi,\n          rp1i,\n          '<->',\n          rp2i,\n        )\n      }\n\n      fv.interpolate(p, rp1, rp2, pv)\n\n      fv.touch(p)\n    }\n\n    state.loop = 1\n  }\n\n  // MSIRP[a] Move Stack Indirect Relative Point\n  // 0x3A-0x3B\n  function MSIRP(a, state) {\n    var stack = state.stack\n    var d = stack.pop() / 64\n    var pi = stack.pop()\n    var p = state.z1[pi]\n    var rp0 = state.z0[state.rp0]\n    var fv = state.fv\n    var pv = state.pv\n\n    fv.setRelative(p, rp0, d, pv)\n    fv.touch(p)\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MSIRP[' + a + ']', d, pi)\n    }\n\n    state.rp1 = state.rp0\n    state.rp2 = pi\n    if (a) {\n      state.rp0 = pi\n    }\n  }\n\n  // ALIGNRP[] Align to reference point.\n  // 0x3C\n  function ALIGNRP(state) {\n    var stack = state.stack\n    var rp0i = state.rp0\n    var rp0 = state.z0[rp0i]\n    var loop = state.loop\n    var fv = state.fv\n    var pv = state.pv\n    var z1 = state.z1\n\n    while (loop--) {\n      var pi = stack.pop()\n      var p = z1[pi]\n\n      if (exports.DEBUG) {\n        console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'ALIGNRP[]', pi)\n      }\n\n      fv.setRelative(p, rp0, 0, pv)\n      fv.touch(p)\n    }\n\n    state.loop = 1\n  }\n\n  // RTG[] Round To Double Grid\n  // 0x3D\n  function RTDG(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'RTDG[]')\n    }\n\n    state.round = roundToDoubleGrid\n  }\n\n  // MIAP[a] Move Indirect Absolute Point\n  // 0x3E-0x3F\n  function MIAP(round, state) {\n    var stack = state.stack\n    var n = stack.pop()\n    var pi = stack.pop()\n    var p = state.z0[pi]\n    var fv = state.fv\n    var pv = state.pv\n    var cv = state.cvt[n]\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MIAP[' + round + ']', n, '(', cv, ')', pi)\n    }\n\n    var d = pv.distance(p, HPZero)\n\n    if (round) {\n      if (Math.abs(d - cv) < state.cvCutIn) {\n        d = cv\n      }\n\n      d = state.round(d)\n    }\n\n    fv.setRelative(p, HPZero, d, pv)\n\n    if (state.zp0 === 0) {\n      p.xo = p.x\n      p.yo = p.y\n    }\n\n    fv.touch(p)\n\n    state.rp0 = state.rp1 = pi\n  }\n\n  // NPUSB[] PUSH N Bytes\n  // 0x40\n  function NPUSHB(state) {\n    var prog = state.prog\n    var ip = state.ip\n    var stack = state.stack\n\n    var n = prog[++ip]\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'NPUSHB[]', n)\n    }\n\n    for (var i = 0; i < n; i++) {\n      stack.push(prog[++ip])\n    }\n\n    state.ip = ip\n  }\n\n  // NPUSHW[] PUSH N Words\n  // 0x41\n  function NPUSHW(state) {\n    var ip = state.ip\n    var prog = state.prog\n    var stack = state.stack\n    var n = prog[++ip]\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'NPUSHW[]', n)\n    }\n\n    for (var i = 0; i < n; i++) {\n      var w = (prog[++ip] << 8) | prog[++ip]\n      if (w & 0x8000) {\n        w = -((w ^ 0xffff) + 1)\n      }\n      stack.push(w)\n    }\n\n    state.ip = ip\n  }\n\n  // WS[] Write Store\n  // 0x42\n  function WS(state) {\n    var stack = state.stack\n    var store = state.store\n\n    if (!store) {\n      store = state.store = []\n    }\n\n    var v = stack.pop()\n    var l = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'WS', v, l)\n    }\n\n    store[l] = v\n  }\n\n  // RS[] Read Store\n  // 0x43\n  function RS(state) {\n    var stack = state.stack\n    var store = state.store\n\n    var l = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'RS', l)\n    }\n\n    var v = (store && store[l]) || 0\n\n    stack.push(v)\n  }\n\n  // WCVTP[] Write Control Value Table in Pixel units\n  // 0x44\n  function WCVTP(state) {\n    var stack = state.stack\n\n    var v = stack.pop()\n    var l = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'WCVTP', v, l)\n    }\n\n    state.cvt[l] = v / 0x40\n  }\n\n  // RCVT[] Read Control Value Table entry\n  // 0x45\n  function RCVT(state) {\n    var stack = state.stack\n    var cvte = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'RCVT', cvte)\n    }\n\n    stack.push(state.cvt[cvte] * 0x40)\n  }\n\n  // GC[] Get Coordinate projected onto the projection vector\n  // 0x46-0x47\n  function GC(a, state) {\n    var stack = state.stack\n    var pi = stack.pop()\n    var p = state.z2[pi]\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'GC[' + a + ']', pi)\n    }\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40)\n  }\n\n  // MD[a] Measure Distance\n  // 0x49-0x4A\n  function MD(a, state) {\n    var stack = state.stack\n    var pi2 = stack.pop()\n    var pi1 = stack.pop()\n    var p2 = state.z1[pi2]\n    var p1 = state.z0[pi1]\n    var d = state.dpv.distance(p1, p2, a, a)\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d)\n    }\n\n    state.stack.push(Math.round(d * 64))\n  }\n\n  // MPPEM[] Measure Pixels Per EM\n  // 0x4B\n  function MPPEM(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'MPPEM[]')\n    }\n    state.stack.push(state.ppem)\n  }\n\n  // FLIPON[] set the auto FLIP Boolean to ON\n  // 0x4D\n  function FLIPON(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'FLIPON[]')\n    }\n    state.autoFlip = true\n  }\n\n  // LT[] Less Than\n  // 0x50\n  function LT(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'LT[]', e2, e1)\n    }\n\n    stack.push(e1 < e2 ? 1 : 0)\n  }\n\n  // LTEQ[] Less Than or EQual\n  // 0x53\n  function LTEQ(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'LTEQ[]', e2, e1)\n    }\n\n    stack.push(e1 <= e2 ? 1 : 0)\n  }\n\n  // GTEQ[] Greater Than\n  // 0x52\n  function GT(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'GT[]', e2, e1)\n    }\n\n    stack.push(e1 > e2 ? 1 : 0)\n  }\n\n  // GTEQ[] Greater Than or EQual\n  // 0x53\n  function GTEQ(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'GTEQ[]', e2, e1)\n    }\n\n    stack.push(e1 >= e2 ? 1 : 0)\n  }\n\n  // EQ[] EQual\n  // 0x54\n  function EQ(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'EQ[]', e2, e1)\n    }\n\n    stack.push(e2 === e1 ? 1 : 0)\n  }\n\n  // NEQ[] Not EQual\n  // 0x55\n  function NEQ(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'NEQ[]', e2, e1)\n    }\n\n    stack.push(e2 !== e1 ? 1 : 0)\n  }\n\n  // ODD[] ODD\n  // 0x56\n  function ODD(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'ODD[]', n)\n    }\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0)\n  }\n\n  // EVEN[] EVEN\n  // 0x57\n  function EVEN(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'EVEN[]', n)\n    }\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1)\n  }\n\n  // IF[] IF test\n  // 0x58\n  function IF(state) {\n    var test = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'IF[]', test)\n    }\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n      skip(state, true)\n\n      if (exports.DEBUG) {\n        console.log(state.step, 'EIF[]')\n      }\n    }\n  }\n\n  // EIF[] End IF\n  // 0x59\n  function EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'EIF[]')\n    }\n  }\n\n  // AND[] logical AND\n  // 0x5A\n  function AND(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'AND[]', e2, e1)\n    }\n\n    stack.push(e2 && e1 ? 1 : 0)\n  }\n\n  // OR[] logical OR\n  // 0x5B\n  function OR(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'OR[]', e2, e1)\n    }\n\n    stack.push(e2 || e1 ? 1 : 0)\n  }\n\n  // NOT[] logical NOT\n  // 0x5C\n  function NOT(state) {\n    var stack = state.stack\n    var e = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'NOT[]', e)\n    }\n\n    stack.push(e ? 0 : 1)\n  }\n\n  // DELTAP1[] DELTA exception P1\n  // DELTAP2[] DELTA exception P2\n  // DELTAP3[] DELTA exception P3\n  // 0x5D, 0x71, 0x72\n  function DELTAP123(b, state) {\n    var stack = state.stack\n    var n = stack.pop()\n    var fv = state.fv\n    var pv = state.pv\n    var ppem = state.ppem\n    var base = state.deltaBase + (b - 1) * 16\n    var ds = state.deltaShift\n    var z0 = state.z0\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'DELTAP[' + b + ']', n, stack)\n    }\n\n    for (var i = 0; i < n; i++) {\n      var pi = stack.pop()\n      var arg = stack.pop()\n      var appem = base + ((arg & 0xf0) >> 4)\n      if (appem !== ppem) {\n        continue\n      }\n\n      var mag = (arg & 0x0f) - 8\n      if (mag >= 0) {\n        mag++\n      }\n      if (exports.DEBUG) {\n        console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds)\n      }\n\n      var p = z0[pi]\n      fv.setRelative(p, p, mag * ds, pv)\n    }\n  }\n\n  // SDB[] Set Delta Base in the graphics state\n  // 0x5E\n  function SDB(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SDB[]', n)\n    }\n\n    state.deltaBase = n\n  }\n\n  // SDS[] Set Delta Shift in the graphics state\n  // 0x5F\n  function SDS(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SDS[]', n)\n    }\n\n    state.deltaShift = Math.pow(0.5, n)\n  }\n\n  // ADD[] ADD\n  // 0x60\n  function ADD(state) {\n    var stack = state.stack\n    var n2 = stack.pop()\n    var n1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'ADD[]', n2, n1)\n    }\n\n    stack.push(n1 + n2)\n  }\n\n  // SUB[] SUB\n  // 0x61\n  function SUB(state) {\n    var stack = state.stack\n    var n2 = stack.pop()\n    var n1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SUB[]', n2, n1)\n    }\n\n    stack.push(n1 - n2)\n  }\n\n  // DIV[] DIV\n  // 0x62\n  function DIV(state) {\n    var stack = state.stack\n    var n2 = stack.pop()\n    var n1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'DIV[]', n2, n1)\n    }\n\n    stack.push((n1 * 64) / n2)\n  }\n\n  // MUL[] MUL\n  // 0x63\n  function MUL(state) {\n    var stack = state.stack\n    var n2 = stack.pop()\n    var n1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MUL[]', n2, n1)\n    }\n\n    stack.push((n1 * n2) / 64)\n  }\n\n  // ABS[] ABSolute value\n  // 0x64\n  function ABS(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'ABS[]', n)\n    }\n\n    stack.push(Math.abs(n))\n  }\n\n  // NEG[] NEGate\n  // 0x65\n  function NEG(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'NEG[]', n)\n    }\n\n    stack.push(-n)\n  }\n\n  // FLOOR[] FLOOR\n  // 0x66\n  function FLOOR(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'FLOOR[]', n)\n    }\n\n    stack.push(Math.floor(n / 0x40) * 0x40)\n  }\n\n  // CEILING[] CEILING\n  // 0x67\n  function CEILING(state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'CEILING[]', n)\n    }\n\n    stack.push(Math.ceil(n / 0x40) * 0x40)\n  }\n\n  // ROUND[ab] ROUND value\n  // 0x68-0x6B\n  function ROUND(dt, state) {\n    var stack = state.stack\n    var n = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'ROUND[]')\n    }\n\n    stack.push(state.round(n / 0x40) * 0x40)\n  }\n\n  // WCVTF[] Write Control Value Table in Funits\n  // 0x70\n  function WCVTF(state) {\n    var stack = state.stack\n    var v = stack.pop()\n    var l = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'WCVTF[]', v, l)\n    }\n\n    state.cvt[l] = (v * state.ppem) / state.font.unitsPerEm\n  }\n\n  // DELTAC1[] DELTA exception C1\n  // DELTAC2[] DELTA exception C2\n  // DELTAC3[] DELTA exception C3\n  // 0x73, 0x74, 0x75\n  function DELTAC123(b, state) {\n    var stack = state.stack\n    var n = stack.pop()\n    var ppem = state.ppem\n    var base = state.deltaBase + (b - 1) * 16\n    var ds = state.deltaShift\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'DELTAC[' + b + ']', n, stack)\n    }\n\n    for (var i = 0; i < n; i++) {\n      var c = stack.pop()\n      var arg = stack.pop()\n      var appem = base + ((arg & 0xf0) >> 4)\n      if (appem !== ppem) {\n        continue\n      }\n\n      var mag = (arg & 0x0f) - 8\n      if (mag >= 0) {\n        mag++\n      }\n\n      var delta = mag * ds\n\n      if (exports.DEBUG) {\n        console.log(state.step, 'DELTACFIX', c, 'by', delta)\n      }\n\n      state.cvt[c] += delta\n    }\n  }\n\n  // SROUND[] Super ROUND\n  // 0x76\n  function SROUND(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SROUND[]', n)\n    }\n\n    state.round = roundSuper\n\n    var period\n\n    switch (n & 0xc0) {\n      case 0x00:\n        period = 0.5\n        break\n      case 0x40:\n        period = 1\n        break\n      case 0x80:\n        period = 2\n        break\n      default:\n        throw new Error('invalid SROUND value')\n    }\n\n    state.srPeriod = period\n\n    switch (n & 0x30) {\n      case 0x00:\n        state.srPhase = 0\n        break\n      case 0x10:\n        state.srPhase = 0.25 * period\n        break\n      case 0x20:\n        state.srPhase = 0.5 * period\n        break\n      case 0x30:\n        state.srPhase = 0.75 * period\n        break\n      default:\n        throw new Error('invalid SROUND value')\n    }\n\n    n &= 0x0f\n\n    if (n === 0) {\n      state.srThreshold = 0\n    } else {\n      state.srThreshold = (n / 8 - 0.5) * period\n    }\n  }\n\n  // S45ROUND[] Super ROUND 45 degrees\n  // 0x77\n  function S45ROUND(state) {\n    var n = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'S45ROUND[]', n)\n    }\n\n    state.round = roundSuper\n\n    var period\n\n    switch (n & 0xc0) {\n      case 0x00:\n        period = Math.sqrt(2) / 2\n        break\n      case 0x40:\n        period = Math.sqrt(2)\n        break\n      case 0x80:\n        period = 2 * Math.sqrt(2)\n        break\n      default:\n        throw new Error('invalid S45ROUND value')\n    }\n\n    state.srPeriod = period\n\n    switch (n & 0x30) {\n      case 0x00:\n        state.srPhase = 0\n        break\n      case 0x10:\n        state.srPhase = 0.25 * period\n        break\n      case 0x20:\n        state.srPhase = 0.5 * period\n        break\n      case 0x30:\n        state.srPhase = 0.75 * period\n        break\n      default:\n        throw new Error('invalid S45ROUND value')\n    }\n\n    n &= 0x0f\n\n    if (n === 0) {\n      state.srThreshold = 0\n    } else {\n      state.srThreshold = (n / 8 - 0.5) * period\n    }\n  }\n\n  // ROFF[] Round Off\n  // 0x7A\n  function ROFF(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'ROFF[]')\n    }\n\n    state.round = roundOff\n  }\n\n  // RUTG[] Round Up To Grid\n  // 0x7C\n  function RUTG(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'RUTG[]')\n    }\n\n    state.round = roundUpToGrid\n  }\n\n  // RDTG[] Round Down To Grid\n  // 0x7D\n  function RDTG(state) {\n    if (exports.DEBUG) {\n      console.log(state.step, 'RDTG[]')\n    }\n\n    state.round = roundDownToGrid\n  }\n\n  // SCANCTRL[] SCAN conversion ConTRoL\n  // 0x85\n  function SCANCTRL(state) {\n    var n = state.stack.pop()\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SCANCTRL[]', n)\n    }\n  }\n\n  // SDPVTL[a] Set Dual Projection Vector To Line\n  // 0x86-0x87\n  function SDPVTL(a, state) {\n    var stack = state.stack\n    var p2i = stack.pop()\n    var p1i = stack.pop()\n    var p2 = state.z2[p2i]\n    var p1 = state.z1[p1i]\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i)\n    }\n\n    var dx\n    var dy\n\n    if (!a) {\n      dx = p1.x - p2.x\n      dy = p1.y - p2.y\n    } else {\n      dx = p2.y - p1.y\n      dy = p1.x - p2.x\n    }\n\n    state.dpv = getUnitVector(dx, dy)\n  }\n\n  // GETINFO[] GET INFOrmation\n  // 0x88\n  function GETINFO(state) {\n    var stack = state.stack\n    var sel = stack.pop()\n    var r = 0\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'GETINFO[]', sel)\n    }\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) {\n      r = 35\n    }\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) {\n      r |= 0x1000\n    }\n\n    stack.push(r)\n  }\n\n  // ROLL[] ROLL the top three stack elements\n  // 0x8A\n  function ROLL(state) {\n    var stack = state.stack\n    var a = stack.pop()\n    var b = stack.pop()\n    var c = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'ROLL[]')\n    }\n\n    stack.push(b)\n    stack.push(a)\n    stack.push(c)\n  }\n\n  // MAX[] MAXimum of top two stack elements\n  // 0x8B\n  function MAX(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MAX[]', e2, e1)\n    }\n\n    stack.push(Math.max(e1, e2))\n  }\n\n  // MIN[] MINimum of top two stack elements\n  // 0x8C\n  function MIN(state) {\n    var stack = state.stack\n    var e2 = stack.pop()\n    var e1 = stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'MIN[]', e2, e1)\n    }\n\n    stack.push(Math.min(e1, e2))\n  }\n\n  // SCANTYPE[] SCANTYPE\n  // 0x8D\n  function SCANTYPE(state) {\n    var n = state.stack.pop()\n    // ignored by opentype.js\n    if (exports.DEBUG) {\n      console.log(state.step, 'SCANTYPE[]', n)\n    }\n  }\n\n  // INSTCTRL[] INSTCTRL\n  // 0x8D\n  function INSTCTRL(state) {\n    var s = state.stack.pop()\n    var v = state.stack.pop()\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'INSTCTRL[]', s, v)\n    }\n\n    switch (s) {\n      case 1:\n        state.inhibitGridFit = !!v\n        return\n      case 2:\n        state.ignoreCvt = !!v\n        return\n      default:\n        throw new Error('invalid INSTCTRL[] selector')\n    }\n  }\n\n  // PUSHB[abc] PUSH Bytes\n  // 0xB0-0xB7\n  function PUSHB(n, state) {\n    var stack = state.stack\n    var prog = state.prog\n    var ip = state.ip\n\n    if (exports.DEBUG) {\n      console.log(state.step, 'PUSHB[' + n + ']')\n    }\n\n    for (var i = 0; i < n; i++) {\n      stack.push(prog[++ip])\n    }\n\n    state.ip = ip\n  }\n\n  // PUSHW[abc] PUSH Words\n  // 0xB8-0xBF\n  function PUSHW(n, state) {\n    var ip = state.ip\n    var prog = state.prog\n    var stack = state.stack\n\n    if (exports.DEBUG) {\n      console.log(state.ip, 'PUSHW[' + n + ']')\n    }\n\n    for (var i = 0; i < n; i++) {\n      var w = (prog[++ip] << 8) | prog[++ip]\n      if (w & 0x8000) {\n        w = -((w ^ 0xffff) + 1)\n      }\n      stack.push(w)\n    }\n\n    state.ip = ip\n  }\n\n  // MDRP[abcde] Move Direct Relative Point\n  // 0xD0-0xEF\n  // (if indirect is 0)\n  //\n  // and\n  //\n  // MIRP[abcde] Move Indirect Relative Point\n  // 0xE0-0xFF\n  // (if indirect is 1)\n\n  function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    var stack = state.stack\n    var cvte = indirect && stack.pop()\n    var pi = stack.pop()\n    var rp0i = state.rp0\n    var rp = state.z0[rp0i]\n    var p = state.z1[pi]\n\n    var md = state.minDis\n    var fv = state.fv\n    var pv = state.dpv\n    var od // original distance\n    var d // moving distance\n    var sign // sign of distance\n    var cv\n\n    d = od = pv.distance(p, rp, true, true)\n    sign = d >= 0 ? 1 : -1 // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d)\n\n    if (indirect) {\n      cv = state.cvt[cvte]\n\n      if (ro && Math.abs(d - cv) < state.cvCutIn) {\n        d = cv\n      }\n    }\n\n    if (keepD && d < md) {\n      d = md\n    }\n\n    if (ro) {\n      d = state.round(d)\n    }\n\n    fv.setRelative(p, rp, sign * d, pv)\n    fv.touch(p)\n\n    if (exports.DEBUG) {\n      console.log(\n        state.step,\n        (indirect ? 'MIRP[' : 'MDRP[') +\n          (setRp0 ? 'M' : 'm') +\n          (keepD ? '>' : '_') +\n          (ro ? 'R' : '_') +\n          (dt === 0 ? 'Gr' : dt === 1 ? 'Bl' : dt === 2 ? 'Wh' : '') +\n          ']',\n        indirect ? cvte + '(' + state.cvt[cvte] + ',' + cv + ')' : '',\n        pi,\n        '(d =',\n        od,\n        '->',\n        sign * d,\n        ')',\n      )\n    }\n\n    state.rp1 = state.rp0\n    state.rp2 = pi\n    if (setRp0) {\n      state.rp0 = pi\n    }\n  }\n\n  /*\n   * The instruction table.\n   */\n  instructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined, // TODO SSWCI\n    /* 0x1F */ undefined, // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined, // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined, // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined, // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined, // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined, // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined, // TODO FLIPOFF\n    /* 0x4F */ undefined, // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined, // TODO NROUND[ab]\n    /* 0x6D */ undefined, // TODO NROUND[ab]\n    /* 0x6E */ undefined, // TODO NROUND[ab]\n    /* 0x6F */ undefined, // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined, // TODO JROT[]\n    /* 0x79 */ undefined, // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined, // TODO FLIPPT\n    /* 0x81 */ undefined, // TODO FLIPRGON\n    /* 0x82 */ undefined, // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined, // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3),\n  ]\n\n  /*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90 \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *---->*rp1\n         .     .                          (+12)\n         .     .                  rp2o *---------->* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------>*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *--->* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .\n    rp2o *-------->*rp2\n\n\n                               (+10)\n                          po *-------->* p\n\n-------\n\n\n           (+10)\n    rp1o *-------->*rp1\n         .         .\n         .         .(+30)\n    rp2o *---------------------------->*rp2\n\n\n                                        (+25)\n                          po *----------------------->* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n  /**\n   * Converts a string into a list of tokens.\n   */\n\n  /**\n   * Create a new token\n   * @param {string} char a single char\n   */\n  function Token(char) {\n    this.char = char\n    this.state = {}\n    this.activeState = null\n  }\n\n  /**\n   * Create a new context range\n   * @param {number} startIndex range start index\n   * @param {number} endOffset range end index offset\n   * @param {string} contextName owner context name\n   */\n  function ContextRange(startIndex, endOffset, contextName) {\n    this.contextName = contextName\n    this.startIndex = startIndex\n    this.endOffset = endOffset\n  }\n\n  /**\n   * Check context start and end\n   * @param {string} contextName a unique context name\n   * @param {function} checkStart a predicate function the indicates a context's start\n   * @param {function} checkEnd a predicate function the indicates a context's end\n   */\n  function ContextChecker(contextName, checkStart, checkEnd) {\n    this.contextName = contextName\n    this.openRange = null\n    this.ranges = []\n    this.checkStart = checkStart\n    this.checkEnd = checkEnd\n  }\n\n  /**\n   * @typedef ContextParams\n   * @type Object\n   * @property {array} context context items\n   * @property {number} currentIndex current item index\n   */\n\n  /**\n   * Create a context params\n   * @param {array} context a list of items\n   * @param {number} currentIndex current item index\n   */\n  function ContextParams(context, currentIndex) {\n    this.context = context\n    this.index = currentIndex\n    this.length = context.length\n    this.current = context[currentIndex]\n    this.backtrack = context.slice(0, currentIndex)\n    this.lookahead = context.slice(currentIndex + 1)\n  }\n\n  /**\n   * Create an event instance\n   * @param {string} eventId event unique id\n   */\n  function Event(eventId) {\n    this.eventId = eventId\n    this.subscribers = []\n  }\n\n  /**\n   * Initialize a core events and auto subscribe required event handlers\n   * @param {any} events an object that enlists core events handlers\n   */\n  function initializeCoreEvents(events) {\n    var this$1 = this\n\n    var coreEvents = [\n      'start',\n      'end',\n      'next',\n      'newToken',\n      'contextStart',\n      'contextEnd',\n      'insertToken',\n      'removeToken',\n      'removeRange',\n      'replaceToken',\n      'replaceRange',\n      'composeRUD',\n      'updateContextsRanges',\n    ]\n\n    coreEvents.forEach(function (eventId) {\n      Object.defineProperty(this$1.events, eventId, {\n        value: new Event(eventId),\n      })\n    })\n\n    if (!!events) {\n      coreEvents.forEach(function (eventId) {\n        var event = events[eventId]\n        if (typeof event === 'function') {\n          this$1.events[eventId].subscribe(event)\n        }\n      })\n    }\n    var requiresContextUpdate = [\n      'insertToken',\n      'removeToken',\n      'removeRange',\n      'replaceToken',\n      'replaceRange',\n      'composeRUD',\n    ]\n    requiresContextUpdate.forEach(function (eventId) {\n      this$1.events[eventId].subscribe(this$1.updateContextsRanges)\n    })\n  }\n\n  /**\n   * Converts a string into a list of tokens\n   * @param {any} events tokenizer core events\n   */\n  function Tokenizer(events) {\n    this.tokens = []\n    this.registeredContexts = {}\n    this.contextCheckers = []\n    this.events = {}\n    this.registeredModifiers = []\n\n    initializeCoreEvents.call(this, events)\n  }\n\n  /**\n   * Sets the state of a token, usually called by a state modifier.\n   * @param {string} key state item key\n   * @param {any} value state item value\n   */\n  Token.prototype.setState = function (key, value) {\n    this.state[key] = value\n    this.activeState = { key: key, value: this.state[key] }\n    return this.activeState\n  }\n\n  Token.prototype.getState = function (stateId) {\n    return this.state[stateId] || null\n  }\n\n  /**\n   * Checks if an index exists in the tokens list.\n   * @param {number} index token index\n   */\n  Tokenizer.prototype.inboundIndex = function (index) {\n    return index >= 0 && index < this.tokens.length\n  }\n\n  /**\n   * Compose and apply a list of operations (replace, update, delete)\n   * @param {array} RUDs replace, update and delete operations\n   * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n   */\n  Tokenizer.prototype.composeRUD = function (RUDs) {\n    var this$1 = this\n\n    var silent = true\n    var state = RUDs.map(function (RUD) {\n      return this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n    })\n    var hasFAILObject = function (obj) {\n      return typeof obj === 'object' && obj.hasOwnProperty('FAIL')\n    }\n    if (state.every(hasFAILObject)) {\n      return {\n        FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n        report: state.filter(hasFAILObject),\n      }\n    }\n    this.dispatch('composeRUD', [\n      state.filter(function (op) {\n        return !hasFAILObject(op)\n      }),\n    ])\n  }\n\n  /**\n   * Replace a range of tokens with a list of tokens\n   * @param {number} startIndex range start index\n   * @param {number} offset range offset\n   * @param {token} tokens a list of tokens to replace\n   * @param {boolean} silent dispatch events and update context ranges\n   */\n  Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n    offset = offset !== null ? offset : this.tokens.length\n    var isTokenType = tokens.every(function (token) {\n      return token instanceof Token\n    })\n    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n      var replaced = this.tokens.splice.apply(this.tokens, [startIndex, offset].concat(tokens))\n      if (!silent) {\n        this.dispatch('replaceToken', [startIndex, offset, tokens])\n      }\n      return [replaced, tokens]\n    } else {\n      return { FAIL: 'replaceRange: invalid tokens or startIndex.' }\n    }\n  }\n\n  /**\n   * Replace a token with another token\n   * @param {number} index token index\n   * @param {token} token a token to replace\n   * @param {boolean} silent dispatch events and update context ranges\n   */\n  Tokenizer.prototype.replaceToken = function (index, token, silent) {\n    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n      var replaced = this.tokens.splice(index, 1, token)\n      if (!silent) {\n        this.dispatch('replaceToken', [index, token])\n      }\n      return [replaced[0], token]\n    } else {\n      return { FAIL: 'replaceToken: invalid token or index.' }\n    }\n  }\n\n  /**\n   * Removes a range of tokens\n   * @param {number} startIndex range start index\n   * @param {number} offset range offset\n   * @param {boolean} silent dispatch events and update context ranges\n   */\n  Tokenizer.prototype.removeRange = function (startIndex, offset, silent) {\n    offset = !isNaN(offset) ? offset : this.tokens.length\n    var tokens = this.tokens.splice(startIndex, offset)\n    if (!silent) {\n      this.dispatch('removeRange', [tokens, startIndex, offset])\n    }\n    return tokens\n  }\n\n  /**\n   * Remove a token at a certain index\n   * @param {number} index token index\n   * @param {boolean} silent dispatch events and update context ranges\n   */\n  Tokenizer.prototype.removeToken = function (index, silent) {\n    if (!isNaN(index) && this.inboundIndex(index)) {\n      var token = this.tokens.splice(index, 1)\n      if (!silent) {\n        this.dispatch('removeToken', [token, index])\n      }\n      return token\n    } else {\n      return { FAIL: 'removeToken: invalid token index.' }\n    }\n  }\n\n  /**\n   * Insert a list of tokens at a certain index\n   * @param {array} tokens a list of tokens to insert\n   * @param {number} index insert the list of tokens at index\n   * @param {boolean} silent dispatch events and update context ranges\n   */\n  Tokenizer.prototype.insertToken = function (tokens, index, silent) {\n    var tokenType = tokens.every(function (token) {\n      return token instanceof Token\n    })\n    if (tokenType) {\n      this.tokens.splice.apply(this.tokens, [index, 0].concat(tokens))\n      if (!silent) {\n        this.dispatch('insertToken', [tokens, index])\n      }\n      return tokens\n    } else {\n      return { FAIL: 'insertToken: invalid token(s).' }\n    }\n  }\n\n  /**\n   * A state modifier that is called on 'newToken' event\n   * @param {string} modifierId state modifier id\n   * @param {function} condition a predicate function that returns true or false\n   * @param {function} modifier a function to update token state\n   */\n  Tokenizer.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.events.newToken.subscribe(function (token, contextParams) {\n      var conditionParams = [token, contextParams]\n      var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true\n      var modifierParams = [token, contextParams]\n      if (canApplyModifier) {\n        var newStateValue = modifier.apply(this, modifierParams)\n        token.setState(modifierId, newStateValue)\n      }\n    })\n    this.registeredModifiers.push(modifierId)\n  }\n\n  /**\n   * Subscribe a handler to an event\n   * @param {function} eventHandler an event handler function\n   */\n  Event.prototype.subscribe = function (eventHandler) {\n    if (typeof eventHandler === 'function') {\n      return this.subscribers.push(eventHandler) - 1\n    } else {\n      return { FAIL: \"invalid '\" + this.eventId + \"' event handler\" }\n    }\n  }\n\n  /**\n   * Unsubscribe an event handler\n   * @param {string} subsId subscription id\n   */\n  Event.prototype.unsubscribe = function (subsId) {\n    this.subscribers.splice(subsId, 1)\n  }\n\n  /**\n   * Sets context params current value index\n   * @param {number} index context params current value index\n   */\n  ContextParams.prototype.setCurrentIndex = function (index) {\n    this.index = index\n    this.current = this.context[index]\n    this.backtrack = this.context.slice(0, index)\n    this.lookahead = this.context.slice(index + 1)\n  }\n\n  /**\n   * Get an item at an offset from the current value\n   * example (current value is 3):\n   *  1    2   [3]   4    5   |   items values\n   * -2   -1    0    1    2   |   offset values\n   * @param {number} offset an offset from current value index\n   */\n  ContextParams.prototype.get = function (offset) {\n    switch (true) {\n      case offset === 0:\n        return this.current\n      case offset < 0 && Math.abs(offset) <= this.backtrack.length:\n        return this.backtrack.slice(offset)[0]\n      case offset > 0 && offset <= this.lookahead.length:\n        return this.lookahead[offset - 1]\n      default:\n        return null\n    }\n  }\n\n  /**\n   * Converts a context range into a string value\n   * @param {contextRange} range a context range\n   */\n  Tokenizer.prototype.rangeToText = function (range) {\n    if (range instanceof ContextRange) {\n      return this.getRangeTokens(range)\n        .map(function (token) {\n          return token.char\n        })\n        .join('')\n    }\n  }\n\n  /**\n   * Converts all tokens into a string\n   */\n  Tokenizer.prototype.getText = function () {\n    return this.tokens\n      .map(function (token) {\n        return token.char\n      })\n      .join('')\n  }\n\n  /**\n   * Get a context by name\n   * @param {string} contextName context name to get\n   */\n  Tokenizer.prototype.getContext = function (contextName) {\n    var context = this.registeredContexts[contextName]\n    return !!context ? context : null\n  }\n\n  /**\n   * Subscribes a new event handler to an event\n   * @param {string} eventName event name to subscribe to\n   * @param {function} eventHandler a function to be invoked on event\n   */\n  Tokenizer.prototype.on = function (eventName, eventHandler) {\n    var event = this.events[eventName]\n    if (!!event) {\n      return event.subscribe(eventHandler)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Dispatches an event\n   * @param {string} eventName event name\n   * @param {any} args event handler arguments\n   */\n  Tokenizer.prototype.dispatch = function (eventName, args) {\n    var this$1 = this\n\n    var event = this.events[eventName]\n    if (event instanceof Event) {\n      event.subscribers.forEach(function (subscriber) {\n        subscriber.apply(this$1, args || [])\n      })\n    }\n  }\n\n  /**\n   * Register a new context checker\n   * @param {string} contextName a unique context name\n   * @param {function} contextStartCheck a predicate function that returns true on context start\n   * @param {function} contextEndCheck  a predicate function that returns true on context end\n   * TODO: call tokenize on registration to update context ranges with the new context.\n   */\n  Tokenizer.prototype.registerContextChecker = function (contextName, contextStartCheck, contextEndCheck) {\n    if (!!this.getContext(contextName)) {\n      return {\n        FAIL: \"context name '\" + contextName + \"' is already registered.\",\n      }\n    }\n    if (typeof contextStartCheck !== 'function') {\n      return {\n        FAIL: 'missing context start check.',\n      }\n    }\n    if (typeof contextEndCheck !== 'function') {\n      return {\n        FAIL: 'missing context end check.',\n      }\n    }\n    var contextCheckers = new ContextChecker(contextName, contextStartCheck, contextEndCheck)\n    this.registeredContexts[contextName] = contextCheckers\n    this.contextCheckers.push(contextCheckers)\n    return contextCheckers\n  }\n\n  /**\n   * Gets a context range tokens\n   * @param {contextRange} range a context range\n   */\n  Tokenizer.prototype.getRangeTokens = function (range) {\n    var endIndex = range.startIndex + range.endOffset\n    return [].concat(this.tokens.slice(range.startIndex, endIndex))\n  }\n\n  /**\n   * Gets the ranges of a context\n   * @param {string} contextName context name\n   */\n  Tokenizer.prototype.getContextRanges = function (contextName) {\n    var context = this.getContext(contextName)\n    if (!!context) {\n      return context.ranges\n    } else {\n      return { FAIL: \"context checker '\" + contextName + \"' is not registered.\" }\n    }\n  }\n\n  /**\n   * Resets context ranges to run context update\n   */\n  Tokenizer.prototype.resetContextsRanges = function () {\n    var registeredContexts = this.registeredContexts\n    for (var contextName in registeredContexts) {\n      if (registeredContexts.hasOwnProperty(contextName)) {\n        var context = registeredContexts[contextName]\n        context.ranges = []\n      }\n    }\n  }\n\n  /**\n   * Updates context ranges\n   */\n  Tokenizer.prototype.updateContextsRanges = function () {\n    this.resetContextsRanges()\n    var chars = this.tokens.map(function (token) {\n      return token.char\n    })\n    for (var i = 0; i < chars.length; i++) {\n      var contextParams = new ContextParams(chars, i)\n      this.runContextCheck(contextParams)\n    }\n    this.dispatch('updateContextsRanges', [this.registeredContexts])\n  }\n\n  /**\n   * Sets the end offset of an open range\n   * @param {number} offset range end offset\n   * @param {string} contextName context name\n   */\n  Tokenizer.prototype.setEndOffset = function (offset, contextName) {\n    var startIndex = this.getContext(contextName).openRange.startIndex\n    var range = new ContextRange(startIndex, offset, contextName)\n    var ranges = this.getContext(contextName).ranges\n    range.rangeId = contextName + '.' + ranges.length\n    ranges.push(range)\n    this.getContext(contextName).openRange = null\n    return range\n  }\n\n  /**\n   * Runs a context check on the current context\n   * @param {contextParams} contextParams current context params\n   */\n  Tokenizer.prototype.runContextCheck = function (contextParams) {\n    var this$1 = this\n\n    var index = contextParams.index\n    this.contextCheckers.forEach(function (contextChecker) {\n      var contextName = contextChecker.contextName\n      var openRange = this$1.getContext(contextName).openRange\n      if (!openRange && contextChecker.checkStart(contextParams)) {\n        openRange = new ContextRange(index, null, contextName)\n        this$1.getContext(contextName).openRange = openRange\n        this$1.dispatch('contextStart', [contextName, index])\n      }\n      if (!!openRange && contextChecker.checkEnd(contextParams)) {\n        var offset = index - openRange.startIndex + 1\n        var range = this$1.setEndOffset(offset, contextName)\n        this$1.dispatch('contextEnd', [contextName, range])\n      }\n    })\n  }\n\n  /**\n   * Converts a text into a list of tokens\n   * @param {string} text a text to tokenize\n   */\n  Tokenizer.prototype.tokenize = function (text) {\n    this.tokens = []\n    this.resetContextsRanges()\n    var chars = Array.from(text)\n    this.dispatch('start')\n    for (var i = 0; i < chars.length; i++) {\n      var char = chars[i]\n      var contextParams = new ContextParams(chars, i)\n      this.dispatch('next', [contextParams])\n      this.runContextCheck(contextParams)\n      var token = new Token(char)\n      this.tokens.push(token)\n      this.dispatch('newToken', [token, contextParams])\n    }\n    this.dispatch('end', [this.tokens])\n    return this.tokens\n  }\n\n  // \n  //  Character Class Assertions  Checks if a char belongs to a certain class \n  // \n  // jscs:disable maximumLineLength\n  /**\n   * Check if a char is Arabic\n   * @param {string} c a single char\n   */\n  function isArabicChar(c) {\n    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c)\n  }\n\n  /**\n   * Check if a char is an isolated arabic char\n   * @param {string} c a single char\n   */\n  function isIsolatedArabicChar(char) {\n    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(\n      char,\n    )\n  }\n\n  /**\n   * Check if a char is an Arabic Tashkeel char\n   * @param {string} c a single char\n   */\n  function isTashkeelArabicChar(char) {\n    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(\n      char,\n    )\n  }\n\n  /**\n   * Check if a char is Latin\n   * @param {string} c a single char\n   */\n  function isLatinChar(c) {\n    return /[A-z]/.test(c)\n  }\n\n  /**\n   * Check if a char is whitespace char\n   * @param {string} c a single char\n   */\n  function isWhiteSpace(c) {\n    return /\\s/.test(c)\n  }\n\n  /**\n   * Query a feature by some of it's properties to lookup a glyph substitution.\n   */\n\n  /**\n   * Create feature query instance\n   * @param {Font} font opentype font instance\n   */\n  function FeatureQuery(font) {\n    this.font = font\n    this.features = {}\n  }\n\n  /**\n   * @typedef SubstitutionAction\n   * @type Object\n   * @property {number} id substitution type\n   * @property {string} tag feature tag\n   * @property {any} substitution substitution value(s)\n   */\n\n  /**\n   * Create a substitution action instance\n   * @param {SubstitutionAction} action\n   */\n  function SubstitutionAction(action) {\n    this.id = action.id\n    this.tag = action.tag\n    this.substitution = action.substitution\n  }\n\n  /**\n   * Lookup a coverage table\n   * @param {number} glyphIndex glyph index\n   * @param {CoverageTable} coverage coverage table\n   */\n  function lookupCoverage(glyphIndex, coverage) {\n    if (!glyphIndex) {\n      return -1\n    }\n    switch (coverage.format) {\n      case 1:\n        return coverage.glyphs.indexOf(glyphIndex)\n\n      case 2:\n        var ranges = coverage.ranges\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i]\n          if (glyphIndex >= range.start && glyphIndex <= range.end) {\n            var offset = glyphIndex - range.start\n            return range.index + offset\n          }\n        }\n        break\n      default:\n        return -1 // not found\n    }\n    return -1\n  }\n\n  /**\n   * Handle a single substitution - format 1\n   * @param {ContextParams} contextParams context params to lookup\n   */\n  function singleSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage)\n    if (substituteIndex === -1) {\n      return null\n    }\n    return glyphIndex + subtable.deltaGlyphId\n  }\n\n  /**\n   * Handle a single substitution - format 2\n   * @param {ContextParams} contextParams context params to lookup\n   */\n  function singleSubstitutionFormat2(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage)\n    if (substituteIndex === -1) {\n      return null\n    }\n    return subtable.substitute[substituteIndex]\n  }\n\n  /**\n   * Lookup a list of coverage tables\n   * @param {any} coverageList a list of coverage tables\n   * @param {ContextParams} contextParams context params to lookup\n   */\n  function lookupCoverageList(coverageList, contextParams) {\n    var lookupList = []\n    for (var i = 0; i < coverageList.length; i++) {\n      var coverage = coverageList[i]\n      var glyphIndex = contextParams.current\n      glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex\n      var lookupIndex = lookupCoverage(glyphIndex, coverage)\n      if (lookupIndex !== -1) {\n        lookupList.push(lookupIndex)\n      }\n    }\n    if (lookupList.length !== coverageList.length) {\n      return -1\n    }\n    return lookupList\n  }\n\n  /**\n   * Handle chaining context substitution - format 3\n   * @param {ContextParams} contextParams context params to lookup\n   */\n  function chainingSubstitutionFormat3(contextParams, subtable) {\n    var lookupsCount =\n      subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length\n    if (contextParams.context.length < lookupsCount) {\n      return []\n    }\n    // INPUT LOOKUP //\n    var inputLookups = lookupCoverageList(subtable.inputCoverage, contextParams)\n    if (inputLookups === -1) {\n      return []\n    }\n    // LOOKAHEAD LOOKUP //\n    var lookaheadOffset = subtable.inputCoverage.length - 1\n    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) {\n      return []\n    }\n    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset)\n    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n      lookaheadContext.shift()\n    }\n    var lookaheadParams = new ContextParams(lookaheadContext, 0)\n    var lookaheadLookups = lookupCoverageList(subtable.lookaheadCoverage, lookaheadParams)\n    // BACKTRACK LOOKUP //\n    var backtrackContext = [].concat(contextParams.backtrack)\n    backtrackContext.reverse()\n    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n      backtrackContext.shift()\n    }\n    if (backtrackContext.length < subtable.backtrackCoverage.length) {\n      return []\n    }\n    var backtrackParams = new ContextParams(backtrackContext, 0)\n    var backtrackLookups = lookupCoverageList(subtable.backtrackCoverage, backtrackParams)\n    var contextRulesMatch =\n      inputLookups.length === subtable.inputCoverage.length &&\n      lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n      backtrackLookups.length === subtable.backtrackCoverage.length\n    var substitutions = []\n    if (contextRulesMatch) {\n      for (var i = 0; i < subtable.lookupRecords.length; i++) {\n        var lookupRecord = subtable.lookupRecords[i]\n        var lookupListIndex = lookupRecord.lookupListIndex\n        var lookupTable = this.getLookupByIndex(lookupListIndex)\n        for (var s = 0; s < lookupTable.subtables.length; s++) {\n          var subtable$1 = lookupTable.subtables[s]\n          var lookup = this.getLookupMethod(lookupTable, subtable$1)\n          var substitutionType = this.getSubstitutionType(lookupTable, subtable$1)\n          if (substitutionType === '12') {\n            for (var n = 0; n < inputLookups.length; n++) {\n              var glyphIndex = contextParams.get(n)\n              var substitution = lookup(glyphIndex)\n              if (substitution) {\n                substitutions.push(substitution)\n              }\n            }\n          }\n        }\n      }\n    }\n    return substitutions\n  }\n\n  /**\n   * Handle ligature substitution - format 1\n   * @param {ContextParams} contextParams context params to lookup\n   */\n  function ligatureSubstitutionFormat1(contextParams, subtable) {\n    // COVERAGE LOOKUP //\n    var glyphIndex = contextParams.current\n    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage)\n    if (ligSetIndex === -1) {\n      return null\n    }\n    // COMPONENTS LOOKUP\n    // (!) note, components are ordered in the written direction.\n    var ligature\n    var ligatureSet = subtable.ligatureSets[ligSetIndex]\n    for (var s = 0; s < ligatureSet.length; s++) {\n      ligature = ligatureSet[s]\n      for (var l = 0; l < ligature.components.length; l++) {\n        var lookaheadItem = contextParams.lookahead[l]\n        var component = ligature.components[l]\n        if (lookaheadItem !== component) {\n          break\n        }\n        if (l === ligature.components.length - 1) {\n          return ligature\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Handle decomposition substitution - format 1\n   * @param {number} glyphIndex glyph index\n   * @param {any} subtable subtable\n   */\n  function decompositionSubstitutionFormat1(glyphIndex, subtable) {\n    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage)\n    if (substituteIndex === -1) {\n      return null\n    }\n    return subtable.sequences[substituteIndex]\n  }\n\n  /**\n   * Get default script features indexes\n   */\n  FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n    var scripts = this.font.tables.gsub.scripts\n    for (var s = 0; s < scripts.length; s++) {\n      var script = scripts[s]\n      if (script.tag === 'DFLT') {\n        return script.script.defaultLangSys.featureIndexes\n      }\n    }\n    return []\n  }\n\n  /**\n   * Get feature indexes of a specific script\n   * @param {string} scriptTag script tag\n   */\n  FeatureQuery.prototype.getScriptFeaturesIndexes = function (scriptTag) {\n    var tables = this.font.tables\n    if (!tables.gsub) {\n      return []\n    }\n    if (!scriptTag) {\n      return this.getDefaultScriptFeaturesIndexes()\n    }\n    var scripts = this.font.tables.gsub.scripts\n    for (var i = 0; i < scripts.length; i++) {\n      var script = scripts[i]\n      if (script.tag === scriptTag && script.script.defaultLangSys) {\n        return script.script.defaultLangSys.featureIndexes\n      } else {\n        var langSysRecords = script.langSysRecords\n        if (!!langSysRecords) {\n          for (var j = 0; j < langSysRecords.length; j++) {\n            var langSysRecord = langSysRecords[j]\n            if (langSysRecord.tag === scriptTag) {\n              var langSys = langSysRecord.langSys\n              return langSys.featureIndexes\n            }\n          }\n        }\n      }\n    }\n    return this.getDefaultScriptFeaturesIndexes()\n  }\n\n  /**\n   * Map a feature tag to a gsub feature\n   * @param {any} features gsub features\n   * @param {string} scriptTag script tag\n   */\n  FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n    var tags = {}\n    for (var i = 0; i < features.length; i++) {\n      var tag = features[i].tag\n      var feature = features[i].feature\n      tags[tag] = feature\n    }\n    this.features[scriptTag].tags = tags\n  }\n\n  /**\n   * Get features of a specific script\n   * @param {string} scriptTag script tag\n   */\n  FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n    var features = this.features[scriptTag]\n    if (this.features.hasOwnProperty(scriptTag)) {\n      return features\n    }\n    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag)\n    if (!featuresIndexes) {\n      return null\n    }\n    var gsub = this.font.tables.gsub\n    features = featuresIndexes.map(function (index) {\n      return gsub.features[index]\n    })\n    this.features[scriptTag] = features\n    this.mapTagsToFeatures(features, scriptTag)\n    return features\n  }\n\n  /**\n   * Get substitution type\n   * @param {any} lookupTable lookup table\n   * @param {any} subtable subtable\n   */\n  FeatureQuery.prototype.getSubstitutionType = function (lookupTable, subtable) {\n    var lookupType = lookupTable.lookupType.toString()\n    var substFormat = subtable.substFormat.toString()\n    return lookupType + substFormat\n  }\n\n  /**\n   * Get lookup method\n   * @param {any} lookupTable lookup table\n   * @param {any} subtable subtable\n   */\n  FeatureQuery.prototype.getLookupMethod = function (lookupTable, subtable) {\n    var this$1 = this\n\n    var substitutionType = this.getSubstitutionType(lookupTable, subtable)\n    switch (substitutionType) {\n      case '11':\n        return function (glyphIndex) {\n          return singleSubstitutionFormat1.apply(this$1, [glyphIndex, subtable])\n        }\n      case '12':\n        return function (glyphIndex) {\n          return singleSubstitutionFormat2.apply(this$1, [glyphIndex, subtable])\n        }\n      case '63':\n        return function (contextParams) {\n          return chainingSubstitutionFormat3.apply(this$1, [contextParams, subtable])\n        }\n      case '41':\n        return function (contextParams) {\n          return ligatureSubstitutionFormat1.apply(this$1, [contextParams, subtable])\n        }\n      case '21':\n        return function (glyphIndex) {\n          return decompositionSubstitutionFormat1.apply(this$1, [glyphIndex, subtable])\n        }\n      default:\n        throw new Error(\n          'lookupType: ' +\n            lookupTable.lookupType +\n            ' - ' +\n            'substFormat: ' +\n            subtable.substFormat +\n            ' ' +\n            'is not yet supported',\n        )\n    }\n  }\n\n  /**\n   * [ LOOKUP TYPES ]\n   * -------------------------------\n   * Single                        1;\n   * Multiple                      2;\n   * Alternate                     3;\n   * Ligature                      4;\n   * Context                       5;\n   * ChainingContext               6;\n   * ExtensionSubstitution         7;\n   * ReverseChainingContext        8;\n   * -------------------------------\n   *\n   */\n\n  /**\n   * @typedef FQuery\n   * @type Object\n   * @param {string} tag feature tag\n   * @param {string} script feature script\n   * @param {ContextParams} contextParams context params\n   */\n\n  /**\n   * Lookup a feature using a query parameters\n   * @param {FQuery} query feature query\n   */\n  FeatureQuery.prototype.lookupFeature = function (query) {\n    var contextParams = query.contextParams\n    var currentIndex = contextParams.index\n    var feature = this.getFeature({\n      tag: query.tag,\n      script: query.script,\n    })\n    if (!feature) {\n      return new Error(\n        \"font '\" +\n          this.font.names.fullName.en +\n          \"' \" +\n          \"doesn't support feature '\" +\n          query.tag +\n          \"' \" +\n          \"for script '\" +\n          query.script +\n          \"'.\",\n      )\n    }\n    var lookups = this.getFeatureLookups(feature)\n    var substitutions = [].concat(contextParams.context)\n    for (var l = 0; l < lookups.length; l++) {\n      var lookupTable = lookups[l]\n      var subtables = this.getLookupSubtables(lookupTable)\n      for (var s = 0; s < subtables.length; s++) {\n        var subtable = subtables[s]\n        var substType = this.getSubstitutionType(lookupTable, subtable)\n        var lookup = this.getLookupMethod(lookupTable, subtable)\n        var substitution = void 0\n        switch (substType) {\n          case '11':\n            substitution = lookup(contextParams.current)\n            if (substitution) {\n              substitutions.splice(\n                currentIndex,\n                1,\n                new SubstitutionAction({\n                  id: 11,\n                  tag: query.tag,\n                  substitution: substitution,\n                }),\n              )\n            }\n            break\n          case '12':\n            substitution = lookup(contextParams.current)\n            if (substitution) {\n              substitutions.splice(\n                currentIndex,\n                1,\n                new SubstitutionAction({\n                  id: 12,\n                  tag: query.tag,\n                  substitution: substitution,\n                }),\n              )\n            }\n            break\n          case '63':\n            substitution = lookup(contextParams)\n            if (Array.isArray(substitution) && substitution.length) {\n              substitutions.splice(\n                currentIndex,\n                1,\n                new SubstitutionAction({\n                  id: 63,\n                  tag: query.tag,\n                  substitution: substitution,\n                }),\n              )\n            }\n            break\n          case '41':\n            substitution = lookup(contextParams)\n            if (substitution) {\n              substitutions.splice(\n                currentIndex,\n                1,\n                new SubstitutionAction({\n                  id: 41,\n                  tag: query.tag,\n                  substitution: substitution,\n                }),\n              )\n            }\n            break\n          case '21':\n            substitution = lookup(contextParams.current)\n            if (substitution) {\n              substitutions.splice(\n                currentIndex,\n                1,\n                new SubstitutionAction({\n                  id: 21,\n                  tag: query.tag,\n                  substitution: substitution,\n                }),\n              )\n            }\n            break\n        }\n        contextParams = new ContextParams(substitutions, currentIndex)\n        if (Array.isArray(substitution) && !substitution.length) {\n          continue\n        }\n        substitution = null\n      }\n    }\n    return substitutions.length ? substitutions : null\n  }\n\n  /**\n   * Checks if a font supports a specific features\n   * @param {FQuery} query feature query object\n   */\n  FeatureQuery.prototype.supports = function (query) {\n    if (!query.script) {\n      return false\n    }\n    this.getScriptFeatures(query.script)\n    var supportedScript = this.features.hasOwnProperty(query.script)\n    if (!query.tag) {\n      return supportedScript\n    }\n    var supportedFeature = this.features[query.script].some(function (feature) {\n      return feature.tag === query.tag\n    })\n    return supportedScript && supportedFeature\n  }\n\n  /**\n   * Get lookup table subtables\n   * @param {any} lookupTable lookup table\n   */\n  FeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n    return lookupTable.subtables || null\n  }\n\n  /**\n   * Get lookup table by index\n   * @param {number} index lookup table index\n   */\n  FeatureQuery.prototype.getLookupByIndex = function (index) {\n    var lookups = this.font.tables.gsub.lookups\n    return lookups[index] || null\n  }\n\n  /**\n   * Get lookup tables for a feature\n   * @param {string} feature\n   */\n  FeatureQuery.prototype.getFeatureLookups = function (feature) {\n    // TODO: memoize\n    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this))\n  }\n\n  /**\n   * Query a feature by it's properties\n   * @param {any} query an object that describes the properties of a query\n   */\n  FeatureQuery.prototype.getFeature = function getFeature(query) {\n    if (!this.font) {\n      return { FAIL: 'No font was found' }\n    }\n    if (!this.features.hasOwnProperty(query.script)) {\n      this.getScriptFeatures(query.script)\n    }\n    var scriptFeatures = this.features[query.script]\n    if (!scriptFeatures) {\n      return { FAIL: 'No feature for script ' + query.script }\n    }\n    if (!scriptFeatures.tags[query.tag]) {\n      return null\n    }\n    return this.features[query.script].tags[query.tag]\n  }\n\n  /**\n   * Arabic word context checkers\n   */\n\n  function arabicWordStartCheck(contextParams) {\n    var char = contextParams.current\n    var prevChar = contextParams.get(-1)\n    return (\n      // ? arabic first char\n      (prevChar === null && isArabicChar(char)) ||\n      // ? arabic char preceded with a non arabic char\n      (!isArabicChar(prevChar) && isArabicChar(char))\n    )\n  }\n\n  function arabicWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1)\n    return (\n      // ? last arabic char\n      nextChar === null ||\n      // ? next char is not arabic\n      !isArabicChar(nextChar)\n    )\n  }\n\n  var arabicWordCheck = {\n    startCheck: arabicWordStartCheck,\n    endCheck: arabicWordEndCheck,\n  }\n\n  /**\n   * Arabic sentence context checkers\n   */\n\n  function arabicSentenceStartCheck(contextParams) {\n    var char = contextParams.current\n    var prevChar = contextParams.get(-1)\n    return (\n      // ? an arabic char preceded with a non arabic char\n      (isArabicChar(char) || isTashkeelArabicChar(char)) && !isArabicChar(prevChar)\n    )\n  }\n\n  function arabicSentenceEndCheck(contextParams) {\n    var nextChar = contextParams.get(1)\n    switch (true) {\n      case nextChar === null:\n        return true\n      case !isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar):\n        var nextIsWhitespace = isWhiteSpace(nextChar)\n        if (!nextIsWhitespace) {\n          return true\n        }\n        if (nextIsWhitespace) {\n          var arabicCharAhead = false\n          arabicCharAhead = contextParams.lookahead.some(function (c) {\n            return isArabicChar(c) || isTashkeelArabicChar(c)\n          })\n          if (!arabicCharAhead) {\n            return true\n          }\n        }\n        break\n      default:\n        return false\n    }\n  }\n\n  var arabicSentenceCheck = {\n    startCheck: arabicSentenceStartCheck,\n    endCheck: arabicSentenceEndCheck,\n  }\n\n  /**\n   * Apply single substitution format 1\n   * @param {Array} substitutions substitutions\n   * @param {any} tokens a list of tokens\n   * @param {number} index token index\n   */\n  function singleSubstitutionFormat1$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution)\n  }\n\n  /**\n   * Apply single substitution format 2\n   * @param {Array} substitutions substitutions\n   * @param {any} tokens a list of tokens\n   * @param {number} index token index\n   */\n  function singleSubstitutionFormat2$1(action, tokens, index) {\n    tokens[index].setState(action.tag, action.substitution)\n  }\n\n  /**\n   * Apply chaining context substitution format 3\n   * @param {Array} substitutions substitutions\n   * @param {any} tokens a list of tokens\n   * @param {number} index token index\n   */\n  function chainingSubstitutionFormat3$1(action, tokens, index) {\n    action.substitution.forEach(function (subst, offset) {\n      var token = tokens[index + offset]\n      token.setState(action.tag, subst)\n    })\n  }\n\n  /**\n   * Apply ligature substitution format 1\n   * @param {Array} substitutions substitutions\n   * @param {any} tokens a list of tokens\n   * @param {number} index token index\n   */\n  function ligatureSubstitutionFormat1$1(action, tokens, index) {\n    var token = tokens[index]\n    token.setState(action.tag, action.substitution.ligGlyph)\n    var compsCount = action.substitution.components.length\n    for (var i = 0; i < compsCount; i++) {\n      token = tokens[index + i + 1]\n      token.setState('deleted', true)\n    }\n  }\n\n  /**\n   * Supported substitutions\n   */\n  var SUBSTITUTIONS = {\n    11: singleSubstitutionFormat1$1,\n    12: singleSubstitutionFormat2$1,\n    63: chainingSubstitutionFormat3$1,\n    41: ligatureSubstitutionFormat1$1,\n  }\n\n  /**\n   * Apply substitutions to a list of tokens\n   * @param {Array} substitutions substitutions\n   * @param {any} tokens a list of tokens\n   * @param {number} index token index\n   */\n  function applySubstitution(action, tokens, index) {\n    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n      SUBSTITUTIONS[action.id](action, tokens, index)\n    }\n  }\n\n  /**\n   * Apply Arabic presentation forms to a range of tokens\n   */\n\n  /**\n   * Check if a char can be connected to it's preceding char\n   * @param {ContextParams} charContextParams context params of a char\n   */\n  function willConnectPrev(charContextParams) {\n    var backtrack = [].concat(charContextParams.backtrack)\n    for (var i = backtrack.length - 1; i >= 0; i--) {\n      var prevChar = backtrack[i]\n      var isolated = isIsolatedArabicChar(prevChar)\n      var tashkeel = isTashkeelArabicChar(prevChar)\n      if (!isolated && !tashkeel) {\n        return true\n      }\n      if (isolated) {\n        return false\n      }\n    }\n    return false\n  }\n\n  /**\n   * Check if a char can be connected to it's proceeding char\n   * @param {ContextParams} charContextParams context params of a char\n   */\n  function willConnectNext(charContextParams) {\n    if (isIsolatedArabicChar(charContextParams.current)) {\n      return false\n    }\n    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n      var nextChar = charContextParams.lookahead[i]\n      var tashkeel = isTashkeelArabicChar(nextChar)\n      if (!tashkeel) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Apply arabic presentation forms to a list of tokens\n   * @param {ContextRange} range a range of tokens\n   */\n  function arabicPresentationForms(range) {\n    var this$1 = this\n\n    var script = 'arab'\n    var tags = this.featuresTags[script]\n    var tokens = this.tokenizer.getRangeTokens(range)\n    if (tokens.length === 1) {\n      return\n    }\n    var contextParams = new ContextParams(\n      tokens.map(function (token) {\n        return token.getState('glyphIndex')\n      }),\n      0,\n    )\n    var charContextParams = new ContextParams(\n      tokens.map(function (token) {\n        return token.char\n      }),\n      0,\n    )\n    tokens.forEach(function (token, index) {\n      if (isTashkeelArabicChar(token.char)) {\n        return\n      }\n      contextParams.setCurrentIndex(index)\n      charContextParams.setCurrentIndex(index)\n      var CONNECT = 0 // 2 bits 00 (10: can connect next) (01: can connect prev)\n      if (willConnectPrev(charContextParams)) {\n        CONNECT |= 1\n      }\n      if (willConnectNext(charContextParams)) {\n        CONNECT |= 2\n      }\n      var tag\n      switch (CONNECT) {\n        case 1:\n          tag = 'fina'\n          break\n        case 2:\n          tag = 'init'\n          break\n        case 3:\n          tag = 'medi'\n          break\n      }\n      if (tags.indexOf(tag) === -1) {\n        return\n      }\n      var substitutions = this$1.query.lookupFeature({\n        tag: tag,\n        script: script,\n        contextParams: contextParams,\n      })\n      if (substitutions instanceof Error) {\n        return console.info(substitutions.message)\n      }\n      substitutions.forEach(function (action, index) {\n        if (action instanceof SubstitutionAction) {\n          applySubstitution(action, tokens, index)\n          contextParams.context[index] = action.substitution\n        }\n      })\n    })\n  }\n\n  /**\n   * Apply Arabic required ligatures feature to a range of tokens\n   */\n\n  /**\n   * Update context params\n   * @param {any} tokens a list of tokens\n   * @param {number} index current item index\n   */\n  function getContextParams(tokens, index) {\n    var context = tokens.map(function (token) {\n      return token.activeState.value\n    })\n    return new ContextParams(context, index || 0)\n  }\n\n  /**\n   * Apply Arabic required ligatures to a context range\n   * @param {ContextRange} range a range of tokens\n   */\n  function arabicRequiredLigatures(range) {\n    var this$1 = this\n\n    var script = 'arab'\n    var tokens = this.tokenizer.getRangeTokens(range)\n    var contextParams = getContextParams(tokens)\n    contextParams.context.forEach(function (glyphIndex, index) {\n      contextParams.setCurrentIndex(index)\n      var substitutions = this$1.query.lookupFeature({\n        tag: 'rlig',\n        script: script,\n        contextParams: contextParams,\n      })\n      if (substitutions.length) {\n        substitutions.forEach(function (action) {\n          return applySubstitution(action, tokens, index)\n        })\n        contextParams = getContextParams(tokens)\n      }\n    })\n  }\n\n  /**\n   * Latin word context checkers\n   */\n\n  function latinWordStartCheck(contextParams) {\n    var char = contextParams.current\n    var prevChar = contextParams.get(-1)\n    return (\n      // ? latin first char\n      (prevChar === null && isLatinChar(char)) ||\n      // ? latin char preceded with a non latin char\n      (!isLatinChar(prevChar) && isLatinChar(char))\n    )\n  }\n\n  function latinWordEndCheck(contextParams) {\n    var nextChar = contextParams.get(1)\n    return (\n      // ? last latin char\n      nextChar === null ||\n      // ? next char is not latin\n      !isLatinChar(nextChar)\n    )\n  }\n\n  var latinWordCheck = {\n    startCheck: latinWordStartCheck,\n    endCheck: latinWordEndCheck,\n  }\n\n  /**\n   * Apply Latin ligature feature to a range of tokens\n   */\n\n  /**\n   * Update context params\n   * @param {any} tokens a list of tokens\n   * @param {number} index current item index\n   */\n  function getContextParams$1(tokens, index) {\n    var context = tokens.map(function (token) {\n      return token.activeState.value\n    })\n    return new ContextParams(context, index || 0)\n  }\n\n  /**\n   * Apply Arabic required ligatures to a context range\n   * @param {ContextRange} range a range of tokens\n   */\n  function latinLigature(range) {\n    var this$1 = this\n\n    var script = 'latn'\n    var tokens = this.tokenizer.getRangeTokens(range)\n    var contextParams = getContextParams$1(tokens)\n    contextParams.context.forEach(function (glyphIndex, index) {\n      contextParams.setCurrentIndex(index)\n      var substitutions = this$1.query.lookupFeature({\n        tag: 'liga',\n        script: script,\n        contextParams: contextParams,\n      })\n      if (substitutions.length) {\n        substitutions.forEach(function (action) {\n          return applySubstitution(action, tokens, index)\n        })\n        contextParams = getContextParams$1(tokens)\n      }\n    })\n  }\n\n  /**\n   * Infer bidirectional properties for a given text and apply\n   * the corresponding layout rules.\n   */\n\n  /**\n   * Create Bidi. features\n   * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n   */\n  function Bidi(baseDir) {\n    this.baseDir = baseDir || 'ltr'\n    this.tokenizer = new Tokenizer()\n    this.featuresTags = {}\n  }\n\n  /**\n   * Sets Bidi text\n   * @param {string} text a text input\n   */\n  Bidi.prototype.setText = function (text) {\n    this.text = text\n  }\n\n  /**\n   * Store essential context checks:\n   * arabic word check for applying gsub features\n   * arabic sentence check for adjusting arabic layout\n   */\n  Bidi.prototype.contextChecks = {\n    latinWordCheck: latinWordCheck,\n    arabicWordCheck: arabicWordCheck,\n    arabicSentenceCheck: arabicSentenceCheck,\n  }\n\n  /**\n   * Register arabic word check\n   */\n  function registerContextChecker(checkId) {\n    var check = this.contextChecks[checkId + 'Check']\n    return this.tokenizer.registerContextChecker(checkId, check.startCheck, check.endCheck)\n  }\n\n  /**\n   * Perform pre tokenization procedure then\n   * tokenize text input\n   */\n  function tokenizeText() {\n    registerContextChecker.call(this, 'latinWord')\n    registerContextChecker.call(this, 'arabicWord')\n    registerContextChecker.call(this, 'arabicSentence')\n    return this.tokenizer.tokenize(this.text)\n  }\n\n  /**\n   * Reverse arabic sentence layout\n   * TODO: check base dir before applying adjustments - priority low\n   */\n  function reverseArabicSentences() {\n    var this$1 = this\n\n    var ranges = this.tokenizer.getContextRanges('arabicSentence')\n    ranges.forEach(function (range) {\n      var rangeTokens = this$1.tokenizer.getRangeTokens(range)\n      this$1.tokenizer.replaceRange(range.startIndex, range.endOffset, rangeTokens.reverse())\n    })\n  }\n\n  /**\n   * Register supported features tags\n   * @param {script} script script tag\n   * @param {Array} tags features tags list\n   */\n  Bidi.prototype.registerFeatures = function (script, tags) {\n    var this$1 = this\n\n    var supportedTags = tags.filter(function (tag) {\n      return this$1.query.supports({ script: script, tag: tag })\n    })\n    if (!this.featuresTags.hasOwnProperty(script)) {\n      this.featuresTags[script] = supportedTags\n    } else {\n      this.featuresTags[script] = this.featuresTags[script].concat(supportedTags)\n    }\n  }\n\n  /**\n   * Apply GSUB features\n   * @param {Array} tagsList a list of features tags\n   * @param {string} script a script tag\n   * @param {Font} font opentype font instance\n   */\n  Bidi.prototype.applyFeatures = function (font, features) {\n    if (!font) {\n      throw new Error('No valid font was provided to apply features')\n    }\n    if (!this.query) {\n      this.query = new FeatureQuery(font)\n    }\n    for (var f = 0; f < features.length; f++) {\n      var feature = features[f]\n      if (!this.query.supports({ script: feature.script })) {\n        continue\n      }\n      this.registerFeatures(feature.script, feature.tags)\n    }\n  }\n\n  /**\n   * Register a state modifier\n   * @param {string} modifierId state modifier id\n   * @param {function} condition a predicate function that returns true or false\n   * @param {function} modifier a modifier function to set token state\n   */\n  Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n    this.tokenizer.registerModifier(modifierId, condition, modifier)\n  }\n\n  /**\n   * Check if 'glyphIndex' is registered\n   */\n  function checkGlyphIndexStatus() {\n    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n      throw new Error('glyphIndex modifier is required to apply ' + 'arabic presentation features.')\n    }\n  }\n\n  /**\n   * Apply arabic presentation forms features\n   */\n  function applyArabicPresentationForms() {\n    var this$1 = this\n\n    var script = 'arab'\n    if (!this.featuresTags.hasOwnProperty(script)) {\n      return\n    }\n    checkGlyphIndexStatus.call(this)\n    var ranges = this.tokenizer.getContextRanges('arabicWord')\n    ranges.forEach(function (range) {\n      arabicPresentationForms.call(this$1, range)\n    })\n  }\n\n  /**\n   * Apply required arabic ligatures\n   */\n  function applyArabicRequireLigatures() {\n    var this$1 = this\n\n    var script = 'arab'\n    if (!this.featuresTags.hasOwnProperty(script)) {\n      return\n    }\n    var tags = this.featuresTags[script]\n    if (tags.indexOf('rlig') === -1) {\n      return\n    }\n    checkGlyphIndexStatus.call(this)\n    var ranges = this.tokenizer.getContextRanges('arabicWord')\n    ranges.forEach(function (range) {\n      arabicRequiredLigatures.call(this$1, range)\n    })\n  }\n\n  /**\n   * Apply required arabic ligatures\n   */\n  function applyLatinLigatures() {\n    var this$1 = this\n\n    var script = 'latn'\n    if (!this.featuresTags.hasOwnProperty(script)) {\n      return\n    }\n    var tags = this.featuresTags[script]\n    if (tags.indexOf('liga') === -1) {\n      return\n    }\n    checkGlyphIndexStatus.call(this)\n    var ranges = this.tokenizer.getContextRanges('latinWord')\n    ranges.forEach(function (range) {\n      latinLigature.call(this$1, range)\n    })\n  }\n\n  /**\n   * Check if a context is registered\n   * @param {string} contextId context id\n   */\n  Bidi.prototype.checkContextReady = function (contextId) {\n    return !!this.tokenizer.getContext(contextId)\n  }\n\n  /**\n   * Apply features to registered contexts\n   */\n  Bidi.prototype.applyFeaturesToContexts = function () {\n    if (this.checkContextReady('arabicWord')) {\n      applyArabicPresentationForms.call(this)\n      applyArabicRequireLigatures.call(this)\n    }\n    if (this.checkContextReady('latinWord')) {\n      applyLatinLigatures.call(this)\n    }\n    if (this.checkContextReady('arabicSentence')) {\n      reverseArabicSentences.call(this)\n    }\n  }\n\n  /**\n   * process text input\n   * @param {string} text an input text\n   */\n  Bidi.prototype.processText = function (text) {\n    if (!this.text || this.text !== text) {\n      this.setText(text)\n      tokenizeText.call(this)\n      this.applyFeaturesToContexts()\n    }\n  }\n\n  /**\n   * Process a string of text to identify and adjust\n   * bidirectional text entities.\n   * @param {string} text input text\n   */\n  Bidi.prototype.getBidiText = function (text) {\n    this.processText(text)\n    return this.tokenizer.getText()\n  }\n\n  /**\n   * Get the current state index of each token\n   * @param {text} text an input text\n   */\n  Bidi.prototype.getTextGlyphs = function (text) {\n    this.processText(text)\n    var indexes = []\n    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n      var token = this.tokenizer.tokens[i]\n      if (token.state.deleted) {\n        continue\n      }\n      var index = token.activeState.value\n      indexes.push(Array.isArray(index) ? index[0] : index)\n    }\n    return indexes\n  }\n\n  // The Font object\n\n  /**\n   * @typedef FontOptions\n   * @type Object\n   * @property {Boolean} empty - whether to create a new empty font\n   * @property {string} familyName\n   * @property {string} styleName\n   * @property {string=} fullName\n   * @property {string=} postScriptName\n   * @property {string=} designer\n   * @property {string=} designerURL\n   * @property {string=} manufacturer\n   * @property {string=} manufacturerURL\n   * @property {string=} license\n   * @property {string=} licenseURL\n   * @property {string=} version\n   * @property {string=} description\n   * @property {string=} copyright\n   * @property {string=} trademark\n   * @property {Number} unitsPerEm\n   * @property {Number} ascender\n   * @property {Number} descender\n   * @property {Number} createdTimestamp\n   * @property {string=} weightClass\n   * @property {string=} widthClass\n   * @property {string=} fsSelection\n   */\n\n  /**\n   * A Font represents a loaded OpenType font file.\n   * It contains a set of glyphs and methods to draw text on a drawing context,\n   * or to get a path representing the text.\n   * @exports opentype.Font\n   * @class\n   * @param {FontOptions}\n   * @constructor\n   */\n  function Font(options) {\n    options = options || {}\n    options.tables = options.tables || {}\n\n    if (!options.empty) {\n      // Check that we've provided the minimum set of names.\n      checkArgument(options.familyName, 'When creating a new Font object, familyName is required.')\n      checkArgument(options.styleName, 'When creating a new Font object, styleName is required.')\n      checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.')\n      checkArgument(options.ascender, 'When creating a new Font object, ascender is required.')\n      checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.')\n\n      // OS X will complain if the names are empty, so we put a single space everywhere by default.\n      this.names = {\n        fontFamily: { en: options.familyName || ' ' },\n        fontSubfamily: { en: options.styleName || ' ' },\n        fullName: { en: options.fullName || options.familyName + ' ' + options.styleName },\n        // postScriptName may not contain any whitespace\n        postScriptName: { en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '') },\n        designer: { en: options.designer || ' ' },\n        designerURL: { en: options.designerURL || ' ' },\n        manufacturer: { en: options.manufacturer || ' ' },\n        manufacturerURL: { en: options.manufacturerURL || ' ' },\n        license: { en: options.license || ' ' },\n        licenseURL: { en: options.licenseURL || ' ' },\n        version: { en: options.version || 'Version 0.1' },\n        description: { en: options.description || ' ' },\n        copyright: { en: options.copyright || ' ' },\n        trademark: { en: options.trademark || ' ' },\n      }\n      this.unitsPerEm = options.unitsPerEm || 1000\n      this.ascender = options.ascender\n      this.descender = options.descender\n      this.createdTimestamp = options.createdTimestamp\n      this.tables = Object.assign(options.tables, {\n        os2: Object.assign(\n          {\n            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,\n          },\n          options.tables.os2,\n        ),\n      })\n    }\n\n    this.supported = true // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || [])\n    this.encoding = new DefaultEncoding(this)\n    this.position = new Position(this)\n    this.substitution = new Substitution(this)\n    this.tables = this.tables || {}\n\n    // needed for low memory mode only.\n    this._push = null\n    this._hmtxTableData = {}\n\n    Object.defineProperty(this, 'hinting', {\n      get: function () {\n        if (this._hinting) {\n          return this._hinting\n        }\n        if (this.outlinesFormat === 'truetype') {\n          return (this._hinting = new Hinting(this))\n        }\n      },\n    })\n  }\n\n  /**\n   * Check if the font has a glyph for the given character.\n   * @param  {string}\n   * @return {Boolean}\n   */\n  Font.prototype.hasChar = function (c) {\n    return this.encoding.charToGlyphIndex(c) !== null\n  }\n\n  /**\n   * Convert the given character to a single glyph index.\n   * Note that this function assumes that there is a one-to-one mapping between\n   * the given character and a glyph; for complex scripts this might not be the case.\n   * @param  {string}\n   * @return {Number}\n   */\n  Font.prototype.charToGlyphIndex = function (s) {\n    return this.encoding.charToGlyphIndex(s)\n  }\n\n  /**\n   * Convert the given character to a single Glyph object.\n   * Note that this function assumes that there is a one-to-one mapping between\n   * the given character and a glyph; for complex scripts this might not be the case.\n   * @param  {string}\n   * @return {opentype.Glyph}\n   */\n  Font.prototype.charToGlyph = function (c) {\n    var glyphIndex = this.charToGlyphIndex(c)\n    var glyph = this.glyphs.get(glyphIndex)\n    if (!glyph) {\n      // .notdef\n      glyph = this.glyphs.get(0)\n    }\n\n    return glyph\n  }\n\n  /**\n   * Update features\n   * @param {any} options features options\n   */\n  Font.prototype.updateFeatures = function (options) {\n    // TODO: update all features options not only 'latn'.\n    return this.defaultRenderOptions.features.map(function (feature) {\n      if (feature.script === 'latn') {\n        return {\n          script: 'latn',\n          tags: feature.tags.filter(function (tag) {\n            return options[tag]\n          }),\n        }\n      } else {\n        return feature\n      }\n    })\n  }\n\n  /**\n   * Convert the given text to a list of Glyph objects.\n   * Note that there is no strict one-to-one mapping between characters and\n   * glyphs, so the list of returned glyphs can be larger or smaller than the\n   * length of the given string.\n   * @param  {string}\n   * @param  {GlyphRenderOptions} [options]\n   * @return {opentype.Glyph[]}\n   */\n  Font.prototype.stringToGlyphs = function (s, options) {\n    var this$1 = this\n\n    var bidi = new Bidi()\n\n    // Create and register 'glyphIndex' state modifier\n    var charToGlyphIndexMod = function (token) {\n      return this$1.charToGlyphIndex(token.char)\n    }\n    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod)\n\n    // roll-back to default features\n    var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features\n\n    bidi.applyFeatures(this, features)\n\n    var indexes = bidi.getTextGlyphs(s)\n\n    var length = indexes.length\n\n    // convert glyph indexes to glyph objects\n    var glyphs = new Array(length)\n    var notdef = this.glyphs.get(0)\n    for (var i = 0; i < length; i += 1) {\n      glyphs[i] = this.glyphs.get(indexes[i]) || notdef\n    }\n    return glyphs\n  }\n\n  /**\n   * @param  {string}\n   * @return {Number}\n   */\n  Font.prototype.nameToGlyphIndex = function (name) {\n    return this.glyphNames.nameToGlyphIndex(name)\n  }\n\n  /**\n   * @param  {string}\n   * @return {opentype.Glyph}\n   */\n  Font.prototype.nameToGlyph = function (name) {\n    var glyphIndex = this.nameToGlyphIndex(name)\n    var glyph = this.glyphs.get(glyphIndex)\n    if (!glyph) {\n      // .notdef\n      glyph = this.glyphs.get(0)\n    }\n\n    return glyph\n  }\n\n  /**\n   * @param  {Number}\n   * @return {String}\n   */\n  Font.prototype.glyphIndexToName = function (gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n      return ''\n    }\n\n    return this.glyphNames.glyphIndexToName(gid)\n  }\n\n  /**\n   * Retrieve the value of the kerning pair between the left glyph (or its index)\n   * and the right glyph (or its index). If no kerning pair is found, return 0.\n   * The kerning value gets added to the advance width when calculating the spacing\n   * between glyphs.\n   * For GPOS kerning, this method uses the default script and language, which covers\n   * most use cases. To have greater control, use font.position.getKerningValue .\n   * @param  {opentype.Glyph} leftGlyph\n   * @param  {opentype.Glyph} rightGlyph\n   * @return {Number}\n   */\n  Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph\n    rightGlyph = rightGlyph.index || rightGlyph\n    var gposKerning = this.position.defaultKerningTables\n    if (gposKerning) {\n      return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph)\n    }\n    // \"kern\" table\n    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0\n  }\n\n  /**\n   * @typedef GlyphRenderOptions\n   * @type Object\n   * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n   *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n   * @property {string} [language='dflt'] - language system used to determine which features to apply.\n   *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n   * @property {boolean} [kerning=true] - whether to include kerning values\n   * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n   *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n   */\n  Font.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: [\n      /**\n       * these 4 features are required to render Arabic text properly\n       * and shouldn't be turned off when rendering arabic text.\n       */\n      { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n      { script: 'latn', tags: ['liga', 'rlig'] },\n    ],\n  }\n\n  /**\n   * Helper function that invokes the given callback for each glyph in the given text.\n   * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n   * @param {string} text - The text to apply.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {GlyphRenderOptions=} options\n   * @param  {Function} callback\n   */\n  Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0\n    y = y !== undefined ? y : 0\n    fontSize = fontSize !== undefined ? fontSize : 72\n    options = Object.assign({}, this.defaultRenderOptions, options)\n    var fontScale = (1 / this.unitsPerEm) * fontSize\n    var glyphs = this.stringToGlyphs(text, options)\n    var kerningLookups\n    if (options.kerning) {\n      var script = options.script || this.position.getDefaultScriptName()\n      kerningLookups = this.position.getKerningTables(script, options.language)\n    }\n    for (var i = 0; i < glyphs.length; i += 1) {\n      var glyph = glyphs[i]\n      callback.call(this, glyph, x, y, fontSize, options)\n      if (glyph.advanceWidth) {\n        x += glyph.advanceWidth * fontScale\n      }\n\n      if (options.kerning && i < glyphs.length - 1) {\n        // We should apply position adjustment lookups in a more generic way.\n        // Here we only use the xAdvance value.\n        var kerningValue = kerningLookups\n          ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index)\n          : this.getKerningValue(glyph, glyphs[i + 1])\n        x += kerningValue * fontScale\n      }\n\n      if (options.letterSpacing) {\n        x += options.letterSpacing * fontSize\n      } else if (options.tracking) {\n        x += (options.tracking / 1000) * fontSize\n      }\n    }\n    return x\n  }\n\n  /**\n   * Create a Path object that represents the given text.\n   * @param  {string} text - The text to create.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {GlyphRenderOptions=} options\n   * @return {opentype.Path}\n   */\n  Font.prototype.getPath = function (text, x, y, fontSize, options) {\n    var fullPath = new Path()\n    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n      var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this)\n      fullPath.extend(glyphPath)\n    })\n    return fullPath\n  }\n\n  /**\n   * Create an array of Path objects that represent the glyphs of a given text.\n   * @param  {string} text - The text to create.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {GlyphRenderOptions=} options\n   * @return {opentype.Path[]}\n   */\n  Font.prototype.getPaths = function (text, x, y, fontSize, options) {\n    var glyphPaths = []\n    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n      var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this)\n      glyphPaths.push(glyphPath)\n    })\n\n    return glyphPaths\n  }\n\n  /**\n   * Returns the advance width of a text.\n   *\n   * This is something different than Path.getBoundingBox() as for example a\n   * suffixed whitespace increases the advanceWidth but not the bounding box\n   * or an overhanging letter like a calligraphic 'f' might have a quite larger\n   * bounding box than its advance width.\n   *\n   * This corresponds to canvas2dContext.measureText(text).width\n   *\n   * @param  {string} text - The text to create.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {GlyphRenderOptions=} options\n   * @return advance width\n   */\n  Font.prototype.getAdvanceWidth = function (text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function () {})\n  }\n\n  /**\n   * Draw the text on the given drawing context.\n   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n   * @param  {string} text - The text to create.\n   * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param  {GlyphRenderOptions=} options\n   */\n  Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx)\n  }\n\n  /**\n   * Draw the points of all glyphs in the text.\n   * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n   * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n   * @param {string} text - The text to create.\n   * @param {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param {GlyphRenderOptions=} options\n   */\n  Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n      glyph.drawPoints(ctx, gX, gY, gFontSize)\n    })\n  }\n\n  /**\n   * Draw lines indicating important font measurements for all glyphs in the text.\n   * Black lines indicate the origin of the coordinate system (point 0,0).\n   * Blue lines indicate the glyph bounding box.\n   * Green line indicates the advance width of the glyph.\n   * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n   * @param {string} text - The text to create.\n   * @param {number} [x=0] - Horizontal position of the beginning of the text.\n   * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n   * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n   * @param {GlyphRenderOptions=} options\n   */\n  Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {\n      glyph.drawMetrics(ctx, gX, gY, gFontSize)\n    })\n  }\n\n  /**\n   * @param  {string}\n   * @return {string}\n   */\n  Font.prototype.getEnglishName = function (name) {\n    var translations = this.names[name]\n    if (translations) {\n      return translations.en\n    }\n  }\n\n  /**\n   * Validate\n   */\n  Font.prototype.validate = function () {\n    var _this = this\n\n    function assert(predicate) {}\n\n    function assertNamePresent(name) {\n      var englishName = _this.getEnglishName(name)\n      assert(englishName && englishName.trim().length > 0)\n    }\n\n    // Identification information\n    assertNamePresent('fontFamily')\n    assertNamePresent('weightName')\n    assertNamePresent('manufacturer')\n    assertNamePresent('copyright')\n    assertNamePresent('version')\n\n    // Dimension information\n    assert(this.unitsPerEm > 0)\n  }\n\n  /**\n   * Convert the font object to a SFNT data structure.\n   * This structure contains all the necessary tables and metadata to create a binary OTF file.\n   * @return {opentype.Table}\n   */\n  Font.prototype.toTables = function () {\n    return sfnt.fontToTable(this)\n  }\n  /**\n   * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n   */\n  Font.prototype.toBuffer = function () {\n    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.')\n    return this.toArrayBuffer()\n  }\n  /**\n   * Converts a `opentype.Font` into an `ArrayBuffer`\n   * @return {ArrayBuffer}\n   */\n  Font.prototype.toArrayBuffer = function () {\n    var sfntTable = this.toTables()\n    var bytes = sfntTable.encode()\n    var buffer = new ArrayBuffer(bytes.length)\n    var intArray = new Uint8Array(buffer)\n    for (var i = 0; i < bytes.length; i++) {\n      intArray[i] = bytes[i]\n    }\n\n    return buffer\n  }\n\n  /**\n   * @private\n   */\n  Font.prototype.fsSelectionValues = {\n    ITALIC: 0x001, //1\n    UNDERSCORE: 0x002, //2\n    NEGATIVE: 0x004, //4\n    OUTLINED: 0x008, //8\n    STRIKEOUT: 0x010, //16\n    BOLD: 0x020, //32\n    REGULAR: 0x040, //64\n    USER_TYPO_METRICS: 0x080, //128\n    WWS: 0x100, //256\n    OBLIQUE: 0x200, //512\n  }\n\n  /**\n   * @private\n   */\n  Font.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9,\n  }\n\n  /**\n   * @private\n   */\n  Font.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK: 900,\n  }\n\n  // The `fvar` table stores font variation axes and instances.\n\n  function addName(name, names) {\n    var nameString = JSON.stringify(name)\n    var nameID = 256\n    for (var nameKey in names) {\n      var n = parseInt(nameKey)\n      if (!n || n < 256) {\n        continue\n      }\n\n      if (JSON.stringify(names[nameKey]) === nameString) {\n        return n\n      }\n\n      if (nameID <= n) {\n        nameID = n + 1\n      }\n    }\n\n    names[nameID] = name\n    return nameID\n  }\n\n  function makeFvarAxis(n, axis, names) {\n    var nameID = addName(axis.name, names)\n    return [\n      { name: 'tag_' + n, type: 'TAG', value: axis.tag },\n      { name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16 },\n      { name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16 },\n      { name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16 },\n      { name: 'flags_' + n, type: 'USHORT', value: 0 },\n      { name: 'nameID_' + n, type: 'USHORT', value: nameID },\n    ]\n  }\n\n  function parseFvarAxis(data, start, names) {\n    var axis = {}\n    var p = new parse.Parser(data, start)\n    axis.tag = p.parseTag()\n    axis.minValue = p.parseFixed()\n    axis.defaultValue = p.parseFixed()\n    axis.maxValue = p.parseFixed()\n    p.skip('uShort', 1) // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {}\n    return axis\n  }\n\n  function makeFvarInstance(n, inst, axes, names) {\n    var nameID = addName(inst.name, names)\n    var fields = [\n      { name: 'nameID_' + n, type: 'USHORT', value: nameID },\n      { name: 'flags_' + n, type: 'USHORT', value: 0 },\n    ]\n\n    for (var i = 0; i < axes.length; ++i) {\n      var axisTag = axes[i].tag\n      fields.push({\n        name: 'axis_' + n + ' ' + axisTag,\n        type: 'FIXED',\n        value: inst.coordinates[axisTag] << 16,\n      })\n    }\n\n    return fields\n  }\n\n  function parseFvarInstance(data, start, axes, names) {\n    var inst = {}\n    var p = new parse.Parser(data, start)\n    inst.name = names[p.parseUShort()] || {}\n    p.skip('uShort', 1) // reserved for flags; no values defined\n\n    inst.coordinates = {}\n    for (var i = 0; i < axes.length; ++i) {\n      inst.coordinates[axes[i].tag] = p.parseFixed()\n    }\n\n    return inst\n  }\n\n  function makeFvarTable(fvar, names) {\n    var result = new table.Table('fvar', [\n      { name: 'version', type: 'ULONG', value: 0x10000 },\n      { name: 'offsetToData', type: 'USHORT', value: 0 },\n      { name: 'countSizePairs', type: 'USHORT', value: 2 },\n      { name: 'axisCount', type: 'USHORT', value: fvar.axes.length },\n      { name: 'axisSize', type: 'USHORT', value: 20 },\n      { name: 'instanceCount', type: 'USHORT', value: fvar.instances.length },\n      { name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4 },\n    ])\n    result.offsetToData = result.sizeOf()\n\n    for (var i = 0; i < fvar.axes.length; i++) {\n      result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names))\n    }\n\n    for (var j = 0; j < fvar.instances.length; j++) {\n      result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names))\n    }\n\n    return result\n  }\n\n  function parseFvarTable(data, start, names) {\n    var p = new parse.Parser(data, start)\n    var tableVersion = p.parseULong()\n    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.')\n    var offsetToData = p.parseOffset16()\n    // Skip countSizePairs.\n    p.skip('uShort', 1)\n    var axisCount = p.parseUShort()\n    var axisSize = p.parseUShort()\n    var instanceCount = p.parseUShort()\n    var instanceSize = p.parseUShort()\n\n    var axes = []\n    for (var i = 0; i < axisCount; i++) {\n      axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names))\n    }\n\n    var instances = []\n    var instanceStart = start + offsetToData + axisCount * axisSize\n    for (var j = 0; j < instanceCount; j++) {\n      instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names))\n    }\n\n    return { axes: axes, instances: instances }\n  }\n\n  var fvar = { make: makeFvarTable, parse: parseFvarTable }\n\n  // The `GDEF` table contains various glyph properties\n\n  var attachList = function () {\n    return {\n      coverage: this.parsePointer(Parser.coverage),\n      attachPoints: this.parseList(Parser.pointer(Parser.uShortList)),\n    }\n  }\n\n  var caretValue = function () {\n    var format = this.parseUShort()\n    check.argument(format === 1 || format === 2 || format === 3, 'Unsupported CaretValue table version.')\n    if (format === 1) {\n      return { coordinate: this.parseShort() }\n    } else if (format === 2) {\n      return { pointindex: this.parseShort() }\n    } else if (format === 3) {\n      // Device / Variation Index tables unsupported\n      return { coordinate: this.parseShort() }\n    }\n  }\n\n  var ligGlyph = function () {\n    return this.parseList(Parser.pointer(caretValue))\n  }\n\n  var ligCaretList = function () {\n    return {\n      coverage: this.parsePointer(Parser.coverage),\n      ligGlyphs: this.parseList(Parser.pointer(ligGlyph)),\n    }\n  }\n\n  var markGlyphSets = function () {\n    this.parseUShort() // Version\n    return this.parseList(Parser.pointer(Parser.coverage))\n  }\n\n  function parseGDEFTable(data, start) {\n    start = start || 0\n    var p = new Parser(data, start)\n    var tableVersion = p.parseVersion(1)\n    check.argument(\n      tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n      'Unsupported GDEF table version.',\n    )\n    var gdef = {\n      version: tableVersion,\n      classDef: p.parsePointer(Parser.classDef),\n      attachList: p.parsePointer(attachList),\n      ligCaretList: p.parsePointer(ligCaretList),\n      markAttachClassDef: p.parsePointer(Parser.classDef),\n    }\n    if (tableVersion >= 1.2) {\n      gdef.markGlyphSets = p.parsePointer(markGlyphSets)\n    }\n    return gdef\n  }\n  var gdef = { parse: parseGDEFTable }\n\n  // The `GPOS` table contains kerning pairs, among other things.\n\n  var subtableParsers$1 = new Array(10) // subtableParsers[0] is unused\n\n  // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n  // this = Parser instance\n  subtableParsers$1[1] = function parseLookup1() {\n    var start = this.offset + this.relativeOffset\n    var posformat = this.parseUShort()\n    if (posformat === 1) {\n      return {\n        posFormat: 1,\n        coverage: this.parsePointer(Parser.coverage),\n        value: this.parseValueRecord(),\n      }\n    } else if (posformat === 2) {\n      return {\n        posFormat: 2,\n        coverage: this.parsePointer(Parser.coverage),\n        values: this.parseValueRecordList(),\n      }\n    }\n    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.')\n  }\n\n  // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\n  subtableParsers$1[2] = function parseLookup2() {\n    var start = this.offset + this.relativeOffset\n    var posFormat = this.parseUShort()\n    check.assert(\n      posFormat === 1 || posFormat === 2,\n      '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.',\n    )\n    var coverage = this.parsePointer(Parser.coverage)\n    var valueFormat1 = this.parseUShort()\n    var valueFormat2 = this.parseUShort()\n    if (posFormat === 1) {\n      // Adjustments for Glyph Pairs\n      return {\n        posFormat: posFormat,\n        coverage: coverage,\n        valueFormat1: valueFormat1,\n        valueFormat2: valueFormat2,\n        pairSets: this.parseList(\n          Parser.pointer(\n            Parser.list(function () {\n              return {\n                // pairValueRecord\n                secondGlyph: this.parseUShort(),\n                value1: this.parseValueRecord(valueFormat1),\n                value2: this.parseValueRecord(valueFormat2),\n              }\n            }),\n          ),\n        ),\n      }\n    } else if (posFormat === 2) {\n      var classDef1 = this.parsePointer(Parser.classDef)\n      var classDef2 = this.parsePointer(Parser.classDef)\n      var class1Count = this.parseUShort()\n      var class2Count = this.parseUShort()\n      return {\n        // Class Pair Adjustment\n        posFormat: posFormat,\n        coverage: coverage,\n        valueFormat1: valueFormat1,\n        valueFormat2: valueFormat2,\n        classDef1: classDef1,\n        classDef2: classDef2,\n        class1Count: class1Count,\n        class2Count: class2Count,\n        classRecords: this.parseList(\n          class1Count,\n          Parser.list(class2Count, function () {\n            return {\n              value1: this.parseValueRecord(valueFormat1),\n              value2: this.parseValueRecord(valueFormat2),\n            }\n          }),\n        ),\n      }\n    }\n  }\n\n  subtableParsers$1[3] = function parseLookup3() {\n    return { error: 'GPOS Lookup 3 not supported' }\n  }\n  subtableParsers$1[4] = function parseLookup4() {\n    return { error: 'GPOS Lookup 4 not supported' }\n  }\n  subtableParsers$1[5] = function parseLookup5() {\n    return { error: 'GPOS Lookup 5 not supported' }\n  }\n  subtableParsers$1[6] = function parseLookup6() {\n    return { error: 'GPOS Lookup 6 not supported' }\n  }\n  subtableParsers$1[7] = function parseLookup7() {\n    return { error: 'GPOS Lookup 7 not supported' }\n  }\n  subtableParsers$1[8] = function parseLookup8() {\n    return { error: 'GPOS Lookup 8 not supported' }\n  }\n  subtableParsers$1[9] = function parseLookup9() {\n    return { error: 'GPOS Lookup 9 not supported' }\n  }\n\n  // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\n  function parseGposTable(data, start) {\n    start = start || 0\n    var p = new Parser(data, start)\n    var tableVersion = p.parseVersion(1)\n    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion)\n\n    if (tableVersion === 1) {\n      return {\n        version: tableVersion,\n        scripts: p.parseScriptList(),\n        features: p.parseFeatureList(),\n        lookups: p.parseLookupList(subtableParsers$1),\n      }\n    } else {\n      return {\n        version: tableVersion,\n        scripts: p.parseScriptList(),\n        features: p.parseFeatureList(),\n        lookups: p.parseLookupList(subtableParsers$1),\n        variations: p.parseFeatureVariationsList(),\n      }\n    }\n  }\n\n  // GPOS Writing //////////////////////////////////////////////\n  // NOT SUPPORTED\n  var subtableMakers$1 = new Array(10)\n\n  function makeGposTable(gpos) {\n    return new table.Table('GPOS', [\n      { name: 'version', type: 'ULONG', value: 0x10000 },\n      { name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts) },\n      { name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features) },\n      { name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1) },\n    ])\n  }\n\n  var gpos = { parse: parseGposTable, make: makeGposTable }\n\n  // The `kern` table contains kerning pairs.\n\n  function parseWindowsKernTable(p) {\n    var pairs = {}\n    // Skip nTables.\n    p.skip('uShort')\n    var subtableVersion = p.parseUShort()\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.')\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2)\n    var nPairs = p.parseUShort()\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3)\n    for (var i = 0; i < nPairs; i += 1) {\n      var leftIndex = p.parseUShort()\n      var rightIndex = p.parseUShort()\n      var value = p.parseShort()\n      pairs[leftIndex + ',' + rightIndex] = value\n    }\n    return pairs\n  }\n\n  function parseMacKernTable(p) {\n    var pairs = {}\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort')\n    var nTables = p.parseULong()\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n      console.warn('Only the first kern subtable is supported.')\n    }\n    p.skip('uLong')\n    var coverage = p.parseUShort()\n    var subtableVersion = coverage & 0xff\n    p.skip('uShort')\n    if (subtableVersion === 0) {\n      var nPairs = p.parseUShort()\n      // Skip searchRange, entrySelector, rangeShift.\n      p.skip('uShort', 3)\n      for (var i = 0; i < nPairs; i += 1) {\n        var leftIndex = p.parseUShort()\n        var rightIndex = p.parseUShort()\n        var value = p.parseShort()\n        pairs[leftIndex + ',' + rightIndex] = value\n      }\n    }\n    return pairs\n  }\n\n  // Parse the `kern` table which contains kerning pairs.\n  function parseKernTable(data, start) {\n    var p = new parse.Parser(data, start)\n    var tableVersion = p.parseUShort()\n    if (tableVersion === 0) {\n      return parseWindowsKernTable(p)\n    } else if (tableVersion === 1) {\n      return parseMacKernTable(p)\n    } else {\n      throw new Error('Unsupported kern table version (' + tableVersion + ').')\n    }\n  }\n\n  var kern = { parse: parseKernTable }\n\n  // The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n  // Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n  // relative to the beginning of the glyphData table.\n  // The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n  // The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n  // version where offsets are stored as uLongs. The `head` table specifies which version to use\n  // (under indexToLocFormat).\n  function parseLocaTable(data, start, numGlyphs, shortVersion) {\n    var p = new parse.Parser(data, start)\n    var parseFn = shortVersion ? p.parseUShort : p.parseULong\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    var glyphOffsets = []\n    for (var i = 0; i < numGlyphs + 1; i += 1) {\n      var glyphOffset = parseFn.call(p)\n      if (shortVersion) {\n        // The short table version stores the actual offset divided by 2.\n        glyphOffset *= 2\n      }\n\n      glyphOffsets.push(glyphOffset)\n    }\n\n    return glyphOffsets\n  }\n\n  var loca = { parse: parseLocaTable }\n\n  // opentype.js\n\n  // Table Directory Entries //////////////////////////////////////////////\n  /**\n   * Parses OpenType table entries.\n   * @param  {DataView}\n   * @param  {Number}\n   * @return {Object[]}\n   */\n  function parseOpenTypeTableEntries(data, numTables) {\n    var tableEntries = []\n    var p = 12\n    for (var i = 0; i < numTables; i += 1) {\n      var tag = parse.getTag(data, p)\n      var checksum = parse.getULong(data, p + 4)\n      var offset = parse.getULong(data, p + 8)\n      var length = parse.getULong(data, p + 12)\n      tableEntries.push({ tag: tag, checksum: checksum, offset: offset, length: length, compression: false })\n      p += 16\n    }\n\n    return tableEntries\n  }\n\n  /**\n   * Parses WOFF table entries.\n   * @param  {DataView}\n   * @param  {Number}\n   * @return {Object[]}\n   */\n  function parseWOFFTableEntries(data, numTables) {\n    var tableEntries = []\n    var p = 44 // offset to the first table directory entry.\n    for (var i = 0; i < numTables; i += 1) {\n      var tag = parse.getTag(data, p)\n      var offset = parse.getULong(data, p + 4)\n      var compLength = parse.getULong(data, p + 8)\n      var origLength = parse.getULong(data, p + 12)\n      var compression = void 0\n      if (compLength < origLength) {\n        compression = 'WOFF'\n      } else {\n        compression = false\n      }\n\n      tableEntries.push({\n        tag: tag,\n        offset: offset,\n        compression: compression,\n        compressedLength: compLength,\n        length: origLength,\n      })\n      p += 20\n    }\n\n    return tableEntries\n  }\n\n  /**\n   * @typedef TableData\n   * @type Object\n   * @property {DataView} data - The DataView\n   * @property {number} offset - The data offset.\n   */\n\n  /**\n   * @param  {DataView}\n   * @param  {Object}\n   * @return {TableData}\n   */\n  function uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n      var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2)\n      var outBuffer = new Uint8Array(tableEntry.length)\n      tinyInflate(inBuffer, outBuffer)\n      if (outBuffer.byteLength !== tableEntry.length) {\n        throw new Error('Decompression error: ' + tableEntry.tag + \" decompressed length doesn't match recorded length\")\n      }\n\n      var view = new DataView(outBuffer.buffer, 0)\n      return { data: view, offset: 0 }\n    } else {\n      return { data: data, offset: tableEntry.offset }\n    }\n  }\n\n  // Public API ///////////////////////////////////////////////////////////\n\n  /**\n   * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n   * Throws an error if the font could not be parsed.\n   * @param  {ArrayBuffer}\n   * @param  {Object} opt - options for parsing\n   * @return {opentype.Font}\n   */\n  function parseBuffer(buffer, opt) {\n    opt = opt === undefined || opt === null ? {} : opt\n\n    var indexToLocFormat\n    var ltagTable\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    var font = new Font({ empty: true })\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    var data = new DataView(buffer, 0)\n    var numTables\n    var tableEntries = []\n    var signature = parse.getTag(data, 0)\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n      font.outlinesFormat = 'truetype'\n      numTables = parse.getUShort(data, 4)\n      tableEntries = parseOpenTypeTableEntries(data, numTables)\n    } else if (signature === 'OTTO') {\n      font.outlinesFormat = 'cff'\n      numTables = parse.getUShort(data, 4)\n      tableEntries = parseOpenTypeTableEntries(data, numTables)\n    } else if (signature === 'wOFF') {\n      var flavor = parse.getTag(data, 4)\n      if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n        font.outlinesFormat = 'truetype'\n      } else if (flavor === 'OTTO') {\n        font.outlinesFormat = 'cff'\n      } else {\n        throw new Error('Unsupported OpenType flavor ' + signature)\n      }\n\n      numTables = parse.getUShort(data, 12)\n      tableEntries = parseWOFFTableEntries(data, numTables)\n    } else {\n      throw new Error('Unsupported OpenType signature ' + signature)\n    }\n\n    var cffTableEntry\n    var fvarTableEntry\n    var glyfTableEntry\n    var gdefTableEntry\n    var gposTableEntry\n    var gsubTableEntry\n    var hmtxTableEntry\n    var kernTableEntry\n    var locaTableEntry\n    var nameTableEntry\n    var metaTableEntry\n    var p\n\n    for (var i = 0; i < numTables; i += 1) {\n      var tableEntry = tableEntries[i]\n      var table = void 0\n      switch (tableEntry.tag) {\n        case 'cmap':\n          table = uncompressTable(data, tableEntry)\n          font.tables.cmap = cmap.parse(table.data, table.offset)\n          font.encoding = new CmapEncoding(font.tables.cmap)\n          break\n        case 'cvt ':\n          table = uncompressTable(data, tableEntry)\n          p = new parse.Parser(table.data, table.offset)\n          font.tables.cvt = p.parseShortList(tableEntry.length / 2)\n          break\n        case 'fvar':\n          fvarTableEntry = tableEntry\n          break\n        case 'fpgm':\n          table = uncompressTable(data, tableEntry)\n          p = new parse.Parser(table.data, table.offset)\n          font.tables.fpgm = p.parseByteList(tableEntry.length)\n          break\n        case 'head':\n          table = uncompressTable(data, tableEntry)\n          font.tables.head = head.parse(table.data, table.offset)\n          font.unitsPerEm = font.tables.head.unitsPerEm\n          indexToLocFormat = font.tables.head.indexToLocFormat\n          break\n        case 'hhea':\n          table = uncompressTable(data, tableEntry)\n          font.tables.hhea = hhea.parse(table.data, table.offset)\n          font.ascender = font.tables.hhea.ascender\n          font.descender = font.tables.hhea.descender\n          font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics\n          break\n        case 'hmtx':\n          hmtxTableEntry = tableEntry\n          break\n        case 'ltag':\n          table = uncompressTable(data, tableEntry)\n          ltagTable = ltag.parse(table.data, table.offset)\n          break\n        case 'maxp':\n          table = uncompressTable(data, tableEntry)\n          font.tables.maxp = maxp.parse(table.data, table.offset)\n          font.numGlyphs = font.tables.maxp.numGlyphs\n          break\n        case 'name':\n          nameTableEntry = tableEntry\n          break\n        case 'OS/2':\n          table = uncompressTable(data, tableEntry)\n          font.tables.os2 = os2.parse(table.data, table.offset)\n          break\n        case 'post':\n          table = uncompressTable(data, tableEntry)\n          font.tables.post = post.parse(table.data, table.offset)\n          font.glyphNames = new GlyphNames(font.tables.post)\n          break\n        case 'prep':\n          table = uncompressTable(data, tableEntry)\n          p = new parse.Parser(table.data, table.offset)\n          font.tables.prep = p.parseByteList(tableEntry.length)\n          break\n        case 'glyf':\n          glyfTableEntry = tableEntry\n          break\n        case 'loca':\n          locaTableEntry = tableEntry\n          break\n        case 'CFF ':\n          cffTableEntry = tableEntry\n          break\n        case 'kern':\n          kernTableEntry = tableEntry\n          break\n        case 'GDEF':\n          gdefTableEntry = tableEntry\n          break\n        case 'GPOS':\n          gposTableEntry = tableEntry\n          break\n        case 'GSUB':\n          gsubTableEntry = tableEntry\n          break\n        case 'meta':\n          metaTableEntry = tableEntry\n          break\n      }\n    }\n\n    var nameTable = uncompressTable(data, nameTableEntry)\n    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable)\n    font.names = font.tables.name\n\n    if (glyfTableEntry && locaTableEntry) {\n      var shortVersion = indexToLocFormat === 0\n      var locaTable = uncompressTable(data, locaTableEntry)\n      var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion)\n      var glyfTable = uncompressTable(data, glyfTableEntry)\n      font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt)\n    } else if (cffTableEntry) {\n      var cffTable = uncompressTable(data, cffTableEntry)\n      cff.parse(cffTable.data, cffTable.offset, font, opt)\n    } else {\n      throw new Error(\"Font doesn't contain TrueType or CFF outlines.\")\n    }\n\n    var hmtxTable = uncompressTable(data, hmtxTableEntry)\n    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt)\n    addGlyphNames(font, opt)\n\n    if (kernTableEntry) {\n      var kernTable = uncompressTable(data, kernTableEntry)\n      font.kerningPairs = kern.parse(kernTable.data, kernTable.offset)\n    } else {\n      font.kerningPairs = {}\n    }\n\n    if (gdefTableEntry) {\n      var gdefTable = uncompressTable(data, gdefTableEntry)\n      font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset)\n    }\n\n    if (gposTableEntry) {\n      var gposTable = uncompressTable(data, gposTableEntry)\n      font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset)\n      font.position.init()\n    }\n\n    if (gsubTableEntry) {\n      var gsubTable = uncompressTable(data, gsubTableEntry)\n      font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset)\n    }\n\n    if (fvarTableEntry) {\n      var fvarTable = uncompressTable(data, fvarTableEntry)\n      font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names)\n    }\n\n    if (metaTableEntry) {\n      var metaTable = uncompressTable(data, metaTableEntry)\n      font.tables.meta = meta.parse(metaTable.data, metaTable.offset)\n      font.metas = font.tables.meta\n    }\n\n    return font\n  }\n\n  return { parseBuffer }\n})()\n\nexport { parseBuffer as parse }\n", "import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nconst hasColorSpace = 'colorSpace' in new Texture()\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n", "import {\n  CompressedTexture,\n  FileLoader,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  UnsignedByteType,\n} from 'three'\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap()\n\nclass BasisTextureLoader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    const EngineFormat = _EngineFormat\n    const TranscoderFormat = _TranscoderFormat\n    const BasisFormat = _BasisFormat\n\n    onmessage = function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel\n                ? transcodeLowLevel(message.taskConfig)\n                : transcode(message.buffers[0])\n\n              const buffers = []\n\n              for (let i = 0; i < mipmaps.length; ++i) {\n                buffers.push(mipmaps[i].data.buffer)\n              }\n\n              self.postMessage({ type: 'transcode', id: message.id, width, height, hasAlpha, mipmaps, format }, buffers)\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    }\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n      })\n    }\n\n    function transcodeLowLevel(taskConfig) {\n      const { basisFormat, width, height, hasAlpha } = taskConfig\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.')\n\n      const mipmaps = []\n\n      if (basisFormat === BasisFormat.ETC1S) {\n        const transcoder = new BasisModule.LowLevelETC1SImageTranscoder()\n\n        const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData\n\n        try {\n          let ok\n\n          ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.')\n\n          ok = transcoder.decodeTables(tablesData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.')\n\n          for (let i = 0; i < taskConfig.levels.length; i++) {\n            const level = taskConfig.levels[i]\n            const imageDesc = taskConfig.globalData.imageDescs[i]\n\n            const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n            const dst = new Uint8Array(dstByteLength)\n\n            ok = transcoder.transcodeImage(\n              transcoderFormat,\n              dst,\n              dstByteLength / blockByteLength,\n              level.data,\n              getWidthInBlocks(transcoderFormat, level.width),\n              getHeightInBlocks(transcoderFormat, level.height),\n              level.width,\n              level.height,\n              level.index,\n              imageDesc.rgbSliceByteOffset,\n              imageDesc.rgbSliceByteLength,\n              imageDesc.alphaSliceByteOffset,\n              imageDesc.alphaSliceByteLength,\n              imageDesc.imageFlags,\n              hasAlpha,\n              false,\n              0,\n              0,\n            )\n\n            assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.')\n\n            mipmaps.push({ data: dst, width: level.width, height: level.height })\n          }\n        } finally {\n          transcoder.delete()\n        }\n      } else {\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i]\n\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n          const dst = new Uint8Array(dstByteLength)\n\n          const ok = BasisModule.transcodeUASTCImage(\n            transcoderFormat,\n            dst,\n            dstByteLength / blockByteLength,\n            level.data,\n            getWidthInBlocks(transcoderFormat, level.width),\n            getHeightInBlocks(transcoderFormat, level.height),\n            level.width,\n            level.height,\n            level.index,\n            0,\n            level.data.byteLength,\n            0,\n            hasAlpha,\n            false,\n            0,\n            0,\n            -1,\n            -1,\n          )\n\n          assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.')\n\n          mipmaps.push({ data: dst, width: level.width, height: level.height })\n        }\n      }\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    function transcode(buffer) {\n      const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer))\n\n      const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = basisFile.getImageWidth(0, 0)\n      const height = basisFile.getImageHeight(0, 0)\n      const levels = basisFile.getNumLevels(0)\n      const hasAlpha = basisFile.getHasAlpha()\n\n      function cleanup() {\n        basisFile.close()\n        basisFile.delete()\n      }\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levels) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader:\tInvalid texture')\n      }\n\n      if (!basisFile.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader: .startTranscoding failed')\n      }\n\n      const mipmaps = []\n\n      for (let mip = 0; mip < levels; mip++) {\n        const mipWidth = basisFile.getImageWidth(0, mip)\n        const mipHeight = basisFile.getImageHeight(0, mip)\n        const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat))\n\n        const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha)\n\n        if (!status) {\n          cleanup()\n          throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.')\n        }\n\n        mipmaps.push({ data: dst, width: mipWidth, height: mipHeight })\n      }\n\n      cleanup()\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function assert(ok, message) {\n      if (!ok) throw new Error(message)\n    }\n\n    function getWidthInBlocks(transcoderFormat, width) {\n      return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat))\n    }\n\n    function getHeightInBlocks(transcoderFormat, height) {\n      return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat))\n    }\n\n    function getTranscodedImageByteLength(transcoderFormat, width, height) {\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n        return width * height * blockByteLength\n      }\n\n      if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n        // GL requires extra padding for very small textures:\n        // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n        const paddedWidth = (width + 3) & ~3\n        const paddedHeight = (height + 3) & ~3\n\n        return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8\n      }\n\n      return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n    this.workerConfig = null\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    const texture = new CompressedTexture()\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture([buffer])\n          .then(function (_texture) {\n            texture.copy(_texture)\n            texture.needsUpdate = true\n\n            if (onLoad) onLoad(texture)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n\n    return texture\n  }\n\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync(options) {\n    const { levels } = options\n\n    const buffers = new Set()\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer)\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options, lowLevel: true })\n  }\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture(buffers, config = {}) {\n    let worker\n    let taskID\n\n    const taskConfig = config\n    let taskCost = 0\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength\n    }\n\n    const texturePending = this._allocateWorker(taskCost)\n      .then((_worker) => {\n        worker = _worker\n        taskID = this.workerNextTaskID++\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'transcode', id: taskID, buffers: buffers, taskConfig: taskConfig }, buffers)\n        })\n      })\n      .then((message) => {\n        const { mipmaps, width, height, format } = message\n\n        const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n        texture.magFilter = LinearFilter\n        texture.generateMipmaps = false\n        texture.needsUpdate = true\n\n        return texture\n      })\n\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    texturePending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          worker._taskLoad -= taskCost\n          delete worker._callbacks[taskID]\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffers[0], { promise: texturePending })\n\n    return texturePending\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject)\n      })\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject)\n      })\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = BasisTextureLoader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n      })\n    }\n\n    return this.transcoderPending\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary,\n        })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n\n      worker._taskLoad += taskCost\n\n      return worker\n    })\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\nexport { BasisTextureLoader }\n", "import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Matrix4,\n  Mesh,\n  MeshStandardMaterial,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector3,\n  Ray,\n  REVISION,\n} from 'three'\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0\nconst FINISH_TYPE_CHROME = 1\nconst FINISH_TYPE_PEARLESCENT = 2\nconst FINISH_TYPE_RUBBER = 3\nconst FINISH_TYPE_MATTE_METALLIC = 4\nconst FINISH_TYPE_METAL = 5\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_AS_IS = 0\nconst FILE_LOCATION_TRY_PARTS = 1\nconst FILE_LOCATION_TRY_P = 2\nconst FILE_LOCATION_TRY_MODELS = 3\nconst FILE_LOCATION_TRY_RELATIVE = 4\nconst FILE_LOCATION_TRY_ABSOLUTE = 5\nconst FILE_LOCATION_NOT_FOUND = 6\n\nconst MAIN_COLOUR_CODE = '16'\nconst MAIN_EDGE_COLOUR_CODE = '24'\n\nconst _tempVec0 = new Vector3()\nconst _tempVec1 = new Vector3()\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color(),\n          },\n          opacity: {\n            value: 1.0,\n          },\n        },\n      ]),\n\n      vertexShader: /* glsl */ `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n\n      fragmentShader: /* glsl */ `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `,\n    })\n\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n      },\n    })\n\n    this.setValues(parameters)\n    this.isLDrawConditionalLineMaterial = true\n  }\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material)\n    this.isConditionalLine = true\n  }\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i]\n    const vertices = face.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    const v2 = vertices[2]\n\n    _tempVec0.subVectors(v1, v0)\n    _tempVec1.subVectors(v2, v1)\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n  }\n}\n\nconst _ray = new Ray()\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n  const hashMultiplier = (1 + 1e-10) * 1e2\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n\n    return `${x},${y},${z}`\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`\n  }\n\n  // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize()\n\n    const scalar = v0.dot(targetRay.direction)\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar)\n\n    return targetRay\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction)\n  }\n\n  const hardEdges = new Set()\n  const hardEdgeRays = new Map()\n  const halfEdgeList = {}\n  const normals = []\n\n  // Save the list of hard edges by hash\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i]\n    const vertices = ls.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    hardEdges.add(hashEdge(v0, v1))\n    hardEdges.add(hashEdge(v1, v0))\n\n    // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray())\n      const rh1 = hashRay(ray)\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray)\n        const rh2 = hashRay(ray)\n\n        const info = {\n          ray,\n          distances: [],\n        }\n\n        hardEdgeRays.set(rh1, info)\n        hardEdgeRays.set(rh2, info)\n      }\n\n      // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n      const info = hardEdgeRays.get(rh1)\n      let d0 = info.ray.direction.dot(v0)\n      let d1 = info.ray.direction.dot(v1)\n      if (d0 > d1) {\n        ;[d0, d1] = [d1, d0]\n      }\n\n      info.distances.push(d0, d1)\n    }\n  }\n\n  // track the half edges associated with each triangle\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i]\n    const vertices = tri.vertices\n    const vertCount = vertices.length\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2\n      const next = (i2 + 1) % vertCount\n      const v0 = vertices[index]\n      const v1 = vertices[next]\n      const hash = hashEdge(v0, v1)\n\n      // don't add the triangle if the edge is supposed to be hard\n      if (hardEdges.has(hash)) {\n        continue\n      }\n\n      // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray)\n\n        const rayHash = hashRay(_ray)\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash)\n          const { ray, distances } = info\n          let d0 = ray.direction.dot(v0)\n          let d1 = ray.direction.dot(v1)\n\n          if (d0 > d1) {\n            ;[d0, d1] = [d1, d0]\n          }\n\n          // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n          let found = false\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true\n              break\n            }\n          }\n\n          if (found) {\n            continue\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri,\n      }\n      halfEdgeList[hash] = info\n    }\n  }\n\n  // Iterate until we've tried to connect all faces to share normals\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key]\n      break\n    }\n\n    if (halfEdge === null) {\n      break\n    }\n\n    // Exhaustively find all connected faces\n    const queue = [halfEdge]\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri\n      const vertices = tri.vertices\n      const vertNormals = tri.normals\n      const faceNormal = tri.faceNormal\n\n      // Check if any edge is connected to another triangle edge\n      const vertCount = vertices.length\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2\n        const next = (i2 + 1) % vertCount\n        const v0 = vertices[index]\n        const v1 = vertices[next]\n\n        // delete this triangle from the list so it won't be found again\n        const hash = hashEdge(v0, v1)\n        delete halfEdgeList[hash]\n\n        const reverseHash = hashEdge(v1, v0)\n        const otherInfo = halfEdgeList[reverseHash]\n        if (otherInfo) {\n          const otherTri = otherInfo.tri\n          const otherIndex = otherInfo.index\n          const otherNormals = otherTri.normals\n          const otherVertCount = otherNormals.length\n          const otherFaceNormal = otherTri.faceNormal\n\n          // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue\n          }\n\n          // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo)\n            delete halfEdgeList[reverseHash]\n          }\n\n          // share the first normal\n          const otherNext = (otherIndex + 1) % otherVertCount\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm)\n            vertNormals[index].norm = otherNormals[otherNext].norm\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext]\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = { norm: new Vector3() }\n            normals.push(sharedNormal1.norm)\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1\n            sharedNormal1.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1\n            sharedNormal1.norm.add(otherFaceNormal)\n          }\n\n          // share the second normal\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm)\n            vertNormals[next].norm = otherNormals[otherIndex].norm\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex]\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() }\n            normals.push(sharedNormal2.norm)\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2\n            sharedNormal2.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2\n            sharedNormal2.norm.add(otherFaceNormal)\n          }\n        }\n      }\n    }\n  }\n\n  // The normals of each face have been added up so now we average them by normalizing the vector.\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize()\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part'\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart'\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line\n    this.lineLength = line.length\n    this.currentCharIndex = 0\n    this.currentChar = ' '\n    this.lineNumber = lineNumber\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return\n      }\n\n      this.currentCharIndex++\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++\n\n    // Seek space\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break\n      }\n\n      this.currentCharIndex++\n    }\n\n    const pos1 = this.currentCharIndex\n\n    this.seekNonSpace()\n\n    return this.line.substring(pos0, pos1)\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()))\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength)\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : ''\n  }\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader\n    this._cache = {}\n  }\n\n  cloneResult(original) {\n    const result = {}\n\n    // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null,\n      }\n    })\n\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone()),\n      }\n    })\n\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n      }\n    })\n\n    // none if this is subsequently modified\n    result.type = original.type\n    result.category = original.category\n    result.keywords = original.keywords\n    result.subobjects = original.subobjects\n    result.totalFaces = original.totalFaces\n    result.startingConstructionStep = original.startingConstructionStep\n    result.materials = original.materials\n    result.group = null\n    return result\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false\n    let locationState = FILE_LOCATION_AS_IS\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase()\n            subobjectURL = fileName\n            triedLowerCase = true\n            locationState = FILE_LOCATION_AS_IS\n          }\n\n          break\n      }\n\n      const loader = this.loader\n      const fileLoader = new FileLoader(loader.manager)\n      fileLoader.setPath(loader.partsLibraryPath)\n      fileLoader.setRequestHeader(loader.requestHeader)\n      fileLoader.setWithCredentials(loader.withCredentials)\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL)\n        return text\n      } catch {\n        continue\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.')\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader\n\n    // final results\n    const faces = []\n    const lineSegments = []\n    const conditionalSegments = []\n    const subobjects = []\n    const materials = {}\n\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null\n    }\n\n    let type = 'Model'\n    let category = null\n    let keywords = null\n    let totalFaces = 0\n\n    // split into lines\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    const lines = text.split('\\n')\n    const numLines = lines.length\n\n    let parsingEmbeddedFiles = false\n    let currentEmbeddedFileName = null\n    let currentEmbeddedText = null\n\n    let bfcCertified = false\n    let bfcCCW = true\n    let bfcInverted = false\n    let bfcCull = true\n\n    let startingConstructionStep = false\n\n    // Parse all line commands\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex]\n\n      if (line.length === 0) continue\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText)\n\n          // New embedded text file\n          currentEmbeddedFileName = line.substring(7)\n          currentEmbeddedText = ''\n        } else {\n          currentEmbeddedText += line + '\\n'\n        }\n\n        continue\n      }\n\n      const lp = new LineParser(line, lineIndex + 1)\n      lp.seekNonSpace()\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue\n      }\n\n      // Parse the line type\n      const lineType = lp.getToken()\n\n      let material\n      let colorCode\n      let segment\n      let ccw\n      let doubleSided\n      let v0, v1, v2, v3, c0, c1\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken()\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken()\n                break\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp)\n                if (material) {\n                  materials[material.userData.code] = material\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString())\n                }\n\n                break\n\n              case '!CATEGORY':\n                category = lp.getToken()\n                break\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',')\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = []\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim())\n                  })\n                }\n\n                break\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true\n                  currentEmbeddedFileName = lp.getRemainingString()\n                  currentEmbeddedText = ''\n\n                  bfcCertified = false\n                  bfcCCW = true\n                }\n\n                break\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken()\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY'\n                      bfcCCW = true\n\n                      break\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW'\n\n                      break\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true\n\n                      break\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP'\n\n                      break\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.')\n\n                      break\n                  }\n                }\n\n                break\n\n              case 'STEP':\n                startingConstructionStep = true\n\n                break\n\n              default:\n                // Other meta directives are not implemented\n                break\n            }\n          }\n\n          break\n\n        // Line type 1: Sub-object file\n        case '1':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n\n          const posX = parseFloat(lp.getToken())\n          const posY = parseFloat(lp.getToken())\n          const posZ = parseFloat(lp.getToken())\n          const m0 = parseFloat(lp.getToken())\n          const m1 = parseFloat(lp.getToken())\n          const m2 = parseFloat(lp.getToken())\n          const m3 = parseFloat(lp.getToken())\n          const m4 = parseFloat(lp.getToken())\n          const m5 = parseFloat(lp.getToken())\n          const m6 = parseFloat(lp.getToken())\n          const m7 = parseFloat(lp.getToken())\n          const m8 = parseFloat(lp.getToken())\n\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1)\n\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/')\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName]\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep,\n          })\n\n          bfcInverted = false\n\n          break\n\n        // Line type 2: Line segment\n        case '2':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n          }\n\n          lineSegments.push(segment)\n\n          break\n\n        // Line type 5: Conditional Line segment\n        case '5':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n          c0 = lp.getVector()\n          c1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1],\n          }\n\n          conditionalSegments.push(segment)\n\n          break\n\n        // Line type 3: Triangle\n        case '3':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n          } else {\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null],\n          })\n          totalFaces++\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null],\n            })\n            totalFaces++\n          }\n\n          break\n\n        // Line type 4: Quadrilateral\n        case '4':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n            v3 = lp.getVector()\n          } else {\n            v3 = lp.getVector()\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null],\n          })\n          totalFaces += 2\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null],\n            })\n            totalFaces += 2\n          }\n\n          break\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.')\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText)\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null,\n    }\n  }\n\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase()\n    const result = this._cache[key]\n    if (result === null || result instanceof Promise) {\n      return null\n    }\n\n    if (clone) {\n      return this.cloneResult(result)\n    } else {\n      return result\n    }\n  }\n\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase()\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName)\n        this._cache[key] = info\n        return info\n      })\n    }\n\n    await this._cache[key]\n  }\n\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase()\n    this._cache[key] = this.parse(text, fileName)\n  }\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n  if (isPassthrough) {\n    colorCode = parentColorCode\n  }\n\n  return materialHierarchy[colorCode] || null\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader\n    this.parseCache = new LDrawParsedCache(loader)\n    this._cache = {}\n  }\n\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader\n    const parseCache = this.parseCache\n    const faceMaterials = new Set()\n\n    // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects\n      const promises = []\n\n      // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i]\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false)\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch((error) => {\n              console.warn(error)\n              return null\n            })\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject)\n        })\n\n        promises.push(promise)\n      }\n\n      const group = new Group()\n      group.userData.category = info.category\n      group.userData.keywords = info.keywords\n      info.group = group\n\n      const subobjectInfos = await Promise.all(promises)\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i]\n        const subobjectInfo = subobjectInfos[i]\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue\n        }\n\n        // if the subobject was loaded as a separate group then apply the parent scopes materials\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale)\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep\n          subobjectGroup.name = subobject.fileName\n\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials)\n\n          group.add(subobjectGroup)\n          continue\n        }\n\n        // add the subobject group if it has children in case it has both children and primitives\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group)\n        }\n\n        // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n        const parentLineSegments = info.lineSegments\n        const parentConditionalSegments = info.conditionalSegments\n        const parentFaces = info.faces\n\n        const lineSegments = subobjectInfo.lineSegments\n        const conditionalSegments = subobjectInfo.conditionalSegments\n\n        const faces = subobjectInfo.faces\n        const matrix = subobject.matrix\n        const inverted = subobject.inverted\n        const matrixScaleInverted = matrix.determinant() < 0\n        const colorCode = subobject.colorCode\n\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i]\n          const vertices = ls.vertices\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true)\n\n          parentLineSegments.push(ls)\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i]\n          const vertices = os.vertices\n          const controlPoints = os.controlPoints\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          controlPoints[0].applyMatrix4(matrix)\n          controlPoints[1].applyMatrix4(matrix)\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true)\n\n          parentConditionalSegments.push(os)\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i]\n          const vertices = tri.vertices\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix)\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false)\n          faceMaterials.add(tri.colorCode)\n\n          // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse()\n          }\n\n          parentFaces.push(tri)\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces\n      }\n\n      // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials)\n      }\n\n      return info\n    }\n\n    // Track material use to see if we need to use the normal smooth slow path for hard edges.\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode)\n    }\n\n    await processInfoSubobjects(info)\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1\n      generateFaceNormals(info.faces)\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments)\n    }\n\n    // Add the primitive objects and metadata.\n    const group = info.group\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces))\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2))\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true))\n    }\n\n    return group\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase()\n      const group = await this._cache[key]\n      return group.clone()\n    } else {\n      return null\n    }\n  }\n\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache\n    const key = fileName.toLowerCase()\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName)\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName)\n\n      const info = parseCache.getData(fileName)\n      const promise = this.processIntoMesh(info)\n\n      // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName)\n      }\n\n      // Cache object if it's a part so it can be reused later.\n      if (isPartType(info.type)) {\n        this._cache[key] = promise\n      }\n\n      // return a copy\n      const group = await promise\n      return group.clone()\n    }\n  }\n\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache\n    const info = parseCache.parse(text)\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName)\n    }\n\n    return this.processIntoMesh(info)\n  }\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1\n  }\n\n  return 1\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial)\n\n  if (totalElements === null) {\n    totalElements = elements.length\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3)\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null\n  const materials = []\n\n  const quadArray = new Array(6)\n  const bufferGeometry = new BufferGeometry()\n  let prevMaterial = null\n  let index0 = 0\n  let numGroupVerts = 0\n  let offset = 0\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem]\n    let vertices = elem.vertices\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0]\n      quadArray[1] = vertices[1]\n      quadArray[2] = vertices[2]\n      quadArray[3] = vertices[0]\n      quadArray[4] = vertices[2]\n      quadArray[5] = vertices[3]\n      vertices = quadArray\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j]\n      const index = offset + j * 3\n      positions[index + 0] = v.x\n      positions[index + 1] = v.y\n      positions[index + 2] = v.z\n    }\n\n    // create the normals array if this is a set of faces\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0]\n        const v1 = vertices[1]\n        const v2 = vertices[2]\n        _tempVec0.subVectors(v1, v0)\n        _tempVec1.subVectors(v2, v1)\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n      }\n\n      let elemNormals = elem.normals\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0]\n        quadArray[1] = elemNormals[1]\n        quadArray[2] = elemNormals[2]\n        quadArray[3] = elemNormals[0]\n        quadArray[4] = elemNormals[2]\n        quadArray[5] = elemNormals[3]\n        elemNormals = quadArray\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm\n        }\n\n        const index = offset + j * 3\n        normals[index + 0] = n.x\n        normals[index + 1] = n.y\n        normals[index + 2] = n.z\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1)\n      }\n\n      const material = elem.material\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material)\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial)\n            } else {\n              materials.push(material.userData.edgeMaterial)\n            }\n          } else {\n            materials.push(null)\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode)\n      }\n\n      prevMaterial = elem.colorCode\n      index0 = offset / 3\n      numGroupVerts = vertices.length\n    } else {\n      numGroupVerts += vertices.length\n    }\n\n    offset += 3 * vertices.length\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1)\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3))\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3))\n  }\n\n  let object3d = null\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true\n\n    const controlArray0 = new Float32Array(elements.length * 3 * 2)\n    const controlArray1 = new Float32Array(elements.length * 3 * 2)\n    const directionArray = new Float32Array(elements.length * 3 * 2)\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i]\n      const vertices = os.vertices\n      const controlPoints = os.controlPoints\n      const c0 = controlPoints[0]\n      const c1 = controlPoints[1]\n      const v0 = vertices[0]\n      const v1 = vertices[1]\n      const index = i * 3 * 2\n      controlArray0[index + 0] = c0.x\n      controlArray0[index + 1] = c0.y\n      controlArray0[index + 2] = c0.z\n      controlArray0[index + 3] = c0.x\n      controlArray0[index + 4] = c0.y\n      controlArray0[index + 5] = c0.z\n\n      controlArray1[index + 0] = c1.x\n      controlArray1[index + 1] = c1.y\n      controlArray1[index + 2] = c1.z\n      controlArray1[index + 3] = c1.x\n      controlArray1[index + 4] = c1.y\n      controlArray1[index + 5] = c1.z\n\n      directionArray[index + 0] = v1.x - v0.x\n      directionArray[index + 1] = v1.y - v0.y\n      directionArray[index + 2] = v1.z - v0.z\n      directionArray[index + 3] = v1.x - v0.x\n      directionArray[index + 4] = v1.y - v0.y\n      directionArray[index + 5] = v1.z - v0.z\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false))\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false))\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false))\n  }\n\n  return object3d\n}\n\n//\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Array of THREE.Material\n    this.materials = []\n    this.materialLibrary = {}\n\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n    this.partsCache = new LDrawPartsGeometryCache(this)\n\n    // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n    this.fileMap = {}\n\n    // Initializes the materials library with default materials\n    this.setMaterials([])\n\n    // If this flag is set to true the vertex normals will be smoothed.\n    this.smoothNormals = true\n\n    // The path to load parts from the LDraw parts library from.\n    this.partsLibraryPath = ''\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path\n    return this\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n\n    const text = await fileLoader.loadAsync(url)\n    const colorLineRegex = /^0 !COLOUR/\n    const lines = text.split(/[\\n\\r]/g)\n    const materials = []\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i]\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '')\n        const material = this.parseColorMetaDirective(new LineParser(directive))\n        materials.push(material)\n      }\n    }\n\n    this.setMaterials(materials)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache\n          .parseModel(text, this.materialLibrary)\n          .then((group) => {\n            this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true)\n            this.computeConstructionSteps(group)\n            onLoad(group)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group)\n      onLoad(group)\n    })\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {}\n    this.materials = []\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i])\n    }\n\n    // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')))\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')))\n\n    return this\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap\n\n    return this\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n    const matLib = this.materialLibrary\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material)\n      matLib[material.userData.code] = material\n    }\n\n    return this\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3)\n\n      return this.parseColorMetaDirective(\n        new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''),\n      )\n    }\n\n    return this.materialLibrary[colorCode] || null\n  }\n\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i])\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material)\n        }\n      }\n    })\n\n    // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine\n      const isPassthrough =\n        (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n      if (isPassthrough) {\n        colorCode = parentColorCode\n      }\n\n      let material = null\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode]\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode)\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`)\n        }\n      } else {\n        return colorCode\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial\n        }\n      }\n\n      return material\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE)\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE)\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n\n    let code = null\n\n    // Triangle and line colors\n    let color = 0xff00ff\n    let edgeColor = 0xff00ff\n\n    // Transparency\n    let alpha = 1\n    let isTransparent = false\n    // Self-illumination:\n    let luminance = 0\n\n    let finishType = FINISH_TYPE_DEFAULT\n\n    let edgeMaterial = null\n\n    const name = lineParser.getToken()\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.',\n      )\n    }\n\n    // Parse tag tokens and their parameters\n    let token = null\n    while (true) {\n      token = lineParser.getToken()\n\n      if (!token) {\n        break\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken()\n          break\n\n        case 'VALUE':\n          color = lineParser.getToken()\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2)\n          } else if (!color.startsWith('#')) {\n            throw new Error(\n              'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          break\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken()\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2)\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor)\n            if (!edgeMaterial) {\n              throw new Error(\n                'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.',\n              )\n            }\n\n            // Get the edge material for this triangle material\n            edgeMaterial = edgeMaterial.userData.edgeMaterial\n          }\n\n          break\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken())\n\n          if (isNaN(alpha)) {\n            throw new Error(\n              'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255))\n\n          if (alpha < 1) {\n            isTransparent = true\n          }\n\n          break\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken())\n\n          if (isNaN(luminance)) {\n            throw new Error(\n              'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.',\n            )\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255))\n\n          break\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME\n          break\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT\n          break\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER\n          break\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC\n          break\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL\n          break\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd()\n          break\n\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' +\n              token +\n              '\" while parsing material' +\n              lineParser.getLineNumberString() +\n              '.',\n          )\n      }\n    }\n\n    let material = null\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0 })\n        break\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.25 })\n        break\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({ color: color, roughness: 0, metalness: 1 })\n        break\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.9, metalness: 0 })\n        break\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.8, metalness: 0.4 })\n        break\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.85 })\n        break\n\n      default:\n        // Should not happen\n        break\n    }\n\n    material.transparent = isTransparent\n    material.premultipliedAlpha = true\n    material.opacity = alpha\n    material.depthWrite = !isTransparent\n\n    material.polygonOffset = true\n    material.polygonOffsetFactor = 1\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance)\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent,\n      })\n      edgeMaterial.userData.code = code\n      edgeMaterial.name = name + ' - Edge'\n\n      // This is the material used for conditional edges\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha,\n      })\n    }\n\n    material.userData.code = code\n    material.name = name\n\n    material.userData.edgeMaterial = edgeMaterial\n\n    this.addMaterial(material)\n\n    return material\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n\n    let stepNumber = 0\n\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++\n        }\n\n        c.userData.constructionStep = stepNumber\n      }\n    })\n\n    model.userData.numConstructionSteps = stepNumber + 1\n  }\n}\n\nexport { LDrawLoader }\n", "import {\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Material,\n  Mesh,\n  MeshPhongMaterial,\n  Points,\n  PointsMaterial,\n  Vector3,\n} from 'three'\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /\n// usemap map_name\nconst _map_use_pattern = /^usemap /\n\nconst _vA = new Vector3()\nconst _vB = new Vector3()\nconst _vC = new Vector3()\n\nconst _ab = new Vector3()\nconst _cb = new Vector3()\n\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n\n    materials: {},\n    materialLibraries: [],\n\n    startObject: function (name, fromDeclaration) {\n      // If the current object (initial from reset) is not from a g/o declaration in the parsed\n      // file. We need to use it for the first parsed g/o to keep things in sync.\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name\n        this.object.fromDeclaration = fromDeclaration !== false\n        return\n      }\n\n      const previousMaterial =\n        this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined\n\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n\n      this.object = {\n        name: name || '',\n        fromDeclaration: fromDeclaration !== false,\n\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false,\n        },\n        materials: [],\n        smooth: true,\n\n        startMaterial: function (name, libraries) {\n          const previous = this._finalize(false)\n\n          // New usemtl declaration overwrites an inherited material, except if faces were declared\n          // after the material, then it must be preserved for proper MultiMaterial continuation.\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1)\n          }\n\n          const material = {\n            index: this.materials.length,\n            name: name || '',\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\n            groupStart: previous !== undefined ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n\n            clone: function (index) {\n              const cloned = {\n                index: typeof index === 'number' ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false,\n              }\n              cloned.clone = this.clone.bind(cloned)\n              return cloned\n            },\n          }\n\n          this.materials.push(material)\n\n          return material\n        },\n\n        currentMaterial: function () {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1]\n          }\n\n          return undefined\n        },\n\n        _finalize: function (end) {\n          const lastMultiMaterial = this.currentMaterial()\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart\n            lastMultiMaterial.inherited = false\n          }\n\n          // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1)\n              }\n            }\n          }\n\n          // Guarantee at least one empty material, this makes the creation later more straight forward.\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: '',\n              smooth: this.smooth,\n            })\n          }\n\n          return lastMultiMaterial\n        },\n      }\n\n      // Inherit previous objects material.\n      // Spec tells us that a declared material must be set to all objects until a new material is declared.\n      // If a usemtl declaration is encountered while this new object is being parsed, it will\n      // overwrite the inherited material. Exception being that there was already face declarations\n      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n        const declared = previousMaterial.clone(0)\n        declared.inherited = true\n        this.object.materials.push(declared)\n      }\n\n      this.objects.push(this.object)\n    },\n\n    finalize: function () {\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n    },\n\n    parseVertexIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseNormalIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseUVIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 2) * 2\n    },\n\n    addVertex: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addVertexPoint: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addVertexLine: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addNormal: function (a, b, c) {\n      const src = this.normals\n      const dst = this.object.geometry.normals\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addFaceNormal: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.normals\n\n      _vA.fromArray(src, a)\n      _vB.fromArray(src, b)\n      _vC.fromArray(src, c)\n\n      _cb.subVectors(_vC, _vB)\n      _ab.subVectors(_vA, _vB)\n      _cb.cross(_ab)\n\n      _cb.normalize()\n\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n    },\n\n    addColor: function (a, b, c) {\n      const src = this.colors\n      const dst = this.object.geometry.colors\n\n      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2])\n      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2])\n      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addUV: function (a, b, c) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n      dst.push(src[b + 0], src[b + 1])\n      dst.push(src[c + 0], src[c + 1])\n    },\n\n    addDefaultUV: function () {\n      const dst = this.object.geometry.uvs\n\n      dst.push(0, 0)\n      dst.push(0, 0)\n      dst.push(0, 0)\n    },\n\n    addUVLine: function (a) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n    },\n\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length\n\n      let ia = this.parseVertexIndex(a, vLen)\n      let ib = this.parseVertexIndex(b, vLen)\n      let ic = this.parseVertexIndex(c, vLen)\n\n      this.addVertex(ia, ib, ic)\n      this.addColor(ia, ib, ic)\n\n      // normals\n\n      if (na !== undefined && na !== '') {\n        const nLen = this.normals.length\n\n        ia = this.parseNormalIndex(na, nLen)\n        ib = this.parseNormalIndex(nb, nLen)\n        ic = this.parseNormalIndex(nc, nLen)\n\n        this.addNormal(ia, ib, ic)\n      } else {\n        this.addFaceNormal(ia, ib, ic)\n      }\n\n      // uvs\n\n      if (ua !== undefined && ua !== '') {\n        const uvLen = this.uvs.length\n\n        ia = this.parseUVIndex(ua, uvLen)\n        ib = this.parseUVIndex(ub, uvLen)\n        ic = this.parseUVIndex(uc, uvLen)\n\n        this.addUV(ia, ib, ic)\n\n        this.object.geometry.hasUVIndices = true\n      } else {\n        // add placeholder values (for inconsistent face definitions)\n\n        this.addDefaultUV()\n      }\n    },\n\n    addPointGeometry: function (vertices) {\n      this.object.geometry.type = 'Points'\n\n      const vLen = this.vertices.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen)\n\n        this.addVertexPoint(index)\n        this.addColor(index)\n      }\n    },\n\n    addLineGeometry: function (vertices, uvs) {\n      this.object.geometry.type = 'Line'\n\n      const vLen = this.vertices.length\n      const uvLen = this.uvs.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen))\n      }\n\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen))\n      }\n    },\n  }\n\n  state.startObject('', false)\n\n  return state\n}\n\n//\n\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.materials = null\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setMaterials(materials) {\n    this.materials = materials\n\n    return this\n  }\n\n  parse(text) {\n    const state = new ParserState()\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    if (text.indexOf('\\\\\\n') !== -1) {\n      // join lines separated by a line continuation character (\\)\n      text = text.replace(/\\\\\\n/g, '')\n    }\n\n    const lines = text.split('\\n')\n    let line = '',\n      lineFirstChar = ''\n    let lineLength = 0\n    let result = []\n\n    // Faster to just trim left side of the line. Use if available.\n    const trimLeft = typeof ''.trimLeft === 'function'\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i]\n\n      line = trimLeft ? line.trimLeft() : line.trim()\n\n      lineLength = line.length\n\n      if (lineLength === 0) continue\n\n      lineFirstChar = line.charAt(0)\n\n      // @todo invoke passed in handler if any\n      if (lineFirstChar === '#') continue\n\n      if (lineFirstChar === 'v') {\n        const data = line.split(/\\s+/)\n\n        switch (data[0]) {\n          case 'v':\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]))\n            } else {\n              // if no colors are defined, add placeholders so color and vertex indices match\n\n              state.colors.push(undefined, undefined, undefined)\n            }\n\n            break\n          case 'vn':\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            break\n          case 'vt':\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]))\n            break\n        }\n      } else if (lineFirstChar === 'f') {\n        const lineData = line.substr(1).trim()\n        const vertexData = lineData.split(/\\s+/)\n        const faceVertices = []\n\n        // Parse the face vertex data into an easy to work with format\n\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j]\n\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split('/')\n            faceVertices.push(vertexParts)\n          }\n        }\n\n        // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n        const v1 = faceVertices[0]\n\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j]\n          const v3 = faceVertices[j + 1]\n\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2])\n        }\n      } else if (lineFirstChar === 'l') {\n        const lineParts = line.substring(1).trim().split(' ')\n        let lineVertices = []\n        const lineUVs = []\n\n        if (line.indexOf('/') === -1) {\n          lineVertices = lineParts\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split('/')\n\n            if (parts[0] !== '') lineVertices.push(parts[0])\n            if (parts[1] !== '') lineUVs.push(parts[1])\n          }\n        }\n\n        state.addLineGeometry(lineVertices, lineUVs)\n      } else if (lineFirstChar === 'p') {\n        const lineData = line.substr(1).trim()\n        const pointData = lineData.split(' ')\n\n        state.addPointGeometry(pointData)\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        // o object_name\n        // or\n        // g group_name\n\n        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        // let name = result[ 0 ].substr( 1 ).trim();\n        const name = (' ' + result[0].substr(1).trim()).substr(1)\n\n        state.startObject(name)\n      } else if (_material_use_pattern.test(line)) {\n        // material\n\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries)\n      } else if (_material_library_pattern.test(line)) {\n        // mtl file\n\n        state.materialLibraries.push(line.substring(7).trim())\n      } else if (_map_use_pattern.test(line)) {\n        // the line is parsed but ignored since the loader assumes textures are defined MTL files\n        // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n        console.warn(\n          'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.',\n        )\n      } else if (lineFirstChar === 's') {\n        result = line.split(' ')\n\n        // smooth shading\n\n        // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n        // but does not define a usemtl for each face set.\n        // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n        // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n        // where explicit usemtl defines geometry groups.\n        // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n        /*\n         * http://paulbourke.net/dataformats/obj/\n         * or\n         * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n         *\n         * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n         * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n         * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n         * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n         * than 0.\"\n         */\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase()\n          state.object.smooth = value !== '0' && value !== 'off'\n        } else {\n          // ZBrush can produce \"s\" lines #11707\n          state.object.smooth = true\n        }\n\n        const material = state.object.currentMaterial()\n        if (material) material.smooth = state.object.smooth\n      } else {\n        // Handle null terminated files without exception\n        if (line === '\\0') continue\n\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"')\n      }\n    }\n\n    state.finalize()\n\n    const container = new Group()\n    container.materialLibraries = [].concat(state.materialLibraries)\n\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0)\n\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i]\n        const geometry = object.geometry\n        const materials = object.materials\n        const isLine = geometry.type === 'Line'\n        const isPoints = geometry.type === 'Points'\n        let hasVertexColors = false\n\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0) continue\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3))\n\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3))\n        }\n\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3))\n        }\n\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2))\n        }\n\n        // Create materials\n\n        const createdMaterials = []\n\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi]\n          const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors\n          let material = state.materials[materialHash]\n\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name)\n\n            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial()\n              Material.prototype.copy.call(materialLine, material)\n              materialLine.color.copy(material.color)\n              material = materialLine\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false })\n              Material.prototype.copy.call(materialPoints, material)\n              materialPoints.color.copy(material.color)\n              materialPoints.map = material.map\n              material = materialPoints\n            }\n          }\n\n          if (material === undefined) {\n            if (isLine) {\n              material = new LineBasicMaterial()\n            } else if (isPoints) {\n              material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n            } else {\n              material = new MeshPhongMaterial()\n            }\n\n            material.name = sourceMaterial.name\n            material.flatShading = sourceMaterial.smooth ? false : true\n            material.vertexColors = hasVertexColors\n\n            state.materials[materialHash] = material\n          }\n\n          createdMaterials.push(material)\n        }\n\n        // Create mesh\n\n        let mesh\n\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi]\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi)\n          }\n\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials)\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials)\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials)\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0])\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0])\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0])\n          }\n        }\n\n        mesh.name = object.name\n\n        container.add(mesh)\n      }\n    } else {\n      // if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3))\n\n        if (state.colors.length > 0 && state.colors[0] !== undefined) {\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3))\n          material.vertexColors = true\n        }\n\n        const points = new Points(buffergeometry, material)\n        container.add(points)\n      }\n    }\n\n    return container\n  }\n}\n\nexport { OBJLoader }\n", "import { CompressedTextureLoader } from 'three'\n\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nclass KTXLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  parse(buffer, loadMipmaps) {\n    const ktx = new KhronosTextureContainer(buffer, 1)\n\n    return {\n      mipmaps: ktx.mipmaps(loadMipmaps),\n      width: ktx.pixelWidth,\n      height: ktx.pixelHeight,\n      format: ktx.glInternalFormat,\n      isCubemap: ktx.numberOfFaces === 6,\n      mipmapCount: ktx.numberOfMipmapLevels,\n    }\n  }\n}\n\nconst HEADER_LEN = 12 + 13 * 4 // identifier + header elements (not including key value meta-data pairs)\n// load types\nconst COMPRESSED_2D = 0 // uses a gl.compressedTexImage2D()\n//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n//const TEX_2D = 2; // uses a gl.texImage2D()\n//const TEX_3D = 3; // uses a gl.texImage3D()\n\nclass KhronosTextureContainer {\n  /**\n   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n   */\n  constructor(arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */) {\n    this.arrayBuffer = arrayBuffer\n\n    // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n    // '', 'K', 'T', 'X', ' ', '1', '1', '', '\\r', '\\n', '\\x1A', '\\n'\n    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n    const identifier = new Uint8Array(this.arrayBuffer, 0, 12)\n    if (\n      identifier[0] !== 0xab ||\n      identifier[1] !== 0x4b ||\n      identifier[2] !== 0x54 ||\n      identifier[3] !== 0x58 ||\n      identifier[4] !== 0x20 ||\n      identifier[5] !== 0x31 ||\n      identifier[6] !== 0x31 ||\n      identifier[7] !== 0xbb ||\n      identifier[8] !== 0x0d ||\n      identifier[9] !== 0x0a ||\n      identifier[10] !== 0x1a ||\n      identifier[11] !== 0x0a\n    ) {\n      console.error('texture missing KTX identifier')\n      return\n    }\n\n    // load the reset of the header in native 32 bit uint\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT\n    const headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize)\n    const endianness = headerDataView.getUint32(0, true)\n    const littleEndian = endianness === 0x04030201\n\n    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian) // must be 0 for compressed textures\n    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian) // must be 1 for compressed textures\n    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian) // must be 0 for compressed textures\n    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian) // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian) // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian) // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian) // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian) // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian) // used for texture arrays\n    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian) // used for cubemap textures, should either be 1 or 6\n    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian) // number of levels; disregard possibility of 0 for compressed textures\n    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian) // the amount of space after the header for meta-data\n\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n    if (this.glType !== 0) {\n      console.warn('only compressed formats currently supported')\n      return\n    } else {\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels)\n    }\n\n    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n      console.warn('only 2D textures currently supported')\n      return\n    }\n\n    if (this.numberOfArrayElements !== 0) {\n      console.warn('texture arrays not currently supported')\n      return\n    }\n\n    if (this.numberOfFaces !== facesExpected) {\n      console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces)\n      return\n    }\n\n    // we now have a completely validated file, so could use existence of loadType as success\n    // would need to make this more elaborate & adjust checks above to support more than one load type\n    this.loadType = COMPRESSED_2D\n  }\n\n  mipmaps(loadMipmaps) {\n    const mipmaps = []\n\n    // initialize width & height for level 1\n    let dataOffset = HEADER_LEN + this.bytesOfKeyValueData\n    let width = this.pixelWidth\n    let height = this.pixelHeight\n    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1\n\n    for (let level = 0; level < mipmapCount; level++) {\n      const imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0] // size per face, since not supporting array cubemaps\n      dataOffset += 4 // size of the image + 4 for the imageSize field\n\n      for (let face = 0; face < this.numberOfFaces; face++) {\n        const byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize)\n\n        mipmaps.push({ data: byteArray, width: width, height: height })\n\n        dataOffset += imageSize\n        dataOffset += 3 - ((imageSize + 3) % 4) // add padding for odd sized image\n      }\n\n      width = Math.max(1.0, width * 0.5)\n      height = Math.max(1.0, height * 0.5)\n    }\n\n    return mipmaps\n  }\n}\n\nexport { KTXLoader }\n", "import {\n  Box3,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry,\n} from 'three'\n\nconst _box = new Box3()\nconst _vector = new Vector3()\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super()\n\n    this.isLineSegmentsGeometry = true\n\n    this.type = 'LineSegmentsGeometry'\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]\n\n    this.setIndex(index)\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix)\n\n      end.applyMatrix4(matrix)\n\n      start.needsUpdate = true\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    return this\n  }\n\n  setPositions(array) {\n    let lineSegments\n\n    if (array instanceof Float32Array) {\n      lineSegments = array\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array)\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1) // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)) // xyz\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)) // xyz\n\n    //\n\n    this.computeBoundingBox()\n    this.computeBoundingSphere()\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    let colors\n\n    if (array instanceof Float32Array) {\n      colors = array\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array)\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1) // rgb(a), rgb(a)\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0)) // rgb(a)\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize)) // rgb(a)\n\n    return this\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry))\n\n    // set colors, maybe\n\n    return this\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start)\n\n      _box.setFromBufferAttribute(end)\n\n      this.boundingBox.union(_box)\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center\n\n      this.boundingBox.getCenter(center)\n\n      let maxRadiusSq = 0\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n\n        _vector.fromBufferAttribute(end, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',\n          this,\n        )\n      }\n    }\n  }\n\n  toJSON() {\n    // todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().')\n\n    return this.applyMatrix4(matrix)\n  }\n}\n\nexport { LineSegmentsGeometry }\n", "import { InstancedInterleavedBuffer, InterleavedBufferAttribute, Mesh, Vector3, Vector4 } from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\n\nconst _start = new Vector3()\nconst _end = new Vector3()\nconst _viewport = new Vector4();\n\nclass Wireframe extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isWireframe = true\n\n    this.type = 'Wireframe'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  onBeforeRender(renderer) {\n\n    const uniforms = this.material.uniforms;\n\n    if (uniforms && uniforms.resolution) {\n\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n\n    }\n\n  }\n}\n\nexport { Wireframe }\n", "import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\nimport { UV1 } from '../_polyfill/uv1'\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3()\nconst _end = new Vector3()\n\nconst _start4 = new Vector4()\nconst _end4 = new Vector4()\n\nconst _ssOrigin = new Vector4()\nconst _ssOrigin3 = new Vector3()\nconst _mvMatrix = new Matrix4()\nconst _line = new Line3()\nconst _closestPoint = new Vector3()\n\nconst _box = new Box3()\nconst _sphere = new Sphere()\nconst _clipToWorldVector = new Vector4()\n\nlet _ray, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i)\n    _line.end.fromBufferAttribute(instanceEnd, i)\n\n    _line.applyMatrix4(matrixWorld);\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n\n  onBeforeRender(renderer) {\n\n    const uniforms = this.material.uniforms;\n\n    if (uniforms && uniforms.resolution) {\n\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n\n    }\n\n  }\n}\n\nexport { LineSegments2 }\n", "/**\n * from https://github.com/gsimone/things/tree/main/packages/three-raycaster-helper\n */\n\nimport {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedMesh,\n  Intersection,\n  Line,\n  LineBasicMaterial,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Raycaster,\n  SphereGeometry,\n  Vector3,\n} from 'three'\n\nconst _o = new Object3D()\nconst _v = new Vector3()\n\nclass RaycasterHelper extends Object3D {\n  raycaster: Raycaster\n  hits: Intersection[]\n\n  origin: Mesh<SphereGeometry, MeshBasicMaterial>\n  near: Line<BufferGeometry, LineBasicMaterial>\n  far: Line<BufferGeometry, LineBasicMaterial>\n\n  nearToFar: Line<BufferGeometry, LineBasicMaterial>\n  originToNear: Line<BufferGeometry, LineBasicMaterial>\n\n  hitPoints: InstancedMesh\n\n  colors = {\n    near: 0xffffff,\n    far: 0xffffff,\n    originToNear: 0x333333,\n    nearToFar: 0xffffff,\n    origin: [0x0eec82, 0xff005b],\n  }\n\n  constructor(raycaster: Raycaster, public numberOfHitsToVisualize = 20) {\n    super()\n    this.raycaster = raycaster\n\n    this.hits = []\n\n    this.origin = new Mesh(new SphereGeometry(0.04, 32), new MeshBasicMaterial())\n    this.origin.name = 'RaycasterHelper_origin'\n    this.origin.raycast = () => null\n\n    const size = 0.1\n    let geometry = new BufferGeometry()\n    // prettier-ignore\n    geometry.setAttribute( 'position', new Float32BufferAttribute( [\n              - size, size, 0,\n              size, size, 0,\n              size, - size, 0,\n              - size, - size, 0,\n              - size, size, 0\n          ], 3 ) );\n\n    this.near = new Line(geometry, new LineBasicMaterial())\n    this.near.name = 'RaycasterHelper_near'\n    this.near.raycast = () => null\n\n    this.far = new Line(geometry, new LineBasicMaterial())\n    this.far.name = 'RaycasterHelper_far'\n    this.far.raycast = () => null\n\n    this.nearToFar = new Line(new BufferGeometry(), new LineBasicMaterial())\n    this.nearToFar.name = 'RaycasterHelper_nearToFar'\n    this.nearToFar.raycast = () => null\n\n    this.nearToFar.geometry.setFromPoints([_v, _v])\n\n    this.originToNear = new Line(this.nearToFar.geometry.clone(), new LineBasicMaterial())\n    this.originToNear.name = 'RaycasterHelper_originToNear'\n    this.originToNear.raycast = () => null\n\n    this.hitPoints = new InstancedMesh(new SphereGeometry(0.04), new MeshBasicMaterial(), this.numberOfHitsToVisualize)\n    this.hitPoints.name = 'RaycasterHelper_hits'\n    this.hitPoints.raycast = () => null\n\n    this.add(this.nearToFar)\n    this.add(this.originToNear)\n\n    this.add(this.near)\n    this.add(this.far)\n\n    this.add(this.origin)\n    this.add(this.hitPoints)\n\n    this.setColors()\n  }\n\n  setColors = (colors?: Partial<typeof this.colors>) => {\n    const _colors = {\n      ...this.colors,\n      ...colors,\n    }\n\n    this.near.material.color.set(_colors.near)\n    this.far.material.color.set(_colors.far)\n    this.nearToFar.material.color.set(_colors.nearToFar)\n    this.originToNear.material.color.set(_colors.originToNear)\n  }\n\n  update = () => {\n    const origin = this.raycaster.ray.origin\n    const direction = this.raycaster.ray.direction\n\n    this.origin.position.copy(origin)\n\n    this.near.position.copy(origin).add(direction.clone().multiplyScalar(this.raycaster.near))\n\n    this.far.position.copy(origin).add(direction.clone().multiplyScalar(this.raycaster.far))\n\n    this.far.lookAt(origin)\n    this.near.lookAt(origin)\n\n    let pos = this.nearToFar.geometry.getAttribute('position') as BufferAttribute\n    pos.set([...this.near.position.toArray(), ...this.far.position.toArray()])\n    pos.needsUpdate = true\n\n    pos = this.originToNear.geometry.getAttribute('position') as BufferAttribute\n    pos.set([...origin.toArray(), ...this.near.position.toArray()])\n    pos.needsUpdate = true\n\n    /**\n     * Update hit points visualization\n     */\n    for (let i = 0; i < this.numberOfHitsToVisualize; i++) {\n      const hit = this.hits?.[i]\n\n      if (hit) {\n        const { point } = hit\n        _o.position.copy(point)\n        _o.scale.setScalar(1)\n      } else {\n        _o.scale.setScalar(0)\n      }\n\n      _o.updateMatrix()\n\n      this.hitPoints.setMatrixAt(i, _o.matrix)\n    }\n\n    this.hitPoints.instanceMatrix.needsUpdate = true\n\n    /**\n     * Update the color of the origin based on wether there are hits.\n     */\n    this.origin.material.color.set(this.hits.length > 0 ? this.colors.origin[0] : this.colors.origin[1])\n  }\n\n  dispose = () => {\n    this.origin.geometry.dispose()\n    this.origin.material.dispose()\n    this.near.geometry.dispose()\n    this.near.material.dispose()\n    this.far.geometry.dispose()\n    this.far.material.dispose()\n    this.nearToFar.geometry.dispose()\n    this.nearToFar.material.dispose()\n    this.originToNear.geometry.dispose()\n    this.originToNear.material.dispose()\n    this.hitPoints.dispose()\n  }\n}\n\nexport { RaycasterHelper }\n", "import { BufferGeometry, Float32BufferAttribute, LineSegments, LineBasicMaterial, Vector3 } from 'three'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\n\nclass VertexTangentsHelper extends LineSegments {\n  constructor(object, size = 1, color = 0x00ffff) {\n    const geometry = new BufferGeometry()\n\n    const nTangents = object.geometry.attributes.tangent.count\n    const positions = new Float32BufferAttribute(nTangents * 2 * 3, 3)\n\n    geometry.setAttribute('position', positions)\n\n    super(geometry, new LineBasicMaterial({ color, toneMapped: false }))\n\n    this.object = object\n    this.size = size\n    this.type = 'VertexTangentsHelper'\n\n    //\n\n    this.matrixAutoUpdate = false\n\n    this.update()\n  }\n\n  update() {\n    this.object.updateMatrixWorld(true)\n\n    const matrixWorld = this.object.matrixWorld\n\n    const position = this.geometry.attributes.position\n\n    //\n\n    const objGeometry = this.object.geometry\n\n    const objPos = objGeometry.attributes.position\n\n    const objTan = objGeometry.attributes.tangent\n\n    let idx = 0\n\n    // for simplicity, ignore index and drawcalls, and render every tangent\n\n    for (let j = 0, jl = objPos.count; j < jl; j++) {\n      _v1.fromBufferAttribute(objPos, j).applyMatrix4(matrixWorld)\n\n      _v2.fromBufferAttribute(objTan, j)\n\n      _v2.transformDirection(matrixWorld).multiplyScalar(this.size).add(_v1)\n\n      position.setXYZ(idx, _v1.x, _v1.y, _v1.z)\n\n      idx = idx + 1\n\n      position.setXYZ(idx, _v2.x, _v2.y, _v2.z)\n\n      idx = idx + 1\n    }\n\n    position.needsUpdate = true\n  }\n\n  dispose() {\n    this.geometry.dispose()\n    this.material.dispose()\n  }\n}\n\nexport { VertexTangentsHelper }\n", "import { BufferGeometry, Float32BufferAttribute, LineSegments, LineBasicMaterial, Matrix3, Vector3 } from 'three'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\nconst _normalMatrix = new Matrix3()\n\nclass VertexNormalsHelper extends LineSegments {\n  constructor(object, size = 1, color = 0xff0000) {\n    const geometry = new BufferGeometry()\n\n    const nNormals = object.geometry.attributes.normal.count\n    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3)\n\n    geometry.setAttribute('position', positions)\n\n    super(geometry, new LineBasicMaterial({ color, toneMapped: false }))\n\n    this.object = object\n    this.size = size\n    this.type = 'VertexNormalsHelper'\n\n    //\n\n    this.matrixAutoUpdate = false\n\n    this.update()\n  }\n\n  update() {\n    this.object.updateMatrixWorld(true)\n\n    _normalMatrix.getNormalMatrix(this.object.matrixWorld)\n\n    const matrixWorld = this.object.matrixWorld\n\n    const position = this.geometry.attributes.position\n\n    //\n\n    const objGeometry = this.object.geometry\n\n    if (objGeometry) {\n      const objPos = objGeometry.attributes.position\n\n      const objNorm = objGeometry.attributes.normal\n\n      let idx = 0\n\n      // for simplicity, ignore index and drawcalls, and render every normal\n\n      for (let j = 0, jl = objPos.count; j < jl; j++) {\n        _v1.fromBufferAttribute(objPos, j).applyMatrix4(matrixWorld)\n\n        _v2.fromBufferAttribute(objNorm, j)\n\n        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1)\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z)\n\n        idx = idx + 1\n\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z)\n\n        idx = idx + 1\n      }\n    }\n\n    position.needsUpdate = true\n  }\n\n  dispose() {\n    this.geometry.dispose()\n    this.material.dispose()\n  }\n}\n\nexport { VertexNormalsHelper }\n", "import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  EventDispatcher,\n  Float32BufferAttribute,\n  Matrix3,\n  Matrix4,\n  MathUtils,\n  Object3D,\n  Sphere,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst _m1 = new Matrix4()\nconst _obj = new Object3D()\nconst _offset = new Vector3()\n\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry()\n\n    const geometry = object.geometry\n\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3)\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3)\n\n      buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices))\n      buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors))\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1)\n\n        buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances))\n      }\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone()\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry()\n    }\n\n    return buffergeometry\n  }\n\n  constructor() {\n    super()\n    this.isGeometry = true\n    this.uuid = MathUtils.generateUUID()\n\n    this.name = ''\n    this.type = 'Geometry'\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n\n    this.morphTargets = []\n    this.morphNormals = []\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    this.lineDistances = []\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.elementsNeedUpdate = false\n    this.verticesNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.lineDistancesNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i]\n      vertex.applyMatrix4(matrix)\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n      face.normal.applyMatrix3(normalMatrix).normalize()\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize()\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    this.verticesNeedUpdate = true\n    this.normalsNeedUpdate = true\n\n    return this\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector)\n\n    _obj.updateMatrix()\n\n    this.applyMatrix4(_obj.matrix)\n\n    return this\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this\n\n    const index = geometry.index !== null ? geometry.index : undefined\n    const attributes = geometry.attributes\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.')\n      return this\n    }\n\n    const position = attributes.position\n    const normal = attributes.normal\n    const color = attributes.color\n    const uv = attributes.uv\n    const uv2 = attributes.uv2\n\n    if (uv2 !== undefined) this.faceVertexUvs[1] = []\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i))\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i))\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors =\n        color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()]\n\n      const vertexNormals =\n        normal === undefined\n          ? []\n          : [\n              new Vector3().fromBufferAttribute(normal, a),\n              new Vector3().fromBufferAttribute(normal, b),\n              new Vector3().fromBufferAttribute(normal, c),\n            ]\n\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex)\n\n      scope.faces.push(face)\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([\n          new Vector2().fromBufferAttribute(uv, a),\n          new Vector2().fromBufferAttribute(uv, b),\n          new Vector2().fromBufferAttribute(uv, c),\n        ])\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([\n          new Vector2().fromBufferAttribute(uv2, a),\n          new Vector2().fromBufferAttribute(uv2, b),\n          new Vector2().fromBufferAttribute(uv2, c),\n        ])\n      }\n    }\n\n    const groups = geometry.groups\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i]\n\n        const start = group.start\n        const count = group.count\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex)\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex)\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2))\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2)\n        }\n      }\n    }\n\n    this.computeFaceNormals()\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    return this\n  }\n\n  center() {\n    this.computeBoundingBox()\n\n    this.boundingBox.getCenter(_offset).negate()\n\n    this.translate(_offset.x, _offset.y, _offset.z)\n\n    return this\n  }\n\n  normalize() {\n    this.computeBoundingSphere()\n\n    const center = this.boundingSphere.center\n    const radius = this.boundingSphere.radius\n\n    const s = radius === 0 ? 1 : 1.0 / radius\n\n    const matrix = new Matrix4()\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1)\n\n    this.applyMatrix4(matrix)\n\n    return this\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vA = this.vertices[face.a]\n      const vB = this.vertices[face.b]\n      const vC = this.vertices[face.c]\n\n      cb.subVectors(vC, vB)\n      ab.subVectors(vA, vB)\n      cb.cross(ab)\n\n      cb.normalize()\n\n      face.normal.copy(cb)\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length)\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3()\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n\n      const cb = new Vector3(),\n        ab = new Vector3()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const vA = this.vertices[face.a]\n        const vB = this.vertices[face.b]\n        const vC = this.vertices[face.c]\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        vertices[face.a].add(cb)\n        vertices[face.b].add(cb)\n        vertices[face.c].add(cb)\n      }\n    } else {\n      this.computeFaceNormals()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        vertices[face.a].add(face.normal)\n        vertices[face.b].add(face.normal)\n        vertices[face.c].add(face.normal)\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize()\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a])\n        vertexNormals[1].copy(vertices[face.b])\n        vertexNormals[2].copy(vertices[face.c])\n      } else {\n        vertexNormals[0] = vertices[face.a].clone()\n        vertexNormals[1] = vertices[face.b].clone()\n        vertexNormals[2] = vertices[face.c].clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal)\n        vertexNormals[1].copy(face.normal)\n        vertexNormals[2].copy(face.normal)\n      } else {\n        vertexNormals[0] = face.normal.clone()\n        vertexNormals[1] = face.normal.clone()\n        vertexNormals[2] = face.normal.clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone()\n      } else {\n        face.__originalFaceNormal.copy(face.normal)\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = []\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone()\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i])\n        }\n      }\n    }\n\n    // use temp geometry to compute face and vertex normals for each morph\n\n    const tmpGeo = new Geometry()\n    tmpGeo.faces = this.faces\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {}\n        this.morphNormals[i].faceNormals = []\n        this.morphNormals[i].vertexNormals = []\n\n        const dstNormalsFace = this.morphNormals[i].faceNormals\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3()\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3(),\n          }\n\n          dstNormalsFace.push(faceNormal)\n          dstNormalsVertex.push(vertexNormals)\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]\n\n      // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices\n\n      // compute morph normals\n\n      tmpGeo.computeFaceNormals()\n      tmpGeo.computeVertexNormals()\n\n      // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const faceNormal = morphNormals.faceNormals[f]\n        const vertexNormals = morphNormals.vertexNormals[f]\n\n        faceNormal.copy(face.normal)\n\n        vertexNormals.a.copy(face.vertexNormals[0])\n        vertexNormals.b.copy(face.vertexNormals[1])\n        vertexNormals.c.copy(face.vertexNormals[2])\n      }\n    }\n\n    // restore original normals\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      face.normal = face.__originalFaceNormal\n      face.vertexNormals = face.__originalVertexNormals\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    this.boundingBox.setFromPoints(this.vertices)\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices)\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry)\n      return\n    }\n\n    let normalMatrix\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix)\n    }\n\n    // vertices\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i]\n\n      const vertexCopy = vertex.clone()\n\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix)\n\n      vertices1.push(vertexCopy)\n    }\n\n    // colors\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone())\n    }\n\n    // faces\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i]\n      let normal, color\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors\n\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset)\n      faceCopy.normal.copy(face.normal)\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize()\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone()\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize()\n        }\n\n        faceCopy.vertexNormals.push(normal)\n      }\n\n      faceCopy.color.copy(face.color)\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j]\n        faceCopy.vertexColors.push(color.clone())\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset\n\n      faces1.push(faceCopy)\n    }\n\n    // uvs\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = []\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh)\n      return\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix()\n\n    this.merge(mesh.geometry, mesh.matrix)\n  }\n\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {} // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n    const unique = [],\n      changes = []\n\n    const precision = Math.pow(10, precisionPoints)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i]\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i\n        unique.push(this.vertices[i])\n        changes[i] = unique.length - 1\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]]\n      }\n    }\n\n    // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n    const faceIndicesToRemove = []\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n\n      face.a = changes[face.a]\n      face.b = changes[face.b]\n      face.c = changes[face.c]\n\n      const indices = [face.a, face.b, face.c]\n\n      // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i)\n          break\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i]\n\n      this.faces.splice(idx, 1)\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1)\n      }\n    }\n\n    // Use unique set of vertices\n\n    const diff = this.vertices.length - unique.length\n    this.vertices = unique\n    return diff\n  }\n\n  setFromPoints(points) {\n    this.vertices = []\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i]\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0))\n    }\n\n    return this\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces\n    const length = faces.length\n\n    // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i\n    }\n\n    // sort faces\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex\n    }\n\n    faces.sort(materialIndexSort)\n\n    // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0]\n    const uvs2 = this.faceVertexUvs[1]\n\n    let newUvs1, newUvs2\n\n    if (uvs1 && uvs1.length === length) newUvs1 = []\n    if (uvs2 && uvs2.length === length) newUvs2 = []\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id\n\n      if (newUvs1) newUvs1.push(uvs1[id])\n      if (newUvs2) newUvs2.push(uvs2[id])\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON',\n      },\n    }\n\n    // standard Geometry serialization\n\n    data.uuid = this.uuid\n    data.type = this.type\n    if (this.name !== '') data.name = this.name\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key]\n      }\n\n      return data\n    }\n\n    const vertices = []\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i]\n      vertices.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    const faces = []\n    const normals = []\n    const normalsHash = {}\n    const colors = []\n    const colorsHash = {}\n    const uvs = []\n    const uvsHash = {}\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      const hasMaterial = true\n      const hasFaceUv = false // deprecated\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined\n      const hasFaceNormal = face.normal.length() > 0\n      const hasFaceVertexNormal = face.vertexNormals.length > 0\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1\n      const hasFaceVertexColor = face.vertexColors.length > 0\n\n      let faceType = 0\n\n      faceType = setBit(faceType, 0, 0) // isQuad\n      faceType = setBit(faceType, 1, hasMaterial)\n      faceType = setBit(faceType, 2, hasFaceUv)\n      faceType = setBit(faceType, 3, hasFaceVertexUv)\n      faceType = setBit(faceType, 4, hasFaceNormal)\n      faceType = setBit(faceType, 5, hasFaceVertexNormal)\n      faceType = setBit(faceType, 6, hasFaceColor)\n      faceType = setBit(faceType, 7, hasFaceVertexColor)\n\n      faces.push(faceType)\n      faces.push(face.a, face.b, face.c)\n      faces.push(face.materialIndex)\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i]\n\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]))\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal))\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals\n\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]))\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color))\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors\n\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]))\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | (1 << position) : value & ~(1 << position)\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString()\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash]\n      }\n\n      normalsHash[hash] = normals.length / 3\n      normals.push(normal.x, normal.y, normal.z)\n\n      return normalsHash[hash]\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString()\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash]\n      }\n\n      colorsHash[hash] = colors.length\n      colors.push(color.getHex())\n\n      return colorsHash[hash]\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString()\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash]\n      }\n\n      uvsHash[hash] = uvs.length / 2\n      uvs.push(uv.x, uv.y)\n\n      return uvsHash[hash]\n    }\n\n    data.data = {}\n\n    data.data.vertices = vertices\n    data.data.normals = normals\n    if (colors.length > 0) data.data.colors = colors\n    if (uvs.length > 0) data.data.uvs = [uvs] // temporal backward compatibility\n    data.data.faces = faces\n\n    return data\n  }\n\n  clone() {\n    /*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n    return new Geometry().copy(this)\n  }\n\n  copy(source) {\n    // reset\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n    this.morphTargets = []\n    this.morphNormals = []\n    this.skinWeights = []\n    this.skinIndices = []\n    this.lineDistances = []\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // name\n\n    this.name = source.name\n\n    // vertices\n\n    const vertices = source.vertices\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone())\n    }\n\n    // colors\n\n    const colors = source.colors\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone())\n    }\n\n    // faces\n\n    const faces = source.faces\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone())\n    }\n\n    // face vertex uvs\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = []\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k]\n\n          uvsCopy.push(uv.clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n\n    // morph targets\n\n    const morphTargets = source.morphTargets\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {}\n      morphTarget.name = morphTargets[i].name\n\n      // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = []\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone())\n        }\n      }\n\n      // normals\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = []\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone())\n        }\n      }\n\n      this.morphTargets.push(morphTarget)\n    }\n\n    // morph normals\n\n    const morphNormals = source.morphNormals\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}\n\n      // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = []\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j]\n          const destVertexNormal = {}\n\n          destVertexNormal.a = srcVertexNormal.a.clone()\n          destVertexNormal.b = srcVertexNormal.b.clone()\n          destVertexNormal.c = srcVertexNormal.c.clone()\n\n          morphNormal.vertexNormals.push(destVertexNormal)\n        }\n      }\n\n      // face normals\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = []\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone())\n        }\n      }\n\n      this.morphNormals.push(morphNormal)\n    }\n\n    // skin weights\n\n    const skinWeights = source.skinWeights\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone())\n    }\n\n    // skin indices\n\n    const skinIndices = source.skinIndices\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone())\n    }\n\n    // line distances\n\n    const lineDistances = source.lineDistances\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i])\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone()\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone()\n    }\n\n    // update flags\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate\n    this.verticesNeedUpdate = source.verticesNeedUpdate\n    this.uvsNeedUpdate = source.uvsNeedUpdate\n    this.normalsNeedUpdate = source.normalsNeedUpdate\n    this.colorsNeedUpdate = source.colorsNeedUpdate\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate\n    this.groupsNeedUpdate = source.groupsNeedUpdate\n\n    return this\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this)\n\n    const buffergeometry = new BufferGeometry()\n\n    const positions = new Float32Array(geometry.vertices.length * 3)\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices))\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3)\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals))\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3)\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors))\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2)\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs))\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2)\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2))\n    }\n\n    // groups\n\n    buffergeometry.groups = geometry.groups\n\n    // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = []\n      const morphTargets = geometry.morphTargets[name]\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i]\n\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3)\n        attribute.name = morphTarget.name\n\n        array.push(attribute.copyVector3sArray(morphTarget.data))\n      }\n\n      buffergeometry.morphAttributes[name] = array\n    }\n\n    // skinning\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4)\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices))\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4)\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights))\n    }\n\n    //\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return buffergeometry\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.')\n  }\n\n  computeLineDistances() {\n    console.error(\n      'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',\n    )\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().')\n    return this.applyMatrix4(matrix)\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' })\n  }\n}\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = []\n    this.normals = []\n    this.colors = []\n    this.uvs = []\n    this.uvs2 = []\n\n    this.groups = []\n\n    this.morphTargets = {}\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    // this.lineDistances = [];\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.verticesNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  computeGroups(geometry) {\n    const groups = []\n\n    let group, i\n    let materialIndex = undefined\n\n    const faces = geometry.faces\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start\n          groups.push(group)\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex,\n        }\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start\n      groups.push(group)\n    }\n\n    this.groups = groups\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces\n    const vertices = geometry.vertices\n    const faceVertexUvs = geometry.faceVertexUvs\n\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0\n\n    // morphs\n\n    const morphTargets = geometry.morphTargets\n    const morphTargetsLength = morphTargets.length\n\n    let morphTargetsPosition\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = []\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.position = morphTargetsPosition\n    }\n\n    const morphNormals = geometry.morphNormals\n    const morphNormalsLength = morphNormals.length\n\n    let morphTargetsNormal\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = []\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.normal = morphTargetsNormal\n    }\n\n    // skins\n\n    const skinIndices = geometry.skinIndices\n    const skinWeights = geometry.skinWeights\n\n    const hasSkinIndices = skinIndices.length === vertices.length\n    const hasSkinWeights = skinWeights.length === vertices.length\n\n    //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.')\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c])\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2])\n      } else {\n        const normal = face.normal\n\n        this.normals.push(normal, normal, normal)\n      }\n\n      const vertexColors = face.vertexColors\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2])\n      } else {\n        const color = face.color\n\n        this.colors.push(color, color, color)\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i)\n\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i)\n\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      // morphs\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices\n\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c])\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i]\n\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c)\n      }\n\n      // skins\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c])\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c])\n      }\n    }\n\n    this.computeGroups(geometry)\n\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return this\n  }\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.normal = normal && normal.isVector3 ? normal : new Vector3()\n    this.vertexNormals = Array.isArray(normal) ? normal : []\n\n    this.color = color && color.isColor ? color : new Color()\n    this.vertexColors = Array.isArray(color) ? color : []\n\n    this.materialIndex = materialIndex\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n\n  copy(source) {\n    this.a = source.a\n    this.b = source.b\n    this.c = source.c\n\n    this.normal.copy(source.normal)\n    this.color.copy(source.color)\n\n    this.materialIndex = source.materialIndex\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone()\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone()\n    }\n\n    return this\n  }\n}\n\nexport { Face3, Geometry }\n"],
  "mappings": "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AE,OAAO,KAAO;IAC3B,UAAU,EAAE,OAAO,EAAE;IAErB,aAAa,EAAE,OAAO,EAAE;IACxB,aAAa,EAAE,OAAO,IAAI,QAAA,EAAU;EACtC;EAEA,cAAc;IACZ;IAEA;IAEA;IACA;IAEA;EAAA,EACA,KAAK,IAAI;EAEX,gBAAgB;IACd;IAEA;IAEA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IAEA;IAEA;IAEA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IAEA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IAEA;IACA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;IACA;IAEA;IAEA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;E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;IAEA;;IAGA;IAEA;IAEA;;IAGA;IAEA;IAEA;;IAGA;IAEA;IAEA;;IAGA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IAEA;IAEA;IAEA;IAEA;;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;;IAGA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IAEA;IAEA;IACA;IAEA;IAEA;;IAGA;IAEA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IAEA;;IAGA;;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAGA;IACA;IACA;;IAGA;IAEA;IACA;IACA;IACA;IAEA;;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IAEA;;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IAEA;;IAGA;IACA;IACA;;IAGA;IACA;IACA;IACA;IACA;IACA;;IAGA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;EAAA,EACA,KAAK,IAAI;AACb;;;ACzSO,IAAM,kBAAkB;EAC7B,SAAS;IACP,gBAAgB;EAClB;EAEA,UAAU;IACR,UAAU,EAAE,OAAO,KAAK;IACxB,YAAY,EAAE,OAAO,IAAI,QAAQ,IAAI,MAAM,IAAI,GAAG,EAAE;EACtD;EAEA,cAAc;IACZ;IAEA;IACA;IAEA;IACA;;IACA;;IACA;;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;EAAA,EACA,KAAK,IAAI;EAEX,gBAAgB;IACd;IAEA;IACA;IAEA;IACA;;IAGA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;;IAGA;;IAGA;IACA;;IAGA;IACA;IACA;IAEA;IACA;IACA;;IAGA;;I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IACR,QAAQ,EAAE,OAAO,KAAK;IACtB,QAAQ,EAAE,OAAO,KAAK;IACtB,OAAO,EAAE,OAAO,EAAI;IACpB,SAAS,EAAE,OAAO,EAAI;EACxB;EAEA,cAAc;IACZ;IAEA;IAEA;IACA;IAEA;EAAA,EACA,KAAK,IAAI;EAEX,gBAAgB;IACd;IACA;IAEA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IACA;IAEA;EAAA,EACA,KAAK,IAAI;AACb;;;ACtCO,IAAM,aAAa;EACxB,UAAU;IACR,UAAU,EAAE,OAAO,KAAK;IACxB,YAAY,EAAE,OAAO,IAAI,QAAQ,IAAI,MAAM,IAAI,GAAG,EAAE;EACtD;EAEA,cAAc;IACZ;IAEA;IAEA;IACA;IAEA;EAAA,EACA,KAAK,IAAI;EAEX,gBAAgB;IACd;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EAAA,EACA,KAAK,IAAI;AACb;;;AC7kCO,IAAM,cAAc;EACzB,UAAU;IACR,UAAU,EAAE,OAAO,KAAK;IACxB,aAAa,EAAE,OAAO,KAAK;IAC3B,cAAc,EAAE,OAAO,KAAK;IAC5B,gBAAgB,EAAE,OAAO,KAAK;I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A;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;;IAEA;IACA;;IAGA;;;;IAKA;IACA;IACA;IACA;IACA;IACA;IACA;;IAGA;;IAGA;IACA;IACA;;IAGA;IACA;;;;;IAOA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IAEA;IACA;IACA;;;;IAKA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;;IAGA;IACA;IACA;IACA;IACA;IACA;;IAGA;IACA;IAEA;IAEA;IACA;IACA;IACA;IAEA;;;;IAKA;IACA;IACA;;IAGA;IAEA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAGA;IACA;IACA;IAEA;IACA;;;IAIA;;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;;IAGA;IACA;;IAGA;IACA;IACA;;IAGA;IACA;;IAEA;IACA;IACA;;IAGA;IACA;IACA;;IAGA;;IAGA;IACA;IACA;IACA;;IAGA;IACA;IACA;IACA;IACA;IACA;EAAA,EACA,KAAK,IAAI;AACb;;;ACjRO,IAAM,wBAAwB;EACnC,UAAU;IACR,OAAO;MACL,OAAO;IACT;IAEA,MAAM;MACJ,OAAO;IACT;IAEA,UAAU;MACR,OAAO;IACT;IAEA,OAAO;MACL,OAAO;IACT;IAEA,eAAe;MACb,OAAO;IACT;EACF;EAEA,cAAc;IACZ;IAEA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;EAAA,EACA,KAAK,IAAI;EAEX,gBAAgB;IACd;IACA;IACA;IACA;IAEA;IACA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IAEA;IACA;;IAIA;IACA;IACA;;IAIA;IACA;IAEA;IAEA;IAEA;EAAA,EACA,KAAK,IAAI;AACb;;;ACjFA,IAAM,WAAW,IAAI,QAAS;;;ACA9B,IAAM,UAAU,IAAI,QAAS;AAC7B,IAAM,SAAS,IAAI,QAAS;AAE5B,IAA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,SAAS,IACxB,SAAS,SAAS;AAEpB,QAAI,CAAC,aAAa;AAEhB,UAAI,eACF;MACA,aAAa,SAAS;AAExB,MAAAA,GAAE,eAAe,KAAK,IAAI,IAAI,IAAIA,GAAE;AACpC,MAAAA,GAAE,SAASA,GAAE,OAAO,OAAO;QACzB,EAAE,MAAM,gBAAgB,MAAM,UAAU,OAAO,GAAI;QACnD,EAAE,MAAM,kBAAkB,MAAM,UAAU,OAAO,EAAG;QACpD,EAAE,MAAM,gBAAgB,MAAM,SAAS,OAAO,aAAc;QAC5D,EAAE,MAAM,kBAAkB,MAAM,SAAS,OAAO,EAAG;QACnD,EAAE,MAAM,iBAAiB,MAAM,SAAS,OAAO,aAAa,SAAS,EAAG;MAChF,CAAO;AAED,MAAAA,GAAE,SAASA,GAAE,OAAO,OAAO,YAAY;IACxC;AAED,WAAOA;EACR;AAED,MAAI,OAAO,EAAE,OAAO,gBAAgB,MAAM,cAAe;AAIzD,MAAI,qBAAqB;IACvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;AAED,MAAI,sBAAsB;IACxB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;AAED,MAAI,oBAAoB;IACtB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;AAED,MAAI,gBAAgB;IAClB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;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CR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,OAAQ;IACR,MAAQ;IACR,MAAQ;IACR,OAAQ;IACR,MAAQ;IACR,MAAQ;IACR,OAAQ;IACR,MAAQ;IACR,OAAQ;IACR,OAAQ;IACR,MAAQ;IACR,OAAQ;IACR,MAAQ;IACR,MAAQ;IACR,OAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,MAAQ;IACR,OAAQ;IACR,OAAQ;IA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ACA;;IACA;;IACA;;IACA;;IACA;;IACA,GAAG,KAAK,QAAW,CAAC;;IACpB,GAAG,KAAK,QAAW,CAAC;;IACpB;;;IACA,GAAG,KAAK,QAAW,CAAC;;IACpB,GAAG,KAAK,QAAW,CAAC;;IACpB;;IACA;;;IACA;;IACA;;;IACA;;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA,UAAU,KAAK,QAAW,CAAC;;IAC3B;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB;;;IACA;;;IACA;;;IACA;;;IACA;;IACA,UAAU,KAAK,QAAW,CAAC;;IAC3B,UAAU,KAAK,QAAW,CAAC;;IAC3B,UAAU,KAAK,QAAW,CAAC;;IAC3B,UAAU,KAAK,QAAW,CAAC;;IAC3B,UAAU,KAAK,QAAW,CAAC;;IAC3B;;IACA;;IACA;;;IACA;;;IACA;;IACA;;IACA;;IACA;;IACA;;;IACA;;;IACA;;;IACA;;;IACA;;;IACA;;IACA;;IACA;;IACA,OAAO,KAAK,QAAW,CAAC;;IACxB,OAAO,KAAK,QAAW,CAAC;;IACxB;;IACA;;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA;;IACA,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,MAAM,KAAK,QAAW,CAAC;;IACvB,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;IACvC,UAAU,KAAK,QAAW,GAAG,GAAG,GAAG,G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",
  "names": ["_v1", "geometry", "i", "name", "index", "buffer", "data", "i", "time", "index", "text", "matrix", "a", "value", "uids", "width", "height", "geometry", "key", "material", "rotation", "position", "scale", "nodeIndex", "geometry", "faces", "i", "length", "__publicField", "_vector", "_matrix", "_position", "_quaternion", "_scale", "_q", "geometry", "rotationMatrix", "material", "__publicField", "geometry", "rotationMatrix", "visible", "position", "scale", "updateRefractorPlane", "updateVirtualCamera", "__publicField", "geometry", "scale", "size", "i", "uniforms", "invAspect", "__publicField", "__publicField", "i", "t", "t2", "i2", "i", "value", "time", "length", "__publicField", "geometry", "yAxis", "val", "rotationMatrix", "material", "__publicField", "__publicField", "geometry", "scale", "__publicField", "matrix", "center", "rotation", "obb", "i", "_v1", "a", "b", "_p", "i", "_v1", "_v2", "_plane", "_vector", "_plane", "__publicField", "width", "height", "material", "value", "width", "height", "i", "scale", "size", "data", "__publicField", "i", "width", "height", "__publicField", "stdDev", "i", "width", "height", "__publicField", "width", "height", "val", "__publicField", "sigma", "sum", "i", "i", "_q", "_identityMatrix", "_a", "__publicField", "_matrix", "_vector", "data", "i", "data", "__publicField", "text", "size", "scale", "i", "createPath", "ShapePath", "data", "width", "height", "instance", "i", "XboneInf", "XAnimationInfo", "XAnimationObj", "XKeyFrameInfo", "XLoader", "_start", "index", "data", "_end", "_obj", "b", "position", "data2", "value", "index", "length", "key", "WeakMap", "transform", "data", "map", "size", "values", "Buffer", "DataView", "Set", "Uint8Array", "bitmask", "othValue", "property", "collection", "includes", "val", "i", "Lexer", "text", "LexerDefinitionErrorType", "time", "msg", "currConfig", "createToken", "getExtraProductionArgument", "PROD_TYPE", "tokenMatcher", "t", "keys", "prefixKeys", "collectorVisitor", "_a", "CstVisitorDefinitionError", "name", "allTokenTypes", "invokeRuleWithTry", "ParserDefinitionErrorType", "Parser", "_b", "CstParser", "i", "resolve", "msg", "data", "value", "decodeText", "i", "key", "text", "init", "index", "width", "height", "jsContent", "binaryContent", "width", "height", "__publicField", "init", "a", "b", "i", "value", "zstd", "data", "lottie", "value", "i", "val", "b", "t", "data", "comp", "loadAnimation", "ob", "cb", "name", "key", "expressionsPlugin", "init", "index", "searchAnimations", "div", "a", "length", "time", "quat", "elem", "_v", "v1", "scale", "transform", "_p", "_a", "_b", "width", "text", "size", "sum", "Font", "mask", "property", "toWorld", "fromWorld", "matrix", "fromComp", "len", "content", "globalData", "position", "_o", "_identityMatrix", "global", "prng", "seed", "j", "s", "BMMath", "wiggle", "velocity", "loopOut", "loopIn", "smooth", "rotation", "i", "sum", "t", "lengths", "val", "length", "offs", "v1", "b", "a", "t2", "Path", "value", "data", "table", "subtableMakers", "Parser", "cmap", "post", "name", "scale", "x", "y", "index", "parseGlyph", "position", "buildPath", "parseCFFCharstring", "key", "size", "meta", "width", "parse", "code", "charString", "head", "hhea", "maxp", "ltag", "property", "text", "os2", "glyphCount", "substCount", "tableData", "gsub", "sfnt", "scripts", "langSysTable", "sub", "transform", "loca", "div", "this$1", "check", "Font", "fvar", "gdef", "gpos", "parseBuffer", "_taskCache", "i", "width", "height", "jsContent", "binaryContent", "worker", "a", "b", "__publicField", "init", "value", "_ray", "_vector", "_viewport", "_start", "_end", "_closestPoint", "_box", "_sphere", "_v1", "_v2", "_v1", "_v2", "t", "i", "r", "_quaternion", "_vector3", "_matrix4", "_position", "_scale", "scale", "cb", "React", "index", "world", "value", "key", "a", "geometry", "size", "instance", "position", "rotation", "name", "matrix", "length"]
}
